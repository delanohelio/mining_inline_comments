{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxODg5ODIz", "number": 902, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxMDoyNFrOEcKdIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoxNzozNFrOEcVn8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTY2ODgyOnYy", "diffSide": "RIGHT", "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxMDoyNFrOHGhr-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo1NTowOVrOHGlhHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTQzNA==", "bodyText": "these two methods (checkKubeConnectivity and mustHaveKubeConnectivity) are not being used anywhere here. Are they intended to be provided as a library?\nThe boolean return is also not being used anywhere (see comment below)", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476605434", "createdAt": "2020-08-25T17:10:24Z", "author": {"login": "fabiokung"}, "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "diffHunk": "@@ -76,6 +88,24 @@ public static ApiClient createApiClient(String kubeApiServerUrl,\n         return client;\n     }\n \n+    public static Either<Boolean, Throwable> checkKubeConnectivity(ApiClient apiClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1ODMxMg==", "bodyText": "Yes, they are used in nftitus.\nThe Either contract in this context makes it sufficient to only check if the error is present.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476658312", "createdAt": "2020-08-25T18:37:50Z", "author": {"login": "tbak"}, "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "diffHunk": "@@ -76,6 +88,24 @@ public static ApiClient createApiClient(String kubeApiServerUrl,\n         return client;\n     }\n \n+    public static Either<Boolean, Throwable> checkKubeConnectivity(ApiClient apiClient) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTQzNA=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2ODE4OA==", "bodyText": "I will change it to Optional to avoid this confusion.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476668188", "createdAt": "2020-08-25T18:55:09Z", "author": {"login": "tbak"}, "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "diffHunk": "@@ -76,6 +88,24 @@ public static ApiClient createApiClient(String kubeApiServerUrl,\n         return client;\n     }\n \n+    public static Either<Boolean, Throwable> checkKubeConnectivity(ApiClient apiClient) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTQzNA=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTY2OTU4OnYy", "diffSide": "RIGHT", "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxMDozNlrOHGhsfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODozODowNVrOHGk6-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTU2NQ==", "bodyText": "not checking the boolean return anywhere", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476605565", "createdAt": "2020-08-25T17:10:36Z", "author": {"login": "fabiokung"}, "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "diffHunk": "@@ -76,6 +88,24 @@ public static ApiClient createApiClient(String kubeApiServerUrl,\n         return client;\n     }\n \n+    public static Either<Boolean, Throwable> checkKubeConnectivity(ApiClient apiClient) {\n+        CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        try {\n+            coreV1Api.getAPIResources();\n+        } catch (Throwable e) {\n+            return Either.ofError(e);\n+        }\n+        return Either.ofValue(true);\n+    }\n+\n+    public static ApiClient mustHaveKubeConnectivity(ApiClient apiClient) {\n+        Either<Boolean, Throwable> check = checkKubeConnectivity(apiClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1ODQyNg==", "bodyText": "The Either contract in this context makes it sufficient to only check if the error is present.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476658426", "createdAt": "2020-08-25T18:38:05Z", "author": {"login": "tbak"}, "path": "titus-common-runtime/src/main/java/com/netflix/titus/runtime/connector/kubernetes/KubeApiClients.java", "diffHunk": "@@ -76,6 +88,24 @@ public static ApiClient createApiClient(String kubeApiServerUrl,\n         return client;\n     }\n \n+    public static Either<Boolean, Throwable> checkKubeConnectivity(ApiClient apiClient) {\n+        CoreV1Api coreV1Api = new CoreV1Api(apiClient);\n+        try {\n+            coreV1Api.getAPIResources();\n+        } catch (Throwable e) {\n+            return Either.ofError(e);\n+        }\n+        return Either.ofValue(true);\n+    }\n+\n+    public static ApiClient mustHaveKubeConnectivity(ApiClient apiClient) {\n+        Either<Boolean, Throwable> check = checkKubeConnectivity(apiClient);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTU2NQ=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTcwMTI4OnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxODozOFrOHGiAOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxODozOFrOHGiAOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxMDYxNg==", "bodyText": "minor: might be a bit more future-proof to use Boolean.parseBoolean() for all these bool attributes", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476610616", "createdAt": "2020-08-25T17:18:38Z", "author": {"login": "fabiokung"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.AgentInstanceGroup;\n+import com.netflix.titus.api.agent.model.InstanceGroupLifecycleState;\n+import com.netflix.titus.api.agent.service.ReadOnlyAgentOperations;\n+import com.netflix.titus.common.util.tuple.Pair;\n+import com.netflix.titus.runtime.connector.agent.AgentDataReplicator;\n+import com.netflix.titus.supplementary.relocation.RelocationAttributes;\n+\n+public class AgentManagementNodeDataResolver implements NodeDataResolver {\n+\n+    private final ReadOnlyAgentOperations agentOperations;\n+    private final AgentDataReplicator agentDataReplicator;\n+    private final Predicate<AgentInstance> fenzoNodeFilter;\n+\n+    public AgentManagementNodeDataResolver(ReadOnlyAgentOperations agentOperations,\n+                                           AgentDataReplicator agentDataReplicator,\n+                                           Predicate<AgentInstance> fenzoNodeFilter) {\n+        this.agentOperations = agentOperations;\n+        this.agentDataReplicator = agentDataReplicator;\n+        this.fenzoNodeFilter = fenzoNodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<Pair<AgentInstanceGroup, List<AgentInstance>>> all = agentOperations.findAgentInstances(pair ->\n+                fenzoNodeFilter.test(pair.getRight())\n+        );\n+        Map<String, Node> result = new HashMap<>();\n+        all.forEach(pair -> {\n+            AgentInstanceGroup serverGroup = pair.getLeft();\n+            List<AgentInstance> instances = pair.getRight();\n+            instances.forEach(instance -> result.put(instance.getId(), toNode(serverGroup, instance)));\n+        });\n+        return result;\n+    }\n+\n+    @Override\n+    public long getStalenessMs() {\n+        return agentDataReplicator.getStalenessMs();\n+    }\n+\n+    private Node toNode(AgentInstanceGroup serverGroup, AgentInstance instance) {\n+        boolean relocationRequired = instance.getAttributes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTcxOTMxOnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyMzowNVrOHGiLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyMzowNVrOHGiLEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxMzM5NA==", "bodyText": "s/relocationNodeAllowed/relocationNotAllowed/g", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476613394", "createdAt": "2020-08-25T17:23:05Z", "author": {"login": "fabiokung"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.AgentInstanceGroup;\n+import com.netflix.titus.api.agent.model.InstanceGroupLifecycleState;\n+import com.netflix.titus.api.agent.service.ReadOnlyAgentOperations;\n+import com.netflix.titus.common.util.tuple.Pair;\n+import com.netflix.titus.runtime.connector.agent.AgentDataReplicator;\n+import com.netflix.titus.supplementary.relocation.RelocationAttributes;\n+\n+public class AgentManagementNodeDataResolver implements NodeDataResolver {\n+\n+    private final ReadOnlyAgentOperations agentOperations;\n+    private final AgentDataReplicator agentDataReplicator;\n+    private final Predicate<AgentInstance> fenzoNodeFilter;\n+\n+    public AgentManagementNodeDataResolver(ReadOnlyAgentOperations agentOperations,\n+                                           AgentDataReplicator agentDataReplicator,\n+                                           Predicate<AgentInstance> fenzoNodeFilter) {\n+        this.agentOperations = agentOperations;\n+        this.agentDataReplicator = agentDataReplicator;\n+        this.fenzoNodeFilter = fenzoNodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<Pair<AgentInstanceGroup, List<AgentInstance>>> all = agentOperations.findAgentInstances(pair ->\n+                fenzoNodeFilter.test(pair.getRight())\n+        );\n+        Map<String, Node> result = new HashMap<>();\n+        all.forEach(pair -> {\n+            AgentInstanceGroup serverGroup = pair.getLeft();\n+            List<AgentInstance> instances = pair.getRight();\n+            instances.forEach(instance -> result.put(instance.getId(), toNode(serverGroup, instance)));\n+        });\n+        return result;\n+    }\n+\n+    @Override\n+    public long getStalenessMs() {\n+        return agentDataReplicator.getStalenessMs();\n+    }\n+\n+    private Node toNode(AgentInstanceGroup serverGroup, AgentInstance instance) {\n+        boolean relocationRequired = instance.getAttributes()\n+                .getOrDefault(RelocationAttributes.RELOCATION_REQUIRED, \"false\")\n+                .equalsIgnoreCase(\"true\");\n+\n+        boolean relocationRequiredImmediately = instance.getAttributes()\n+                .getOrDefault(RelocationAttributes.RELOCATION_REQUIRED_IMMEDIATELY, \"false\")\n+                .equalsIgnoreCase(\"true\");\n+\n+        boolean relocationNodeAllowed = instance.getAttributes()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTc1MDQ2OnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoyNjoxNlrOHGiaYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODo1Njo0NVrOHGllAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNzMxNA==", "bodyText": "thoughts on changing the contract here to return Optional<Long>, and be more explicit when sync has not occurred?", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476617314", "createdAt": "2020-08-25T17:26:16Z", "author": {"login": "fabiokung"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.runtime.connector.kubernetes.KubeApiFacade;\n+import com.netflix.titus.supplementary.relocation.RelocationConfiguration;\n+import io.kubernetes.client.informer.SharedIndexInformer;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LABEL_MACHINE_GROUP;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.TAINT_EFFECT_NO_EXECUTE;\n+\n+public class KubernetesNodeDataResolver implements NodeDataResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KubernetesNodeDataResolver.class);\n+\n+    private static final long NOT_SYNCED_STALENESS_MS = 10 * 3600_000;\n+\n+    private final SharedIndexInformer<V1Node> nodeInformer;\n+    private final Predicate<V1Node> nodeFilter;\n+\n+    private final Function<String, Matcher> relocationRequiredTaintsMatcher;\n+    private final Function<String, Matcher> relocationRequiredImmediatelyTaintsMatcher;\n+\n+    public KubernetesNodeDataResolver(RelocationConfiguration configuration,\n+                                      KubeApiFacade kubeApiFacade,\n+                                      Predicate<V1Node> nodeFilter) {\n+        this.nodeInformer = kubeApiFacade.getNodeInformer();\n+        this.relocationRequiredTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredTaints,\n+                \"nodeRelocationRequiredTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.relocationRequiredImmediatelyTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredImmediatelyTaints,\n+                \"nodeRelocationRequiredImmediatelyTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.nodeFilter = nodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<V1Node> k8Nodes = nodeInformer.getIndexer().list().stream().filter(nodeFilter).collect(Collectors.toList());\n+        Map<String, Node> result = new HashMap<>();\n+        k8Nodes.forEach(k8Node -> toReconcilerNode(k8Node).ifPresent(node -> result.put(node.getId(), node)));\n+        return result;\n+    }\n+\n+    private Optional<Node> toReconcilerNode(V1Node k8Node) {\n+        if (k8Node.getMetadata() == null\n+                || k8Node.getMetadata().getName() == null\n+                || k8Node.getMetadata().getLabels() == null\n+                || k8Node.getSpec() == null\n+                || k8Node.getSpec().getTaints() == null) {\n+            return Optional.empty();\n+        }\n+\n+        Map<String, String> k8Labels = k8Node.getMetadata().getLabels();\n+\n+        String serverGroupId = k8Labels.get(NODE_LABEL_MACHINE_GROUP);\n+        if (serverGroupId == null) {\n+            return Optional.empty();\n+        }\n+\n+        Node node = Node.newBuilder()\n+                .withId(k8Node.getMetadata().getName())\n+                .withServerGroupId(serverGroupId)\n+                .withRelocationRequired(anyNoExecuteMatch(k8Node, relocationRequiredTaintsMatcher))\n+                .withRelocationRequiredImmediately(anyNoExecuteMatch(k8Node, relocationRequiredImmediatelyTaintsMatcher))\n+                .build();\n+        return Optional.of(node);\n+    }\n+\n+    private boolean anyNoExecuteMatch(V1Node k8Node, Function<String, Matcher> taintsMatcher) {\n+        return k8Node.getSpec().getTaints().stream().anyMatch(taint ->\n+                TAINT_EFFECT_NO_EXECUTE.equals(taint.getEffect()) && taintsMatcher.apply(taint.getKey()).matches()\n+        );\n+    }\n+\n+    /**\n+     * Kubernetes informer does not provide staleness details, just information about the first sync.\n+     */\n+    @Override\n+    public long getStalenessMs() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2OTE4Ng==", "bodyText": "We use this approach in other places/APIs, so to be consistent we should change it everywhere.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476669186", "createdAt": "2020-08-25T18:56:45Z", "author": {"login": "tbak"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.runtime.connector.kubernetes.KubeApiFacade;\n+import com.netflix.titus.supplementary.relocation.RelocationConfiguration;\n+import io.kubernetes.client.informer.SharedIndexInformer;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LABEL_MACHINE_GROUP;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.TAINT_EFFECT_NO_EXECUTE;\n+\n+public class KubernetesNodeDataResolver implements NodeDataResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KubernetesNodeDataResolver.class);\n+\n+    private static final long NOT_SYNCED_STALENESS_MS = 10 * 3600_000;\n+\n+    private final SharedIndexInformer<V1Node> nodeInformer;\n+    private final Predicate<V1Node> nodeFilter;\n+\n+    private final Function<String, Matcher> relocationRequiredTaintsMatcher;\n+    private final Function<String, Matcher> relocationRequiredImmediatelyTaintsMatcher;\n+\n+    public KubernetesNodeDataResolver(RelocationConfiguration configuration,\n+                                      KubeApiFacade kubeApiFacade,\n+                                      Predicate<V1Node> nodeFilter) {\n+        this.nodeInformer = kubeApiFacade.getNodeInformer();\n+        this.relocationRequiredTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredTaints,\n+                \"nodeRelocationRequiredTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.relocationRequiredImmediatelyTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredImmediatelyTaints,\n+                \"nodeRelocationRequiredImmediatelyTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.nodeFilter = nodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<V1Node> k8Nodes = nodeInformer.getIndexer().list().stream().filter(nodeFilter).collect(Collectors.toList());\n+        Map<String, Node> result = new HashMap<>();\n+        k8Nodes.forEach(k8Node -> toReconcilerNode(k8Node).ifPresent(node -> result.put(node.getId(), node)));\n+        return result;\n+    }\n+\n+    private Optional<Node> toReconcilerNode(V1Node k8Node) {\n+        if (k8Node.getMetadata() == null\n+                || k8Node.getMetadata().getName() == null\n+                || k8Node.getMetadata().getLabels() == null\n+                || k8Node.getSpec() == null\n+                || k8Node.getSpec().getTaints() == null) {\n+            return Optional.empty();\n+        }\n+\n+        Map<String, String> k8Labels = k8Node.getMetadata().getLabels();\n+\n+        String serverGroupId = k8Labels.get(NODE_LABEL_MACHINE_GROUP);\n+        if (serverGroupId == null) {\n+            return Optional.empty();\n+        }\n+\n+        Node node = Node.newBuilder()\n+                .withId(k8Node.getMetadata().getName())\n+                .withServerGroupId(serverGroupId)\n+                .withRelocationRequired(anyNoExecuteMatch(k8Node, relocationRequiredTaintsMatcher))\n+                .withRelocationRequiredImmediately(anyNoExecuteMatch(k8Node, relocationRequiredImmediatelyTaintsMatcher))\n+                .build();\n+        return Optional.of(node);\n+    }\n+\n+    private boolean anyNoExecuteMatch(V1Node k8Node, Function<String, Matcher> taintsMatcher) {\n+        return k8Node.getSpec().getTaints().stream().anyMatch(taint ->\n+                TAINT_EFFECT_NO_EXECUTE.equals(taint.getEffect()) && taintsMatcher.apply(taint.getKey()).matches()\n+        );\n+    }\n+\n+    /**\n+     * Kubernetes informer does not provide staleness details, just information about the first sync.\n+     */\n+    @Override\n+    public long getStalenessMs() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNzMxNA=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTc3MjM5OnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzozMDoyMlrOHGimng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzozMDoyMlrOHGimng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyMDQ0Ng==", "bodyText": "minor: s/k8/k8s/g", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476620446", "createdAt": "2020-08-25T17:30:22Z", "author": {"login": "fabiokung"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.runtime.connector.kubernetes.KubeApiFacade;\n+import com.netflix.titus.supplementary.relocation.RelocationConfiguration;\n+import io.kubernetes.client.informer.SharedIndexInformer;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LABEL_MACHINE_GROUP;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.TAINT_EFFECT_NO_EXECUTE;\n+\n+public class KubernetesNodeDataResolver implements NodeDataResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KubernetesNodeDataResolver.class);\n+\n+    private static final long NOT_SYNCED_STALENESS_MS = 10 * 3600_000;\n+\n+    private final SharedIndexInformer<V1Node> nodeInformer;\n+    private final Predicate<V1Node> nodeFilter;\n+\n+    private final Function<String, Matcher> relocationRequiredTaintsMatcher;\n+    private final Function<String, Matcher> relocationRequiredImmediatelyTaintsMatcher;\n+\n+    public KubernetesNodeDataResolver(RelocationConfiguration configuration,\n+                                      KubeApiFacade kubeApiFacade,\n+                                      Predicate<V1Node> nodeFilter) {\n+        this.nodeInformer = kubeApiFacade.getNodeInformer();\n+        this.relocationRequiredTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredTaints,\n+                \"nodeRelocationRequiredTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.relocationRequiredImmediatelyTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredImmediatelyTaints,\n+                \"nodeRelocationRequiredImmediatelyTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.nodeFilter = nodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<V1Node> k8Nodes = nodeInformer.getIndexer().list().stream().filter(nodeFilter).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MTQ4NTYxOnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/Node.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoxNDowOFrOHGzyVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoxNDowOFrOHGzyVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwMTk3NA==", "bodyText": "Precondition checks (notNull, notEmpty) would help here with id, serverGroupId", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476901974", "createdAt": "2020-08-26T00:14:08Z", "author": {"login": "amit-git"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/Node.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+public class Node {\n+\n+    private final String id;\n+    private final String serverGroupId;\n+\n+    private boolean relocationNotAllowed;\n+    private boolean relocationRequired;\n+    private boolean relocationRequiredImmediately;\n+    private boolean serverGroupRelocationRequired;\n+\n+    public Node(String id,\n+                String serverGroupId) {\n+        this.id = id;\n+        this.serverGroupId = serverGroupId;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getServerGroupId() {\n+        return serverGroupId;\n+    }\n+\n+    public boolean isRelocationNotAllowed() {\n+        return relocationNotAllowed;\n+    }\n+\n+    public boolean isRelocationRequired() {\n+        return relocationRequired;\n+    }\n+\n+    public boolean isRelocationRequiredImmediately() {\n+        return relocationRequiredImmediately;\n+    }\n+\n+    public boolean isServerGroupRelocationRequired() {\n+        return serverGroupRelocationRequired;\n+    }\n+\n+    public Builder toBuilder() {\n+        return newBuilder()\n+                .withId(id)\n+                .withServerGroupId(serverGroupId)\n+                .withRelocationRequired(relocationRequired)\n+                .withRelocationRequiredImmediately(relocationRequiredImmediately)\n+                .withRelocationNotAllowed(relocationNotAllowed)\n+                .withServerGroupRelocationRequired(serverGroupRelocationRequired);\n+    }\n+\n+    public static Builder newBuilder() {\n+        return new Builder();\n+    }\n+\n+    public static final class Builder {\n+        private String id;\n+        private String serverGroupId;\n+        private boolean relocationRequired;\n+        private boolean relocationNotAllowed;\n+        private boolean relocationRequiredImmediately;\n+        private boolean serverGroupRelocationRequired;\n+\n+        private Builder() {\n+        }\n+\n+        public Builder withId(String id) {\n+            this.id = id;\n+            return this;\n+        }\n+\n+        public Builder withServerGroupId(String serverGroupId) {\n+            this.serverGroupId = serverGroupId;\n+            return this;\n+        }\n+\n+        public Builder withRelocationNotAllowed(boolean relocationNotAllowed) {\n+            this.relocationNotAllowed = relocationNotAllowed;\n+            return this;\n+        }\n+\n+        public Builder withRelocationRequired(boolean relocationRequired) {\n+            this.relocationRequired = relocationRequired;\n+            return this;\n+        }\n+\n+        public Builder withRelocationRequiredImmediately(boolean relocationRequiredImmediately) {\n+            this.relocationRequiredImmediately = relocationRequiredImmediately;\n+            return this;\n+        }\n+\n+        public Builder withServerGroupRelocationRequired(boolean serverGroupRelocationRequired) {\n+            this.serverGroupRelocationRequired = serverGroupRelocationRequired;\n+            return this;\n+        }\n+\n+        public Node build() {\n+            Node node = new Node(id, serverGroupId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MTQ5MDcyOnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoxNToyNlrOHGz1mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoyMDoxNVrOHHTxyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwMjgxMA==", "bodyText": "Could be more clear calling it out as FenzoNodeResolver ?", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476902810", "createdAt": "2020-08-26T00:15:26Z", "author": {"login": "amit-git"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.AgentInstanceGroup;\n+import com.netflix.titus.api.agent.model.InstanceGroupLifecycleState;\n+import com.netflix.titus.api.agent.service.ReadOnlyAgentOperations;\n+import com.netflix.titus.common.util.tuple.Pair;\n+import com.netflix.titus.runtime.connector.agent.AgentDataReplicator;\n+import com.netflix.titus.supplementary.relocation.RelocationAttributes;\n+\n+public class AgentManagementNodeDataResolver implements NodeDataResolver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNjEyMw==", "bodyText": "It is resolver for AgentManagement API which is used by Fenzo only.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r477426123", "createdAt": "2020-08-26T16:20:15Z", "author": {"login": "tbak"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/AgentManagementNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import com.netflix.titus.api.agent.model.AgentInstance;\n+import com.netflix.titus.api.agent.model.AgentInstanceGroup;\n+import com.netflix.titus.api.agent.model.InstanceGroupLifecycleState;\n+import com.netflix.titus.api.agent.service.ReadOnlyAgentOperations;\n+import com.netflix.titus.common.util.tuple.Pair;\n+import com.netflix.titus.runtime.connector.agent.AgentDataReplicator;\n+import com.netflix.titus.supplementary.relocation.RelocationAttributes;\n+\n+public class AgentManagementNodeDataResolver implements NodeDataResolver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwMjgxMA=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MTQ5ODcyOnYy", "diffSide": "RIGHT", "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoxNzozNFrOHGz7Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoyMzoxMlrOHHT44A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwNDIyNw==", "bodyText": "minor : could it be combined with the indexer -> stream -> filter expression above ?", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r476904227", "createdAt": "2020-08-26T00:17:34Z", "author": {"login": "amit-git"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.runtime.connector.kubernetes.KubeApiFacade;\n+import com.netflix.titus.supplementary.relocation.RelocationConfiguration;\n+import io.kubernetes.client.informer.SharedIndexInformer;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LABEL_MACHINE_GROUP;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.TAINT_EFFECT_NO_EXECUTE;\n+\n+public class KubernetesNodeDataResolver implements NodeDataResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KubernetesNodeDataResolver.class);\n+\n+    private static final long NOT_SYNCED_STALENESS_MS = 10 * 3600_000;\n+\n+    private final SharedIndexInformer<V1Node> nodeInformer;\n+    private final Predicate<V1Node> nodeFilter;\n+\n+    private final Function<String, Matcher> relocationRequiredTaintsMatcher;\n+    private final Function<String, Matcher> relocationRequiredImmediatelyTaintsMatcher;\n+\n+    public KubernetesNodeDataResolver(RelocationConfiguration configuration,\n+                                      KubeApiFacade kubeApiFacade,\n+                                      Predicate<V1Node> nodeFilter) {\n+        this.nodeInformer = kubeApiFacade.getNodeInformer();\n+        this.relocationRequiredTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredTaints,\n+                \"nodeRelocationRequiredTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.relocationRequiredImmediatelyTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredImmediatelyTaints,\n+                \"nodeRelocationRequiredImmediatelyTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.nodeFilter = nodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<V1Node> k8Nodes = nodeInformer.getIndexer().list().stream().filter(nodeFilter).collect(Collectors.toList());\n+        Map<String, Node> result = new HashMap<>();\n+        k8Nodes.forEach(k8Node -> toReconcilerNode(k8Node).ifPresent(node -> result.put(node.getId(), node)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzkzNg==", "bodyText": "I wanted separate data access and filtering from data transformation. It helps in the debugging process.", "url": "https://github.com/Netflix/titus-control-plane/pull/902#discussion_r477427936", "createdAt": "2020-08-26T16:23:12Z", "author": {"login": "tbak"}, "path": "titus-supplementary-component/task-relocation/src/main/java/com/netflix/titus/supplementary/relocation/connector/KubernetesNodeDataResolver.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.supplementary.relocation.connector;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.runtime.connector.kubernetes.KubeApiFacade;\n+import com.netflix.titus.supplementary.relocation.RelocationConfiguration;\n+import io.kubernetes.client.informer.SharedIndexInformer;\n+import io.kubernetes.client.openapi.models.V1Node;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.NODE_LABEL_MACHINE_GROUP;\n+import static com.netflix.titus.runtime.kubernetes.KubeConstants.TAINT_EFFECT_NO_EXECUTE;\n+\n+public class KubernetesNodeDataResolver implements NodeDataResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KubernetesNodeDataResolver.class);\n+\n+    private static final long NOT_SYNCED_STALENESS_MS = 10 * 3600_000;\n+\n+    private final SharedIndexInformer<V1Node> nodeInformer;\n+    private final Predicate<V1Node> nodeFilter;\n+\n+    private final Function<String, Matcher> relocationRequiredTaintsMatcher;\n+    private final Function<String, Matcher> relocationRequiredImmediatelyTaintsMatcher;\n+\n+    public KubernetesNodeDataResolver(RelocationConfiguration configuration,\n+                                      KubeApiFacade kubeApiFacade,\n+                                      Predicate<V1Node> nodeFilter) {\n+        this.nodeInformer = kubeApiFacade.getNodeInformer();\n+        this.relocationRequiredTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredTaints,\n+                \"nodeRelocationRequiredTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.relocationRequiredImmediatelyTaintsMatcher = RegExpExt.dynamicMatcher(\n+                configuration::getNodeRelocationRequiredImmediatelyTaints,\n+                \"nodeRelocationRequiredImmediatelyTaints\",\n+                Pattern.DOTALL,\n+                logger);\n+        this.nodeFilter = nodeFilter;\n+    }\n+\n+    @Override\n+    public Map<String, Node> resolve() {\n+        List<V1Node> k8Nodes = nodeInformer.getIndexer().list().stream().filter(nodeFilter).collect(Collectors.toList());\n+        Map<String, Node> result = new HashMap<>();\n+        k8Nodes.forEach(k8Node -> toReconcilerNode(k8Node).ifPresent(node -> result.put(node.getId(), node)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwNDIyNw=="}, "originalCommit": {"oid": "d3f419e57412f9d66d9c649e6209b34ac460dc22"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4013, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}