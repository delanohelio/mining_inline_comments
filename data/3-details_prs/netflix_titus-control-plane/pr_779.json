{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MzkwMzc5", "number": 779, "title": "Shared Kube/Titus job reconciler", "bodyText": "", "createdAt": "2020-02-18T02:52:08Z", "url": "https://github.com/Netflix/titus-control-plane/pull/779", "merged": true, "mergeCommit": {"oid": "80a226069f71ecda1bdb8bf6695b106e29f9758c"}, "closed": true, "closedAt": "2020-02-19T21:15:46Z", "author": {"login": "tbak"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFYsfKgH2gAyMzc2MzkwMzc5OmRlOGQzYWJkMDU5NDQyMzFlNjc5ZWM2Mzc4ZDg5ZDg2NzBhOTFkMWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcF9JzMgFqTM2MTQzNTMxNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e", "author": {"user": {"login": "tbak", "name": null}}, "url": "https://github.com/Netflix/titus-control-plane/commit/de8d3abd05944231e679ec6378d89d8670a91d1e", "committedDate": "2020-02-18T02:42:01Z", "message": "Shared Kube/Titus job reconciler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTEzNDMw", "url": "https://github.com/Netflix/titus-control-plane/pull/779#pullrequestreview-360513430", "createdAt": "2020-02-18T17:03:18Z", "commit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowMzoxOFrOFrKt_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowOTo0M1rOFrK9Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwODcwMg==", "bodyText": "please add javadocs", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380808702", "createdAt": "2020-02-18T17:03:18Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/KubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import reactor.core.publisher.Flux;\n+\n+public interface KubeJobManagementReconciler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTg1OA==", "bodyText": "Instead of doing this, I suggest looking up the pod object and then using the pods nodeName so nodeName can change.", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380809858", "createdAt": "2020-02-18T17:05:13Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";\n+                        break;\n+                }\n+\n+                publishEvent(task,\n+                        TaskStatus.newBuilder()\n+                                .withState(TaskState.Finished)\n+                                .withReasonCode(reasonCode)\n+                                .withReasonMessage(reasonMessage)\n+                                .withTimestamp(clock.wallTime())\n+                                .build()\n+                );\n+            }\n+            logger.info(\"Finished orphaned task transitions to finished ({})\", kind);\n+        });\n+    }\n+\n+    private Optional<V1Node> findNode(Task task, Map<String, V1Node> nodes) {\n+        String instanceId = task.getTaskContext().get(TaskAttributes.TASK_ATTRIBUTES_AGENT_INSTANCE_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQ5OQ==", "bodyText": "I think there should be a better message here. Maybe Agent terminated due to underlying issue?", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380810499", "createdAt": "2020-02-18T17:06:14Z", "author": {"login": "corindwyer"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjU3NA==", "bodyText": "If there are many Accepted entries in the status history then you might not get the correct one.", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380812574", "createdAt": "2020-02-18T17:09:43Z", "author": {"login": "corindwyer"}, "path": "titus-api/src/main/java/com/netflix/titus/api/jobmanager/model/job/TaskStatus.java", "diffHunk": "@@ -153,6 +153,14 @@ public static boolean isEvicted(Task task) {\n                 ).orElse(false);\n     }\n \n+    public static boolean hasPod(Task task) {\n+        TaskStatus acceptedStatus = JobFunctions.findTaskStatus(task, TaskState.Accepted).orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTM0Nzgw", "url": "https://github.com/Netflix/titus-control-plane/pull/779#pullrequestreview-360534780", "createdAt": "2020-02-18T17:32:49Z", "commit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzozMjo1MFrOFrLwvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzo0OTo1MVrOFrMUxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyNTc5MQ==", "bodyText": "minor: add (matcher, reasonString) pairs to a collection and findFirst() on it to reduce duplication here", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380825791", "createdAt": "2020-02-18T17:32:50Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultContainerResultCodeResolver.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.common.util.RegExpExt;\n+import com.netflix.titus.common.util.StringExt;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Singleton\n+public class DefaultContainerResultCodeResolver implements ContainerResultCodeResolver {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultContainerResultCodeResolver.class);\n+\n+    private final Function<String, Matcher> invalidRequestMessageMatcherFactory;\n+    private final Function<String, Matcher> crashedMessageMatcherFactory;\n+    private final Function<String, Matcher> transientSystemErrorMessageMatcherFactory;\n+    private final Function<String, Matcher> localSystemErrorMessageMatcherFactory;\n+    private final Function<String, Matcher> unknownSystemErrorMessageMatcherFactory;\n+\n+    @Inject\n+    public DefaultContainerResultCodeResolver(MesosConfiguration mesosConfiguration) {\n+        this.invalidRequestMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getInvalidRequestMessagePattern, \"invalidRequestMessagePattern\", Pattern.DOTALL, logger);\n+        this.crashedMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getCrashedMessagePattern, \"crashedMessagePattern\", Pattern.DOTALL, logger);\n+        this.transientSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getTransientSystemErrorMessagePattern, \"transientSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+        this.localSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getLocalSystemErrorMessagePattern, \"localSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+        this.unknownSystemErrorMessageMatcherFactory = RegExpExt.dynamicMatcher(mesosConfiguration::getUnknownSystemErrorMessagePattern, \"unknownSystemErrorMessagePattern\", Pattern.DOTALL, logger);\n+    }\n+\n+    public Optional<String> resolve(TaskState taskState, String reasonMessage) {\n+        if (taskState != com.netflix.titus.api.jobmanager.model.job.TaskState.Finished || StringExt.isEmpty(reasonMessage)) {\n+            return Optional.empty();\n+        }\n+\n+        if (invalidRequestMessageMatcherFactory.apply(reasonMessage).matches()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyODM2MA==", "bodyText": "log something and/or emit a metric so we know when reconciliation is not running? Or alternatively, emit a metric when it runs", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380828360", "createdAt": "2020-02-18T17:37:43Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyOTIwMA==", "bodyText": "\ud83d\udc4d, something like: Terminated due to an issue with the underlying host machine", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380829200", "createdAt": "2020-02-18T17:39:15Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQ5OQ=="}, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMDEwMw==", "bodyText": "suggestion, something like: Abandoned with unknown state due to lack of status updates from the host machine", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380830103", "createdAt": "2020-02-18T17:40:55Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzMTY2NA==", "bodyText": "In the TaskState.Accepted && hasPod() case, I think we need a grace time to allow state propagation through kube-apiserver and our informers, otherwise we may be killing tasks prematurely", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380831664", "createdAt": "2020-02-18T17:43:45Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/DefaultKubeJobManagementReconciler.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.netflix.titus.master.mesos.kubeapiserver;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.netflix.spectator.api.Gauge;\n+import com.netflix.spectator.api.Registry;\n+import com.netflix.titus.api.jobmanager.TaskAttributes;\n+import com.netflix.titus.api.jobmanager.model.job.JobFunctions;\n+import com.netflix.titus.api.jobmanager.model.job.Task;\n+import com.netflix.titus.api.jobmanager.model.job.TaskState;\n+import com.netflix.titus.api.jobmanager.model.job.TaskStatus;\n+import com.netflix.titus.api.jobmanager.service.V3JobOperations;\n+import com.netflix.titus.common.framework.scheduler.ScheduleReference;\n+import com.netflix.titus.common.framework.scheduler.model.ScheduleDescriptor;\n+import com.netflix.titus.common.runtime.TitusRuntime;\n+import com.netflix.titus.common.util.Evaluators;\n+import com.netflix.titus.common.util.ExecutorsExt;\n+import com.netflix.titus.common.util.guice.annotation.Activator;\n+import com.netflix.titus.common.util.guice.annotation.Deactivator;\n+import com.netflix.titus.common.util.rx.ReactorExt;\n+import com.netflix.titus.common.util.time.Clock;\n+import com.netflix.titus.master.MetricConstants;\n+import com.netflix.titus.master.mesos.ContainerEvent;\n+import com.netflix.titus.master.mesos.MesosConfiguration;\n+import com.netflix.titus.master.mesos.V3ContainerEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.KubeApiFacade;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodEvent;\n+import com.netflix.titus.master.mesos.kubeapiserver.direct.model.PodNotFoundEvent;\n+import io.kubernetes.client.models.V1Node;\n+import io.kubernetes.client.models.V1Pod;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * {@link DefaultKubeJobManagementReconciler} checks that for each placed {@link Task} there exists a pod. If the pod does not\n+ * exist, and a task is in a running state, the task is moved to a finished state.\n+ */\n+@Singleton\n+public class DefaultKubeJobManagementReconciler implements KubeJobManagementReconciler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultKubeJobManagementReconciler.class);\n+\n+    private enum OrphanedKind {\n+        /**\n+         * If the last task status was KillInitiated and the system missed the last event then the assumption is that\n+         * the kubelet successfully terminated the pod and deleted the pod object.\n+         */\n+        KILL_INITIATED,\n+\n+        /**\n+         * If task is associated with an non-existing agent, assume the agent was terminated.\n+         */\n+        NODE_TERMINATED,\n+\n+        UNKNOWN\n+    }\n+\n+    private static final int ORPHANED_POD_TIMEOUT_MS = 60_000;\n+\n+    private final MesosConfiguration mesosConfiguration;\n+    private final KubeApiFacade kubeApiFacade;\n+    private final V3JobOperations v3JobOperations;\n+\n+    private final Clock clock;\n+    private final TitusRuntime titusRuntime;\n+\n+    private final DirectProcessor<ContainerEvent> v3ContainerEventProcessor = DirectProcessor.create();\n+    private final FluxSink<ContainerEvent> v3ContainerEventSink = v3ContainerEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final DirectProcessor<PodEvent> podEventProcessor = DirectProcessor.create();\n+    private final FluxSink<PodEvent> podEventSink = podEventProcessor.sink(FluxSink.OverflowStrategy.IGNORE);\n+\n+    private final Map<OrphanedKind, Gauge> orphanedTaskGauges;\n+\n+    private ScheduleReference schedulerRef;\n+\n+    @Inject\n+    public DefaultKubeJobManagementReconciler(MesosConfiguration mesosConfiguration,\n+                                              KubeApiFacade kubeApiFacade,\n+                                              V3JobOperations v3JobOperations,\n+                                              TitusRuntime titusRuntime) {\n+        this.mesosConfiguration = mesosConfiguration;\n+        this.kubeApiFacade = kubeApiFacade;\n+        this.v3JobOperations = v3JobOperations;\n+        this.clock = titusRuntime.getClock();\n+        this.titusRuntime = titusRuntime;\n+\n+        Registry registry = titusRuntime.getRegistry();\n+\n+        this.orphanedTaskGauges = Stream.of(OrphanedKind.values()).collect(Collectors.toMap(\n+                Function.identity(),\n+                kind -> registry.gauge(MetricConstants.METRIC_KUBERNETES + \"orphanedTasks\", \"kind\", kind.name())\n+        ));\n+    }\n+\n+    @Activator\n+    public void enterActiveMode() {\n+        ScheduleDescriptor scheduleDescriptor = ScheduleDescriptor.newBuilder()\n+                .withName(\"reconcileNodesAndPods\")\n+                .withDescription(\"Reconcile nodes and pods\")\n+                .withInitialDelay(Duration.ofMillis(mesosConfiguration.getReconcilerInitialDelayMs()))\n+                .withInterval(Duration.ofMillis(mesosConfiguration.getReconcilerIntervalMs()))\n+                .withTimeout(Duration.ofMinutes(5))\n+                .build();\n+        this.schedulerRef = titusRuntime.getLocalScheduler().schedule(\n+                scheduleDescriptor,\n+                e -> reconcile(),\n+                ExecutorsExt.namedSingleThreadExecutor(DefaultKubeJobManagementReconciler.class.getSimpleName())\n+        );\n+    }\n+\n+    @Deactivator\n+    @PreDestroy\n+    public void shutdown() {\n+        Evaluators.acceptNotNull(schedulerRef, ScheduleReference::cancel);\n+    }\n+\n+    @Override\n+    public Flux<ContainerEvent> getV3ContainerEventSource() {\n+        return v3ContainerEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    @Override\n+    public Flux<PodEvent> getPodEventSource() {\n+        return podEventProcessor.compose(ReactorExt.badSubscriberHandler(logger));\n+    }\n+\n+    private void reconcile() {\n+        if (!mesosConfiguration.isReconcilerEnabled() || !kubeApiFacade.getNodeInformer().hasSynced() || !kubeApiFacade.getPodInformer().hasSynced()) {\n+            return;\n+        }\n+\n+        List<V1Node> nodes = kubeApiFacade.getNodeInformer().getIndexer().list();\n+        List<V1Pod> pods = kubeApiFacade.getPodInformer().getIndexer().list();\n+        List<Task> tasks = v3JobOperations.getTasks();\n+\n+        Map<String, V1Node> nodesById = nodes.stream().collect(Collectors.toMap(\n+                node -> node.getMetadata().getName(),\n+                Function.identity()\n+        ));\n+        Map<String, Task> currentTasks = tasks.stream().collect(Collectors.toMap(Task::getId, Function.identity()));\n+        Set<String> currentPodNames = pods.stream().map(p -> p.getMetadata().getName()).collect(Collectors.toSet());\n+\n+        transitionOrphanedTasks(currentTasks, currentPodNames, nodesById);\n+    }\n+\n+    /**\n+     * Transition orphaned tasks to Finished that don't exist in Kubernetes.\n+     */\n+    private void transitionOrphanedTasks(Map<String, Task> currentTasks, Set<String> currentPodNames, Map<String, V1Node> nodes) {\n+        List<Task> tasksNotInApiServer = currentTasks.values().stream()\n+                .filter(t -> shouldTaskBeInApiServer(t) && !currentPodNames.contains(t.getId()))\n+                .collect(Collectors.toList());\n+\n+        Map<OrphanedKind, List<Task>> orphanedTasksByKind = new HashMap<>();\n+        for (Task task : tasksNotInApiServer) {\n+            if (task.getStatus().getState().equals(TaskState.KillInitiated)) {\n+                orphanedTasksByKind.computeIfAbsent(OrphanedKind.KILL_INITIATED, s -> new ArrayList<>()).add(task);\n+            } else {\n+                if (findNode(task, nodes).isPresent()) {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.UNKNOWN, s -> new ArrayList<>()).add(task);\n+                } else {\n+                    orphanedTasksByKind.computeIfAbsent(OrphanedKind.NODE_TERMINATED, s -> new ArrayList<>()).add(task);\n+                }\n+            }\n+        }\n+\n+        orphanedTasksByKind.forEach((kind, tasks) -> {\n+            logger.info(\"Attempting to transition {} orphaned tasks to finished ({}): {}\", tasks.size(), kind, tasks);\n+            orphanedTaskGauges.get(kind).set(tasks.size());\n+\n+            for (Task task : tasks) {\n+\n+                String reasonCode;\n+                String reasonMessage;\n+                switch (kind) {\n+                    case KILL_INITIATED:\n+                        reasonCode = TaskStatus.REASON_TASK_KILLED;\n+                        reasonMessage = \"Task killed\";\n+                        break;\n+                    case NODE_TERMINATED:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Agent terminated\";\n+                        break;\n+                    case UNKNOWN:\n+                    default:\n+                        reasonCode = TaskStatus.REASON_TASK_LOST;\n+                        reasonMessage = \"Task lost between control plane and machine\";\n+                        break;\n+                }\n+\n+                publishEvent(task,\n+                        TaskStatus.newBuilder()\n+                                .withState(TaskState.Finished)\n+                                .withReasonCode(reasonCode)\n+                                .withReasonMessage(reasonMessage)\n+                                .withTimestamp(clock.wallTime())\n+                                .build()\n+                );\n+            }\n+            logger.info(\"Finished orphaned task transitions to finished ({})\", kind);\n+        });\n+    }\n+\n+    private Optional<V1Node> findNode(Task task, Map<String, V1Node> nodes) {\n+        String instanceId = task.getTaskContext().get(TaskAttributes.TASK_ATTRIBUTES_AGENT_INSTANCE_ID);\n+        if (instanceId == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(nodes.get(instanceId));\n+    }\n+\n+    private boolean shouldTaskBeInApiServer(Task task) {\n+        boolean isRunning = TaskState.isRunning(task.getStatus().getState());\n+\n+        if (JobFunctions.isOwnedByKubeScheduler(task)) {\n+            return isRunning || (task.getStatus().getState() == TaskState.Accepted && TaskStatus.hasPod(task));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgzNTAxNQ==", "bodyText": "minor: maybe s/pod/task/ since this is an user facing message", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r380835015", "createdAt": "2020-02-18T17:49:51Z", "author": {"login": "fabiokung"}, "path": "titus-server-master/src/main/java/com/netflix/titus/master/mesos/kubeapiserver/direct/DefaultDirectKubeApiServerIntegrator.java", "diffHunk": "@@ -146,7 +150,14 @@ public void shutdown() {\n                 metrics.terminateError(task, e, timer.elapsed(TimeUnit.MILLISECONDS));\n \n                 if (e.getMessage().equalsIgnoreCase(NOT_FOUND) && task.getStatus().getState() == TaskState.Accepted) {\n-                    sendEvent(PodEvent.onPodNotFound(task));\n+                    sendEvent(PodEvent.onPodNotFound(task,\n+                            TaskStatus.newBuilder()\n+                                    .withState(TaskState.Finished)\n+                                    .withReasonCode(TaskStatus.REASON_TASK_LOST)\n+                                    .withReasonMessage(\"Pod terminate requested, but the pod is not found\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de8d3abd05944231e679ec6378d89d8670a91d1e"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76ce8e4091510dd56da59c41019caf8918a3390c", "author": {"user": {"login": "tbak", "name": null}}, "url": "https://github.com/Netflix/titus-control-plane/commit/76ce8e4091510dd56da59c41019caf8918a3390c", "committedDate": "2020-02-18T19:01:15Z", "message": "Code review updates, bug fixes and improvements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjM2Nzkz", "url": "https://github.com/Netflix/titus-control-plane/pull/779#pullrequestreview-360636793", "createdAt": "2020-02-18T20:07:14Z", "commit": {"oid": "76ce8e4091510dd56da59c41019caf8918a3390c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDM1MzE1", "url": "https://github.com/Netflix/titus-control-plane/pull/779#pullrequestreview-361435315", "createdAt": "2020-02-19T21:04:13Z", "commit": {"oid": "76ce8e4091510dd56da59c41019caf8918a3390c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowNDoxM1rOFr3jDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowNDoxM1rOFr3jDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzE4Mw==", "bodyText": "minor: I know it is not related to your PR, but what is agent.res? A comment here may help", "url": "https://github.com/Netflix/titus-control-plane/pull/779#discussion_r381543183", "createdAt": "2020-02-19T21:04:13Z", "author": {"login": "fabiokung"}, "path": "titus-api/src/main/java/com/netflix/titus/api/jobmanager/TaskAttributes.java", "diffHunk": "@@ -22,15 +22,19 @@\n      */\n     public static final String TASK_ATTRIBUTES_AGENT_REGION = \"agent.region\";\n     public static final String TASK_ATTRIBUTES_AGENT_ZONE = \"agent.zone\";\n+    public static final String TASK_ATTRIBUTES_AGENT_AMI = \"agent.ami\";\n     public static final String TASK_ATTRIBUTES_AGENT_ASG = \"agent.asg\";\n     public static final String TASK_ATTRIBUTES_AGENT_HOST = \"agent.host\";\n+    public static final String TASK_ATTRIBUTES_AGENT_CLUSTER = \"agent.cluster\";\n     public static final String TASK_ATTRIBUTES_AGENT_INSTANCE_ID = \"agent.instanceId\";\n     public static final String TASK_ATTRIBUTES_AGENT_ITYPE = \"agent.itype\";\n+    public static final String TASK_ATTRIBUTES_AGENT_RES = \"agent.res\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76ce8e4091510dd56da59c41019caf8918a3390c"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 631, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}