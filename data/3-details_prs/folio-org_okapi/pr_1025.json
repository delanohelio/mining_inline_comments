{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDcyNTg4", "number": 1025, "title": "Okapi 916 match path using hash", "bodyText": "OKAPI-916... More refactoring than at first sight, because the matching.. redirects.. auth caching.. metrics was all combined in one function. The ModuleCache is \"unaware\" of tenants, and is managed by TenantManager so that there's one ModuleCache per tenant. The redirect functionality is ugly and not in use.. We should consider removing it.\nRunning through all end points for Q2 modules, the number of match invocations is down from about 500k to 5k. That's ProxyTest.testManyModules.", "createdAt": "2020-10-29T18:22:38Z", "url": "https://github.com/folio-org/okapi/pull/1025", "merged": true, "mergeCommit": {"oid": "5057791f695f6bffb5799640ab9c6a74269df3a5"}, "closed": true, "closedAt": "2020-11-04T17:57:12Z", "author": {"login": "adamdickmeiss"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXVytIgH2gAyNTEyNDcyNTg4OmE3YzE2MGFiMjcxOTQxYzQxZmI3MjkyMGFkMjE0ODk1YTk3NDE2NTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZRhBmAFqTUyMzU5OTI5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a7c160ab271941c41fb72920ad214895a9741654", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/a7c160ab271941c41fb72920ad214895a9741654", "committedDate": "2020-10-29T17:40:53Z", "message": "Whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "223a35584edfa0e8807ccfef4f330011349f94d0", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/223a35584edfa0e8807ccfef4f330011349f94d0", "committedDate": "2020-10-29T17:41:05Z", "message": "Useless messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41b4df8a911c929a0db08f1eac6d4ac3ed51189f", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/41b4df8a911c929a0db08f1eac6d4ac3ed51189f", "committedDate": "2020-10-29T17:41:15Z", "message": "Might as well be static"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad8d47fc22d2d1cedd537291232165075c037b0", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/0ad8d47fc22d2d1cedd537291232165075c037b0", "committedDate": "2020-10-29T17:42:17Z", "message": "Two more static; fix npr for no module token returned by auth"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42f9510af093d3f77aa237a3582a5406ca69b049", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/42f9510af093d3f77aa237a3582a5406ca69b049", "committedDate": "2020-10-29T17:42:32Z", "message": "Log cause when job fails"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64ed6c09275c61d07cf2b2319a49bee4dd7a9a2c", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/64ed6c09275c61d07cf2b2319a49bee4dd7a9a2c", "committedDate": "2020-10-29T17:45:08Z", "message": "Deploy 104 modules and test paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1202237036481422d29de951632d3d5bf8a64f0a", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/1202237036481422d29de951632d3d5bf8a64f0a", "committedDate": "2020-10-30T14:44:42Z", "message": "Allow ProxyTest to use Metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41e7c4626897fab465953f7a4d5d2373edae4c35", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/41e7c4626897fab465953f7a4d5d2373edae4c35", "committedDate": "2020-10-30T14:54:40Z", "message": "ModuleCache with lookup in progress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a75d339b7b573e6da328a20daa16dc73293e33f4", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/a75d339b7b573e6da328a20daa16dc73293e33f4", "committedDate": "2020-10-30T14:55:28Z", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89c4e099dfdaf9c8e490ad2ec623490e97bdeff3", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/89c4e099dfdaf9c8e490ad2ec623490e97bdeff3", "committedDate": "2020-10-31T14:38:48Z", "message": "Tests for ModuleCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfb2ace8a9f2ff1fce85e93e76d3ec395553ce49", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/dfb2ace8a9f2ff1fce85e93e76d3ec395553ce49", "committedDate": "2020-11-01T09:41:40Z", "message": "ModuleCacheEntry; more testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e1fc5509ce35053b3e5c140883c9a49bd5d69a8", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/0e1fc5509ce35053b3e5c140883c9a49bd5d69a8", "committedDate": "2020-11-02T09:43:46Z", "message": "Consider id for multi entries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c90da2b311c556a7e27d4b0ecb014b6d6fee1dfe", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/c90da2b311c556a7e27d4b0ecb014b6d6fee1dfe", "committedDate": "2020-11-02T16:00:28Z", "message": "ModuleCache in use\n\nEntries of ype redirect not handled (ProxyTest.testRedirect ignored)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "147c4e1c7aff661080a6344ee7356536f4ef21b7", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/147c4e1c7aff661080a6344ee7356536f4ef21b7", "committedDate": "2020-11-02T17:04:25Z", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "385bcda208ffc15903594f57c639c6b0da4d85c8", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/385bcda208ffc15903594f57c639c6b0da4d85c8", "committedDate": "2020-11-03T10:27:17Z", "message": "Handling redirect; ModuleManager wo TenantManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a71c8a2b23f8100398929b1fbef7544b08cfd8f4", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/a71c8a2b23f8100398929b1fbef7544b08cfd8f4", "committedDate": "2020-11-03T11:09:04Z", "message": "Add ModuleUtilTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "648bdca223fbca754c593fb18c637a074fe3e383", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/648bdca223fbca754c593fb18c637a074fe3e383", "committedDate": "2020-11-03T11:31:19Z", "message": "Test ModuleCache.getPatternPrefix separately"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c2f610492a93f8ae24e9c4d5be71a6a3c4630e7", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/1c2f610492a93f8ae24e9c4d5be71a6a3c4630e7", "committedDate": "2020-11-03T11:52:25Z", "message": "Per tenant module cache updates\n\nTenant removal clears ModuleCache. Tenant updates during start up\nalso updates ModuleCache."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8aed2ba8156894efbfbcd6bbed02f1f399fb56a", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/e8aed2ba8156894efbfbcd6bbed02f1f399fb56a", "committedDate": "2020-11-03T12:20:18Z", "message": "Remove log info msg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a42c5ecdadc8bd46f41fccaefd173c8e56381cd6", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/a42c5ecdadc8bd46f41fccaefd173c8e56381cd6", "committedDate": "2020-11-03T12:25:36Z", "message": "ModuleUtilTest SQ recommendations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87b2f2974c22a3156338534560d49503cb555cc6", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/87b2f2974c22a3156338534560d49503cb555cc6", "committedDate": "2020-11-03T13:44:00Z", "message": "Metrics for ProxyService.getModulesForRequest again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cdb1be41fcfb37ce5e40519f3e864dca9adf35d", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/5cdb1be41fcfb37ce5e40519f3e864dca9adf35d", "committedDate": "2020-11-03T13:44:42Z", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ad676506323184056b912d75d07985e0adead4", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/b6ad676506323184056b912d75d07985e0adead4", "committedDate": "2020-11-03T14:38:49Z", "message": "Delete module woes\n\nDelete module has always returned 404 on not found; but the RAML\ndidn't say so."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNzA1NDIx", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-522705421", "createdAt": "2020-11-03T17:04:42Z", "commit": {"oid": "b6ad676506323184056b912d75d07985e0adead4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDo0MlrOHs4WCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDo0MlrOHs4WCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjUzOA==", "bodyText": "This should be replaced by\nreturn Future.succeededFuture(enabledModulesCache.computeIfAbsent(tenant.getId(), key -> new ModuleCache(new LinkedList<>())));", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r516822538", "createdAt": "2020-11-03T17:04:42Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -1044,6 +1085,68 @@ private ModuleInstance getTenantInstanceForInterface(\n     });\n   }\n \n+  /**\n+   * Get module cache for tenant.\n+   * @param tenant Tenant\n+   * @return Module Cache\n+   */\n+  public Future<ModuleCache> getModuleCache(Tenant tenant) {\n+    if (!enabledModulesCache.containsKey(tenant.getId())) {\n+      return Future.succeededFuture(new ModuleCache(new LinkedList<>()));\n+    }\n+    return Future.succeededFuture(enabledModulesCache.get(tenant.getId()));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ad676506323184056b912d75d07985e0adead4"}, "originalPosition": 237}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/3cc3fcd6a99e03d0a644a984067083fdc4f20e72", "committedDate": "2020-11-04T07:34:19Z", "message": "Merge branch 'master' into OKAPI-916-match-path-using-hash"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMTU4NDUy", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523158452", "createdAt": "2020-11-04T09:02:15Z", "commit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTowMjoxNVrOHtOusQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTowMjoxNVrOHtOusQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTI5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n          \n          \n            \n                      return moduleManager.delete(id).map(\"\");", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517189297", "createdAt": "2020-11-04T09:02:15Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -904,7 +904,14 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n   }\n \n   private Future<String> deleteModule(String id) {\n-    return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n+    return tenantManager.getModuleUser(id)\n+        .compose(tenants -> {\n+          if (!tenants.isEmpty()) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10206\", id, tenants.get(0))));\n+          }\n+          return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMTY2OTg2", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523166986", "createdAt": "2020-11-04T09:13:01Z", "commit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToxMzowMVrOHtPHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToxMzowMVrOHtPHqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5NTY5MA==", "bodyText": ".onComplete(cacheRes -> {\n  if (cacheRes.failed()) {\n    FAILUREBLOCK\n    return;\n  }\n  ModuleCache cache = cacheRes.result();\n  SUCCESSBLOCK\n});\n\nshould be replaced by\n.onFailure(cause -> {\n  FAILUREBLOCK\n}).onSuccess(cache -> {\n  SUCCESSBLOCK\n});", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517195690", "createdAt": "2020-11-04T09:13:01Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -664,16 +560,16 @@ public void proxy(RoutingContext ctx) {\n         pc.responseError(400, messages.getMessage(\"10106\", tenantId));\n         return;\n       }\n-      Tenant tenant = gres.result();\n-      moduleManager.getEnabledModules(tenant).onComplete(mres -> {\n-        if (mres.failed()) {\n+      tenantManager.getModuleCache(gres.result()).onComplete(cacheRes -> {\n+        if (cacheRes.failed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c54c3f68d6d4faaf9d13d5bf0f71db6a166a9d8", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/4c54c3f68d6d4faaf9d13d5bf0f71db6a166a9d8", "committedDate": "2020-11-04T11:39:02Z", "message": "map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce0eef4e2a42c62f152aca29968ace24c4109ce2", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/ce0eef4e2a42c62f152aca29968ace24c4109ce2", "committedDate": "2020-11-04T11:39:33Z", "message": "Refactor to use on{Failure,Success} rather than onComplete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/5e231f3db75a49c0062a339bebb7b1544e00a162", "committedDate": "2020-11-04T12:18:19Z", "message": "efactor to use on{Failure,Success} rather than onComplete 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzQ0MzU0", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523344354", "createdAt": "2020-11-04T13:11:07Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxMTowN1rOHtXZjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxMTowN1rOHtXZjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMTM0Mg==", "bodyText": "Can you extract this duplicated code into some method, for example assertEmptyReport(RestAssuredClient c)?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517331342", "createdAt": "2020-11-04T13:11:07Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/ModuleTest.java", "diffHunk": "@@ -625,10 +625,22 @@ public void testFilters(TestContext context) {\n \n     // Clean up (in reverse order)\n     logger.debug(\"testFilters starting to clean up\");\n-    given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n-    given().delete(locationPostDeployment).then().log().ifValidationFails().statusCode(204);\n+    c = api.createRestAssured3();\n+    c.given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n+    Assert.assertTrue(\"raml: \" + c.getLastReport().toString(),\n+        c.getLastReport().isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzQ4OTg5", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523348989", "createdAt": "2020-11-04T13:17:19Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxNzoxOVrOHtXnow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxNzoxOVrOHtXnow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDk0Nw==", "bodyText": "You can directly provide an empty string when you use CsvSource' quoting:\n\"{id}, ''\"", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517334947", "createdAt": "2020-11-04T13:17:19Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzQ5ODkw", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523349890", "createdAt": "2020-11-04T13:18:27Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODoyN1rOHtXqIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODoyN1rOHtXqIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void testGetPatternPrefix(ArgumentsAccessor accessor) {\n          \n          \n            \n              void testGetPatternPrefix(String pathPattern, String expect) {", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517335587", "createdAt": "2020-11-04T13:18:27Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzcwNTk2", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523370596", "createdAt": "2020-11-04T13:43:14Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzoxNFrOHtYm2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzoxNFrOHtYm2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyOA==", "bodyText": "Is this supposed to be onSuccess or onComplete? Do you want checkSuperTenant always be done?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517351128", "createdAt": "2020-11-04T13:43:14Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onComplete(ires -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c163b7873bd39612c79bcc35ee0732a71bbc08c3", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/c163b7873bd39612c79bcc35ee0732a71bbc08c3", "committedDate": "2020-11-04T13:49:18Z", "message": "assertEmptyReport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9f1540bf3939b848a933217e32345ad9600ec89", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/b9f1540bf3939b848a933217e32345ad9600ec89", "committedDate": "2020-11-04T13:49:33Z", "message": "Simplify test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa6594a1fe961147d351b6695b8356397ca68122", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/aa6594a1fe961147d351b6695b8356397ca68122", "committedDate": "2020-11-04T13:51:15Z", "message": "Was supposed to be onSucccess"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzc5NzA5", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523379709", "createdAt": "2020-11-04T13:53:49Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Mzo0OVrOHtZBww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Mzo0OVrOHtZBww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODAxOQ==", "bodyText": "Looks like this method is not used anymore.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517358019", "createdAt": "2020-11-04T13:53:49Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -132,62 +133,13 @@ private void makeTraceHeader(ModuleInstance mi, int statusCode,\n     pc.logResponse(mi.getModuleDescriptor().getId(), url, statusCode);\n   }\n \n-  private boolean match(RoutingEntry e, HttpServerRequest req) {\n+  private static boolean match(RoutingEntry e, HttpServerRequest req) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/9d3a75fb829a43f31e4f92cff99f320bafe5004c", "committedDate": "2020-11-04T14:00:38Z", "message": "Remove unused ProxyService.match"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzg4MTU5", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523388159", "createdAt": "2020-11-04T14:02:58Z", "commit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMjo1OVrOHtZaqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMjo1OVrOHtZaqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ==", "bodyText": "If you have\nFunction<ModuleInstance, RoutingEntry> routingEntry = ModuleInstance::getRoutingEntry;\n\nyou can reduce the two lines to a one-liner:\nassertThat(instances).extracting(routingEntry).containsExactly(routingEntry1);", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517364395", "createdAt": "2020-11-04T14:02:59Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDA2MzM2", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523406336", "createdAt": "2020-11-04T14:21:51Z", "commit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMTo1MlrOHtaRTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMTo1MlrOHtaRTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODM4Mw==", "bodyText": "assertThat is missing", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378383", "createdAt": "2020-11-04T14:21:52Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDA2ODE1", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523406815", "createdAt": "2020-11-04T14:22:20Z", "commit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMjoyMFrOHtaSsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMjoyMFrOHtaSsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODczOA==", "bodyText": "assertThat is missing", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378738", "createdAt": "2020-11-04T14:22:20Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/perms/users\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users1\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    ModuleCache.lookup(\"/perms/user\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a10a105ab55b5afc5ff07aaf25aa3d5710791b63", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/a10a105ab55b5afc5ff07aaf25aa3d5710791b63", "committedDate": "2020-11-04T14:24:51Z", "message": "Simplify instance list assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ccea4e1e7b1e873ae877fc0ce0d00471ad6b436", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/7ccea4e1e7b1e873ae877fc0ce0d00471ad6b436", "committedDate": "2020-11-04T14:26:06Z", "message": "Missing assertThat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eec483352002704e4c720ce3eda6e5b0abf59745", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/eec483352002704e4c720ce3eda6e5b0abf59745", "committedDate": "2020-11-04T14:31:01Z", "message": "Missing assertThat 2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda", "committedDate": "2020-11-04T14:45:01Z", "message": "Use StandardCharsets.UTF_8 and avoid exception handling"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDU4OTQx", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523458941", "createdAt": "2020-11-04T15:15:21Z", "commit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToyMVrOHtcrVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToyMVrOHtcrVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzgxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int index = 0;\n          \n          \n            \n                while (index < pathPattern.length()) {\n          \n          \n            \n                  if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n          \n          \n            \n                    while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n          \n          \n            \n                      --index;\n          \n          \n            \n                    }\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  index++;\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern.substring(0, index);\n          \n          \n            \n                int lastSlash = 0;\n          \n          \n            \n                for (int i = 0; i < pathPattern.length(); i++) {\n          \n          \n            \n                  switch (pathPattern.charAt(i)) {\n          \n          \n            \n                    case '*':\n          \n          \n            \n                    case '{':\n          \n          \n            \n                      return pathPattern.substring(0, lastSlash);\n          \n          \n            \n                    case '/':\n          \n          \n            \n                      lastSlash = i + 1;\n          \n          \n            \n                      break;\n          \n          \n            \n                    default:\n          \n          \n            \n                      break;\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern;", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517417812", "createdAt": "2020-11-04T15:15:21Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNDg4OTgy", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523488982", "createdAt": "2020-11-04T15:46:05Z", "commit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTo0NjowNVrOHteDqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTo0NjowNVrOHteDqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDQyNw==", "bodyText": "We can use lastIndexOf:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int index = tryUri.length() - 1;\n          \n          \n            \n                  while (index > 0 && tryUri.charAt(index - 1) != '/') {\n          \n          \n            \n                    --index;\n          \n          \n            \n                  }\n          \n          \n            \n                  if (index <= 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index);\n          \n          \n            \n                  int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n          \n          \n            \n                  if (index < 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index + 1);", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517440427", "createdAt": "2020-11-04T15:46:05Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.length() - 1;\n+      while (index > 0 && tryUri.charAt(index - 1) != '/') {\n+        --index;\n+      }\n+      if (index <= 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTAwMjQy", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523500242", "createdAt": "2020-11-04T15:57:48Z", "commit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/290e3ba0211f27b6b3a72d9912640193b2e75c34", "committedDate": "2020-11-04T16:17:35Z", "message": "Two simplifications for working with uris"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTMwMjY3", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523530267", "createdAt": "2020-11-04T16:29:19Z", "commit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoyOToyMFrOHtf_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoyOToyMFrOHtf_NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjA1Mg==", "bodyText": "This PR did not change this part, but I am wondering if we should consider downgrade Okapi version for superteant so it matches the actual running version?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517472052", "createdAt": "2020-11-04T16:29:20Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onSuccess(ires -> {\n         checkSuperTenant(okapiModule, promise);\n       });\n     });\n     return promise.future();\n   }\n \n   private void checkSuperTenant(String okapiModule, Promise<Void> promise) {\n-    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n-        Tenant st = gres.result();\n-        Set<String> enabledMods = st.getEnabled().keySet();\n-        if (enabledMods.contains(okapiModule)) {\n-          logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n-          promise.complete();\n-          return;\n-        }\n-        // Check version compatibility\n-        String enver = \"\";\n-        for (String emod : enabledMods) {\n-          if (emod.startsWith(\"okapi-\")) {\n-            enver = emod;\n-          }\n-        }\n-        final String ev = enver;\n-        logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n-            ev, okapiModule);\n-        // See Okapi-359 about version checks across the cluster\n-        if (ModuleId.compare(ev, okapiModule) >= 4) {\n-          logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n-                  + \"{} we already have {} in the database. Use that!\",\n-              okapiVersion, ev);\n-          promise.complete();\n-          return;\n+    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onSuccess(tenant -> {\n+      // we already have one, go on\n+      logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n+      Set<String> enabledMods = tenant.getEnabled().keySet();\n+      if (enabledMods.contains(okapiModule)) {\n+        logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n+        promise.complete();\n+        return;\n+      }\n+      // Check version compatibility\n+      String enver = \"\";\n+      for (String emod : enabledMods) {\n+        if (emod.startsWith(\"okapi-\")) {\n+          enver = emod;\n         }\n-        logger.info(\"checkSuperTenant: Need to upgrade the stored version from {} to {}\",\n-            ev, okapiModule);\n-        // Use the commit, easier interface.\n-        // the internal module can not have dependencies\n-        // See Okapi-359 about version checks across the cluster\n-        tenantManager.updateModuleCommit(st, ev, okapiModule).onComplete(ures -> {\n-          if (ures.failed()) {\n-            promise.fail(ures.cause());\n-            return;\n-          }\n-          logger.info(\"Upgraded the InternalModule version from '{}' to '{}' for {}\",\n-              ev, okapiModule, XOkapiHeaders.SUPERTENANT_ID);\n-          promise.complete();\n-        });\n+      }\n+      final String ev = enver;\n+      logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n+          ev, okapiModule);\n+      // See Okapi-359 about version checks across the cluster\n+      if (ModuleId.compare(ev, okapiModule) >= 4) {\n+        logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n+                + \"{} we already have {} in the database. Use that!\",\n+            okapiVersion, ev);\n+        promise.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTMxNjQ0", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523531644", "createdAt": "2020-11-04T16:30:46Z", "commit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMDo0N1rOHtgDOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMDo0N1rOHtgDOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MzA4MA==", "bodyText": "Can this loop be combined with above one?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517473080", "createdAt": "2020-11-04T16:30:47Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTM0NDU5", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523534459", "createdAt": "2020-11-04T16:33:50Z", "commit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMzo1MFrOHtgLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMzo1MFrOHtgLbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg==", "bodyText": "Wondering if we should extract this so it won't be executed every time?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517475182", "createdAt": "2020-11-04T16:33:50Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/fc5dca92bc319f90e95bdb6b78c98c28510ff4e1", "committedDate": "2020-11-04T17:09:38Z", "message": "token cache check in one loop"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTc2NjAw", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523576600", "createdAt": "2020-11-04T17:21:21Z", "commit": {"oid": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyMToyMVrOHtiI1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyMToyMVrOHtiI1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNzI4Ng==", "bodyText": "Can remove ModuleCache prefix since it is in the same class.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517507286", "createdAt": "2020-11-04T17:21:21Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int lastSlash = 0;\n+    for (int i = 0; i < pathPattern.length(); i++) {\n+      switch (pathPattern.charAt(i)) {\n+        case '*':\n+        case '{':\n+          return pathPattern.substring(0, lastSlash);\n+        case '/':\n+          lastSlash = i + 1;\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+    return pathPattern;\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n+      if (index < 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index + 1);\n+    }\n+    return instances;\n+  }\n+\n+  /**\n+   * Find module instances for uri(path) and method.\n+   * @param uri request uri\n+   * @param method HTTP method\n+   * @param id Proxy-ID for multi lookup; otherwise null\n+   * @return module instances that match\n+   * @throws IllegalArgumentException for redirect errors\n+   */\n+  public List<ModuleInstance> lookup(String uri, HttpMethod method, String id) {\n+    logger.debug(\"lookup {} {} id={}\", () -> method.name(), () -> uri, () -> id);\n+    logger.debug(\"Available modules {}\", () -> ModuleUtil.moduleList(moduleDescriptors));\n+    // perform lookup of filters\n+    List<ModuleInstance> instances = ModuleCache.lookup(uri, method, filterMap, false, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1"}, "originalPosition": 183}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2990eb925468eb868afdc73718db2ce55dcb32ff", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/2990eb925468eb868afdc73718db2ce55dcb32ff", "committedDate": "2020-11-04T17:30:25Z", "message": "Omit redunt class ref"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba73b84e4a2f0086abdecb27a0b3a89273863bbd", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/ba73b84e4a2f0086abdecb27a0b3a89273863bbd", "committedDate": "2020-11-04T17:31:14Z", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-916-match-path-using-hash"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ae3f36f9e2c01077d38efedc3d133814cb773d6", "author": {"user": {"login": "adamdickmeiss", "name": "Adam Dickmeiss"}}, "url": "https://github.com/folio-org/okapi/commit/9ae3f36f9e2c01077d38efedc3d133814cb773d6", "committedDate": "2020-11-04T17:48:07Z", "message": "Construct instance comparator once"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzNTk5Mjkw", "url": "https://github.com/folio-org/okapi/pull/1025#pullrequestreview-523599290", "createdAt": "2020-11-04T17:49:48Z", "commit": {"oid": "9ae3f36f9e2c01077d38efedc3d133814cb773d6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2897, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}