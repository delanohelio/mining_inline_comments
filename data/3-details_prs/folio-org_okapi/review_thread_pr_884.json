{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MjkzMzcz", "number": 884, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyODozNFrODiSzpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozNTozM1rODitAAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg2MzEwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyODozNFrOFtddXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMjowNjowMVrOFteYfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjg5NA==", "bodyText": "There are two relevant cases that should also been tested:\nIf mdA100, mdA110, mdD100 and mdD110 are available, and mdA100 and mdD100 are enabled.\nFirst case: Enable mdA110 and check that both are upgraded.\nSecond case: Enable mdD110 and check that both are upgraded.", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383212894", "createdAt": "2020-02-24T11:28:34Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyODAyOA==", "bodyText": "First case: only mdA110 will be upgraded, because mdD100 can use the provided interface of mdA110.\nSecond case: both will be upgraded, because mdD110 will require mdA110.", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383228028", "createdAt": "2020-02-24T12:06:01Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjg5NA=="}, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg2OTAxOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMTozMTowN1rOFtdhGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzowNDoyOFrOFtf3Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ==", "bodyText": "In all these tests there is no need to use Async.\nReplace \"res -> { context.assertTrue(res.succeeded());\" by \"context.asyncAssertSuccess(res ->\"\nand \"res -> { context.assertTrue(res.failed());\" by \"context.asyncAssertFailure(exception ->\"", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383213851", "createdAt": "2020-02-24T11:31:07Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMDY4Ng==", "bodyText": "oh yes.. Seen that before", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383220686", "createdAt": "2020-02-24T11:48:09Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyNTA2MA==", "bodyText": "Can't do like that, cause AsyncResult != ExtendedAsyncResult. I know one could use a utility or something, but least the async is systematically used.", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383225060", "createdAt": "2020-02-24T11:58:31Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI1MjMyMw==", "bodyText": "That's true and technical dept. https://issues.folio.org/browse/OKAPI-810 \"Replace ExtendedAsyncResult by AsyncResult where possible\"", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383252323", "createdAt": "2020-02-24T13:04:28Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,180 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMzg1MQ=="}, "originalCommit": {"oid": "66737df6b10006b74fdfdd990af6f631f9e3e37b"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MzE3NDQzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMzoyMTozOVrOFtgXOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMjo1MzozNlrOFuE79w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MDQ3NQ==", "bodyText": "Yes, no moduleD upgrade is needed because moduleA's new interface is compatible (int-1.0 -> int-1.1).\nCan you add another test where moduleA-1.0.0 is upgraded to moduleA-2.0.0 with int-2.0 and this triggers the moduleD upgrade from moduleD-1.0.0 to moduleD-2.0.0 because moduleD-2.0.0 has optional dependency on int-2.0?", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383260475", "createdAt": "2020-02-24T13:21:39Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,247 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // upgrade base dependency which is still compatible with optional interface\n+  @Test\n+  public void testInstallOptionalExistingModule2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdA110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f9196e01f079f92ea80d4f1995573cf244f2d2c"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg1OTcwMw==", "bodyText": "Good one. That was a reverse dependency not catched.. Now fixed.", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383859703", "createdAt": "2020-02-25T12:53:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/DepResolutionTest.java", "diffHunk": "@@ -220,23 +235,247 @@ public void test4(TestContext context) {\n     });\n   }\n \n+  // install optional with no provided ingerface enabled\n+  @Test\n+  public void testInstallOptional1(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with a matched interface provided\n+  @Test\n+  public void testInstallOptional2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD100.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleD-1.0.0\", tml.get(0).getId());\n+      context.assertEquals(null, tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that is too low (error)\n+  @Test\n+  public void testInstallOptionalFail(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.failed());\n+      context.assertEquals(\"enable moduleD-1.1.0 failed: interface int required by module moduleD-1.1.0 not found\", res.cause().getMessage());\n+      async.complete();\n+    });\n+  }\n+\n+  // install optional with existing interface that needs upgrading\n+  @Test\n+  public void testInstallOptionalExistingModule(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+    modsAvailable.put(mdE100.getId(), mdE100);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdD110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(2, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());\n+      context.assertEquals(\"moduleD-1.1.0\", tml.get(1).getId());\n+      context.assertEquals(null, tml.get(1).getFrom());\n+      context.assertEquals(\"enable\", tml.get(1).getAction().name());\n+      async.complete();\n+    });\n+  }\n+\n+  // upgrade base dependency which is still compatible with optional interface\n+  @Test\n+  public void testInstallOptionalExistingModule2(TestContext context) {\n+    Async async = context.async();\n+\n+    Map<String, ModuleDescriptor> modsAvailable = new HashMap<>();\n+    modsAvailable.put(mdA100.getId(), mdA100);\n+    modsAvailable.put(mdA110.getId(), mdA110);\n+    modsAvailable.put(mdD100.getId(), mdD100);\n+    modsAvailable.put(mdD110.getId(), mdD110);\n+\n+    Map<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+    modsEnabled.put(mdA100.getId(), mdA100);\n+    modsEnabled.put(mdD100.getId(), mdD100);\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    TenantModuleDescriptor tm = new TenantModuleDescriptor();\n+    tm.setAction(TenantModuleDescriptor.Action.enable);\n+    tm.setId(mdA110.getId());\n+    tml.add(tm);\n+\n+    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n+      context.assertTrue(res.succeeded());\n+      logger.debug(\"tml result = \" + Json.encodePrettily(tml));\n+      context.assertEquals(1, tml.size());\n+      context.assertEquals(\"moduleA-1.1.0\", tml.get(0).getId());\n+      context.assertEquals(\"moduleA-1.0.0\", tml.get(0).getFrom());\n+      context.assertEquals(\"enable\", tml.get(0).getAction().name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2MDQ3NQ=="}, "originalCommit": {"oid": "7f9196e01f079f92ea80d4f1995573cf244f2d2c"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzA4MzI4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzoxNDo1MFrOFuFkFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1ODozNlrOFuHCVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2OTk3Mg==", "bodyText": "ret is not used. Can you remove this variable?", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383869972", "createdAt": "2020-02-25T13:14:50Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+      if (mTo != null) {\n+        List<String> ret = addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757aec1531861244e26af07a53574f885da4818d"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDEwMA==", "bodyText": "Done", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383894100", "createdAt": "2020-02-25T13:58:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+      if (mTo != null) {\n+        List<String> ret = addModuleDependencies(mTo, modsAvailable, modsEnabled, tml);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2OTk3Mg=="}, "originalCommit": {"oid": "757aec1531861244e26af07a53574f885da4818d"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzE1NDU4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzozNTozM1rOFuGOwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1ODoyOVrOFuHCDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MDg5Ng==", "bodyText": "This will reduce the cyclomatic complexity from 52 to 37 -- less nesting improves readability:\n  for (InterfaceDescriptor prov : md.getProvidesList()) {\n    for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n      if (! prov.getId().equals(req.getId()) || prov.isCompatible(req)) {\n        continue;\n      }\n      for (ModuleDescriptor ma : modsAvailable.values()) {\n        if (! me.getProduct().equals(ma.getProduct())) {\n          continue;\n        }\n        for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n          if (prov.isCompatible(re1) && (mTo == null || ma.compareTo(mTo) > 0)) {\n            mTo = ma;\n          }\n        }\n      }\n    }\n  }", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383880896", "createdAt": "2020-02-25T13:35:33Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757aec1531861244e26af07a53574f885da4818d"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDAzMA==", "bodyText": "Done", "url": "https://github.com/folio-org/okapi/pull/884#discussion_r383894030", "createdAt": "2020-02-25T13:58:29Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/DepResolution.java", "diffHunk": "@@ -458,14 +487,57 @@ private static void addOrReplace(List<TenantModuleDescriptor> tml, ModuleDescrip\n     tml.add(t);\n   }\n \n+  private static void upgradeLeafs(ModuleDescriptor md, Map<String, ModuleDescriptor> modsAvailable,\n+    Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n+\n+    Iterator<ModuleDescriptor> it = modsEnabled.values().iterator();\n+    while (it.hasNext()) {\n+      ModuleDescriptor me = it.next();\n+      if (me.equals(md)) {\n+        continue;\n+      }\n+      ModuleDescriptor mTo = null;\n+      for (InterfaceDescriptor prov : md.getProvidesList()) {\n+        for (InterfaceDescriptor req : me.getRequiresOptionalList()) {\n+          if (prov.getId().equals(req.getId()) && !prov.isCompatible(req)) {\n+            for (ModuleDescriptor ma : modsAvailable.values()) {\n+              if (me.getProduct().equals(ma.getProduct())) {\n+                for (InterfaceDescriptor re1 : ma.getRequiresOptionalList()) {\n+                  if (prov.isCompatible(re1)) {\n+                    if (mTo == null || ma.compareTo(mTo) > 0) {\n+                      mTo = ma;\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4MDg5Ng=="}, "originalCommit": {"oid": "757aec1531861244e26af07a53574f885da4818d"}, "originalPosition": 230}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 216, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}