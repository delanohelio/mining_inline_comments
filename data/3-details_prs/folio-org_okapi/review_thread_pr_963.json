{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NzYwNDM2", "number": 963, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1Nzo0MFrOEkCs6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMTowNzozOFrOEnOD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjI4NDU2OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/raml/okapi.raml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1Nzo0MFrOHSvjDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowODozN1rOHS1hsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTQzOA==", "bodyText": "The default value is missing. We need it to display on https://dev.folio.org/reference/api/#okapi", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489415438", "createdAt": "2020-09-16T12:57:40Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzM5Mw==", "bodyText": "There's no default for any parameters in the Okapi RAML (but mentioned in the description in places). I'll add it.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489513393", "createdAt": "2020-09-16T15:08:37Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTQzOA=="}, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjI4NTg0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/raml/okapi.raml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjo1ODowMFrOHSvj4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNTowODo0M1rOHS1h6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTY1MQ==", "bodyText": "The default value is missing. We need it to display on https://dev.folio.org/reference/api/#okapi", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489415651", "createdAt": "2020-09-16T12:58:00Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors\n+            type: boolean\n+            required: false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUxMzQ1MA==", "bodyText": "OK", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489513450", "createdAt": "2020-09-16T15:08:43Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors\n+            type: boolean\n+            required: false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNTY1MQ=="}, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MjMwMTEyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/raml/okapi.raml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzowMToyNVrOHSvtPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTozODozNFrOHTyr_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA==", "bodyText": "Should be more verbose what \"ignore\" means. The complete explanation that exists in guide.md should be included in the description here to show on the primary documentation site https://dev.folio.org/reference/api/#okapi", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489418044", "createdAt": "2020-09-16T13:01:25Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzMzM2NQ==", "bodyText": "The RAML will never include all material from the guide. But I can copy the material for this one if you like.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r489533365", "createdAt": "2020-09-16T15:35:12Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA=="}, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUxNTQ1Mw==", "bodyText": "Yes, please.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490515453", "createdAt": "2020-09-17T19:38:34Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/raml/okapi.raml", "diffHunk": "@@ -790,10 +815,18 @@ types:\n           must be deployed (optionally) and enabled/disabled by the existing\n           tenants-modules CRUD service.\n         queryParameters:\n+          async:\n+            description: Whether to install in the background\n+            type: boolean\n+            required: false\n           deploy:\n             description: Whether to deploy (or undeploy if disabling)\n             type: boolean\n             required: false\n+          ignoreErrors:\n+            description: Whether to ignore module init errors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxODA0NA=="}, "originalCommit": {"oid": "60a521c1f3f3b6f1e5fc013c718c6a6b20eb0832"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzg0MDQzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0MTo0MVrOHTlxwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo0MToxOFrOHTwTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMzkzNg==", "bodyText": "Did you intentionally re-use this permission?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490303936", "createdAt": "2020-09-17T14:41:41Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"\n+        + \"    \\\"type\\\" : \\\"internal\\\" \"\n+        + \"   }, {\"\n         + \"    \\\"methods\\\" :  [ \\\"POST\\\" ],\"\n         + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install/{installId}\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf5ab7bfcb9304049cfd2b8b53bba92703464963"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NjM1Mw==", "bodyText": "yes. But I can see that in other cases, we have used suffix \".list\" for \"get all\". I'll do that. Hope that's ok.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490476353", "createdAt": "2020-09-17T18:41:18Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"\n+        + \"    \\\"type\\\" : \\\"internal\\\" \"\n+        + \"   }, {\"\n         + \"    \\\"methods\\\" :  [ \\\"POST\\\" ],\"\n         + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install/{installId}\\\",\"\n+        + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.install.get\\\" ], \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMzkzNg=="}, "originalCommit": {"oid": "bf5ab7bfcb9304049cfd2b8b53bba92703464963"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2Nzg0NDA0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDo0MjoxMlrOHTlz-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODo0MjozNlrOHTwWIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwNDUwNw==", "bodyText": "Does this mean it's possible to check the status of a sync install?  Is it worth mentioning that in the docs?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490304507", "createdAt": "2020-09-17T14:42:12Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf5ab7bfcb9304049cfd2b8b53bba92703464963"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NzA4OA==", "bodyText": "Yes. I can mention it.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490477088", "createdAt": "2020-09-17T18:42:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -256,11 +254,21 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n         + \"    \\\"permissionsRequired\\\" : [ \\\"okapi.proxy.tenants.upgrade.post\\\" ], \"\n         + \"    \\\"type\\\" : \\\"internal\\\" \"\n         + \"   }, {\"\n+        + \"    \\\"methods\\\" :  [ \\\"GET\\\" ],\"\n+        + \"    \\\"pathPattern\\\" : \\\"/_/proxy/tenants/{tenantId}/install\\\",\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwNDUwNw=="}, "originalCommit": {"oid": "bf5ab7bfcb9304049cfd2b8b53bba92703464963"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTUwNTE0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyMjo0MFrOHT2ACg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwODo1Mjo0N1rOHUEFqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2OTczOA==", "bodyText": "Consider to use uppercase M for manager part", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490569738", "createdAt": "2020-09-17T21:22:40Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -214,16 +215,12 @@ public void start(Promise<Void> promise) {\n \n   private Future<Void> startModmanager() {\n     logger.info(\"startModmanager\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgwMDU1NQ==", "bodyText": "ok. Renaming the function.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490800555", "createdAt": "2020-09-18T08:52:47Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -214,16 +215,12 @@ public void start(Promise<Void> promise) {\n \n   private Future<Void> startModmanager() {\n     logger.info(\"startModmanager\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2OTczOA=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTUwOTk2OnYy", "diffSide": "RIGHT", "path": "doc/guide.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyNDoxNVrOHT2C1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwOTowMzo1NFrOHUEe2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MDQ1NA==", "bodyText": "Maybe mention and explain possible stages (deploy, call, and undeploy) here?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490570454", "createdAt": "2020-09-17T21:24:15Z", "author": {"login": "hjiebsco"}, "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,71 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `date`: start time of job in UTC ISO8601 format.\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgwNzAwMA==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490807000", "createdAt": "2020-09-18T09:03:54Z", "author": {"login": "adamdickmeiss"}, "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,71 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `date`: start time of job in UTC ISO8601 format.\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MDQ1NA=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTUxNDA3OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/InstallJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToyNTo0MVrOHT2FXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNjoyNjo1NVrOHUs_MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MTEwMQ==", "bodyText": "This is the starting date. Is it possible to add a finish date to know the duration of the install/upgrade?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490571101", "createdAt": "2020-09-17T21:25:41Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/InstallJob.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.folio.okapi.bean;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import java.util.List;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class InstallJob {\n+\n+  private String id;\n+\n+  private Boolean complete;\n+\n+  private String date;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ3MDY0MQ==", "bodyText": "ok. done", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491470641", "createdAt": "2020-09-19T16:26:55Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/InstallJob.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.folio.okapi.bean;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import java.util.List;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class InstallJob {\n+\n+  private String id;\n+\n+  private Boolean complete;\n+\n+  private String date;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU3MTEwMQ=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTU3MjcyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo0NjowNlrOHT2o0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwOTowOTo1NVrOHUEr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4MDE3Ng==", "bodyText": "Consider change id to tenantId", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490580176", "createdAt": "2020-09-17T21:46:06Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMDM0Ng==", "bodyText": "Good idea.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490810346", "createdAt": "2020-09-18T09:09:55Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4MDE3Ng=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTU5OTYzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo1NjowMFrOHT25dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDozMToxMFrOHWkVSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ==", "bodyText": "Do we support checking the status of async upgrade?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490584439", "createdAt": "2020-09-17T21:56:00Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(id, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMDc2NA==", "bodyText": "yes. Should probably be mentioned.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490810764", "createdAt": "2020-09-18T09:10:33Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(id, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQyNTk5Mw==", "bodyText": "This /upgrade endpoint method does not return location header, so how does the caller know where to track the status?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493425993", "createdAt": "2020-09-23T10:31:10Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +729,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String id) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(id, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDQzOQ=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTY5MTc2OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjozMzoyN1rOHT3xGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwOToxMTowM1rOHUEufA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU5ODY4Mw==", "bodyText": "Typo. Should be Clone, not Close", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490598683", "createdAt": "2020-09-17T22:33:27Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Close an entry without status (for Install without async).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxMTAwNA==", "bodyText": "yep", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490811004", "createdAt": "2020-09-18T09:11:03Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Close an entry without status (for Install without async).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU5ODY4Mw=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTczMjY4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjo1MDoyMFrOHT4IWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwOToyMDoyNFrOHUFDgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYwNDYzMg==", "bodyText": "Should we also set stage to be pending for tm in tml2?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490604632", "createdAt": "2020-09-17T22:50:20Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 1189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDgxNjM4Ng==", "bodyText": "No. That wasn't the intention. The meaning was that it would return entries without status/stage .. for the async immediate response.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490816386", "createdAt": "2020-09-18T09:20:24Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYwNDYzMg=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 1189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTc5NjgwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzoyMToxOFrOHT4t7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMTo1Mzo1N1rOHUKBqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxNDI1Mw==", "bodyText": "Should we check async here and update tml stage to undeploy? BTW stage.undeploy has not been used anywhere in the project yet.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490614253", "createdAt": "2020-09-17T23:21:18Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);\n+          future = future.compose(x -> {\n+            for (TenantModuleDescriptor tm : tml) {\n+              tm.setStage(TenantModuleDescriptor.Stage.pending);\n+            }\n+            return jobs.put(t.getId(), job.getId(), job);\n+          });\n+        }\n+        if (options.getDeploy()) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              for (TenantModuleDescriptor tm : tml) {\n+                tm.setStage(TenantModuleDescriptor.Stage.deploy);\n               }\n+              return jobs.put(t.getId(), job.getId(), job);\n             });\n-      }\n+          }\n+          future = future.compose(x -> autoDeploy(t, modsAvailable, tml));\n+        }\n+        for (TenantModuleDescriptor tm : tml) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              tm.setStage(TenantModuleDescriptor.Stage.call);\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+          if (options.getIgnoreErrors()) {\n+            Promise<Void> promise1 = Promise.promise();\n+            installTenantModule(t, pc, options, modsAvailable, tm).onComplete(x -> {\n+              if (x.failed()) {\n+                logger.warn(\"Ignoring error for tenant {} module {}\",\n+                    t.getId(), tm.getId(), x.cause());\n+              }\n+              promise1.complete();\n+            });\n+            future = future.compose(x -> promise1.future());\n+          } else {\n+            future = future.compose(x -> installTenantModule(t, pc, options, modsAvailable, tm));\n+          }\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              if (tm.getMessage() == null) {\n+                tm.setStage(TenantModuleDescriptor.Stage.done);\n+              }\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+        }\n+        if (options.getDeploy()) {\n+          future.compose(x -> autoUndeploy(t, modsAvailable, tml));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 1240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg5NzgzMg==", "bodyText": "Yes. I have change things so that deploy and undeploy only change state for particular modules (which might be a subset of all modules in the list).", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r490897832", "createdAt": "2020-09-18T11:53:57Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -982,144 +752,186 @@ void listModulesFromInterface(String tenantId,\n             }\n           }\n         }\n-        fut.handle(new Success<>(mdList));\n-      }); // modlist\n-    }); // tenant\n+        return Future.succeededFuture(mdList);\n+      });\n+    });\n   }\n \n-  void installUpgradeModules(String tenantId, ProxyContext pc,\n-                             TenantInstallOptions options, List<TenantModuleDescriptor> tml,\n-                             Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+  Future<InstallJob> installUpgradeGet(String tenantId, String installId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.getNotFound(tenantId, installId));\n+  }\n \n+  Future<List<InstallJob>> installUpgradeGetList(String tenantId) {\n+    return tenants.getNotFound(tenantId).compose(x -> jobs.get(tenantId).compose(list -> {\n+      if (list == null) {\n+        return Future.succeededFuture(new LinkedList<>());\n+      }\n+      return Future.succeededFuture(list);\n+    }));\n+  }\n+\n+  Future<List<TenantModuleDescriptor>> installUpgradeCreate(\n+      String tenantId, String installId, ProxyContext pc,\n+      TenantInstallOptions options, List<TenantModuleDescriptor> tml) {\n+\n+    logger.info(\"installUpgradeCreate InstallId={}\", installId);\n     if (tml != null) {\n       for (TenantModuleDescriptor tm : tml) {\n         if (tm.getAction() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10405\", tm.getId())));\n-          return;\n+          return Future.failedFuture(new OkapiError(ErrorType.USER,\n+              messages.getMessage(\"10405\", tm.getId())));\n         }\n       }\n     }\n-    tenants.get(tenantId, gres -> {\n-      if (gres.failed()) {\n-        fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        return;\n-      }\n-      Tenant t = gres.result();\n-      moduleManager.getModulesWithFilter(options.getPreRelease(),\n-          options.getNpmSnapshot(), null, mres -> {\n-            if (mres.failed()) {\n-              fut.handle(new Failure<>(mres.getType(), mres.cause()));\n-              return;\n-            }\n-            List<ModuleDescriptor> modResult = mres.result();\n-            HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modResult.size());\n-            HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n-            for (ModuleDescriptor md : modResult) {\n-              modsAvailable.put(md.getId(), md);\n-              logger.info(\"mod available: {}\", md.getId());\n-              if (t.isEnabled(md.getId())) {\n-                logger.info(\"mod enabled: {}\", md.getId());\n-                modsEnabled.put(md.getId(), md);\n+    return tenants.getNotFound(tenantId).compose(tenant ->\n+        moduleManager.getModulesWithFilter(options.getPreRelease(),\n+            options.getNpmSnapshot(), null)\n+            .compose(modules -> {\n+              HashMap<String, ModuleDescriptor> modsAvailable = new HashMap<>(modules.size());\n+              HashMap<String, ModuleDescriptor> modsEnabled = new HashMap<>();\n+              for (ModuleDescriptor md : modules) {\n+                modsAvailable.put(md.getId(), md);\n+                logger.info(\"mod available: {}\", md.getId());\n+                if (tenant.isEnabled(md.getId())) {\n+                  logger.info(\"mod enabled: {}\", md.getId());\n+                  modsEnabled.put(md.getId(), md);\n+                }\n               }\n-            }\n-            List<TenantModuleDescriptor> tml2\n-                = prepareTenantModuleList(modsAvailable, modsEnabled, tml);\n-            installUpgradeModules2(t, pc, options, modsAvailable, modsEnabled, tml2, fut);\n-          });\n-    });\n+              InstallJob job = new InstallJob();\n+              job.setId(installId);\n+              job.setDate(Instant.now().toString());\n+              if (tml == null) {\n+                job.setModules(upgrades(modsAvailable, modsEnabled));\n+              } else {\n+                job.setModules(tml);\n+              }\n+              job.setComplete(false);\n+              return runJob(tenant, pc, options, modsAvailable, modsEnabled, job);\n+            }));\n   }\n \n-  private List<TenantModuleDescriptor> prepareTenantModuleList(\n-      Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml) {\n-\n-    if (tml == null) { // upgrade case . Mark all newer modules for install\n-      List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n-      for (String id : modsEnabled.keySet()) {\n-        ModuleId moduleId = new ModuleId(id);\n-        String latestId = moduleId.getLatest(modsAvailable.keySet());\n-        if (!latestId.equals(id)) {\n-          TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n-          tmd.setAction(Action.enable);\n-          tmd.setId(latestId);\n-          logger.info(\"upgrade.. enable {}\", latestId);\n-          tmd.setFrom(id);\n-          tml2.add(tmd);\n-        }\n+  private List<TenantModuleDescriptor> upgrades(\n+      Map<String, ModuleDescriptor> modsAvailable, Map<String, ModuleDescriptor> modsEnabled) {\n+\n+    List<TenantModuleDescriptor> tml = new LinkedList<>();\n+    for (String id : modsEnabled.keySet()) {\n+      ModuleId moduleId = new ModuleId(id);\n+      String latestId = moduleId.getLatest(modsAvailable.keySet());\n+      if (!latestId.equals(id)) {\n+        TenantModuleDescriptor tmd = new TenantModuleDescriptor();\n+        tmd.setAction(Action.enable);\n+        tmd.setId(latestId);\n+        logger.info(\"upgrade.. enable {}\", latestId);\n+        tmd.setFrom(id);\n+        tml.add(tmd);\n       }\n-      return tml2;\n-    } else {\n-      return tml;\n     }\n+    return tml;\n   }\n \n-  private void installUpgradeModules2(\n-      Tenant t, ProxyContext pc,\n-      TenantInstallOptions options,\n+  private Future<List<TenantModuleDescriptor>> runJob(\n+      Tenant t, ProxyContext pc, TenantInstallOptions options,\n       Map<String, ModuleDescriptor> modsAvailable,\n-      Map<String, ModuleDescriptor> modsEnabled, List<TenantModuleDescriptor> tml,\n-      Handler<ExtendedAsyncResult<List<TenantModuleDescriptor>>> fut) {\n+      Map<String, ModuleDescriptor> modsEnabled, InstallJob job) {\n \n-    DepResolution.installSimulate(modsAvailable, modsEnabled, tml, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n+    List<TenantModuleDescriptor> tml = job.getModules();\n+    return DepResolution.installSimulate(modsAvailable, modsEnabled, tml).compose(res -> {\n       if (options.getSimulate()) {\n-        fut.handle(new Success<>(tml));\n-      } else {\n-        installAutodeploy(t, pc, options, modsAvailable, tml, tml.iterator(),\n-            res1 -> {\n-              if (res1.failed()) {\n-                fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-              } else {\n-                fut.handle(new Success<>(tml));\n+        return Future.succeededFuture(tml);\n+      }\n+      return jobs.add(t.getId(), job.getId(), job).compose(res2 -> {\n+        Promise<List<TenantModuleDescriptor>> promise = Promise.promise();\n+        Future<Void> future = Future.succeededFuture();\n+        if (options.getAsync()) {\n+          List<TenantModuleDescriptor> tml2 = new LinkedList<>();\n+          for (TenantModuleDescriptor tm : tml) {\n+            tml2.add(tm.cloneWithoutStatus());\n+          }\n+          promise.complete(tml2);\n+          future = future.compose(x -> {\n+            for (TenantModuleDescriptor tm : tml) {\n+              tm.setStage(TenantModuleDescriptor.Stage.pending);\n+            }\n+            return jobs.put(t.getId(), job.getId(), job);\n+          });\n+        }\n+        if (options.getDeploy()) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              for (TenantModuleDescriptor tm : tml) {\n+                tm.setStage(TenantModuleDescriptor.Stage.deploy);\n               }\n+              return jobs.put(t.getId(), job.getId(), job);\n             });\n-      }\n+          }\n+          future = future.compose(x -> autoDeploy(t, modsAvailable, tml));\n+        }\n+        for (TenantModuleDescriptor tm : tml) {\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              tm.setStage(TenantModuleDescriptor.Stage.call);\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+          if (options.getIgnoreErrors()) {\n+            Promise<Void> promise1 = Promise.promise();\n+            installTenantModule(t, pc, options, modsAvailable, tm).onComplete(x -> {\n+              if (x.failed()) {\n+                logger.warn(\"Ignoring error for tenant {} module {}\",\n+                    t.getId(), tm.getId(), x.cause());\n+              }\n+              promise1.complete();\n+            });\n+            future = future.compose(x -> promise1.future());\n+          } else {\n+            future = future.compose(x -> installTenantModule(t, pc, options, modsAvailable, tm));\n+          }\n+          if (options.getAsync()) {\n+            future = future.compose(x -> {\n+              if (tm.getMessage() == null) {\n+                tm.setStage(TenantModuleDescriptor.Stage.done);\n+              }\n+              return jobs.put(t.getId(), job.getId(), job);\n+            });\n+          }\n+        }\n+        if (options.getDeploy()) {\n+          future.compose(x -> autoUndeploy(t, modsAvailable, tml));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxNDI1Mw=="}, "originalCommit": {"oid": "92d63f729135c8ad34283fc1a02545d9ba26ce17"}, "originalPosition": 1240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzUwNzM3OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMDo0OToyNFrOHUbfpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNToyMTozNVrOHUso2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDAzOA==", "bodyText": "status has been renamed to stage.\nShould the javadoc been renamed to Clone an entry without stage and the method been renamed to cloneWithoutState?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491184038", "createdAt": "2020-09-18T20:49:24Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry without status and stage (for Install without async).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneWithoutStatus() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NDkyMQ==", "bodyText": "I'll rename it again and update the information about the purpose of this function.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491464921", "createdAt": "2020-09-19T15:21:35Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry without status and stage (for Install without async).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneWithoutStatus() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE4NDAzOA=="}, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzU0OTI1OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTowNToxNVrOHUb4Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNToyNTo1MVrOHUsqVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MDM1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      return add(dd).compose(x -> Future.succeededFuture(dd));\n          \n          \n            \n                      return add(dd).map(dd);", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491190355", "createdAt": "2020-09-18T21:05:15Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NTMwMA==", "bodyText": "OK. Should be using map (which I haven't done before , I think)", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491465300", "createdAt": "2020-09-19T15:25:51Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5MDM1NQ=="}, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzYxMTYzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMTozMTowNVrOHUcc4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNToyNjoyMlrOHUsqfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTcxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return addAndDeploy0(dd).compose(res -> {\n          \n          \n            \n                  return deploymentStore.insert(res).compose(x -> Future.succeededFuture(res));\n          \n          \n            \n                return addAndDeploy0(dd)\n          \n          \n            \n                    .compose(res -> deploymentStore.insert(res).map(res));", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491199714", "createdAt": "2020-09-18T21:31:05Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -113,48 +94,27 @@ public void setModuleManager(ModuleManager mgr) {\n     this.moduleManager = mgr;\n   }\n \n-  void add(DeploymentDescriptor md, Handler<ExtendedAsyncResult<Void>> fut) {\n-    deployments.getKeys(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n-      CompList<Void> futures = new CompList<>(ErrorType.INTERNAL);\n-      for (String moduleId : res.result()) {\n-        Promise<Void> promise = Promise.promise();\n-        futures.add(promise);\n-        deployments.get(moduleId, md.getInstId(), r -> {\n-          if (r.succeeded()) {\n-            promise.fail(\"dup InstId\");\n-            return;\n+  Future<Void> add(DeploymentDescriptor md) {\n+    return deployments.getKeys().compose(res -> {\n+      Future<Void> future = Future.succeededFuture();\n+      for (String moduleId : res) {\n+        future = future.compose(a -> deployments.get(moduleId, md.getInstId()).compose(b -> {\n+          if (b != null) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10809\", md.getInstId())));\n           }\n-          promise.complete();\n-        });\n+          return Future.succeededFuture();\n+        }));\n       }\n-      futures.all(res2 -> {\n-        if (res2.failed()) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10809\", md.getInstId())));\n-          return;\n-        }\n-        deployments.add(md.getSrvcId(), md.getInstId(), md, fut);\n-      });\n+      return future.compose(res2 -> {\n+        return deployments.add(md.getSrvcId(), md.getInstId(), md);\n+      }).mapEmpty();\n     });\n   }\n \n-  void addAndDeploy(DeploymentDescriptor dd,\n-                    Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-    addAndDeploy0(dd, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        deploymentStore.insert(res.result(), res1 -> {\n-          if (res1.failed()) {\n-            fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-          } else {\n-            fut.handle(new Success<>(res.result()));\n-          }\n-        });\n-      }\n+  Future<DeploymentDescriptor> addAndDeploy(DeploymentDescriptor dd) {\n+    return addAndDeploy0(dd).compose(res -> {\n+      return deploymentStore.insert(res).compose(x -> Future.succeededFuture(res));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2NTM0Mw==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491465343", "createdAt": "2020-09-19T15:26:22Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -113,48 +94,27 @@ public void setModuleManager(ModuleManager mgr) {\n     this.moduleManager = mgr;\n   }\n \n-  void add(DeploymentDescriptor md, Handler<ExtendedAsyncResult<Void>> fut) {\n-    deployments.getKeys(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-        return;\n-      }\n-      CompList<Void> futures = new CompList<>(ErrorType.INTERNAL);\n-      for (String moduleId : res.result()) {\n-        Promise<Void> promise = Promise.promise();\n-        futures.add(promise);\n-        deployments.get(moduleId, md.getInstId(), r -> {\n-          if (r.succeeded()) {\n-            promise.fail(\"dup InstId\");\n-            return;\n+  Future<Void> add(DeploymentDescriptor md) {\n+    return deployments.getKeys().compose(res -> {\n+      Future<Void> future = Future.succeededFuture();\n+      for (String moduleId : res) {\n+        future = future.compose(a -> deployments.get(moduleId, md.getInstId()).compose(b -> {\n+          if (b != null) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10809\", md.getInstId())));\n           }\n-          promise.complete();\n-        });\n+          return Future.succeededFuture();\n+        }));\n       }\n-      futures.all(res2 -> {\n-        if (res2.failed()) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10809\", md.getInstId())));\n-          return;\n-        }\n-        deployments.add(md.getSrvcId(), md.getInstId(), md, fut);\n-      });\n+      return future.compose(res2 -> {\n+        return deployments.add(md.getSrvcId(), md.getInstId(), md);\n+      }).mapEmpty();\n     });\n   }\n \n-  void addAndDeploy(DeploymentDescriptor dd,\n-                    Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-    addAndDeploy0(dd, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        deploymentStore.insert(res.result(), res1 -> {\n-          if (res1.failed()) {\n-            fut.handle(new Failure<>(res1.getType(), res1.cause()));\n-          } else {\n-            fut.handle(new Success<>(res.result()));\n-          }\n-        });\n-      }\n+  Future<DeploymentDescriptor> addAndDeploy(DeploymentDescriptor dd) {\n+    return addAndDeploy0(dd).compose(res -> {\n+      return deploymentStore.insert(res).compose(x -> Future.succeededFuture(res));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5OTcxNA=="}, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc2NjUyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo0MDozN1rOHUd6XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNjowNDo1N1rOHUs3wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzY0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return getNode(nodeId).compose(nodeDescriptor -> {\n          \n          \n            \n                  String reqData = Json.encode(dd);\n          \n          \n            \n                  Promise<DeploymentDescriptor> promise = Promise.promise();\n          \n          \n            \n                  vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n          \n          \n            \n                      deliveryOptions).onComplete(ar -> {\n          \n          \n            \n                        if (ar.failed()) {\n          \n          \n            \n                          promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n          \n          \n            \n                        } else {\n          \n          \n            \n                          String b = (String) ar.result().body();\n          \n          \n            \n                          DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n          \n          \n            \n                          promise.complete(pmd);\n          \n          \n            \n                        }\n          \n          \n            \n                      });\n          \n          \n            \n                  return promise.future();\n          \n          \n            \n                return getNode(nodeId)\n          \n          \n            \n                    .flatMap(nodeDescriptor -> {\n          \n          \n            \n                      String url = nodeDescriptor.getUrl() + \"/deploy\";\n          \n          \n            \n                      return vertx.eventBus().request(url, Json.encode(dd), deliveryOptions)\n          \n          \n            \n                          .recover(e -> Future.failedFuture(new OkapiError(ErrorType.USER, e.getMessage())));\n          \n          \n            \n                    })\n          \n          \n            \n                    .map(message -> Json.decodeValue((String) message.body(), DeploymentDescriptor.class));", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491223645", "createdAt": "2020-09-18T22:40:37Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2ODczOA==", "bodyText": "neat", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491468738", "createdAt": "2020-09-19T16:04:57Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzY0NQ=="}, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzc3NjMwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMjo0NjoxNVrOHUd_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQxNjowNTowNFrOHUs30Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTAxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  futures.add(callUndeploy(dd).compose(res -> {\n          \n          \n            \n                    return deploymentStore.delete(dd.getInstId());\n          \n          \n            \n                  }).mapEmpty());\n          \n          \n            \n                  futures.add(callUndeploy(dd)\n          \n          \n            \n                      .compose(res -> deploymentStore.delete(dd.getInstId()))\n          \n          \n            \n                      .mapEmpty());", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491225019", "createdAt": "2020-09-18T22:46:15Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId, String instId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId, String instId) {\n     logger.info(\"removeAndUndeploy: srvcId {} instId {}\", srvcId, instId);\n-    deployments.get(srvcId, instId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        List<DeploymentDescriptor> ddList = new LinkedList<>();\n-        ddList.add(res.result());\n-        removeAndUndeploy(ddList, fut);\n-      }\n+    return deployments.getNotFound(srvcId, instId).compose(res -> {\n+      List<DeploymentDescriptor> ddList = new LinkedList<>();\n+      ddList.add(res);\n+      return removeAndUndeploy(ddList);\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId) {\n     logger.info(\"removeAndUndeploy: srvcId {}\", srvcId);\n-    deployments.get(srvcId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n+    return deployments.get(srvcId).compose(res -> {\n+      if (res == null) {\n+        return Future.failedFuture(new OkapiError(ErrorType.NOT_FOUND, srvcId));\n       }\n+      return removeAndUndeploy(res);\n     });\n   }\n \n-  void removeAndUndeploy(Handler<ExtendedAsyncResult<Void>> fut) {\n+  Future<Void> removeAndUndeploy() {\n     logger.info(\"removeAndUndeploy all\");\n-    this.get(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n-      }\n-    });\n+    return this.get().compose(res -> removeAndUndeploy(res));\n   }\n \n-  private void removeAndUndeploy(List<DeploymentDescriptor> ddList,\n-                                 Handler<ExtendedAsyncResult<Void>> fut) {\n+  private Future<Void> removeAndUndeploy(List<DeploymentDescriptor> ddList) {\n \n-    CompList<List<Void>> futures = new CompList<>(ErrorType.INTERNAL);\n+    List<Future> futures = new LinkedList<>();\n     for (DeploymentDescriptor dd : ddList) {\n-      Promise<Void> promise = Promise.promise();\n       logger.info(\"removeAndUndeploy {} {}\", dd.getSrvcId(), dd.getInstId());\n-      callUndeploy(dd, res -> {\n-        if (res.succeeded()) {\n-          deploymentStore.delete(dd.getInstId(), promise::handle);\n-        } else {\n-          promise.handle(res);\n-        }\n-      });\n-      futures.add(promise);\n+      futures.add(callUndeploy(dd).compose(res -> {\n+        return deploymentStore.delete(dd.getInstId());\n+      }).mapEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ2ODc1Mw==", "bodyText": "done", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r491468753", "createdAt": "2020-09-19T16:05:04Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DiscoveryManager.java", "diffHunk": "@@ -166,196 +126,127 @@ void addAndDeploy(DeploymentDescriptor dd,\n    *   3: No nodeId: Do not deploy at all, just record the existence (URL and instId) of the module.\n    * </p>\n    */\n-  private void addAndDeploy0(DeploymentDescriptor dd,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy0(DeploymentDescriptor dd) {\n \n     String tmp = Json.encodePrettily(dd);\n     logger.info(\"addAndDeploy: {}\", tmp);\n     final String modId = dd.getSrvcId();\n     if (modId == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10800\")));\n-      return;\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10800\")));\n     }\n-    moduleManager.get(modId, gres -> {\n-      if (gres.failed()) {\n-        if (gres.getType() == ErrorType.NOT_FOUND) {\n-          fut.handle(new Failure<>(ErrorType.NOT_FOUND, messages.getMessage(\"10801\", modId)));\n-        } else {\n-          fut.handle(new Failure<>(gres.getType(), gres.cause()));\n-        }\n-      } else {\n-        addAndDeploy1(dd, gres.result(), fut);\n-      }\n-    });\n+    return moduleManager.get(modId).compose(gres -> addAndDeploy1(dd, gres));\n   }\n \n-  private void addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n+  private Future<DeploymentDescriptor> addAndDeploy1(DeploymentDescriptor dd, ModuleDescriptor md) {\n \n     LaunchDescriptor launchDesc = dd.getDescriptor();\n     final String nodeId = dd.getNodeId();\n     if (nodeId == null) {\n       if (launchDesc == null) { // 3: externally deployed\n         if (dd.getInstId() == null) {\n-          fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10802\")));\n+          return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10802\")));\n         } else {\n-          add(dd, res -> { // just add it\n-            if (res.failed()) {\n-              fut.handle(new Failure<>(res.getType(), res.cause()));\n-            } else {\n-              fut.handle(new Success<>(dd));\n-            }\n-          });\n+          return add(dd).compose(x -> Future.succeededFuture(dd));\n         }\n       } else {\n-        fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10803\")));\n+        return Future.failedFuture(new OkapiError(ErrorType.USER, messages.getMessage(\"10803\")));\n       }\n     } else {\n       if (launchDesc == null) {\n-        addAndDeploy2(dd, md, fut, nodeId);\n+        return addAndDeploy2(dd, md, nodeId);\n       } else { // Have a launch descriptor already in dd\n-        callDeploy(nodeId, dd, fut);\n+        return callDeploy(nodeId, dd);\n       }\n     }\n   }\n \n-  private void addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n-                             Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut,\n-                             String nodeId) {\n+  private Future<DeploymentDescriptor> addAndDeploy2(DeploymentDescriptor dd, ModuleDescriptor md,\n+                                                     String nodeId) {\n     String modId = dd.getSrvcId();\n     LaunchDescriptor modLaunchDesc = md.getLaunchDescriptor();\n     if (modLaunchDesc == null) {\n-      fut.handle(new Failure<>(ErrorType.USER, messages.getMessage(\"10804\", modId)));\n-    } else {\n-      dd.setDescriptor(modLaunchDesc);\n-      callDeploy(nodeId, dd, fut);\n+      return Future.failedFuture(new OkapiError(ErrorType.USER,\n+          messages.getMessage(\"10804\", modId)));\n     }\n+    dd.setDescriptor(modLaunchDesc);\n+    return callDeploy(nodeId, dd);\n   }\n \n   /**\n    * Helper to actually launch (deploy) a module on a node.\n    */\n-  private void callDeploy(String nodeId, DeploymentDescriptor dd,\n-                          Handler<ExtendedAsyncResult<DeploymentDescriptor>> fut) {\n-\n-    getNode(nodeId, nodeRes -> {\n-      if (nodeRes.failed()) {\n-        fut.handle(new Failure<>(nodeRes.getType(), nodeRes.cause()));\n-      } else {\n-        String reqData = Json.encode(dd);\n-        vertx.eventBus().request(nodeRes.result().getUrl() + \"/deploy\", reqData,\n-            deliveryOptions, ar -> {\n-              if (ar.failed()) {\n-                fut.handle(new Failure<>(ErrorType.USER, ar.cause().getMessage()));\n-              } else {\n-                String b = (String) ar.result().body();\n-                DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n-                fut.handle(new Success<>(pmd));\n-              }\n-            });\n-      }\n+  private Future<DeploymentDescriptor> callDeploy(String nodeId, DeploymentDescriptor dd) {\n+    return getNode(nodeId).compose(nodeDescriptor -> {\n+      String reqData = Json.encode(dd);\n+      Promise<DeploymentDescriptor> promise = Promise.promise();\n+      vertx.eventBus().request(nodeDescriptor.getUrl() + \"/deploy\", reqData,\n+          deliveryOptions).onComplete(ar -> {\n+            if (ar.failed()) {\n+              promise.fail(new OkapiError(ErrorType.USER, ar.cause().getMessage()));\n+            } else {\n+              String b = (String) ar.result().body();\n+              DeploymentDescriptor pmd = Json.decodeValue(b, DeploymentDescriptor.class);\n+              promise.complete(pmd);\n+            }\n+          });\n+      return promise.future();\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId, String instId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId, String instId) {\n     logger.info(\"removeAndUndeploy: srvcId {} instId {}\", srvcId, instId);\n-    deployments.get(srvcId, instId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        List<DeploymentDescriptor> ddList = new LinkedList<>();\n-        ddList.add(res.result());\n-        removeAndUndeploy(ddList, fut);\n-      }\n+    return deployments.getNotFound(srvcId, instId).compose(res -> {\n+      List<DeploymentDescriptor> ddList = new LinkedList<>();\n+      ddList.add(res);\n+      return removeAndUndeploy(ddList);\n     });\n   }\n \n-  void removeAndUndeploy(String srvcId,\n-                         Handler<ExtendedAsyncResult<Void>> fut) {\n-\n+  Future<Void> removeAndUndeploy(String srvcId) {\n     logger.info(\"removeAndUndeploy: srvcId {}\", srvcId);\n-    deployments.get(srvcId, res -> {\n-      if (res.failed()) {\n-        logger.warn(\"deployment.get failed\");\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n+    return deployments.get(srvcId).compose(res -> {\n+      if (res == null) {\n+        return Future.failedFuture(new OkapiError(ErrorType.NOT_FOUND, srvcId));\n       }\n+      return removeAndUndeploy(res);\n     });\n   }\n \n-  void removeAndUndeploy(Handler<ExtendedAsyncResult<Void>> fut) {\n+  Future<Void> removeAndUndeploy() {\n     logger.info(\"removeAndUndeploy all\");\n-    this.get(res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        removeAndUndeploy(res.result(), fut);\n-      }\n-    });\n+    return this.get().compose(res -> removeAndUndeploy(res));\n   }\n \n-  private void removeAndUndeploy(List<DeploymentDescriptor> ddList,\n-                                 Handler<ExtendedAsyncResult<Void>> fut) {\n+  private Future<Void> removeAndUndeploy(List<DeploymentDescriptor> ddList) {\n \n-    CompList<List<Void>> futures = new CompList<>(ErrorType.INTERNAL);\n+    List<Future> futures = new LinkedList<>();\n     for (DeploymentDescriptor dd : ddList) {\n-      Promise<Void> promise = Promise.promise();\n       logger.info(\"removeAndUndeploy {} {}\", dd.getSrvcId(), dd.getInstId());\n-      callUndeploy(dd, res -> {\n-        if (res.succeeded()) {\n-          deploymentStore.delete(dd.getInstId(), promise::handle);\n-        } else {\n-          promise.handle(res);\n-        }\n-      });\n-      futures.add(promise);\n+      futures.add(callUndeploy(dd).compose(res -> {\n+        return deploymentStore.delete(dd.getInstId());\n+      }).mapEmpty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNTAxOQ=="}, "originalCommit": {"oid": "667da414de694fad916f1ecaa95059ba7ae20580"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODAxNTA4OnYy", "diffSide": "RIGHT", "path": "doc/guide.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDoxNDo0NlrOHWjaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNDo1MzoyOFrOHWyktQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA==", "bodyText": "Should we mention undeploy stage here?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493410918", "createdAt": "2020-09-23T10:14:46Z", "author": {"login": "hjiebsco"}, "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,77 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `startDate`: start time of job in UTC ISO8601 format.\n+ * `endDate`: end time of job in UTC ISO8601 format (only present when complete)\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred. Stage is one of\n+ * `pending`: module is yet to be upgraded/deployed/etc..\n+ * `deploy`: module is being deployed\n+ * `call`: module is being called via system interface, such as `_tenant`,\n+    `_tenantPermissions`, ..\n+ * `done`: module is fully upgraded", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NDQ5NA==", "bodyText": "Yep.\nShould I rename  stage call to in invoke instead? The reason would be that invoke parameter controls whether a module should be invoked/called ..", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493474494", "createdAt": "2020-09-23T11:25:47Z", "author": {"login": "adamdickmeiss"}, "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,77 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `startDate`: start time of job in UTC ISO8601 format.\n+ * `endDate`: end time of job in UTC ISO8601 format (only present when complete)\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred. Stage is one of\n+ * `pending`: module is yet to be upgraded/deployed/etc..\n+ * `deploy`: module is being deployed\n+ * `call`: module is being called via system interface, such as `_tenant`,\n+    `_tenantPermissions`, ..\n+ * `done`: module is fully upgraded", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA=="}, "originalCommit": {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTMxNw==", "bodyText": "either call or invoke seems fine to me.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493659317", "createdAt": "2020-09-23T14:53:28Z", "author": {"login": "hjiebsco"}, "path": "doc/guide.md", "diffHunk": "@@ -2621,7 +2623,77 @@ the install operation will also deploy and un-deploy as\n necessary. This will only work if the ModuleDescriptor has the\n launchDescriptor property.\n \n-### Purge\n+### Install jobs and asynchronous operations\n+\n+For Okapi 4.2.0 and later, the install operation can be asynchronous.\n+The asynchronous operation is enabled by URI parameter 'async=true'.\n+As for the \"synchronous\" operation, the dependency check is performed\n+first and install/upgrade will return 400 HTTP error upon failure.\n+\n+Following that, the install operation will create an install \"job\" on the\n+server side and return HTTP status 201 along with a location of the newly\n+created install job. The returned JSON content is defined by schema\n+([InstallJob.json](../okapi-core/src/main/raml/InstallJob.json)).\n+\n+This location can then be inspected with HTTP GET for the progress of\n+the install operation. The location is same base URI as install, but\n+with a slash + the job ID. The install job has properties such as\n+\n+ * `complete`: boolean which tells whether the job has completed\n+ * `id`: job id\n+ * `startDate`: start time of job in UTC ISO8601 format.\n+ * `endDate`: end time of job in UTC ISO8601 format (only present when complete)\n+ * `modules`: enable/disable list of modules along with status.\n+\n+Each module entry is defined by schema\n+([TenantModuleDescriptor.json](../okapi-core/src/main/raml/TenantModuleDescriptor.json)).\n+Brief list of properties:\n+\n+ * `id`: module ID\n+ * `from`: old module ID (absent if not upgrading)\n+ * `action`: enable/disable/uptodate\n+ * `stage`: the current stage of the module\n+ * `message`: present upon error (error message)\n+\n+If `message` property is present an error has occurred and `stage`\n+indicates at which stage the error occurred. Stage is one of\n+ * `pending`: module is yet to be upgraded/deployed/etc..\n+ * `deploy`: module is being deployed\n+ * `call`: module is being called via system interface, such as `_tenant`,\n+    `_tenantPermissions`, ..\n+ * `done`: module is fully upgraded", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxMDkxOA=="}, "originalCommit": {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODAzNDU5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMDoxODozMlrOHWjmyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMToyNjozMlrOHWnVVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxNDA4OA==", "bodyText": "Maybe just me, Legacy gives me an impression that this method will go away and should not be used. :)", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493414088", "createdAt": "2020-09-23T10:18:32Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry with only original tenant module information (Before async install).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneLegacy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NTE1Ng==", "bodyText": "Fair. It's not going a way. I'll rename it again.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493475156", "createdAt": "2020-09-23T11:26:32Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/TenantModuleDescriptor.java", "diffHunk": "@@ -58,4 +66,27 @@ public String getMessage() {\n   public void setMessage(String message) {\n     this.message = message;\n   }\n+\n+  public Stage getStage() {\n+    return stage;\n+  }\n+\n+  public void setStage(Stage stage) {\n+    this.stage = stage;\n+  }\n+\n+  /**\n+   * Clone an entry with only original tenant module information (Before async install).\n+   * @return entry\n+   */\n+  @JsonIgnore\n+  public TenantModuleDescriptor cloneLegacy() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQxNDA4OA=="}, "originalCommit": {"oid": "2f59ff59bbdf3a1dbe1ad43311cbcc9280a4a675"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4OTU4ODIwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNTowMjozNVrOHWzB1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNToxMzoxMVrOHWzh5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY2Njc3Mg==", "bodyText": "@adamdickmeiss, I asked earlier if we support checking the status of async upgrade? You said yes. But this /upgrade endpoint method does not return location header, so how does the caller know where to track the status?", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493666772", "createdAt": "2020-09-23T15:02:35Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +735,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String tenantId) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76b75345e95b928fc7517fe7ae7e1e5ab373108"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NDk4MQ==", "bodyText": "You are right. I'll fix that (so that it returns location, I mean for async=true).", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r493674981", "createdAt": "2020-09-23T15:13:11Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -768,154 +735,121 @@ private void installModulesForTenant(ProxyContext pc, String id,\n           TenantModuleDescriptor[].class);\n       List<TenantModuleDescriptor> tm = new LinkedList<>();\n       Collections.addAll(tm, tml);\n-      tenantManager.installUpgradeModules(id, pc, options, tm, res -> {\n-        if (res.failed()) {\n-          fut.handle(new Failure<>(res.getType(), res.cause()));\n-        } else {\n-          logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-          fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-        }\n-      });\n+      UUID installId = UUID.randomUUID();\n+      return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, tm)\n+          .compose(res -> {\n+            String jsonResponse = Json.encodePrettily(res);\n+            logger.info(\"installTenantModulesPost returns: {}\", jsonResponse);\n+            if (options.getAsync()) {\n+              return location(pc, installId.toString(), null, jsonResponse);\n+            } else {\n+              return Future.succeededFuture(jsonResponse);\n+            }\n+          });\n     } catch (DecodeException ex) {\n-      fut.handle(new Failure<>(ErrorType.USER, ex));\n+      return Future.failedFuture(new OkapiError(ErrorType.USER, ex.getMessage()));\n     }\n   }\n \n-  private void upgradeModulesForTenant(ProxyContext pc, String id,\n-                                       Handler<ExtendedAsyncResult<String>> fut) {\n+  private Future<String> installTenantModulesGetList(String tenantId) {\n+    return tenantManager.installUpgradeGetList(tenantId)\n+        .compose(installJobList -> Future.succeededFuture(Json.encodePrettily(installJobList)));\n+  }\n+\n+  private Future<String> installTenantModulesGet(String tenantId, String installId) {\n+    return tenantManager.installUpgradeGet(tenantId, installId)\n+        .compose(installJob -> Future.succeededFuture(Json.encodePrettily(installJob)));\n+  }\n+\n+  private Future<String> upgradeModulesForTenant(ProxyContext pc, String tenantId) {\n \n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n-    tenantManager.installUpgradeModules(id, pc, options, null, res -> {\n-      if (res.failed()) {\n-        fut.handle(new Failure<>(res.getType(), res.cause()));\n-      } else {\n-        logger.info(\"installUpgradeModules returns: {}\", Json.encodePrettily(res.result()));\n-        fut.handle(new Success<>(Json.encodePrettily(res.result())));\n-      }\n-    });\n+    UUID installId = UUID.randomUUID();\n+    return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, null)\n+        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY2Njc3Mg=="}, "originalCommit": {"oid": "a76b75345e95b928fc7517fe7ae7e1e5ab373108"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTYwMzAzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMTowNzozOFrOHXsqnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMTowNzozOFrOHXsqnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxMTEwMQ==", "bodyText": "Technically right. Maybe a little bit counter intuitive. Mentioning this in the guide should help.", "url": "https://github.com/folio-org/okapi/pull/963#discussion_r494611101", "createdAt": "2020-09-24T21:07:38Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -766,7 +766,16 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n     TenantInstallOptions options = ModuleUtil.createTenantOptions(pc.getCtx().request());\n     UUID installId = UUID.randomUUID();\n     return tenantManager.installUpgradeCreate(tenantId, installId.toString(), pc, options, null)\n-        .compose(res -> Future.succeededFuture(Json.encodePrettily(res)));\n+        .compose(res -> {\n+          String jsonResponse = Json.encodePrettily(res);\n+          if (options.getAsync()) {\n+            // using same location as install\n+            String baseUri = pc.getCtx().request().uri().replace(\"/upgrade\", \"/install\");\n+            return location(pc, installId.toString(), baseUri, jsonResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c85e2c7162b01c80a5535ffa3c5b8dc5bb0ca85f"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 130, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}