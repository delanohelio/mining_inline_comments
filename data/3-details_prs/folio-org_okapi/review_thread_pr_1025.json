{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDcyNTg4", "number": 1025, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDo0MlrOE05mEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyMToyMVrOE1UpiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTA1MDQxOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNzowNDo0MlrOHs4WCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDozNjoyNVrOHs_jyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjUzOA==", "bodyText": "This should be replaced by\nreturn Future.succeededFuture(enabledModulesCache.computeIfAbsent(tenant.getId(), key -> new ModuleCache(new LinkedList<>())));", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r516822538", "createdAt": "2020-11-03T17:04:42Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -1044,6 +1085,68 @@ private ModuleInstance getTenantInstanceForInterface(\n     });\n   }\n \n+  /**\n+   * Get module cache for tenant.\n+   * @param tenant Tenant\n+   * @return Module Cache\n+   */\n+  public Future<ModuleCache> getModuleCache(Tenant tenant) {\n+    if (!enabledModulesCache.containsKey(tenant.getId())) {\n+      return Future.succeededFuture(new ModuleCache(new LinkedList<>()));\n+    }\n+    return Future.succeededFuture(enabledModulesCache.get(tenant.getId()));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ad676506323184056b912d75d07985e0adead4"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk0MDc0Nw==", "bodyText": "More elegant indeed.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r516940747", "createdAt": "2020-11-03T20:36:25Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/TenantManager.java", "diffHunk": "@@ -1044,6 +1085,68 @@ private ModuleInstance getTenantInstanceForInterface(\n     });\n   }\n \n+  /**\n+   * Get module cache for tenant.\n+   * @param tenant Tenant\n+   * @return Module Cache\n+   */\n+  public Future<ModuleCache> getModuleCache(Tenant tenant) {\n+    if (!enabledModulesCache.containsKey(tenant.getId())) {\n+      return Future.succeededFuture(new ModuleCache(new LinkedList<>()));\n+    }\n+    return Future.succeededFuture(enabledModulesCache.get(tenant.getId()));\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyMjUzOA=="}, "originalCommit": {"oid": "b6ad676506323184056b912d75d07985e0adead4"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTQ2MTM4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTowMjoxNVrOHtOusQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjoxMTozMVrOHtVdlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTI5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n          \n          \n            \n                      return moduleManager.delete(id).map(\"\");", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517189297", "createdAt": "2020-11-04T09:02:15Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -904,7 +904,14 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n   }\n \n   private Future<String> deleteModule(String id) {\n-    return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n+    return tenantManager.getModuleUser(id)\n+        .compose(tenants -> {\n+          if (!tenants.isEmpty()) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10206\", id, tenants.get(0))));\n+          }\n+          return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5OTYwNw==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517299607", "createdAt": "2020-11-04T12:11:31Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/InternalModule.java", "diffHunk": "@@ -904,7 +904,14 @@ public static ModuleDescriptor moduleDescriptor(String okapiVersion) {\n   }\n \n   private Future<String> deleteModule(String id) {\n-    return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));\n+    return tenantManager.getModuleUser(id)\n+        .compose(tenants -> {\n+          if (!tenants.isEmpty()) {\n+            return Future.failedFuture(new OkapiError(ErrorType.USER,\n+                messages.getMessage(\"10206\", id, tenants.get(0))));\n+          }\n+          return moduleManager.delete(id).compose(res -> Future.succeededFuture(\"\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTI5Nw=="}, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTUwMjM5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToxMzowMVrOHtPHqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjoxMTozN1rOHtVdzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5NTY5MA==", "bodyText": ".onComplete(cacheRes -> {\n  if (cacheRes.failed()) {\n    FAILUREBLOCK\n    return;\n  }\n  ModuleCache cache = cacheRes.result();\n  SUCCESSBLOCK\n});\n\nshould be replaced by\n.onFailure(cause -> {\n  FAILUREBLOCK\n}).onSuccess(cache -> {\n  SUCCESSBLOCK\n});", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517195690", "createdAt": "2020-11-04T09:13:01Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -664,16 +560,16 @@ public void proxy(RoutingContext ctx) {\n         pc.responseError(400, messages.getMessage(\"10106\", tenantId));\n         return;\n       }\n-      Tenant tenant = gres.result();\n-      moduleManager.getEnabledModules(tenant).onComplete(mres -> {\n-        if (mres.failed()) {\n+      tenantManager.getModuleCache(gres.result()).onComplete(cacheRes -> {\n+        if (cacheRes.failed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI5OTY2Mg==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517299662", "createdAt": "2020-11-04T12:11:37Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -664,16 +560,16 @@ public void proxy(RoutingContext ctx) {\n         pc.responseError(400, messages.getMessage(\"10106\", tenantId));\n         return;\n       }\n-      Tenant tenant = gres.result();\n-      moduleManager.getEnabledModules(tenant).onComplete(mres -> {\n-        if (mres.failed()) {\n+      tenantManager.getModuleCache(gres.result()).onComplete(cacheRes -> {\n+        if (cacheRes.failed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5NTY5MA=="}, "originalCommit": {"oid": "3cc3fcd6a99e03d0a644a984067083fdc4f20e72"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjM3NTU4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/ModuleTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxMTowN1rOHtXZjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NjozNlrOHtYvKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMTM0Mg==", "bodyText": "Can you extract this duplicated code into some method, for example assertEmptyReport(RestAssuredClient c)?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517331342", "createdAt": "2020-11-04T13:11:07Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/ModuleTest.java", "diffHunk": "@@ -625,10 +625,22 @@ public void testFilters(TestContext context) {\n \n     // Clean up (in reverse order)\n     logger.debug(\"testFilters starting to clean up\");\n-    given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n-    given().delete(locationPostDeployment).then().log().ifValidationFails().statusCode(204);\n+    c = api.createRestAssured3();\n+    c.given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n+    Assert.assertTrue(\"raml: \" + c.getLastReport().toString(),\n+        c.getLastReport().isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MzI1OQ==", "bodyText": "ok (in use in other tests, though, so could also move it to a test util).", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517353259", "createdAt": "2020-11-04T13:46:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/ModuleTest.java", "diffHunk": "@@ -625,10 +625,22 @@ public void testFilters(TestContext context) {\n \n     // Clean up (in reverse order)\n     logger.debug(\"testFilters starting to clean up\");\n-    given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n-    given().delete(locationPostDeployment).then().log().ifValidationFails().statusCode(204);\n+    c = api.createRestAssured3();\n+    c.given().delete(locPostEnable).then().log().ifValidationFails().statusCode(204);\n+    Assert.assertTrue(\"raml: \" + c.getLastReport().toString(),\n+        c.getLastReport().isEmpty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMTM0Mg=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjM5OTA4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxNzoxOVrOHtXnow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOToyM1rOHtYD9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDk0Nw==", "bodyText": "You can directly provide an empty string when you use CsvSource' quoting:\n\"{id}, ''\"", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517334947", "createdAt": "2020-11-04T13:17:19Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjE5OA==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517342198", "createdAt": "2020-11-04T13:29:23Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDk0Nw=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjQwMzA4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoxODoyN1rOHtXqIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzoyOToyOVrOHtYEPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTU4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void testGetPatternPrefix(ArgumentsAccessor accessor) {\n          \n          \n            \n              void testGetPatternPrefix(String pathPattern, String expect) {", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517335587", "createdAt": "2020-11-04T13:18:27Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MjI3MA==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517342270", "createdAt": "2020-11-04T13:29:29Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTU4Nw=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjUwMDU5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0MzoxNFrOHtYm2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MjoyNlrOHtY-Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyOA==", "bodyText": "Is this supposed to be onSuccess or onComplete? Do you want checkSuperTenant always be done?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517351128", "createdAt": "2020-11-04T13:43:14Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onComplete(ires -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NzE0Ng==", "bodyText": "It should be onSuccess  (and that was the existing behavior).", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517357146", "createdAt": "2020-11-04T13:52:26Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onComplete(ires -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1MTEyOA=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjU0MzQ0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1Mzo0OVrOHtZBww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1OToxNlrOHtZQJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODAxOQ==", "bodyText": "Looks like this method is not used anymore.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517358019", "createdAt": "2020-11-04T13:53:49Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -132,62 +133,13 @@ private void makeTraceHeader(ModuleInstance mi, int statusCode,\n     pc.logResponse(mi.getModuleDescriptor().getId(), url, statusCode);\n   }\n \n-  private boolean match(RoutingEntry e, HttpServerRequest req) {\n+  private static boolean match(RoutingEntry e, HttpServerRequest req) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MTcwMg==", "bodyText": "Right", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517361702", "createdAt": "2020-11-04T13:59:16Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -132,62 +133,13 @@ private void makeTraceHeader(ModuleInstance mi, int statusCode,\n     pc.logResponse(mi.getModuleDescriptor().getId(), url, statusCode);\n   }\n \n-  private boolean match(RoutingEntry e, HttpServerRequest req) {\n+  private static boolean match(RoutingEntry e, HttpServerRequest req) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODAxOQ=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjU4NDE5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDowMjo1OVrOHtZaqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0OTo1M1rOHtbhjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ==", "bodyText": "If you have\nFunction<ModuleInstance, RoutingEntry> routingEntry = ModuleInstance::getRoutingEntry;\n\nyou can reduce the two lines to a one-liner:\nassertThat(instances).extracting(routingEntry).containsExactly(routingEntry1);", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517364395", "createdAt": "2020-11-04T14:02:59Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjA2Ng==", "bodyText": "ok.. I can tell you.. You'll be able to find many constructs  - for example in ModuleTest - that could be simplified.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517372066", "createdAt": "2020-11-04T14:13:18Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5ODkyNA==", "bodyText": "Thanks, more readable now.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517398924", "createdAt": "2020-11-04T14:49:53Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id},\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(ArgumentsAccessor accessor) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(accessor.getString(0));\n+    String expect = accessor.getString(1);\n+    if (expect == null) {\n+      expect = \"\";\n+    }\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2NDM5NQ=="}, "originalCommit": {"oid": "5e231f3db75a49c0062a339bebb7b1544e00a162"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjY3Njg1OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMTo1MlrOHtaRTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0MzozNlrOHtbPiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODM4Mw==", "bodyText": "assertThat is missing", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378383", "createdAt": "2020-11-04T14:21:52Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5NDMxMw==", "bodyText": "yep. Corrected.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517394313", "createdAt": "2020-11-04T14:43:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODM4Mw=="}, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjY3OTEyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyMjoyMFrOHtaSsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDoyNjoxN1rOHtaeDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODczOA==", "bodyText": "assertThat is missing", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517378738", "createdAt": "2020-11-04T14:22:20Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/perms/users\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users1\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    ModuleCache.lookup(\"/perms/user\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4MTY0NQ==", "bodyText": "good catch", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517381645", "createdAt": "2020-11-04T14:26:17Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/ModuleCacheTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import org.folio.okapi.bean.InterfaceDescriptor;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+class ModuleCacheTest {\n+  @ParameterizedTest\n+  @CsvSource({\n+      \"/, /\",\n+      \"/{id}, /\",\n+      \"{id}, ''\",\n+      \"/a/b{id}, /a/\",\n+      \"/a/*c, /a/\",\n+      \"/a/b*, /a/\",\n+      \"/a/b/, /a/b/\",\n+      \"/a/b, /a/b\",\n+      \"/a/{id}, /a/\",\n+  })\n+  void testGetPatternPrefix(String pathPattern, String expect) {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPathPattern(pathPattern);\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(expect);\n+  }\n+\n+  @Test\n+  void testPathPrefix()\n+  {\n+    RoutingEntry routingEntry = new RoutingEntry();\n+    routingEntry.setPath(\"/a/b\");\n+    assertThat(ModuleCache.getPatternPrefix(routingEntry)).isEqualTo(\"/\");\n+  }\n+\n+  @Test\n+  void testLookupEmpty() {\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null)).isEmpty();\n+  }\n+\n+  @Test\n+  void testLookupRoutingEntries() {\n+    ModuleDescriptor md = new ModuleDescriptor();\n+    md.setId(\"module-1.0.0\");\n+    List<RoutingEntry> routingEntries = new LinkedList<>();\n+    RoutingEntry routingEntry1 = new RoutingEntry();\n+    routingEntry1.setPathPattern(\"/a/b\");\n+    routingEntry1.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry1);\n+    RoutingEntry routingEntry2 = new RoutingEntry();\n+    routingEntry2.setPathPattern(\"/a/b\");\n+    routingEntry2.setMethods(new String[] {\"POST\"});\n+    routingEntries.add(routingEntry2);\n+    RoutingEntry routingEntry3 = new RoutingEntry();\n+    routingEntry3.setPathPattern(\"/a/b/{id}/c\");\n+    routingEntry3.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry3);\n+    RoutingEntry routingEntry4 = new RoutingEntry();\n+    routingEntry4.setPathPattern(\"/p/*/y\");\n+    routingEntry4.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry4);\n+    RoutingEntry routingEntry5 = new RoutingEntry();\n+    routingEntry5.setPathPattern(\"/perms/users*\");\n+    routingEntry5.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry5);\n+    RoutingEntry routingEntry6 = new RoutingEntry();\n+    routingEntry6.setPath(\"/old/type\");\n+    routingEntry6.setMethods(new String[] {\"GET\"});\n+    routingEntries.add(routingEntry6);\n+\n+    Map<String, List<ModuleCache.ModuleCacheEntry>> map = new HashMap<>();\n+    ModuleCache.add(md, map, routingEntries);\n+\n+    assertThat(ModuleCache.lookup(\"\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/\", HttpMethod.GET, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, null)).isEmpty();\n+    List<ModuleInstance> instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.GET, map, true, \"module-1.0.0\");\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry1);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.GET, map, true, \"other-1.0.0\")).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b\", HttpMethod.POST, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry2);\n+\n+    assertThat(ModuleCache.lookup(\"/a\", HttpMethod.PUT, map, true, null)).isEmpty();\n+    assertThat(ModuleCache.lookup(\"/a/b/\", HttpMethod.GET, map, true, null)).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/a/b/id/c\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry3);\n+\n+    instances = ModuleCache.lookup(\"/p/id/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry4);\n+\n+    ModuleCache.lookup(\"/p/id/z\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id\", HttpMethod.GET, map, true, null).isEmpty();\n+    ModuleCache.lookup(\"/p/id/y/z\", HttpMethod.GET, map, true, null).isEmpty();\n+\n+    instances = ModuleCache.lookup(\"/perms/users\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users/y\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    instances = ModuleCache.lookup(\"/perms/users1\", HttpMethod.GET, map, true, null);\n+    assertThat(instances.size()).isEqualTo(1);\n+    assertThat(instances.get(0).getRoutingEntry()).isEqualTo(routingEntry5);\n+\n+    ModuleCache.lookup(\"/perms/user\", HttpMethod.GET, map, true, null).isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3ODczOA=="}, "originalCommit": {"oid": "9d3a75fb829a43f31e4f92cff99f320bafe5004c"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjkyMzcyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNToyMVrOHtcrVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoxMjozNlrOHtfQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzgxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int index = 0;\n          \n          \n            \n                while (index < pathPattern.length()) {\n          \n          \n            \n                  if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n          \n          \n            \n                    while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n          \n          \n            \n                      --index;\n          \n          \n            \n                    }\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  index++;\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern.substring(0, index);\n          \n          \n            \n                int lastSlash = 0;\n          \n          \n            \n                for (int i = 0; i < pathPattern.length(); i++) {\n          \n          \n            \n                  switch (pathPattern.charAt(i)) {\n          \n          \n            \n                    case '*':\n          \n          \n            \n                    case '{':\n          \n          \n            \n                      return pathPattern.substring(0, lastSlash);\n          \n          \n            \n                    case '/':\n          \n          \n            \n                      lastSlash = i + 1;\n          \n          \n            \n                      break;\n          \n          \n            \n                    default:\n          \n          \n            \n                      break;\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                return pathPattern;", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517417812", "createdAt": "2020-11-04T15:15:21Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2MDAzMw==", "bodyText": "Ok. A little more lines, but perhaps more readable. In particular it avoids substring when there's no masking.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517460033", "createdAt": "2020-11-04T16:12:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzgxMg=="}, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzA2NTE4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNTo0NjowNVrOHteDqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoxNjo1OFrOHtfcDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDQyNw==", "bodyText": "We can use lastIndexOf:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int index = tryUri.length() - 1;\n          \n          \n            \n                  while (index > 0 && tryUri.charAt(index - 1) != '/') {\n          \n          \n            \n                    --index;\n          \n          \n            \n                  }\n          \n          \n            \n                  if (index <= 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index);\n          \n          \n            \n                  int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n          \n          \n            \n                  if (index < 0) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  tryUri = tryUri.substring(0, index + 1);", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517440427", "createdAt": "2020-11-04T15:46:05Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.length() - 1;\n+      while (index > 0 && tryUri.charAt(index - 1) != '/') {\n+        --index;\n+      }\n+      if (index <= 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2MzA1NQ==", "bodyText": "Definitely shorter.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517463055", "createdAt": "2020-11-04T16:16:58Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int index = 0;\n+    while (index < pathPattern.length()) {\n+      if (pathPattern.charAt(index) == '*' || pathPattern.charAt(index) == '{') {\n+        while (index > 0 && pathPattern.charAt(index - 1) != '/') {\n+          --index;\n+        }\n+        break;\n+      }\n+      index++;\n+    }\n+    return pathPattern.substring(0, index);\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.length() - 1;\n+      while (index > 0 && tryUri.charAt(index - 1) != '/') {\n+        --index;\n+      }\n+      if (index <= 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MDQyNw=="}, "originalCommit": {"oid": "5a0dcd5f3ba004d6f00d2d27f17bf72df31e9cda"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzI2MjYzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjoyOToyMFrOHtf_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzowNTo1NlrOHthiKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjA1Mg==", "bodyText": "This PR did not change this part, but I am wondering if we should consider downgrade Okapi version for superteant so it matches the actual running version?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517472052", "createdAt": "2020-11-04T16:29:20Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onSuccess(ires -> {\n         checkSuperTenant(okapiModule, promise);\n       });\n     });\n     return promise.future();\n   }\n \n   private void checkSuperTenant(String okapiModule, Promise<Void> promise) {\n-    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n-        Tenant st = gres.result();\n-        Set<String> enabledMods = st.getEnabled().keySet();\n-        if (enabledMods.contains(okapiModule)) {\n-          logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n-          promise.complete();\n-          return;\n-        }\n-        // Check version compatibility\n-        String enver = \"\";\n-        for (String emod : enabledMods) {\n-          if (emod.startsWith(\"okapi-\")) {\n-            enver = emod;\n-          }\n-        }\n-        final String ev = enver;\n-        logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n-            ev, okapiModule);\n-        // See Okapi-359 about version checks across the cluster\n-        if (ModuleId.compare(ev, okapiModule) >= 4) {\n-          logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n-                  + \"{} we already have {} in the database. Use that!\",\n-              okapiVersion, ev);\n-          promise.complete();\n-          return;\n+    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onSuccess(tenant -> {\n+      // we already have one, go on\n+      logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n+      Set<String> enabledMods = tenant.getEnabled().keySet();\n+      if (enabledMods.contains(okapiModule)) {\n+        logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n+        promise.complete();\n+        return;\n+      }\n+      // Check version compatibility\n+      String enver = \"\";\n+      for (String emod : enabledMods) {\n+        if (emod.startsWith(\"okapi-\")) {\n+          enver = emod;\n         }\n-        logger.info(\"checkSuperTenant: Need to upgrade the stored version from {} to {}\",\n-            ev, okapiModule);\n-        // Use the commit, easier interface.\n-        // the internal module can not have dependencies\n-        // See Okapi-359 about version checks across the cluster\n-        tenantManager.updateModuleCommit(st, ev, okapiModule).onComplete(ures -> {\n-          if (ures.failed()) {\n-            promise.fail(ures.cause());\n-            return;\n-          }\n-          logger.info(\"Upgraded the InternalModule version from '{}' to '{}' for {}\",\n-              ev, okapiModule, XOkapiHeaders.SUPERTENANT_ID);\n-          promise.complete();\n-        });\n+      }\n+      final String ev = enver;\n+      logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n+          ev, okapiModule);\n+      // See Okapi-359 about version checks across the cluster\n+      if (ModuleId.compare(ev, okapiModule) >= 4) {\n+        logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n+                + \"{} we already have {} in the database. Use that!\",\n+            okapiVersion, ev);\n+        promise.complete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5NzM4Nw==", "bodyText": "We could it it's just the Okapi module .. But we do have to be careful.. Eg ModuleDescriptors with new properties that suddenly will not be recognized by Okapi anymore.. I'll see what I can do as part of the \"upgrade Okapi module for all tenants\".. https://issues.folio.org/browse/OKAPI-930", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517497387", "createdAt": "2020-11-04T17:05:56Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/MainVerticle.java", "diffHunk": "@@ -253,78 +250,71 @@ public void start(Promise<Void> promise) {\n     final ModuleDescriptor md = InternalModule.moduleDescriptor(okapiVersion);\n     final String okapiModule = md.getId();\n     final String interfaceVersion = md.getProvides()[0].getVersion();\n-    moduleManager.get(okapiModule).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.debug(\"checkInternalModules: Already have {} \"\n-            + \" with interface version {}\", okapiModule, interfaceVersion);\n-        // See Okapi-359 about version checks across the cluster\n-        checkSuperTenant(okapiModule, promise);\n-        return;\n-      }\n-      if (OkapiError.getType(gres.cause()) != ErrorType.NOT_FOUND) {\n-        promise.fail(gres.cause()); // something went badly wrong\n+    moduleManager.get(okapiModule).onSuccess(gres -> {\n+      // we already have one, go on\n+      logger.debug(\"checkInternalModules: Already have {} \"\n+          + \" with interface version {}\", okapiModule, interfaceVersion);\n+      // See Okapi-359 about version checks across the cluster\n+      checkSuperTenant(okapiModule, promise);\n+    }).onFailure(cause -> {\n+      if (OkapiError.getType(cause) != ErrorType.NOT_FOUND) {\n+        promise.fail(cause); // something went badly wrong\n         return;\n       }\n       logger.debug(\"Creating the internal Okapi module {} with interface version {}\",\n           okapiModule, interfaceVersion);\n-      moduleManager.create(md, true, true, true).onComplete(ires -> {\n-        if (ires.failed()) {\n-          promise.fail(ires.cause()); // something went badly wrong\n-          return;\n-        }\n+      moduleManager.create(md, true, true, true).onFailure(cause1 ->\n+          promise.fail(cause1) // something went badly wrong\n+      ).onSuccess(ires -> {\n         checkSuperTenant(okapiModule, promise);\n       });\n     });\n     return promise.future();\n   }\n \n   private void checkSuperTenant(String okapiModule, Promise<Void> promise) {\n-    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onComplete(gres -> {\n-      if (gres.succeeded()) { // we already have one, go on\n-        logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n-        Tenant st = gres.result();\n-        Set<String> enabledMods = st.getEnabled().keySet();\n-        if (enabledMods.contains(okapiModule)) {\n-          logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n-          promise.complete();\n-          return;\n-        }\n-        // Check version compatibility\n-        String enver = \"\";\n-        for (String emod : enabledMods) {\n-          if (emod.startsWith(\"okapi-\")) {\n-            enver = emod;\n-          }\n-        }\n-        final String ev = enver;\n-        logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n-            ev, okapiModule);\n-        // See Okapi-359 about version checks across the cluster\n-        if (ModuleId.compare(ev, okapiModule) >= 4) {\n-          logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n-                  + \"{} we already have {} in the database. Use that!\",\n-              okapiVersion, ev);\n-          promise.complete();\n-          return;\n+    tenantManager.get(XOkapiHeaders.SUPERTENANT_ID).onSuccess(tenant -> {\n+      // we already have one, go on\n+      logger.info(\"checkSuperTenant: Already have \" + XOkapiHeaders.SUPERTENANT_ID);\n+      Set<String> enabledMods = tenant.getEnabled().keySet();\n+      if (enabledMods.contains(okapiModule)) {\n+        logger.info(\"checkSuperTenant: enabled version is {}\", okapiModule);\n+        promise.complete();\n+        return;\n+      }\n+      // Check version compatibility\n+      String enver = \"\";\n+      for (String emod : enabledMods) {\n+        if (emod.startsWith(\"okapi-\")) {\n+          enver = emod;\n         }\n-        logger.info(\"checkSuperTenant: Need to upgrade the stored version from {} to {}\",\n-            ev, okapiModule);\n-        // Use the commit, easier interface.\n-        // the internal module can not have dependencies\n-        // See Okapi-359 about version checks across the cluster\n-        tenantManager.updateModuleCommit(st, ev, okapiModule).onComplete(ures -> {\n-          if (ures.failed()) {\n-            promise.fail(ures.cause());\n-            return;\n-          }\n-          logger.info(\"Upgraded the InternalModule version from '{}' to '{}' for {}\",\n-              ev, okapiModule, XOkapiHeaders.SUPERTENANT_ID);\n-          promise.complete();\n-        });\n+      }\n+      final String ev = enver;\n+      logger.debug(\"checkSuperTenant: Enabled version is '{}', not '{}'\",\n+          ev, okapiModule);\n+      // See Okapi-359 about version checks across the cluster\n+      if (ModuleId.compare(ev, okapiModule) >= 4) {\n+        logger.warn(\"checkSuperTenant: This Okapi is too old,\"\n+                + \"{} we already have {} in the database. Use that!\",\n+            okapiVersion, ev);\n+        promise.complete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MjA1Mg=="}, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzI2OTEyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMDo0N1rOHtgDOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzowNzowMlrOHthlNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MzA4MA==", "bodyText": "Can this loop be combined with above one?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517473080", "createdAt": "2020-11-04T16:30:47Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5ODE2NA==", "bodyText": "Yes. Will do.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517498164", "createdAt": "2020-11-04T17:07:02Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MzA4MA=="}, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzI4MjA4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNjozMzo1MFrOHtgLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzo0ODoyMlrOHtjJPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg==", "bodyText": "Wondering if we should extract this so it won't be executed every time?", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517475182", "createdAt": "2020-11-04T16:33:50Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ5OTI3MQ==", "bodyText": "I don't see how we could save this sorting.. Having said that we're sorting - in most cases two modules: auth + handler module.. Suppose a few audit.. and we're up to 4.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517499271", "createdAt": "2020-11-04T17:08:51Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNjA5Mw==", "bodyText": "I mean define it just once somewhere and then use it every time.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517506093", "createdAt": "2020-11-04T17:19:26Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyMzc3NA==", "bodyText": "ok. done", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517523774", "createdAt": "2020-11-04T17:48:22Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -228,89 +173,36 @@ private boolean checkTokenCache(String tenant, HttpServerRequest req, String pat\n     }\n   }\n \n-  /**\n-   * Builds the pipeline of modules to be invoked for a request. Sets the\n-   * default authToken for each ModuleInstance. Later, these can be overwritten\n-   * by the ModuleTokens from the auth, if needed.\n-   *\n-   * @param pc ProxyContext\n-   * @param enabledModules modules enabled for the current tenant\n-   * @return a list of ModuleInstances. In case of error, sets up ctx and returns null.\n-   */\n-  private List<ModuleInstance> getModulesForRequest(ProxyContext pc,\n-                                                    List<ModuleDescriptor> enabledModules) {\n-\n-    Timer.Sample sample = MetricsHelper.getTimerSample();\n-    final String name = \"ProxyService.getModulesForRequest\";\n-\n-    List<ModuleInstance> mods = new ArrayList<>();\n+  private List<ModuleInstance> getModulesForRequest(ProxyContext pc, ModuleCache moduleCache) {\n     HttpServerRequest req = pc.getCtx().request();\n     final String id = req.getHeader(XOkapiHeaders.MODULE_ID);\n-    logger.debug(\"getModulesForRequest: Matching {} {}\", req.method(), req.uri());\n-\n+    List<ModuleInstance> mods = null;\n+    try {\n+      mods = moduleCache.lookup(req.uri(), req.method(), id);\n+    } catch (IllegalArgumentException e) {\n+      pc.responseError(500, e.getMessage());\n+      return null;\n+    }\n     boolean skipAuth = false;\n-    Timer.Sample sampleLoopEnabledModules = MetricsHelper.getTimerSample();\n-\n-    for (ModuleDescriptor md : enabledModules) {\n-      logger.debug(\"getModulesForRequest:  looking at {}\", md.getId());\n-      List<RoutingEntry> rr = null;\n-      if (id == null) {\n-        rr = md.getProxyRoutingEntries();\n-      } else if (id.equals(md.getId())) {\n-        rr = md.getMultiRoutingEntries();\n-      }\n-      if (rr != null) {\n-        Timer.Sample sampleLoopRoutingEntries = MetricsHelper.getTimerSample();\n-        for (RoutingEntry re : rr) {\n-          if (match(re, req)) {\n-            ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), true);\n-\n-            skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n-            mods.add(mi);\n-            logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-                re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-            break;\n-          }\n-        }\n-        MetricsHelper.recordCodeExecutionTime(sampleLoopRoutingEntries,\n-            name + \".loopRoutingEntries\");\n+    for (ModuleInstance mi : mods) {\n+      if (mi.isHandler()) {\n+        RoutingEntry re = mi.getRoutingEntry();\n+        skipAuth = checkTokenCache(pc.getTenant(), req, re.getPathPattern(), mi);\n+        logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\",\n+            mi.getModuleDescriptor().getId(),\n+            re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n       }\n-      rr = md.getFilterRoutingEntries();\n-      Timer.Sample sampleLoopFilterEntries = MetricsHelper.getTimerSample();\n-      for (RoutingEntry re : rr) {\n-        if (match(re, req)) {\n-          ModuleInstance mi = new ModuleInstance(md, re, req.uri(), req.method(), false);\n-          mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n-          mods.add(mi);\n-          if (!resolveRedirects(pc, mods, re, enabledModules, \"\", req.uri())) {\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries,\n-                name + \".loopFilterEntries\");\n-            MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules,\n-                name + \".loopEnabledModules\");\n-            MetricsHelper.recordCodeExecutionTime(sample, name);\n-            return null;\n-          }\n-          logger.debug(\"getModulesForRequest:  Added {} {} {} {} / {}\", md.getId(),\n-              re.getPathPattern(), re.getPath(), re.getPhase(), re.getLevel());\n-        }\n+    }\n+    for (ModuleInstance mi : mods) {\n+      if (!mi.isHandler()) {\n+        mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));\n       }\n-      MetricsHelper.recordCodeExecutionTime(sampleLoopFilterEntries, name + \".loopFilterEntries\");\n     }\n-    MetricsHelper.recordCodeExecutionTime(sampleLoopEnabledModules, name + \".loopEnabledModules\");\n-\n-    Timer.Sample sampleSortModuleInstances = MetricsHelper.getTimerSample();\n-    Comparator<ModuleInstance> cmp = (ModuleInstance a, ModuleInstance b)\n-        -> a.getRoutingEntry().getPhaseLevel().compareTo(b.getRoutingEntry().getPhaseLevel());\n+    Comparator<ModuleInstance> cmp = Comparator.comparing((ModuleInstance a)\n+        -> a.getRoutingEntry().getPhaseLevel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3NTE4Mg=="}, "originalCommit": {"oid": "290e3ba0211f27b6b3a72d9912640193b2e75c34"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzQ4Mjk2OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyMToyMVrOHtiI1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNzoyMToyMVrOHtiI1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNzI4Ng==", "bodyText": "Can remove ModuleCache prefix since it is in the same class.", "url": "https://github.com/folio-org/okapi/pull/1025#discussion_r517507286", "createdAt": "2020-11-04T17:21:21Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/ModuleCache.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package org.folio.okapi.util;\n+\n+import io.vertx.core.http.HttpMethod;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.bean.ModuleDescriptor;\n+import org.folio.okapi.bean.ModuleInstance;\n+import org.folio.okapi.bean.RoutingEntry;\n+import org.folio.okapi.common.Messages;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class ModuleCache {\n+  private static final Logger logger = OkapiLogger.get();\n+  private static final Messages messages = Messages.getInstance();\n+\n+  static class ModuleCacheEntry {\n+    final ModuleDescriptor moduleDescriptor;\n+    final RoutingEntry routingEntry;\n+\n+    public ModuleCacheEntry(ModuleDescriptor moduleDescriptor, RoutingEntry routingEntry) {\n+      this.moduleDescriptor = moduleDescriptor;\n+      this.routingEntry = routingEntry;\n+    }\n+  }\n+\n+  final Map<String, List<ModuleCacheEntry>> proxyMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> multiMap = new HashMap<>();\n+  final Map<String, List<ModuleCacheEntry>> filterMap = new HashMap<>();\n+  final List<ModuleDescriptor> moduleDescriptors;\n+\n+  /**\n+   * Construct cache with module descriptors.\n+   * @param moduleDescriptors to be cached\n+   */\n+  public ModuleCache(List<ModuleDescriptor> moduleDescriptors) {\n+    this.moduleDescriptors = moduleDescriptors;\n+    for (ModuleDescriptor moduleDescriptor : moduleDescriptors) {\n+      add(moduleDescriptor);\n+    }\n+  }\n+\n+  /**\n+   * Return modules descriptors in cache.\n+   * @return list of modules\n+   */\n+  public List<ModuleDescriptor> getModules() {\n+    return moduleDescriptors;\n+  }\n+\n+  static String getPatternPrefix(RoutingEntry re) {\n+    String pathPattern = re.getPathPattern();\n+    if (pathPattern == null) {\n+      return \"/\"; // anything but pathPattern is legacy so we don't care about those\n+    }\n+    int lastSlash = 0;\n+    for (int i = 0; i < pathPattern.length(); i++) {\n+      switch (pathPattern.charAt(i)) {\n+        case '*':\n+        case '{':\n+          return pathPattern.substring(0, lastSlash);\n+        case '/':\n+          lastSlash = i + 1;\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+    return pathPattern;\n+  }\n+\n+  static void add(ModuleDescriptor moduleDescriptor, Map<String, List<ModuleCacheEntry>> map,\n+                  List<RoutingEntry> entries) {\n+    for (RoutingEntry routingEntry : entries) {\n+      String prefix = getPatternPrefix(routingEntry);\n+      List<ModuleCacheEntry> list = map.get(prefix);\n+      if (list == null) {\n+        list = new LinkedList<>();\n+        map.put(prefix, list);\n+      }\n+      list.add(new ModuleCacheEntry(moduleDescriptor, routingEntry));\n+    }\n+  }\n+\n+  private void add(ModuleDescriptor moduleDescriptor) {\n+    add(moduleDescriptor, proxyMap, moduleDescriptor.getProxyRoutingEntries());\n+    add(moduleDescriptor, multiMap, moduleDescriptor.getMultiRoutingEntries());\n+    add(moduleDescriptor, filterMap, moduleDescriptor.getFilterRoutingEntries());\n+  }\n+\n+  private void resolveRedirect(List<ModuleInstance> instances, RoutingEntry re, String loop,\n+                               Set<RoutingEntry> routingEntries,\n+                               HttpMethod method, String uri) {\n+    if (re.getProxyType() != RoutingEntry.ProxyType.REDIRECT) {\n+      return;\n+    }\n+    logger.debug(\"resolveRedirect begin redirectPath={}\", re.getRedirectPath());\n+    boolean found = false;\n+    final String redirectPath = re.getRedirectPath();\n+\n+    List<ModuleInstance> lookup = lookup(redirectPath, method, filterMap, false, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, false);\n+        instances.add(mi);\n+        resolveRedirect(instances, tryre, loop + \" -> \" + redirectPath, routingEntries,\n+            method, redirectUri);\n+      } else {\n+        throw new IllegalArgumentException(messages.getMessage(\"10100\", loop, redirectPath));\n+      }\n+    }\n+    lookup = lookup(redirectPath, method, proxyMap, true, null);\n+    for (ModuleInstance instance : lookup) {\n+      RoutingEntry tryre = instance.getRoutingEntry();\n+      String redirectUri = re.getRedirectUri(uri);\n+      found = true;\n+      if (routingEntries.add(tryre)) {\n+        ModuleInstance mi = new ModuleInstance(instance.getModuleDescriptor(), tryre, redirectUri,\n+            method, true);\n+        instances.add(mi);\n+      }\n+    }\n+    logger.debug(\"resolveRedirect end redirectPath={} found={}\", re.getRedirectPath(), found);\n+    if (!found) {\n+      throw new IllegalArgumentException(messages.getMessage(\"10101\", uri, redirectPath));\n+    }\n+  }\n+\n+  static List<ModuleInstance> lookup(String uri, HttpMethod method, Map<String,\n+      List<ModuleCacheEntry>> map, boolean handler, String id) {\n+    List<ModuleInstance> instances = new LinkedList<>();\n+    String tryUri = uri;\n+    for (int index = 0; index < uri.length(); index++) {\n+      if (uri.charAt(index) == '#' || uri.charAt(index) == '?') {\n+        tryUri = tryUri.substring(0, index);\n+        break;\n+      }\n+    }\n+    while (true) {\n+      List<ModuleCacheEntry> candidateInstances = map.get(tryUri);\n+      if (candidateInstances != null) {\n+        for (ModuleCacheEntry candiate : candidateInstances) {\n+          if (candiate.routingEntry.match(uri, method.name())\n+              && (id == null || id.equals(candiate.moduleDescriptor.getId()))) {\n+            instances.add(new ModuleInstance(candiate.moduleDescriptor,\n+                candiate.routingEntry, uri, method, handler));\n+            if (handler) {\n+              return instances;\n+            }\n+          }\n+        }\n+      }\n+      int index = tryUri.lastIndexOf('/', tryUri.length() - 2);\n+      if (index < 0) {\n+        break;\n+      }\n+      tryUri = tryUri.substring(0, index + 1);\n+    }\n+    return instances;\n+  }\n+\n+  /**\n+   * Find module instances for uri(path) and method.\n+   * @param uri request uri\n+   * @param method HTTP method\n+   * @param id Proxy-ID for multi lookup; otherwise null\n+   * @return module instances that match\n+   * @throws IllegalArgumentException for redirect errors\n+   */\n+  public List<ModuleInstance> lookup(String uri, HttpMethod method, String id) {\n+    logger.debug(\"lookup {} {} id={}\", () -> method.name(), () -> uri, () -> id);\n+    logger.debug(\"Available modules {}\", () -> ModuleUtil.moduleList(moduleDescriptors));\n+    // perform lookup of filters\n+    List<ModuleInstance> instances = ModuleCache.lookup(uri, method, filterMap, false, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5dca92bc319f90e95bdb6b78c98c28510ff4e1"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 189, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}