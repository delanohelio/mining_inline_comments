{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMDYyMjQ0", "number": 978, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToyNzowMFrOEotwrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMTowMzo0NlrOEowX1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTI4MjM3OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/DockerModuleHandle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToyNzowMFrOHZ9ybw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTo0MToyMlrOHZ-amQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk4ODc4Mw==", "bodyText": "if (dockerPull) {\n  return pullImage().compose(x -> prepareContainer());\n}\nreturn prepareContainer();", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r496988783", "createdAt": "2020-09-29T19:27:00Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/DockerModuleHandle.java", "diffHunk": "@@ -373,64 +348,40 @@ private int getExposedPort(JsonObject b) {\n     return exposedPort;\n   }\n \n-  private void prepareContainer(Handler<AsyncResult<Void>> startFuture) {\n-    getImage(res1 -> {\n-      if (res1.failed()) {\n-        logger.warn(\"getImage failed 1 : {}\", res1.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(res1.cause()));\n-        return;\n-      }\n-      if (hostPort == 0) {\n-        startFuture.handle(Future.failedFuture(messages.getMessage(\"11300\")));\n-        return;\n-      }\n+  private Future<Void> prepareContainer() {\n+    if (hostPort == 0) {\n+      return Future.failedFuture(messages.getMessage(\"11300\"));\n+    }\n+    return getImage().compose(res1 -> {\n       int exposedPort;\n       try {\n-        exposedPort = getExposedPort(res1.result());\n-      } catch (Exception ex) {\n-        startFuture.handle(Future.failedFuture(ex));\n-        return;\n+        exposedPort = getExposedPort(res1);\n+      } catch (Exception e) {\n+        logger.warn(\"{}\", e.getMessage(), e);\n+        return Future.failedFuture(e);\n       }\n-      createContainer(exposedPort, res2 -> {\n-        if (res2.failed()) {\n-          startFuture.handle(res2);\n-          return;\n-        }\n-        startContainer(res3 -> {\n-          if (res3.failed()) {\n-            deleteContainer(x -> startFuture.handle(res3));\n-            return;\n-          }\n-          getContainerLog(res4 -> {\n-            if (res4.failed()) {\n-              this.stop(x -> startFuture.handle(res4));\n-              return;\n-            }\n-            startFuture.handle(res4);\n-          });\n-        });\n-      });\n+      return createContainer(exposedPort)\n+          .compose(res2 -> startContainer()\n+              .onFailure(cause -> deleteContainer())\n+              .compose(res3 -> getContainerLog())\n+      );\n     });\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n+  public Future<Void> start() {\n+    Future<Void> future = Future.succeededFuture();\n     if (dockerPull) {\n-      pullImage(res -> prepareContainer(startFuture));\n-    } else {\n-      prepareContainer(startFuture);\n+      future = future.compose(x -> pullImage());\n     }\n+    return future.compose(x -> prepareContainer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21267a01164893126a84200faa2f4a99aa5312e8"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5OTA2NQ==", "bodyText": "OK. The reason for existing layout was to mention prepareContainer only once.", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r496999065", "createdAt": "2020-09-29T19:41:22Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/DockerModuleHandle.java", "diffHunk": "@@ -373,64 +348,40 @@ private int getExposedPort(JsonObject b) {\n     return exposedPort;\n   }\n \n-  private void prepareContainer(Handler<AsyncResult<Void>> startFuture) {\n-    getImage(res1 -> {\n-      if (res1.failed()) {\n-        logger.warn(\"getImage failed 1 : {}\", res1.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(res1.cause()));\n-        return;\n-      }\n-      if (hostPort == 0) {\n-        startFuture.handle(Future.failedFuture(messages.getMessage(\"11300\")));\n-        return;\n-      }\n+  private Future<Void> prepareContainer() {\n+    if (hostPort == 0) {\n+      return Future.failedFuture(messages.getMessage(\"11300\"));\n+    }\n+    return getImage().compose(res1 -> {\n       int exposedPort;\n       try {\n-        exposedPort = getExposedPort(res1.result());\n-      } catch (Exception ex) {\n-        startFuture.handle(Future.failedFuture(ex));\n-        return;\n+        exposedPort = getExposedPort(res1);\n+      } catch (Exception e) {\n+        logger.warn(\"{}\", e.getMessage(), e);\n+        return Future.failedFuture(e);\n       }\n-      createContainer(exposedPort, res2 -> {\n-        if (res2.failed()) {\n-          startFuture.handle(res2);\n-          return;\n-        }\n-        startContainer(res3 -> {\n-          if (res3.failed()) {\n-            deleteContainer(x -> startFuture.handle(res3));\n-            return;\n-          }\n-          getContainerLog(res4 -> {\n-            if (res4.failed()) {\n-              this.stop(x -> startFuture.handle(res4));\n-              return;\n-            }\n-            startFuture.handle(res4);\n-          });\n-        });\n-      });\n+      return createContainer(exposedPort)\n+          .compose(res2 -> startContainer()\n+              .onFailure(cause -> deleteContainer())\n+              .compose(res3 -> getContainerLog())\n+      );\n     });\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n+  public Future<Void> start() {\n+    Future<Void> future = Future.succeededFuture();\n     if (dockerPull) {\n-      pullImage(res -> prepareContainer(startFuture));\n-    } else {\n-      prepareContainer(startFuture);\n+      future = future.compose(x -> pullImage());\n     }\n+    return future.compose(x -> prepareContainer());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk4ODc4Mw=="}, "originalCommit": {"oid": "21267a01164893126a84200faa2f4a99aa5312e8"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTM5NzA5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTo1NDo0MlrOHZ-2PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMjo1MzowMFrOHacDgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwNjE0MQ==", "bodyText": "No need for the promise:\nif (port == 0) {\n  return start2();\n}\n// fail if port is already in use\nNetClientOptions options = new NetClientOptions().setConnectTimeout(200);\nNetClient c = vertx.createNetClient(options);\nreturn c.connect(port, \"localhost\").compose(socket -> {\n  socket.close();\n  return Future.failedFuture(messages.getMessage(\"11502\", Integer.toString(port)));\n}, fail -> start2());", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497006141", "createdAt": "2020-09-29T19:54:42Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -73,24 +72,25 @@ public ProcessModuleHandle(Vertx vertx, LaunchDescriptor desc, String id,\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n-    if (port > 0) {\n+  public Future<Void> start() {\n+    Promise<Void> promise = Promise.promise();\n+    if (port == 0) {\n+      promise.complete();\n+    } else {\n       // fail if port is already in use\n       NetClientOptions options = new NetClientOptions().setConnectTimeout(200);\n       NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n+      c.connect(port, \"localhost\").onComplete(res -> {\n         if (res.succeeded()) {\n           NetSocket socket = res.result();\n           socket.close();\n-          startFuture.handle(Future.failedFuture(\n-              messages.getMessage(\"11502\", Integer.toString(port))));\n+          promise.fail(messages.getMessage(\"11502\", Integer.toString(port)));\n         } else {\n-          start2(startFuture);\n+          promise.complete();\n         }\n       });\n-    } else {\n-      start2(startFuture);\n     }\n+    return promise.future().compose(x -> start2());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4NDY3Mw==", "bodyText": "oh .. the 2nd argument to compose is useful for \"negating\".", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497484673", "createdAt": "2020-09-30T12:53:00Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -73,24 +72,25 @@ public ProcessModuleHandle(Vertx vertx, LaunchDescriptor desc, String id,\n   }\n \n   @Override\n-  public void start(Handler<AsyncResult<Void>> startFuture) {\n-    if (port > 0) {\n+  public Future<Void> start() {\n+    Promise<Void> promise = Promise.promise();\n+    if (port == 0) {\n+      promise.complete();\n+    } else {\n       // fail if port is already in use\n       NetClientOptions options = new NetClientOptions().setConnectTimeout(200);\n       NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n+      c.connect(port, \"localhost\").onComplete(res -> {\n         if (res.succeeded()) {\n           NetSocket socket = res.result();\n           socket.close();\n-          startFuture.handle(Future.failedFuture(\n-              messages.getMessage(\"11502\", Integer.toString(port))));\n+          promise.fail(messages.getMessage(\"11502\", Integer.toString(port)));\n         } else {\n-          start2(startFuture);\n+          promise.complete();\n         }\n       });\n-    } else {\n-      start2(startFuture);\n     }\n+    return promise.future().compose(x -> start2());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwNjE0MQ=="}, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTQxMjQxOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTo1OToxMVrOHZ-_nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzo1NTo0NVrOHaezlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwODU0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return tcpPortWaiting.waitReady(process).onFailure(x -> {\n          \n          \n            \n                  this.stopProcess();\n          \n          \n            \n                });\n          \n          \n            \n                return tcpPortWaiting.waitReady(process).onFailure(x -> stopProcess());", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497008541", "createdAt": "2020-09-29T19:59:11Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyOTc1MQ==", "bodyText": "yep", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497529751", "createdAt": "2020-09-30T13:55:45Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwODU0MQ=="}, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTQ2NDg5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoxNDo1MlrOHZ_fmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxMzo1NTo1MlrOHae0Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjcyOA==", "bodyText": "Using compose results in more simple code:\nNetClientOptions options = new NetClientOptions().setConnectTimeout(50);\nNetClient c = vertx.createNetClient(options);\nreturn c.connect(port, \"localhost\").compose(socket -> {\n  socket.close();\n  if (iter > 0) {\n    Promise<Void> promise = Promise.promise();\n    vertx.setTimer(100, id -> waitPortToClose(iter - 1).onComplete(promise::handle));\n    return promise.future();\n  } else {\n    return Future.failedFuture(messages.getMessage(\"11503\", Integer.toString(port)));\n  }\n}, fail -> Future.succeededFuture());", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497016728", "createdAt": "2020-09-29T20:14:52Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });\n   }\n \n-  private void waitPortToClose(Handler<AsyncResult<Void>> stopFuture, int iter) {\n-    if (port > 0) {\n-      // fail if port is already in use\n-      NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n-      NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n-        if (res.succeeded()) {\n-          NetSocket socket = res.result();\n-          socket.close();\n-          if (iter > 0) {\n-            vertx.setTimer(100, x -> waitPortToClose(stopFuture, iter - 1));\n-          } else {\n-            stopFuture.handle(Future.failedFuture(\n-                messages.getMessage(\"11503\", Integer.toString(port))));\n-          }\n+  private Future<Void> waitPortToClose(int iter) {\n+    if (port == 0) {\n+      return Future.succeededFuture();\n+    }\n+    NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n+    NetClient c = vertx.createNetClient(options);\n+    Promise<Void> promise = Promise.promise();\n+    c.connect(port, \"localhost\").onComplete(res -> {\n+      if (res.succeeded()) {\n+        NetSocket socket = res.result();\n+        socket.close();\n+        if (iter > 0) {\n+          vertx.setTimer(100, id -> waitPortToClose(iter - 1).onComplete(promise::handle));\n         } else {\n-          stopFuture.handle(Future.succeededFuture());\n+          promise.fail(messages.getMessage(\"11503\", Integer.toString(port)));\n         }\n-      });\n-    } else {\n-      stopFuture.handle(Future.succeededFuture());\n-    }\n+      } else {\n+        promise.complete();\n+      }\n+    });\n+    return promise.future();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyOTg1OA==", "bodyText": "yep", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497529858", "createdAt": "2020-09-30T13:55:52Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/service/impl/ProcessModuleHandle.java", "diffHunk": "@@ -175,100 +175,81 @@ private void start2(Handler<AsyncResult<Void>> startFuture) {\n         }\n       }\n       future.complete();\n-    }, false, result -> {\n-      if (result.failed()) {\n-        logger.debug(\"ProcessModuleHandle.start2() executeBlocking failed {}\",\n-            result.cause().getMessage());\n-        startFuture.handle(Future.failedFuture(result.cause()));\n-      } else {\n-        start3(startFuture);\n-      }\n-    });\n+    }, false).compose(x -> start3());\n   }\n \n-  private void start3(Handler<AsyncResult<Void>> startFuture) {\n-    tcpPortWaiting.waitReady(process, x -> {\n-      if (x.failed()) {\n-        this.stopProcess(y -> startFuture.handle(Future.failedFuture(x.cause())));\n-      } else {\n-        startFuture.handle(Future.succeededFuture());\n-      }\n+  private Future<Void> start3() {\n+    return tcpPortWaiting.waitReady(process).onFailure(x -> {\n+      this.stopProcess();\n     });\n   }\n \n-  private void waitPortToClose(Handler<AsyncResult<Void>> stopFuture, int iter) {\n-    if (port > 0) {\n-      // fail if port is already in use\n-      NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n-      NetClient c = vertx.createNetClient(options);\n-      c.connect(port, \"localhost\", res -> {\n-        if (res.succeeded()) {\n-          NetSocket socket = res.result();\n-          socket.close();\n-          if (iter > 0) {\n-            vertx.setTimer(100, x -> waitPortToClose(stopFuture, iter - 1));\n-          } else {\n-            stopFuture.handle(Future.failedFuture(\n-                messages.getMessage(\"11503\", Integer.toString(port))));\n-          }\n+  private Future<Void> waitPortToClose(int iter) {\n+    if (port == 0) {\n+      return Future.succeededFuture();\n+    }\n+    NetClientOptions options = new NetClientOptions().setConnectTimeout(50);\n+    NetClient c = vertx.createNetClient(options);\n+    Promise<Void> promise = Promise.promise();\n+    c.connect(port, \"localhost\").onComplete(res -> {\n+      if (res.succeeded()) {\n+        NetSocket socket = res.result();\n+        socket.close();\n+        if (iter > 0) {\n+          vertx.setTimer(100, id -> waitPortToClose(iter - 1).onComplete(promise::handle));\n         } else {\n-          stopFuture.handle(Future.succeededFuture());\n+          promise.fail(messages.getMessage(\"11503\", Integer.toString(port)));\n         }\n-      });\n-    } else {\n-      stopFuture.handle(Future.succeededFuture());\n-    }\n+      } else {\n+        promise.complete();\n+      }\n+    });\n+    return promise.future();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNjcyOA=="}, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTQ5NjY0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TcpPortWaiting.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoyMzo1NVrOHZ_y_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDoyMzo1NVrOHZ_y_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAyMTY5Mg==", "bodyText": "The @return javadoc should be removed because it does not give any additional information. (At least startFuture should be removed).", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497021692", "createdAt": "2020-09-29T20:23:55Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TcpPortWaiting.java", "diffHunk": "@@ -62,13 +63,12 @@ public void setMaxIterations(int maxIterations) {\n   /**\n    * Wait for process and server to be listening.\n    * @param process Process to monitor\n-   * @param startFuture async result\n+   * @return startFuture async result", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTcxMDI4OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/DeploymentManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMTowMzo0NlrOHaB-WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDowMToxNVrOHafExA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NzM2OQ==", "bodyText": "@SuppressWarnings(\"indentation\")  // indentation of fail -> {\n\n...\n  return mh.start().compose(started -> {\n    DeploymentDescriptor md2 = new DeploymentDescriptor(md1.getInstId(), md1.getSrvcId(),\n        moduleUrl, descriptor, mh);\n    md2.setNodeId(md1.getNodeId() != null ? md1.getNodeId() : host);\n    list.put(md2.getInstId(), md2);\n    return dm.add(md2).map(md2);\n  }, fail -> {\n    ports.free(usePort);\n    logger.warn(\"Deploying {} failed\", md1.getSrvcId());\n    return Future.failedFuture(new OkapiError(ErrorType.USER, fail.getMessage()));\n  });", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497057369", "createdAt": "2020-09-29T21:03:46Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DeploymentManager.java", "diffHunk": "@@ -181,21 +179,19 @@ public DeploymentManager(Vertx vertx, DiscoveryManager dm, EnvManager em,\n       ModuleHandle mh = ModuleHandleFactory.create(vertx, descriptor,\n           md1.getSrvcId(), ports, moduleHost, usePort, config);\n       Promise<DeploymentDescriptor> promise = Promise.promise();\n-      mh.start(future -> {\n-        if (future.failed()) {\n+      mh.start().onComplete(res -> {\n+        if (res.failed()) {\n           ports.free(usePort);\n           logger.warn(\"Deploying {} failed\", md1.getSrvcId());\n-          promise.fail(new OkapiError(ErrorType.USER, future.cause().getMessage()));\n+          promise.fail(new OkapiError(ErrorType.USER, res.cause().getMessage()));\n           return;\n         }\n         DeploymentDescriptor md2\n             = new DeploymentDescriptor(md1.getInstId(), md1.getSrvcId(),\n             moduleUrl, descriptor, mh);\n         md2.setNodeId(md1.getNodeId() != null ? md1.getNodeId() : host);\n         list.put(md2.getInstId(), md2);\n-        dm.add(md2).onComplete(res -> {\n-          promise.complete(md2);\n-        });\n+        dm.add(md2).onComplete(res1 -> promise.handle(res1.map(md2)));\n       });\n       return promise.future();\n     });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUzNDE0OA==", "bodyText": "ok", "url": "https://github.com/folio-org/okapi/pull/978#discussion_r497534148", "createdAt": "2020-09-30T14:01:15Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/DeploymentManager.java", "diffHunk": "@@ -181,21 +179,19 @@ public DeploymentManager(Vertx vertx, DiscoveryManager dm, EnvManager em,\n       ModuleHandle mh = ModuleHandleFactory.create(vertx, descriptor,\n           md1.getSrvcId(), ports, moduleHost, usePort, config);\n       Promise<DeploymentDescriptor> promise = Promise.promise();\n-      mh.start(future -> {\n-        if (future.failed()) {\n+      mh.start().onComplete(res -> {\n+        if (res.failed()) {\n           ports.free(usePort);\n           logger.warn(\"Deploying {} failed\", md1.getSrvcId());\n-          promise.fail(new OkapiError(ErrorType.USER, future.cause().getMessage()));\n+          promise.fail(new OkapiError(ErrorType.USER, res.cause().getMessage()));\n           return;\n         }\n         DeploymentDescriptor md2\n             = new DeploymentDescriptor(md1.getInstId(), md1.getSrvcId(),\n             moduleUrl, descriptor, mh);\n         md2.setNodeId(md1.getNodeId() != null ? md1.getNodeId() : host);\n         list.put(md2.getInstId(), md2);\n-        dm.add(md2).onComplete(res -> {\n-          promise.complete(md2);\n-        });\n+        dm.add(md2).onComplete(res1 -> promise.handle(res1.map(md2)));\n       });\n       return promise.future();\n     });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1NzM2OQ=="}, "originalCommit": {"oid": "eed6c84ae3cc72d4e909989501a10e426f5b0e51"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 143, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}