{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0OTUwNDYy", "number": 981, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTozMzozOVrOEpbtSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNToyMjo1MFrOEqXi7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODgxMDMzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTozMzozOVrOHbGMtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTozMzozOVrOHbGMtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTE1OQ==", "bodyText": "Not in use anywhere, so I don't think it's necessary to define it.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498175159", "createdAt": "2020-10-01T11:33:39Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Convenience constructor using the default TTL and max size.\n+   */\n+  public TokenCache() {\n+    this(DEFAULT_TTL, DEFAULT_MAX_SIZE);\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExODgxMTQ0OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMTozNDowN1rOHbGNbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxMjo0OTowMlrOHbIx9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTM0MQ==", "bodyText": "That's going to be a lot of logging by default.. with info log-level I mean.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498175341", "createdAt": "2020-10-01T11:34:07Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Convenience constructor using the default TTL and max size.\n+   */\n+  public TokenCache() {\n+    this(DEFAULT_TTL, DEFAULT_MAX_SIZE);\n+  }\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.info(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.info(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.info(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.info(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzQ2Mw==", "bodyText": "OK I'll make it debug", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498217463", "createdAt": "2020-10-01T12:49:02Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Convenience constructor using the default TTL and max size.\n+   */\n+  public TokenCache() {\n+    this(DEFAULT_TTL, DEFAULT_MAX_SIZE);\n+  }\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.info(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.info(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.info(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.info(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTM0MQ=="}, "originalCommit": {"oid": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzU2ODE5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNzowODozN1rOHb1LOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMjo0OFrOHe5wgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ==", "bodyText": "Since userId is part of the key, is there a reason to store it as part of the CacheEntry as well?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498944825", "createdAt": "2020-10-02T17:08:37Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MTA2Mg==", "bodyText": "yeah I guess not.  Adam and Julian have both asked questions about the cache keys as well, I guess this needs more thought", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498951062", "createdAt": "2020-10-02T17:21:32Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyOTE2MA==", "bodyText": "I think getting rid of user will be best. That means whatever content mod-authtoken puts there in the future is \"safe\" (eg group or other property that identifies what the session/token is).", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499529160", "createdAt": "2020-10-05T11:29:18Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTYzMw==", "bodyText": "Removed userId from the cache key", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165633", "createdAt": "2020-10-09T03:32:48Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzk3MDM2OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMjo1OToxMFrOHcb41Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzo0ODozMVrOHcngAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTA5Mw==", "bodyText": "Can you use consistent case of id, either always upper or always lower in method, parameter and variable?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499579093", "createdAt": "2020-10-05T12:59:10Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2OTM0NA==", "bodyText": "Good catch - typo", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499769344", "createdAt": "2020-10-05T17:48:31Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTA5Mw=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzk3ODQzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzowMToxMFrOHcb9rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMjowM1rOHe5v7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MDMzNQ==", "bodyText": "The lower x looks odd but it is required by Google Code Style.\nCan we remove \"xOkapi\" from the name?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499580335", "createdAt": "2020-10-05T13:01:10Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;\n+  }\n+\n+  public String getxOkapiPermissions() {\n+    return xokapiPermissions;\n+  }\n+\n+  public void setxOkapiPermissions(String xokapiPermissions) {\n+    this.xokapiPermissions = xokapiPermissions;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQ4NQ==", "bodyText": "renamed them.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165485", "createdAt": "2020-10-09T03:32:03Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;\n+  }\n+\n+  public String getxOkapiPermissions() {\n+    return xokapiPermissions;\n+  }\n+\n+  public void setxOkapiPermissions(String xokapiPermissions) {\n+    this.xokapiPermissions = xokapiPermissions;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MDMzNQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzk4ODkxOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzowMzo1MlrOHccEOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMTo1MFrOHe5vvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MjAwOQ==", "bodyText": "Can we be sure that there is no old userId and permission in mi? Or should we set them to null?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499582009", "createdAt": "2020-10-05T13:03:52Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;\n+    String pathPattern = re.getPathPattern();\n+\n+    CacheEntry cached = tokenCache.get(pc.getTenant(), req.method().name(),\n+        pathPattern == null ? req.path() : pathPattern, req.getHeader(XOkapiHeaders.USER_ID),\n+        req.headers().get(XOkapiHeaders.TOKEN));\n+\n+    if (cached != null) {\n+      mi.setAuthToken(cached.token);\n+      mi.setxOkapiUserId(cached.xokapiUserid);\n+      mi.setxOkapiPermissions(cached.xokapiPermissions);\n+\n+      skipAuth = true;\n+    } else {\n+      mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQzOA==", "bodyText": "done", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165438", "createdAt": "2020-10-09T03:31:50Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;\n+    String pathPattern = re.getPathPattern();\n+\n+    CacheEntry cached = tokenCache.get(pc.getTenant(), req.method().name(),\n+        pathPattern == null ? req.path() : pathPattern, req.getHeader(XOkapiHeaders.USER_ID),\n+        req.headers().get(XOkapiHeaders.TOKEN));\n+\n+    if (cached != null) {\n+      mi.setAuthToken(cached.token);\n+      mi.setxOkapiUserId(cached.xokapiUserid);\n+      mi.setxOkapiPermissions(cached.xokapiPermissions);\n+\n+      skipAuth = true;\n+    } else {\n+      mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MjAwOQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODAwMDk2OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzowNzowMVrOHccLrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMTozOVrOHe5vng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzkxOQ==", "bodyText": "This variable is not needed. We can directly return true or false.\nThere should be javadoc explaining the return value.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499583919", "createdAt": "2020-10-05T13:07:01Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQwNg==", "bodyText": "done", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165406", "createdAt": "2020-10-09T03:31:39Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzkxOQ=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODEzMTcwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzozNzozNFrOHcdcIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMToyNlrOHe5vXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA==", "bodyText": "Why do we the replaceAll?\nCan the replaceAll been applied to only those variables that needs it?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499604514", "createdAt": "2020-10-05T13:37:34Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.debug(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+\n+  private String genKey(String method, String path, String userId, String token) {\n+    return (userId + \"|\" + method + \"|\" + path + \"|\" + token).replaceAll(\"[\\n\\t\\r]\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0MDQwNA==", "bodyText": "I added this because sonarqube was complaining.  I suppose it could be applied to only the token (userId has been removed from the cache key in my latest changes)", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r501740404", "createdAt": "2020-10-08T13:55:07Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.debug(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+\n+  private String genKey(String method, String path, String userId, String token) {\n+    return (userId + \"|\" + method + \"|\" + path + \"|\" + token).replaceAll(\"[\\n\\t\\r]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTM0Mg==", "bodyText": "now only call this on token", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165342", "createdAt": "2020-10-09T03:31:26Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.debug(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+\n+  private String genKey(String method, String path, String userId, String token) {\n+    return (userId + \"|\" + method + \"|\" + path + \"|\" + token).replaceAll(\"[\\n\\t\\r]\", \"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODU0ODQxOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/TokenCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTowODoyMFrOHcheWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMDo0NlrOHe5u1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MDYxOA==", "bodyText": "The test runs faster when using 50 ms for ttl and 10 ms for polling.\natMost should use ttl + 2*poll. Using ttl + poll may fail because of a race condition, we don't want spurious failures.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499670618", "createdAt": "2020-10-05T15:08:20Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/TokenCacheTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.folio.okapi.util;\n+\n+import org.junit.Test;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class TokenCacheTest {\n+  \n+  @Test\n+  public void testMaxSize() {\n+    TokenCache cache = TokenCache.builder()\n+        .withMaxSize(2)\n+        .build();\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(1, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"bar\", \"barTok\");\n+    assertEquals(\"barTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\").token);\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(2, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"baz\", \"bazTok\");\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+    assertEquals(2, cache.size());\n+    \n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(null, cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\")); //evicted.\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+  }\n+  \n+  @Test\n+  public void testTtl() {\n+    long ttl = 500l;\n+\n+    TokenCache cache = TokenCache.builder()\n+        .withTtl(ttl)\n+        .build();\n+\n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+\n+    await().with()\n+        .pollInterval(100, TimeUnit.MILLISECONDS)\n+        .atMost(ttl + 100, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTIwNA==", "bodyText": "done", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165204", "createdAt": "2020-10-09T03:30:46Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/TokenCacheTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.folio.okapi.util;\n+\n+import org.junit.Test;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class TokenCacheTest {\n+  \n+  @Test\n+  public void testMaxSize() {\n+    TokenCache cache = TokenCache.builder()\n+        .withMaxSize(2)\n+        .build();\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(1, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"bar\", \"barTok\");\n+    assertEquals(\"barTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\").token);\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(2, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"baz\", \"bazTok\");\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+    assertEquals(2, cache.size());\n+    \n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(null, cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\")); //evicted.\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+  }\n+  \n+  @Test\n+  public void testTtl() {\n+    long ttl = 500l;\n+\n+    TokenCache cache = TokenCache.builder()\n+        .withTtl(ttl)\n+        .build();\n+\n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+\n+    await().with()\n+        .pollInterval(100, TimeUnit.MILLISECONDS)\n+        .atMost(ttl + 100, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MDYxOA=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODU1ODAwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/test/java/org/folio/okapi/util/MetricsHelperTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNToxMDoyNlrOHchkUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwMzozMDozOFrOHe5uqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MjE0Nw==", "bodyText": "This can be reduced to 200L", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499672147", "createdAt": "2020-10-05T15:10:26Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/MetricsHelperTest.java", "diffHunk": "@@ -99,6 +101,51 @@ void testRecordHttpClientResponseTime() {\n     assertEquals(1, timer.count());\n   }\n \n+  @Test\n+  void testRecordTokenCacheEvent() {\n+    String userId = \"03975dd7-8004-48cf-bd21-4d7ff2e74ca2\";\n+    String anotherUserId = \"54412e3d-a024-4914-8d54-8b84e66513a6\";\n+\n+    long ttl = 2000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTE2Mg==", "bodyText": "done", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165162", "createdAt": "2020-10-09T03:30:38Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/test/java/org/folio/okapi/util/MetricsHelperTest.java", "diffHunk": "@@ -99,6 +101,51 @@ void testRecordHttpClientResponseTime() {\n     assertEquals(1, timer.count());\n   }\n \n+  @Test\n+  void testRecordTokenCacheEvent() {\n+    String userId = \"03975dd7-8004-48cf-bd21-4d7ff2e74ca2\";\n+    String anotherUserId = \"54412e3d-a024-4914-8d54-8b84e66513a6\";\n+\n+    long ttl = 2000L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MjE0Nw=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODYxNDIwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNToyMjo1MFrOHciHAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNjo0OToyNVrOHfRhBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg==", "bodyText": "The cache will grow to its max size and will never shrink because an expired token is only evicted if there is a get request. If there is a get request for an expired token then mod-authtoken is called and a new cache entry is created.\nConsider to extend the put method to check the two oldest cache entries whether they are expired and to remove them.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499681026", "createdAt": "2020-10-05T15:22:50Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgwODM0MA==", "bodyText": "I'm not seeing any good way to get the two oldest cache entries w/o iterating the entire keySet...  Any ideas?", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r501808340", "createdAt": "2020-10-08T15:22:50Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUzMTMxNA==", "bodyText": "In LruCache replace K by String and V by CacheEntry. Then do this:\n@Override\npublic CacheEntry put(String key, CacheEntry value) {\n  CacheEntry old = super.put(key, value);\n\n  if (size() < 3) {\n    return old;\n  }\n\n  Iterator<Map.Entry<String, CacheEntry>> it = entrySet().iterator();\n  for (int i=0; i<2; i++) {\n    String k = it.next();\n    if (expired(k)) {\n      remove(k);\n    } else {\n      break;\n    }\n  }\n\n  return old;\n}", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502531314", "createdAt": "2020-10-09T16:05:09Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDg4NA==", "bodyText": "I had to look at the javadocs again, but I now see that the iteration order is least-recently accessed to most-recently accessed, exactly what we want.  Thanks @julianladisch.", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502554884", "createdAt": "2020-10-09T16:49:25Z", "author": {"login": "craigmcnally"}, "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}, "originalCommit": {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 147, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}