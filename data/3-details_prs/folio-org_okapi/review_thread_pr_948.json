{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxOTg2MjY1", "number": 948, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozNDo1OVrOEKIKPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzo1NzowMlrOEKhZCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDU0OTEwOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozNDo1OVrOGq_b9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MToyMFrOGrCi4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMjcyNA==", "bodyText": "If r can handle less data per second than ctx.response() the data in r's queue will grow until out of memory.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447732724", "createdAt": "2020-06-30T14:34:59Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzY0OQ==", "bodyText": "More theoretical than practical. But I'll change and resume when all writes are done.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783649", "createdAt": "2020-06-30T15:41:20Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMjcyNA=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDU1ODAzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozNjo1MVrOGq_hhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MToxMVrOGrCidA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDE1MA==", "bodyText": "If r can handle less data per second than clientRequest the data in r's queue will grow until out of memory.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447734150", "createdAt": "2020-06-30T14:36:51Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -798,7 +799,8 @@ private void proxyRequestResponse(Iterator<ModuleInstance> it,\n       stream.handler(data -> {\n         pc.trace(\"proxyRequestResponse request chunk '\"\n             + data.toString() + \"'\");\n-        clientRequest.write(data);\n+        stream.pause();\n+        clientRequest.write(data, comp -> stream.resume());\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzU0MA==", "bodyText": "More theoretical than practical. But I'll change and resume when all writes are done.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783540", "createdAt": "2020-06-30T15:41:11Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -798,7 +799,8 @@ private void proxyRequestResponse(Iterator<ModuleInstance> it,\n       stream.handler(data -> {\n         pc.trace(\"proxyRequestResponse request chunk '\"\n             + data.toString() + \"'\");\n-        clientRequest.write(data);\n+        stream.pause();\n+        clientRequest.write(data, comp -> stream.resume());\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDE1MA=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDU2MTY1OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozNzo0MlrOGq_j7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MTozNlrOGrCjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDc2NQ==", "bodyText": "res should be renamed to stream or readStream", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447734765", "createdAt": "2020-06-30T14:37:42Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4Mzg0MA==", "bodyText": "Shouldn't be a problem.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783840", "createdAt": "2020-06-30T15:41:36Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDc2NQ=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTA5NjQyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoyOTozMFrOGrEsMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxOTo0OToyOVrOGrMBdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw==", "bodyText": "write(Buffer, Handler) does NOT wait if the queue is full. It calls the Handler after appending Buffer to the queue regardless of the queue status.\nThe documenation\n\nhttps://vertx.io/docs/apidocs/io/vertx/core/streams/WriteStream.html\nhttps://vertx.io/docs/vertx-core/java/#streams\n\nexplains to call writeQueueFull() to get a signal about a full queue.\nYou probably need to implement\n\nhttps://vertx.io/docs/apidocs/io/vertx/core/streams/Pump.html\nhttps://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/streams/impl/PipeImpl.java\n\nwith one ReadStream and multiple WriteStreams.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447818803", "createdAt": "2020-06-30T16:29:30Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzOTY3MA==", "bodyText": "write(Buffer data, Handler<AsyncResult> handler)\nSame as write(Buffer) but with an handler called when the operation completes\nand and FWIW, Hongwei sees no memory issues.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447839670", "createdAt": "2020-06-30T17:00:10Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0ODE4OA==", "bodyText": "I can try to make a solution that does not use write with handler, but with writeQueueFull and drainHandler.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447848188", "createdAt": "2020-06-30T17:13:05Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDExOA==", "bodyText": "OK.. Now in place.. More complicated than before.. And as far as I can see results are similar, memory wise. Hongwei, you'll have to test this one.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447870118", "createdAt": "2020-06-30T17:47:43Z", "author": {"login": "adamdickmeiss"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDk4NA==", "bodyText": "Tested. Still works.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447894984", "createdAt": "2020-06-30T18:29:49Z", "author": {"login": "hjiebsco"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzODkzMg==", "bodyText": "package tmp;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.junit5.VertxExtension;\nimport io.vertx.junit5.VertxTestContext;\n\n@ExtendWith(VertxExtension.class)\nclass StreamTest {\n  String chunk = StringUtils.repeat(\"chunk \", 20000);\n\n  void writeChunk(int i, HttpClientRequest request) {\n    request.write(chunk, res -> writeChunk(i+1, request));\n    System.out.println(i + \" \" + request.writeQueueFull() + \" \");\n  }\n\n  @Test()\n  void test(Vertx vertx, VertxTestContext vtc) {\n    vertx\n    .createHttpServer()\n    .requestHandler(req -> {\n      req.pause();\n      // don't fetch the data\n    })\n    .listen(8888, server -> {\n      HttpClientRequest request = vertx\n      .createHttpClient()\n      .post(8888, \"localhost\", \"/\")\n      .setChunked(true)\n      .handler(handler -> {});\n      writeChunk(1, request);\n    });\n  }\n}\npackage tmp;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.junit5.VertxExtension;\nimport io.vertx.junit5.VertxTestContext;\n\n@ExtendWith(VertxExtension.class)\nclass StreamTest {\n  String chunk = StringUtils.repeat(\"chunk \", 20000);\n\n  void writeChunk(int i, HttpClientRequest request) {\n    request.write(chunk, res -> writeChunk(i+1, request));\n    System.out.println(i + \" \" + request.writeQueueFull() + \" \");\n  }\n\n  @Test()\n  void test(Vertx vertx, VertxTestContext vtc) {\n    vertx\n    .createHttpServer()\n    .requestHandler(req -> {\n      req.pause();\n      // don't fetch the data\n    })\n    .listen(8888, server -> {\n      HttpClientRequest request = vertx\n      .createHttpClient()\n      .post(8888, \"localhost\", \"/\")\n      .setChunked(true)\n      .handler(handler -> {});\n      writeChunk(1, request);\n    });\n  }\n}\n\nOutput:\n1 false \n2 true \n3 true \n4 true \n...", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447938932", "createdAt": "2020-06-30T19:49:29Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, "originalCommit": {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjM4MDQyOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo0Njo0MlrOGrRBFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo0ODo1NVrOGrRDsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMDc1Nw==", "bodyText": "List<HttpClientRequest> can be changed to List<? extends WriteStream<Buffer>>", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448020757", "createdAt": "2020-06-30T22:46:42Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,57 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a72c80cda6d9115c5db34687255f3ad2b5e824b3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTQyNA==", "bodyText": "Instead of handling mainWriteStream and logWriteStreams separately they should be combined into one array or list.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448021424", "createdAt": "2020-06-30T22:48:55Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,57 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMDc1Nw=="}, "originalCommit": {"oid": "a72c80cda6d9115c5db34687255f3ad2b5e824b3"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjM5OTYzOnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NToxNVrOGrRMfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1NToxNVrOGrRMfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzY3OQ==", "bodyText": "This won't work in all cases.\nA WriteStream will always call the drainHandler, even if ProxyService missed the time period where the WriteStream queue was full.\nHow about a pauseAndResume method:\nfor each WriteStream\n  if not full\n    set drainHandler to null\n  else\n    set drainHandler to pauseAndResume\n    pause readStream\n    exit this method.\nresume readStream\n\nCall this method after data has been written to the WriteStreams.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448023679", "createdAt": "2020-06-30T22:55:15Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,57 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {\n+    readStream.handler(data -> {\n+      AtomicInteger pend = new AtomicInteger();\n+      // two passes.. to avoid drainHandler being fired off too early.\n+      // first pass: see if any of writing streams are full?\n+      mainWriteStream.write(data);\n+      if (mainWriteStream.writeQueueFull()) {\n+        pend.incrementAndGet();\n+      }\n+      for (WriteStream<Buffer> w : logWriteStreams) {\n+        w.write(data);\n+        if (w.writeQueueFull()) {\n+          pend.incrementAndGet();\n+        }\n+      }\n+      if (pend.get() == 0) {\n+        return;\n+      }\n+      // second pass: at least one was full. pause and set up drainHandlers for full ones.\n+      readStream.pause();\n+      if (mainWriteStream.writeQueueFull()) {\n+        mainWriteStream.drainHandler(x -> {\n+          if (pend.decrementAndGet() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a72c80cda6d9115c5db34687255f3ad2b5e824b3"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDY4Mjk5OnYy", "diffSide": "RIGHT", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzo1NzowMlrOGrnB6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMzo1NzowMlrOGrnB6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4MTQxNw==", "bodyText": "Using an AtomicInteger won't work in all cases:\n\nThe drainHandler may be called asynchronously at a later time. It may happen that the ProxyService missed the time period where the WriteStream queue was full and only sees the drainHandler call.\nA WriteStream implementation may have a high watermark for writeQueueFull() and a low watermark for calling drainHandler. Example: https://github.com/eclipse-vertx/vert.x/blob/3.9.1/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java#L70-L71 where high watermark is 128 * 1024 and low watermark is half of this = 64 * 1024.\n\nThis algorithm for a pauseAndResume method avoids any counting and only uses the current full status:\nfor each WriteStream\n  if not full\n    set drainHandler to null\n  else\n    set drainHandler to pauseAndResume\n    pause readStream\n    exit this method.\n// this point is only reached if all WriteStreams are not full\nresume readStream\n\nCall this method after data has been written to the WriteStreams.", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448381417", "createdAt": "2020-07-01T13:57:02Z", "author": {"login": "julianladisch"}, "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,55 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {\n+    List<WriteStream<Buffer>> writeStreams = new LinkedList<>();\n+    writeStreams.add(mainWriteStream);\n+    for (WriteStream<Buffer> w : logWriteStreams) {\n+      writeStreams.add(w);\n+    }\n+    pumpOneToMany(readStream, writeStreams);\n+    readStream.exceptionHandler(e\n+        -> pc.warn(\"streamHandle: content exception \", e));\n+    readStream.resume();\n+  }\n+\n+  private static void pumpOneToMany(ReadStream<Buffer> readStream,\n+                                    List<WriteStream<Buffer>> writeStreams) {\n+\n+    readStream.handler(data -> {\n+      AtomicInteger pend = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08e0b602eae0d6f827bddf0ff201d735c4096bf1"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 108, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}