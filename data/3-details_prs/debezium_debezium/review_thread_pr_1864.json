{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MDc5NDcy", "number": 1864, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMjo0MTo1MFrOEqTMVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzoxMzowMFrOEqT8UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzkwMTAxOnYy", "diffSide": "LEFT", "path": "documentation/modules/ROOT/partials/assemblies/mysql-connector/assembly-overview-of-how-the-mysql-connector-works.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMjo0MTo1MFrOHcbOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjowMjoyOVrOHcjynw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2ODIxMw==", "bodyText": "We need this toc::[] line to be ported to the mysql.adoc file so that the right-hand navigation bar is produced for the upstream documentation.  See the other connector docs for how/where this is placed for rendering.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499568213", "createdAt": "2020-10-05T12:41:50Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/partials/assemblies/mysql-connector/assembly-overview-of-how-the-mysql-connector-works.adoc", "diffHunk": "@@ -1,25 +0,0 @@\n-\n-// Metadata created by nebel\n-//\n-// UserStory: As an Evaluator or Developer, I want to gain a general understanding of how the CDC's MySQL connector functions so that I can better use the application.\n-:context: debezium\n-[id=\"overview-of-how-the-mysql-connector-works\"]\n-= Overview of how the MySQL connector works\n-\n-toc::[]", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODU3NQ==", "bodyText": "This is back in place with the next commit.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499708575", "createdAt": "2020-10-05T16:02:29Z", "author": {"login": "TovaCohen"}, "path": "documentation/modules/ROOT/partials/assemblies/mysql-connector/assembly-overview-of-how-the-mysql-connector-works.adoc", "diffHunk": "@@ -1,25 +0,0 @@\n-\n-// Metadata created by nebel\n-//\n-// UserStory: As an Evaluator or Developer, I want to gain a general understanding of how the CDC's MySQL connector functions so that I can better use the application.\n-:context: debezium\n-[id=\"overview-of-how-the-mysql-connector-works\"]\n-= Overview of how the MySQL connector works\n-\n-toc::[]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU2ODIxMw=="}, "originalCommit": null, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzkxMzE3OnYy", "diffSide": "RIGHT", "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMjo0NTowN1rOHcbVzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjoxMjozN1rOHckLQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3MDEyNw==", "bodyText": "The latest sentence in this paragraph seems out of place at least for the upstream docs because the docs then jump right into discussing schema changes.  I'm wondering if the topology topic would make the most sense to be listed first or if the xref links to jump to various sections make sense to be rendered upstream?", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499570127", "createdAt": "2020-10-05T12:45:07Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNDg4Mg==", "bodyText": "I moved that last sentence in the introductory paragraph, about topologies, to be the first sentence.\nI moved the toplogies section to be the first subsection in How the connector works.\nI don't think the list of xref links is needed in the text panel because they will appear in the navigation panel on the right upstream.  Downstream, you see the links for the subsections only if you clicked the main section that contains them, and that's why I add them for downstream rendering. In other words, downstream, if you are scrolling content, the navigation panel on the left does not necessarily show you what you are looking at, and it is very long because it is for the whole book. Let me know if you want something different. Otherwise, this update will be in the next commit.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499714882", "createdAt": "2020-10-05T16:12:37Z", "author": {"login": "TovaCohen"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3MDEyNw=="}, "originalCommit": null, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzk4NjA1OnYy", "diffSide": "RIGHT", "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzowMzoxMFrOHccCfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzozNDowNFrOHdGslg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTU2NA==", "bodyText": "I'm of the opinion that now that we've added Tombstone and PK updates options here, should we consider formatting these entries despite how the headings are may formatted?  To me this goes back to having camel-case elements and upper-case elements when we discussed HSTORE and TIMESTAMP in the PG docs.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499581564", "createdAt": "2020-10-05T13:03:10Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxODc4MQ==", "bodyText": "Sorry. I don't understand what you want to see in the doc.\nThe way it is now, the user will see these links:\ncreate events\nupdate events\nPrimary key updates\ndelete events\nTombstone events\nHow should this change?", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499718781", "createdAt": "2020-10-05T16:18:39Z", "author": {"login": "TovaCohen"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTU2NA=="}, "originalCommit": null, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3NTYzMA==", "bodyText": "I wonder if it would look more uniform if the text here was\nCreate events\nUpdate events\nPrimary key updates\nDelete events\nTombstone events", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499875630", "createdAt": "2020-10-05T21:12:52Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTU2NA=="}, "originalCommit": null, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NjU1OA==", "bodyText": "Agreed, the italic setting looks a bit odd when looking at it in the navigation menu.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r500066558", "createdAt": "2020-10-06T07:38:33Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTU2NA=="}, "originalCommit": null, "originalPosition": 548}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4MDQ3MA==", "bodyText": "I feel strongly that the headings need to immediately convey, as much as possible, that \"create\", \"delete\", and \"update\" are being used as adjectives and not as imperative verbs. While yes, the headings you suggest, Chris, are uniform, they are less helpful to a user who is trying to learn.\nWe already made the update I am suggesting in the doc for Db2 and for PostgreSQL. Whatever we decide here, will need to be applied to the doc for those connectors, and to the doc for the other connectors as we update their doc. You can see how it looks in the navigation panel now:\nhttps://debezium.io/documentation/reference/1.2/connectors/postgresql.html#postgresql-events\nhttps://debezium.io/documentation/reference/1.2/connectors/db2.html#db2-events\nPlease reconsider leaving it the way I did it.\nAlternatively, I would be okay (though not as happy) with:\nCREATE events\nUPDATE events\nPrimary key updates\nDELETE events\nTombstone events", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r500280470", "createdAt": "2020-10-06T13:34:04Z", "author": {"login": "TovaCohen"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MTU2NA=="}, "originalCommit": null, "originalPosition": 548}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODAyMzg1OnYy", "diffSide": "RIGHT", "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzoxMzowMFrOHccZow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMToxMzo0OVrOHcuAsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NzQ5MQ==", "bodyText": "I am curious if rendering of this type of layout needs some CSS changes upstream.  What I actually see upstream when this gets rendered is the following:\nAdvanced MySQL connector configuration properties\nThe following table describes ...\n\nYou'll notice there is no spacing between the heading, no underline which essentially makes the heading flow into the text so you might actually miss notion that the section has changed to something else.  I've added DBZ-2631 as a follow-up for this.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499587491", "createdAt": "2020-10-05T13:13:00Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>\n+* <<mysql-update-events,_update_ events>>\n+* <<mysql-primary-key-updates,Primary key updates>>\n+* <<mysql-delete-events,_delete_ events>>\n+* <<mysql-tombstone-events,Tombstone events>>\n+\n+// Type: continue\n+[id=\"mysql-create-events\"]\n+=== _create_ events\n+\n+The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { // <1>\n+    \"type\": \"struct\",\n+    \"fields\": [\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", // <2>\n+        \"field\": \"before\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", \n+        \"field\": \"after\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"connector\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ],\n+        \"optional\": false,\n+        \"name\": \"io.debezium.connector.mysql.Source\", // <3>\n+        \"field\": \"source\"\n+      },\n+      {\n+        \"type\": \"string\",\n+        \"optional\": false,\n+        \"field\": \"op\"\n+      },\n+      {\n+        \"type\": \"int64\",\n+        \"optional\": true,\n+        \"field\": \"ts_ms\"\n+      }\n+    ],\n+    \"optional\": false,\n+    \"name\": \"mysql-server-1.inventory.customers.Envelope\" // <4>\n+  },\n+  \"payload\": { // <5>\n+    \"op\": \"c\", // <6>\n+    \"ts_ms\": 1465491411815, // <7>\n+    \"before\": null, // <8>\n+    \"after\": { // <9>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <10>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 0,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')\"\n+    }\n+  }\n+}\n+----\n+\n+.Descriptions of _create_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table. \n+\n+|2\n+|`name`\n+a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +\n+ +\n+`mysql-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +\n+ +\n+Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database. This means that when using the {link-prefix}:{link-avro-serialization}[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.\n+\n+|3\n+|`name`\n+|`io.debezium.connector.mysql.Source` is the schema for the payload's `source` field. This schema is specific to the MySQL connector. The connector uses it for all events that it generates. \n+\n+|4\n+|`name`\n+|`mysql-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `mysql-server-1` is the connector name, `inventory` is the database, and `customers` is the table.\n+\n+|5\n+|`payload`\n+|The value's actual data. This is the information that the change event is providing. +\n+ +\n+It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.\n+However, by using the {link-prefix}:{link-avro-serialization}[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.\n+\n+|6\n+|`op`\n+a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are: \n+\n+* `c` = create\n+* `u` = update\n+* `d` = delete\n+* `r` = read (applies to only snapshots)\n+\n+|7\n+|`ts_ms`\n+a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|8\n+|`before`\n+| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content. \n+\n+|9\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.\n+\n+|10\n+|`source`\n+a| Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the new row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|===\n+\n+// Type: continue\n+[id=\"mysql-update-events\"]\n+=== _update_ events\n+\n+The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": { // <2>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 484,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"UPDATE customers SET first_name='Anne Marie' WHERE id=1004\"\n+    },\n+    \"op\": \"u\", // <4>\n+    \"ts_ms\": 1465581029523 \n+  }\n+}\n+----\n+\n+.Descriptions of _update_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`\n+\n+|2\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`. \n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.\n+\n+|===\n+\n+[NOTE]\n+====\n+Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a {link-prefix}:{link-mysql-connector}#mysql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section. \n+====\n+\n+// Type: continue\n+[id=\"mysql-primary-key-updates\"]\n+=== Primary key updates\n+\n+An `UPDATE` operation that changes a row's primary key field(s) is known\n+as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change: \n+\n+* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.\n+\n+* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.\n+\n+// Type: continue\n+[id=\"mysql-delete-events\"]\n+=== _delete_ events\n+\n+The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:  \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": null, // <2>\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 805,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"DELETE FROM customers WHERE id=1004\"\n+    },\n+    \"op\": \"d\", // <4>\n+    \"ts_ms\": 1465581902461 // <5>\n+  }\n+}\n+----\n+\n+.Descriptions of _delete_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.\n+\n+|2\n+|`after`\n+| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.\n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.\n+\n+|5\n+|`ts_ms`\n+a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|===\n+\n+A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.\n+\n+MySQL connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.\n+\n+// Type: continue\n+[id=\"mysql-tombstone-events\"]\n+=== Tombstone events\n+When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}\u2019s MySQL connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.\n+\n+// Type: reference\n+// ModuleID: how-debezium-mysql-connectors-map-data-types\n+// Title: How {prodname} MySQL connectors map data types\n+[[mysql-data-types]]\n+== Data type mappings\n+\n+The {prodname} MySQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. The MySQL data type of that column dictates how {prodname} represents the value in the event.\n+\n+Columns that store strings are defined in MySQL with a character set and collation. The MySQL connector uses the column's character set when reading the binary representation of the column values in the binlog events. \n+\n+The connector can map MySQL data types to both _literal_ and _semantic_ types.\n+\n+* *Literal type*: how the value is represented using Kafka Connect schema types\n+* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name)\n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:mysql-basic-types[]\n+* xref:mysql-temporal-types[]\n+* xref:mysql-decimal-types[]\n+* xref:mysql-boolean-values[]\n+* xref:mysql-spatial-types[]\n+\n+endif::product[]\n+\n+[id=\"mysql-basic-types\"]\n+=== Basic types\n+\n+The following table shows how the connector maps basic MySQL data types.\n+\n+.Descriptions of basic type mappings\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`BOOLEAN, BOOL`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(1)`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(>1)`\n+|`BYTES`\n+a|`io.debezium.data.Bits` +\n+The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +\n+`numBytes = n/8 + (n%8== 0 ? 0 : 1)`\n+\n+|`TINYINT`\n+|`INT16`\n+a|_n/a_\n+\n+|`SMALLINT[(M)]`\n+|`INT16`\n+a|_n/a_\n+\n+|`MEDIUMINT[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`INT, INTEGER[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`BIGINT[(M)]`\n+|`INT64`\n+a|_n/a_\n+\n+|`REAL[(M,D)]`\n+|`FLOAT32`\n+a|_n/a_\n+\n+|`FLOAT[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DOUBLE[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`CHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`VARCHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`BINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`VARBINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`BLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`MEDIUMBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`MEDIUMTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`LONGBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`LONGTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`JSON`\n+|`STRING`\n+a|`io.debezium.data.Json` +\n+Contains the string representation of a `JSON` document, array, or scalar.\n+\n+|`ENUM`\n+|`STRING`\n+a|`io.debezium.data.Enum` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`SET`\n+|`STRING`\n+a|`io.debezium.data.EnumSet` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`YEAR[(2\\|4)]`\n+|`INT32`\n+|`io.debezium.time.Year`\n+\n+|`TIMESTAMP[(M)]`\n+|`STRING`\n+a|`io.debezium.time.ZonedTimestamp` +\n+In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision. MySQL allows `M` to be in the range of `0-6`.\n+\n+|===\n+\n+[id=\"mysql-temporal-types\"]\n+=== Temporal types\n+\n+Excluding the `TIMESTAMP` data type, MySQL temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema. \n+\n+MySQL allows zero-values for `DATE, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values. The MySQL connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.\n+\n+.Temporal values without time zones\n+The `DATETIME` type represents a local date and time such as \"2018-01-13 09:48:27\". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column\u2019s precision by using UTC. The `TIMESTAMP` type represents a timestamp without time zone information. It is converted by MySQL from the server (or session\u2019s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:\n+\n+* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.\n+* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.\n+\n+Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session\u2019s) current time zone. The time zone will be queried from the server by default. If this fails, it must be specified explicitly by the database `serverTimezone` MySQL configuration option. For example, if the database\u2019s time zone (either globally or configured for the connector by means of the `serverTimezone` option) is \"America/Los_Angeles\", the TIMESTAMP value \"2018-06-20 06:37:03\" is represented by a `ZonedTimestamp` with the value \"2018-06-20T13:37:03Z\".\n+\n+The time zone of the JVM running Kafka Connect and Debezium does not affect these conversions.\n+\n+More details about properties related to termporal values are in the documentation for {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+time.precision.mode=adaptive_time_microseconds(default)::\n+The MySQL connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.\n++\n+.Mappings when `time.precision.mode=adaptive_time_microseconds`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`io.debezium.time.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`io.debezium.time.MicroTime` +\n+Represents the time value in microseconds and does not include time zone information. MySQL allows `M` to be in the range of `0-6`.\n+\n+|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`\n+|`INT64`\n+a|`io.debezium.time.Timestamp` +\n+Represents the number of milliseconds past the epoch and does not include time zone information.\n+\n+|`DATETIME(4), DATETIME(5), DATETIME(6)`\n+|`INT64`\n+a|`io.debezium.time.MicroTimestamp` +\n+Represents the number of microseconds past the epoch and does not include time zone information.\n+\n+|===\n+\n+time.precision.mode=connect::\n+The MySQL connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.\n++\n+.Mappings when `time.precision.mode=connect`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`org.apache.kafka.connect.data.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Time` +\n+Represents the time value in microseconds since midnight and does not include time zone information.\n+\n+|`DATETIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Timestamp` +\n+Represents the number of milliseconds since the epoch, and does not include time zone information.\n+\n+|===\n+\n+[id=\"mysql-decimal-types\"]\n+=== Decimal types\n+\n+{prodname} connectors handle decimals according to the setting of the {link-prefix}:{link-mysql-connector}#mysql-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property]. \n+\n+decimal.handling.mode=precise::\n++\n+.Mappings when `decimal.handing.mode=precise`\n+[cols=\"30%a,15%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|`DECIMAL[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|===\n+\n+decimal.handling.mode=double::\n++\n+.Mappings when `decimal.handing.mode=double`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|===\n+\n+decimal.handling.mode=string::\n++\n+.Mappings when `decimal.handing.mode=string`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|===\n+\n+[id=\"mysql-boolean-values\"]\n+=== Boolean values\n+\n+MySQL handles the `BOOLEAN` value internally in a specific way.\n+The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.\n+When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.\n+During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.\n+\n+ifdef::community[]\n+The operator can configure the out-of-the-box {link-prefix}:{link-custom-converters}[`TinyIntOneToBooleanConverter` custom converter] that would either map all `TINYINT(1)` columns to `BOOLEAN` or if the `selector` parameter is set then a subset of columns could be enumerated using comma-separated regular expressions.\n+endif::community[]\n+\n+Following is an example configuration:\n+\n+----\n+converters=boolean\n+boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter\n+boolean.selector=db1.table1.*, db1.table2.column1\n+----\n+\n+[id=\"mysql-spatial-types\"]\n+=== Spatial types\n+\n+Currently, the {prodname} MySQL connector supports the following spatial data types.\n+\n+.Description of spatial type mappings\n+[cols=\"35%a,15%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`GEOMETRY, +\n+LINESTRING, +\n+POLYGON, +\n+MULTIPOINT, +\n+MULTILINESTRING, +\n+MULTIPOLYGON, +\n+GEOMETRYCOLLECTION`\n+|`STRUCT`\n+a|`io.debezium.data.geometry.Geometry` +\n+Contains a structure with two fields:\n+\n+* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure\n+* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.\n+\n+|===\n+\n+// Type: assembly\n+// ModuleID: setting-up-mysql-to-run-a-debezium-connector\n+// Title: Setting up MySQL to run a {prodname} connector\n+[[setting-up-mysql]]\n+== Set up\n+\n+Some MySQL setup tasks are required before you can install and run a {prodname} connector. \n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:creating-a-mysql-user-for-a-debezium-connector[]\n+* xref:enabling-the-mysql-binlog-for-debezium[]\n+* xref:enabling-mysql-gtids-for-debezium[]\n+* xref:configuring-mysql-session-timeouts-for-debezium[]\n+* xref:enabling-query-log-events-for-debezium-mysql-connectors[]\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: creating-a-mysql-user-for-a-debezium-connector\n+// Title: Creating a MySQL user for a {prodname} connector\n+[[mysql-creating-user]]\n+=== Creating a user \n+\n+A {prodname} MySQL connector requires a MySQL user account. This MySQL user must have appropriate permissions on all databases for which the {prodname} MySQL connector captures changes.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+\n+.Procedure\n+\n+. Create the MySQL user:\n++\n+[source,SQL]\n+----\n+mysql> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';\n+----\n+\n+. Grant the required permissions to the user:\n++\n+[source,SQL]\n+----\n+mysql> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n+----\n++\n+The table below describes the permissions. \n++\n+IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK_TABLES` permissions to the user that you create. See {link-prefix}:{link-mysql-connector}#mysql-snapshots[snapshots] for more details.\n+\n+. Finalize the user's permissions:\n++\n+[source,SQL]\n+----\n+mysql> FLUSH PRIVILEGES;\n+----\n+\n+[[permissions-explained-mysql-connector]]\n+.Descriptions of user permissions\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Keyword |Description\n+\n+|`SELECT`\n+|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.\n+\n+|`RELOAD`\n+|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.\n+\n+|`SHOW DATABASES`\n+|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.\n+\n+|`REPLICATION SLAVE`\n+|Enables the connector to connect to and read the MySQL server binlog.\n+\n+|`REPLICATION CLIENT`\n+a|Enables the connector the use of the following statements:\n+\n+* `SHOW MASTER STATUS`\n+* `SHOW SLAVE STATUS`\n+* `SHOW BINARY LOGS`\n+\n+The connector always requires this.\n+\n+|`ON`\n+|Identifies the database to which the permissions apply.\n+\n+|`TO 'user'`\n+|Specifies the user to grant the permissions to.\n+\n+|`IDENTIFIED BY 'password'`\n+|Specifies the user's MySQL password.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-the-mysql-binlog-for-debezium\n+// Title: Enabling the MySQL binlog for {prodname}\n+[[enable-mysql-binlog]]\n+=== Enabling the binlog \n+\n+You must enable binary logging for MySQL replication. The binary logs record transaction updates for replication tools to propagate changes. \n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Appropriate MySQL user privileges.\n+\n+.Procedure\n+\n+. Check whether the `log-bin` option is already on:\n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+. If it is `OFF`, configure your MySQL server configuration file with the following properties, which are described in the table below:\n++\n+[source,properties]\n+----\n+server-id         = 223344 \n+log_bin           = mysql-bin \n+binlog_format     = ROW \n+binlog_row_image  = FULL \n+expire_logs_days  = 10 \n+----\n+\n+. Confirm your changes by checking the binlog status once more: \n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+[[binlog-configuration-properties-mysql-connector]]\n+.Descriptions of MySQL binlog configuration properties\n+[cols=\"1,4\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Description\n+\n+|`server-id`\n+|The value for the `server-id` must be unique for each server and replication client in the MySQL cluster. During MySQL connector set up, {prodname} assigns a unique server ID to the connector.\n+\n+|`log_bin`\n+|The value of `log_bin` is the base name of the sequence of binlog files.\n+\n+|`binlog_format`\n+|The `binlog-format` must be set to `ROW` or `row`.\n+\n+|`binlog_row_image`\n+|The `binlog_row_image` must be set to `FULL` or `full`.\n+\n+|`expire_logs_days`\n+|This is the number of days for automatic binlog file removal. The default is `0`, which means no automatic removal. Set the value to match the needs of your environment. See {link-prefix}:{link-mysql-connector}#mysql-purges-binlog-files-used-by-debezium[MySQL purges binlog files].\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-mysql-gtids-for-debezium\n+// Title: Enabling MySQL Global Transaction Identifiers for {prodname}\n+[[enable-mysql-gtids]]\n+=== Enabling GTIDs\n+\n+Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.\n+\n+GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Enable `gtid_mode`:\n++\n+[source,SQL]\n+----\n+mysql> gtid_mode=ON\n+----\n+\n+. Enable `enforce_gtid_consistency`:\n++\n+[source,SQL]\n+----\n+mysql> enforce_gtid_consistency=ON\n+----\n+\n+. Confirm the changes:\n++\n+[source,SQL]\n+----\n+mysql> show global variables like '%GTID%';\n+----\n+\n+.Result\n+[source,SQL]\n+----\n++--------------------------+-------+\n+| Variable_name            | Value |\n++--------------------------+-------+\n+| enforce_gtid_consistency | ON    |\n+| gtid_mode                | ON    |\n++--------------------------+-------+\n+----\n+\n+.Descriptions of GTID options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`gtid_mode`\n+a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|`enforce_gtid_consistency`\n+a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|===\n+\n+\n+// Type: procedure\n+// ModuleID: configuring-mysql-session-timeouts-for-debezium\n+// Title: Configuring MySQL session timesouts for {prodname}\n+[[mysql-session-timeouts]]\n+=== Configuring session timeouts\n+\n+When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read. You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your MySQL configuration file.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Configure `interactive_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> interactive_timeout=<duration-in-seconds>\n+----\n+\n+. Configure `wait_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> wait_timeout=<duration-in-seconds>\n+----\n+\n+.Descriptions of MySQL session timeout options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`interactive_timeout`\n+a|The number of seconds the server waits for activity on an interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL's documentation] for more details.\n+\n+|`wait_timeout`\n+a|The number of seconds the server waits for activity on a non-interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_wait_timeout[MySQL's documentation] for more details.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors\n+// Title: Enabling query log events for {prodname} MySQL connectors\n+[[enable-query-log-events]]\n+=== Enabling query log events \n+\n+You might want to see the original `SQL` statement for each binlog event. Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.\n+\n+This option is available in MySQL 5.6 and later.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowlede of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+* Enable `binlog_rows_query_log_events`:\n++\n+[source,SQL]\n+----\n+mysql> binlog_rows_query_log_events=ON\n+----\n++\n+`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.\n++\n+** `ON` = enabled\n+** `OFF` = disabled\n+\n+// Type: assembly\n+// ModuleID: deploying-debezium-mysql-connectors\n+// Title: Deploying {prodname} MySQL connectors\n+[[mysql-deploying-a-connector]]\n+== Deployment\n+\n+To deploy a {prodname} MySQL connector, install the {prodname} MySQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:installing-debezium-mysql-connectors[]\n+* xref:debezium-mysql-connector-configuration-example[]\n+* xref:adding-debezium-mysql-connector-configuration-to-kafka-connect[]\n+* xref:descriptions-of-debezium-mysql-connector-configuration-properties[]\n+endif::product[]\n+\n+// Type: procedure\n+// Title: Installing {prodname} MySQL connectors\n+[id=\"installing-debezium-mysql-connectors\"]\n+=== Installing\n+\n+To install a {prodname} MySQL connector, download the connector archive, extract it to your Kafka Connect environment, and ensure that the plug-ins parent directory is specified in your Kafka Connect environment.\n+\n+.Prerequisites\n+\n+* link:https://zookeeper.apache.org/[Zookeeper], link:http://kafka.apache.org/[Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.\n+* MySQL Server is installed and set up for {prodname}.\n+\n+.Procedure\n+\n+ifdef::product[]\n+. Download the link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[{prodname} MySQL connector].\n+endif::product[]\n+ifdef::community[]\n+ifeval::['{page-version}' == 'master']\n+. Download the {prodname} link:{link-mysql-plugin-snapshot}[MySQL connector plug-in].\n+endif::[]\n+ifeval::['{page-version}' != 'master']\n+. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].\n+endif::[]\n+endif::community[]\n+. Extract the files into your Kafka Connect environment.\n+. Add the plug-ins parent directory to your Kafka Connect `plugin.path`:\n++\n+[source]\n+----\n+plugin.path=/kafka/connect\n+----\n++\n+The above example assumes that you extracted the {prodname} MySQL connector into the `/kafka/connect/debezium-connector-mysql` path.\n+\n+. Restart your Kafka Connect process. This ensures that the new JAR files are picked up.\n+\n+// Type: concept\n+// ModuleID: debezium-mysql-connector-configuration-example\n+// Title: {prodname} MySQL connector configuration example\n+[[mysql-example-configuration]]\n+=== Connector configuration example\n+\n+ifdef::community[]\n+Typically, you configure a {prodname} MySQL connector in a `.json` file that sets configuration properties for the connector. Following is an example configuration for a MySQL connector that connects to a MySQL server on port 3306 at 192.168.99.100, whose logical name is `fullfillment`.\n+\n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,json]\n+----\n+{\n+  \"name\": \"inventory-connector\", // <1>\n+  \"config\": {\n+    \"connector.class\": \"io.debezium.connector.mysql.MySqlConnector\", // <2>\n+    \"database.hostname\": \"192.168.99.100\", // <3>\n+    \"database.port\": \"3306\", // <4>\n+    \"database.user\": \"debezium-user\", // <5>\n+    \"database.password\": \"debezium-user-pw\", // <6>\n+    \"database.server.id\": \"184054\", <7>\n+    \"database.server.name\": \"fullfillment\", // <8>\n+    \"database.whitelist\": \"inventory\", // <9>\n+    \"database.history.kafka.bootstrap.servers\": \"kafka:9092\", // <10>\n+    \"database.history.kafka.topic\": \"dbhistory.fullfillment\", // <11>\n+    \"include.schema.changes\": \"true\" // <12>\n+  }\n+}\n+----\n+<1> Connector's name when registered with the Kafka Connect service.\n+<2> Connector's class name.\n+<3> MySQL server address.\n+<4> MySQL server port number.\n+<5> MySQL user with the appropriate privileges.\n+<6> MySQL user's password.\n+<7> Unique ID of the connector.\n+<8> Logical name of the MySQL server or cluster.\n+<9> List of databases hosted by the specified server.\n+<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database history topic.\n+<11> Name of the database history topic. This topic is for internal use only and should not be used by consumers. \n+<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers. \n+endif::community[]\n+\n+ifdef::product[]\n+\n+Typically, you configure a {prodname} MySQL connector in a `.yaml` file that sets connector configuration properties. Following is an example of the configuration for a MySQL connector that connects to a MySQL server on port 3306 and captures changes to the `inventory` database. \n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,yaml,options=\"nowrap\"]\n+----\n+  apiVersion: kafka.strimzi.io/v1beta1\n+  kind: KafkaConnector\n+  metadata:\n+    name: inventory-connector  // <1>\n+    labels:\n+      strimzi.io/cluster: my-connect-cluster\n+  spec:\n+    class: io.debezium.connector.mysql.MySqlConnector\n+    tasksMax: 1  // <2>\n+    config:  // <3>\n+      database.hostname: mysql  // <4>\n+      database.port: 3306\n+      database.user: debezium\n+      database.password: dbz\n+      database.server.id: 184054  // <5>\n+      database.server.name: dbserver1  // <5>\n+      database.whitelist: inventory  // <6>\n+      database.history.kafka.bootstrap.servers: my-cluster-kafka-bootstrap:9092  // <7>\n+      database.history.kafka.topic: schema-changes.inventory  // <7>\n+----\n+\n+.Descriptions of connector configuration settings\n+[cols=\"1,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Item |Description\n+\n+|1\n+|The name of the connector.\n+\n+|2\n+|Only one task should operate at any one time.\n+Because the MySQL connector reads the MySQL server\u2019s `binlog`,\n+using a single connector task ensures proper order and event handling.\n+The Kafka Connect service uses connectors to start one or more tasks that do the work,\n+and it automatically distributes the running tasks across the cluster of Kafka Connect services.\n+If any of the services stop or crash,\n+those tasks will be redistributed to running services.\n+\n+|3\n+|The connector\u2019s configuration.\n+\n+|4\n+|The database host, which is the name of the container running the MySQL server (`mysql`).\n+\n+|5\n+|A unique server ID and name.\n+The server name is the logical identifier for the MySQL server or cluster of servers.\n+This name is used as the prefix for all Kafka topics.\n+\n+|6\n+|Changes in only the `inventory` database are captured.\n+\n+|7\n+|The connector stores the history of the database schemas in Kafka using this broker (the same broker to which you are sending events) and topic name.\n+Upon restart, the connector recovers the schemas of the database that existed at the point in time in the binlog when the connector should begin reading.\n+\n+|===\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: adding-debezium-mysql-connector-configuration-to-kafka-connect\n+// Title: Adding {prodname} MySQL connector configuration to Kafka Connect\n+[[mysql-adding-configuration]]\n+=== Adding connector configuration \n+ifdef::community[]\n+To start running a MySQL connector, configure a connector and add the configuration to your Kafka Connect cluster. \n+\n+.Prerequisites\n+\n+* {link-prefix}:{link-mysql-connector}#setting-up-mysql[MySQL server] is \n+set up for a {prodname} connector.\n+\n+* {prodname} MySQL connector is installed. \n+\n+.Procedure\n+\n+. Create a configuration for the MySQL connector.\n+\n+. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster. \n+\n+endif::community[]\n+\n+ifdef::product[]\n+You can use a provided {prodname} container to deploy a {prodname} MySQL connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment. \n+\n+.Prerequisites\n+\n+* Podman or Docker is installed.\n+* You have sufficient rights to create and manage containers.\n+* You downloaded the {prodname} MySQL connector archive. \n+\n+.Procedure\n+\n+. Extract the {prodname} MySQL connector archive to create a directory structure for the connector plug-in, for example: \n++\n+[subs=\"+macros\"]\n+----\n+pass:quotes[*tree ./my-plugins/*]\n+./my-plugins/\n+\u251c\u2500\u2500 debezium-connector-mysql\n+\u2502   \u251c\u2500\u2500 ...\n+----\n+\n+. Create and publish a custom image for running your {prodname} connector:\n+\n+.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:\n++\n+[subs=\"+macros,+attributes\"]\n+----\n+FROM {DockerKafkaConnect}\n+USER root:root\n+pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]\n+USER 1001\n+----\n++\n+Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.\n+\n+.. Build the container image. For example, if you saved the `Dockerfile` that you created in the previous step as `debezium-container-for-mysql`, and if `Dockerfile` is in the current directory, then you would run the following command:\n++\n+`podman build -t debezium-container-for-mysql:latest .`\n+\n+.. Push your custom image to your container registry, for example:\n++\n+`podman push debezium-container-for-mysql:latest`\n+\n+.. Point to the new container image. Do one of the following:\n++\n+* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:\n++\n+[source,yaml,subs=\"+attributes\"]\n+----\n+apiVersion: {KafkaConnectApiVersion}\n+kind: KafkaConnector\n+metadata:\n+  name: my-connect-cluster\n+spec:\n+  #...\n+  image: debezium-container-for-mysql\n+----\n++\n+* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.\n+\n+. Create a `KafkaConnector` custom resource that defines your {prodname} MySQL connector instance. See {LinkDebeziumUserGuide}#mysql-example-configuration[the connector configuration example].\n+\n+. Apply the connector instance, for example: \n++\n+`oc apply -f inventory-connector.yaml`\n++\n+This registers `inventory-connector` and the connector starts to run against the `inventory` database.\n+\n+. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.\n+\n+.. Display the Kafka Connect log output:\n++\n+[source,shell,options=\"nowrap\"]\n+----\n+oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)\n+----\n+\n+.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines: \n++\n+[source,shell,options=\"nowrap\"]\n+----\n+... INFO Starting snapshot for ...\n+... INFO Snapshot is using user 'debezium' ... \n+----\n+\n+endif::product[]\n+\n+.Results\n+\n+When the connector starts, it {link-prefix}:{link-mysql-connector}#mysql-snapshots[performs a consistent snapshot] of the MySQL databases that the connector is configured for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics. \n+\n+// Type: reference\n+// ModuleID: descriptions-of-debezium-mysql-connector-configuration-properties\n+// Title: Description of {prodname} MySQL connector configuration properties\n+[[mysql-connector-properties]]\n+=== Connector properties\n+\n+The {prodname} MySQL connector has numerous configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:\n+\n+* xref:mysql-required-connector-configuration-properties[Required connector configuration properties]\n+* xref:mysql-advanced-connector-configuration-properties[Advanced connector configuration properties]\n+* xref:mysql-pass-through-configuration-properties[Pass-through configuration properties]\n+\n+[id=\"mysql-required-connector-configuration-properties\"]\n+The following configuration properties are _required_ unless a default value is available.\n+\n+.Required MySQL connector configuration properties\n+[cols=\"33%a,17%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Default |Description\n+\n+|[[mysql-property-name]]<<mysql-property-name, `name`>>\n+|\n+|Unique name for the connector. Attempting to register again with the same name fails. This property is required by all Kafka Connect connectors.\n+\n+|[[mysql-property-connector-class]]<<mysql-property-connector-class, `connector.class`>>\n+|\n+|The name of the Java class for the connector. Always specify  `io.debezium{zwsp}.connector.mysql.MySqlConnector` for the MySQL connector.\n+\n+|[[mysql-property-tasks-max]]<<mysql-property-tasks-max, `tasks.max`>>\n+|`1`\n+|The maximum number of tasks that should be created for this connector. The MySQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.\n+\n+|[[mysql-property-database-hostname]]<<mysql-property-database-hostname, `database.hostname`>>\n+|\n+|IP address or host name of the MySQL database server.\n+\n+|[[mysql-property-database-port]]<<mysql-property-database-port, `database.port`>>\n+|`3306`\n+|Integer port number of the MySQL database server.\n+\n+|[[mysql-property-database-user]]<<mysql-property-database-user, `database.user`>>\n+|\n+|Name of the MySQL database to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-password]]<<mysql-property-database-password, `database.password`>>\n+|\n+|Password to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-server-name]]<<mysql-property-database-server-name, `database.server.name`>>\n+|\n+|Logical name that identifies and provides a namespace for the particular MySQL database server/cluster in which {prodname} is capturing changes. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector.\n+Only alphanumeric characters and underscores are allowed in this name.\n+\n+|[[mysql-property-database-server-id]]<<mysql-property-database-server-id, `database.server.id`>>\n+|_random_\n+|A numeric ID of this database client, which must be unique across all currently-running database processes in the MySQL cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog. By default, a random number between 5400 and 6400 is generated, though the recommendation is to explicitly set a value.  \n+\n+|[[mysql-property-database-history-kafka-topic]]<<mysql-property-database-history-kafka-topic, `database.history.kafka{zwsp}.topic`>>\n+|\n+|The full name of the Kafka topic where the connector stores the database schema history.\n+\n+|[[mysql-property-database-history-kafka-bootstrap-servers]]<<mysql-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap{zwsp}.servers`>>\n+|\n+|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.\n+\n+|[[mysql-property-database-whitelist]]\n+[[mysql-property-database-include-list]]<<mysql-property-database-include-list, `database.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of the databases for which to capture changes. The connector does not capture changes in any database whose name is not in `database.include.list`. By default, the connector captures changes in all databases. \n+Do not also set the `database.exclude.list` connector confiuration property.\n+\n+|[[mysql-property-database-blacklist]]\n+[[mysql-property-database-exclude-list]]<<mysql-property-database-exclude-list, `database.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of databases for which you do not want to capture changes. The connector captures changes in any database whose name is not in the `database.exclude.list`. \n+Do not also set the `database.include.list` connector configuration property.\n+\n+|[[mysql-property-table-whitelist]]\n+[[mysql-property-table-include-list]]<<mysql-property-table-include-list, `table.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture. The connector does not capture changes in any table not included in `table.include.list`. Each identifier is of the form _databaseName_._tableName_. By default, the connector captures changes in every non-system table in each database whose changes are being captured.\n+Do not also specify the `table.exclude.list` connector configuration property.\n+\n+|[[mysql-property-table-blacklist]]\n+[[mysql-property-table-exclude-list]]<<mysql-property-table-exclude-list, `table.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture. The connector captures changes in any table not included in `table.exclude.list`. Each identifier is of the form _databaseName_._tableName_.\n+Do not also specify the `table.include.list` connector configuration property.\n+\n+|[[mysql-property-column-blacklist]]\n+[[mysql-property-column-exclude-list]]<<mysql-property-column-exclude-list, `column.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-include-list]]<<mysql-property-column-include-list, `column.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-truncate-to-length-chars]]<<mysql-property-column-truncate-to-length-chars, `column.truncate.to{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be truncated in the change event record values if the field values are longer than the specified number of characters. You can configure multiple properties with different lengths in a single configuration. The length must be a positive integer. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-with-length-chars]]<<mysql-property-column-mask-with-length-chars, `column.mask.with{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be replaced in the change event message values with a field value consisting of the specified number of asterisk (`*`) characters. You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-hash]]<<mysql-property-column-mask-hash, `column.mask{zwsp}.hash._hashAlgorithm_{zwsp}.with.salt._salt_`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in the change event record values. Pseudonyms consist of the hashed value obtained by applying the algorithm `_hashAlgorithm_` and salt `_salt_`. +\n+ +\n+Based on the hash function used, referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n+The hash result is automatically shortened to the length of the column. +\n+ +\n+You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. For example: +\n+ +\n+`column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName` +\n+ +\n+`CzQMA0cB5K` is a randomly selected salt.\n+ +\n+Depending on the configured `_hashAlgorithm_`, the selected `_salt_`, and the actual data set, the resulting masked data set might not be completely anonymized.\n+\n+|[[mysql-property-column-propagate-source-type]]<<mysql-property-column-propagate-source-type, `column.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+\n+`pass:[_]pass:[_]{prodname}.source.column.type` \n+\n+`pass:[_]pass:[_]{prodname}.source.column.length` \n+ \n+`pass:[_]pass:[_]{prodname}.source.column.scale` \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified names for columns are of one of these forms: \n+\n+_databaseName_._tableName_._columnName_ \n+\n+_databaseName_._schemaName_._tableName_._columnName_\n+\n+|[[mysql-property-datatype-propagate-source-type]]<<mysql-property-datatype-propagate-source-type, `datatype.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+ \n+`pass:[_]pass:[_]debezium.source.column.type`  \n+\n+`pass:[_]pass:[_]debezium.source.column.length`\n+\n+`pass:[_]pass:[_]debezium.source.column.scale`  \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified data type names are of one of these forms: \n+\n+_databaseName_._tableName_._typeName_ \n+\n+_databaseName_._schemaName_._tableName_._typeName_ \n+ \n+See {link-prefix}:{link-mysql-connector}#mysql-data-types[how MySQL connectors map data types] for the list of MySQL-specific data type names.\n+\n+|[[mysql-property-time-precision-mode]]<<mysql-property-time-precision-mode, `time.precision.mode`>>\n+|`adaptive_time{zwsp}_microseconds`\n+|Time, date, and timestamps can be represented with different kinds of precision, including: +\n+ +\n+`adaptive_time_microseconds` (the default) captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +\n+ +\n+ifdef::community[]\n+`adaptive` (deprecated) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +\n+endif::community[]\n+ +\n+`connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.\n+\n+|[[mysql-property-decimal-handling-mode]]<<mysql-property-decimal-handling-mode,`decimal.handling.mode`>>\n+|`precise`\n+|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +\n+ +\n+`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +\n+ +\n+`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +\n+ +\n+`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.\n+\n+|[[mysql-property-bigint-unsigned-handling-mode]]<<mysql-property-bigint-unsigned-handling-mode, `bigint.unsigned{zwsp}.handling.mode`>>\n+|`long`\n+|Specifies how BIGINT UNSIGNED columns should be represented in change events. Possible settings are: +\n+ +\n+ `long` represents values by using Java's `long`, which might not offer the precision but which is easy to use in consumers. `long` is usually the preferred setting. +\n+ +\n+`precise` uses `java.math.BigDecimal` to represent values, which are encoded in the change events by using a binary representation and Kafka Connect's `org.apache.kafka.connect.data.Decimal` type. Use this setting when working with values larger than 2^63, because these values cannot be conveyed by using `long`.\n+\n+|[[mysql-property-include-schema-changes]]<<mysql-property-include-schema-changes, `include.schema{zwsp}.changes`>>\n+|`true`\n+|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded by using a key that contains the database name and whose value includes the DDL statement(s). This is independent of how the connector internally records database history. \n+\n+|[[mysql-property-include-query]]<<mysql-property-include-query, `include.query`>>\n+|`false`\n+|Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +\n+ +\n+If you set this option to `true` then you must also configure MySQL with the `binlog_rows_query_log_events` option set to `ON`. When `include.query` is `true`, the query is not present for events that the snapshot process generates. +\n+ +\n+Setting `include.query`to `true` might expose tables or fields explicitly excluded or masked by including the original SQL statement in the change event. For this reason, the default setting is `false`.\n+\n+|[[mysql-property-event-processing-failure-handling-mode]]<<mysql-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to exceptions during deserialization of binlog events. +\n+ +\n+`fail` propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and then skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-inconsistent-schema-handling-mode]]<<mysql-property-inconsistent-schema-handling-mode, `inconsistent.schema{zwsp}.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to binlog events that relate to tables that are not present in internal schema representation. That is, the internal representation is not consistent with the database. +\n+ +\n+`fail` throws an exception that indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-max-queue-size]]<<mysql-property-max-queue-size, `max.queue.size`>>\n+|`8192`\n+|Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the binlog reader when, for example, writes to Kafka are slow or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified by the `max.batch.size` property.\n+\n+|[[mysql-property-max-batch-size]]<<mysql-property-max-batch-size, `max.batch.size`>>\n+|`2048`\n+|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.\n+\n+|[[mysql-property-poll-interval-ms]]<<mysql-property-poll-interval-ms, `poll.interval.ms`>>\n+|`1000`\n+|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.\n+\n+|[[mysql-property-connect-timeout-ms]]<<mysql-property-connect-timeout-ms, `connect.timeout.ms`>>\n+|`30000`\n+|A positive integer value that specifies the maximum time in milliseconds this connector should wait after trying to connect to the MySQL database server before timing out. Defaults to 30 seconds.\n+\n+|[[mysql-property-gtid-source-includes]]<<mysql-property-gtid-source-includes, `gtid.source.includes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that match one of these include patterns are used.\n+Do not also specify a setting for `gtid.source.excludes`.\n+\n+|[[mysql-property-gtid-source-excludes]]<<mysql-property-gtid-source-excludes, `gtid.source.excludes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that do not match any of these exclude patterns are used. Do not also specify a value for `gtid.source.includes`.\n+\n+ifdef::community[]\n+|[[mysql-property-gtid-new-channel-position]]<<mysql-property-gtid-new-channel-position, `gtid.new.channel.position`>> +\n+_deprecated and scheduled for removal_\n+|`earliest`\n+|When set to `latest`, when the connector sees a new GTID channel, it starts consuming from the last executed transaction in that GTID channel. If set to `earliest` (default), the connector starts reading that channel from the first available (not purged) GTID position. `earliest` is useful when you have an active-passive MySQL setup where {prodname} is connected to the primary server. In this case, during failover, the replica with the new UUID (and GTID channel) starts receiving writes before {prodname} is connected. These writes would be lost when using `latest`.\n+endif::community[]\n+\n+|[[mysql-property-tombstones-on-delete]]<<mysql-property-tombstones-on-delete, `tombstones.on.delete`>>\n+|`true`\n+|Controls whether a delete event is followed by a tombstone event. +\n+ +\n+`true`  - a delete operation is represented by a delete event and a subsequent tombstone event.  +\n+ +\n+`false` - only a delete event is emitted. +\n+ +\n+After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row. \n+\n+|[[mysql-property-message-key-columns]]<<mysql-property-message-key-columns, `message.key.columns`>>\n+|_empty string_\n+|A semicolon separated list of tables with regular expressions that match table column names. The connector maps values in matching columns to key fields in change event records that it sends to Kafka topics. This is useful when a table does not have a primary key, or when you want to order change event records in a Kafka topic according to a field that is not a primary key. +\n+ +\n+Separate entries with semicolons. Insert a colon between the fully-qualified table name and its regular expression. The format (shown with spaces for clarity only) is: +\n+ +\n+_database-name_ `.` _table-name_ `:` _regexp_ `;` ... +\n+ +\n+For example: +\n+ +\n+`dbA.table_a:regex_1;dbB.table_b:regex_2;dbC.table_c:regex_3` +\n+ +\n+If `table_a` has an `id` column, and `regex_1` is `^i` (matches any column that starts with `i`), the connector maps the value in the `id` column of `table_a` to a key field in change events that the connector sends to Kafka. \n+\n+|[[mysql-property-binary-handling-mode]]<<mysql-property-binary-handling-mode,`binary.handling.mode`>>\n+|bytes\n+|Specifies how binary columns, for example, `blob`, `binary`, `varbinary`, should be represented in change events. Possible settings:  +\n+ +\n+`bytes` represents binary data as a byte array. +\n+ +\n+`base64` represents binary data as a base64-encoded String. +\n+ +\n+`hex` represents binary data as a hex-encoded (base16) String.\n+\n+|===\n+\n+[id=\"mysql-advanced-connector-configuration-properties\"]\n+.Advanced MySQL connector configuration properties", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 2214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNDY5NQ==", "bodyText": "DBZ-2631 has been resolved.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499624695", "createdAt": "2020-10-05T14:06:16Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>\n+* <<mysql-update-events,_update_ events>>\n+* <<mysql-primary-key-updates,Primary key updates>>\n+* <<mysql-delete-events,_delete_ events>>\n+* <<mysql-tombstone-events,Tombstone events>>\n+\n+// Type: continue\n+[id=\"mysql-create-events\"]\n+=== _create_ events\n+\n+The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { // <1>\n+    \"type\": \"struct\",\n+    \"fields\": [\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", // <2>\n+        \"field\": \"before\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", \n+        \"field\": \"after\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"connector\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ],\n+        \"optional\": false,\n+        \"name\": \"io.debezium.connector.mysql.Source\", // <3>\n+        \"field\": \"source\"\n+      },\n+      {\n+        \"type\": \"string\",\n+        \"optional\": false,\n+        \"field\": \"op\"\n+      },\n+      {\n+        \"type\": \"int64\",\n+        \"optional\": true,\n+        \"field\": \"ts_ms\"\n+      }\n+    ],\n+    \"optional\": false,\n+    \"name\": \"mysql-server-1.inventory.customers.Envelope\" // <4>\n+  },\n+  \"payload\": { // <5>\n+    \"op\": \"c\", // <6>\n+    \"ts_ms\": 1465491411815, // <7>\n+    \"before\": null, // <8>\n+    \"after\": { // <9>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <10>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 0,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')\"\n+    }\n+  }\n+}\n+----\n+\n+.Descriptions of _create_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table. \n+\n+|2\n+|`name`\n+a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +\n+ +\n+`mysql-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +\n+ +\n+Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database. This means that when using the {link-prefix}:{link-avro-serialization}[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.\n+\n+|3\n+|`name`\n+|`io.debezium.connector.mysql.Source` is the schema for the payload's `source` field. This schema is specific to the MySQL connector. The connector uses it for all events that it generates. \n+\n+|4\n+|`name`\n+|`mysql-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `mysql-server-1` is the connector name, `inventory` is the database, and `customers` is the table.\n+\n+|5\n+|`payload`\n+|The value's actual data. This is the information that the change event is providing. +\n+ +\n+It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.\n+However, by using the {link-prefix}:{link-avro-serialization}[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.\n+\n+|6\n+|`op`\n+a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are: \n+\n+* `c` = create\n+* `u` = update\n+* `d` = delete\n+* `r` = read (applies to only snapshots)\n+\n+|7\n+|`ts_ms`\n+a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|8\n+|`before`\n+| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content. \n+\n+|9\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.\n+\n+|10\n+|`source`\n+a| Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the new row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|===\n+\n+// Type: continue\n+[id=\"mysql-update-events\"]\n+=== _update_ events\n+\n+The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": { // <2>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 484,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"UPDATE customers SET first_name='Anne Marie' WHERE id=1004\"\n+    },\n+    \"op\": \"u\", // <4>\n+    \"ts_ms\": 1465581029523 \n+  }\n+}\n+----\n+\n+.Descriptions of _update_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`\n+\n+|2\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`. \n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.\n+\n+|===\n+\n+[NOTE]\n+====\n+Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a {link-prefix}:{link-mysql-connector}#mysql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section. \n+====\n+\n+// Type: continue\n+[id=\"mysql-primary-key-updates\"]\n+=== Primary key updates\n+\n+An `UPDATE` operation that changes a row's primary key field(s) is known\n+as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change: \n+\n+* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.\n+\n+* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.\n+\n+// Type: continue\n+[id=\"mysql-delete-events\"]\n+=== _delete_ events\n+\n+The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:  \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": null, // <2>\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 805,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"DELETE FROM customers WHERE id=1004\"\n+    },\n+    \"op\": \"d\", // <4>\n+    \"ts_ms\": 1465581902461 // <5>\n+  }\n+}\n+----\n+\n+.Descriptions of _delete_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.\n+\n+|2\n+|`after`\n+| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.\n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.\n+\n+|5\n+|`ts_ms`\n+a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|===\n+\n+A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.\n+\n+MySQL connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.\n+\n+// Type: continue\n+[id=\"mysql-tombstone-events\"]\n+=== Tombstone events\n+When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}\u2019s MySQL connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.\n+\n+// Type: reference\n+// ModuleID: how-debezium-mysql-connectors-map-data-types\n+// Title: How {prodname} MySQL connectors map data types\n+[[mysql-data-types]]\n+== Data type mappings\n+\n+The {prodname} MySQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. The MySQL data type of that column dictates how {prodname} represents the value in the event.\n+\n+Columns that store strings are defined in MySQL with a character set and collation. The MySQL connector uses the column's character set when reading the binary representation of the column values in the binlog events. \n+\n+The connector can map MySQL data types to both _literal_ and _semantic_ types.\n+\n+* *Literal type*: how the value is represented using Kafka Connect schema types\n+* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name)\n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:mysql-basic-types[]\n+* xref:mysql-temporal-types[]\n+* xref:mysql-decimal-types[]\n+* xref:mysql-boolean-values[]\n+* xref:mysql-spatial-types[]\n+\n+endif::product[]\n+\n+[id=\"mysql-basic-types\"]\n+=== Basic types\n+\n+The following table shows how the connector maps basic MySQL data types.\n+\n+.Descriptions of basic type mappings\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`BOOLEAN, BOOL`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(1)`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(>1)`\n+|`BYTES`\n+a|`io.debezium.data.Bits` +\n+The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +\n+`numBytes = n/8 + (n%8== 0 ? 0 : 1)`\n+\n+|`TINYINT`\n+|`INT16`\n+a|_n/a_\n+\n+|`SMALLINT[(M)]`\n+|`INT16`\n+a|_n/a_\n+\n+|`MEDIUMINT[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`INT, INTEGER[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`BIGINT[(M)]`\n+|`INT64`\n+a|_n/a_\n+\n+|`REAL[(M,D)]`\n+|`FLOAT32`\n+a|_n/a_\n+\n+|`FLOAT[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DOUBLE[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`CHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`VARCHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`BINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`VARBINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`BLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`MEDIUMBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`MEDIUMTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`LONGBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`LONGTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`JSON`\n+|`STRING`\n+a|`io.debezium.data.Json` +\n+Contains the string representation of a `JSON` document, array, or scalar.\n+\n+|`ENUM`\n+|`STRING`\n+a|`io.debezium.data.Enum` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`SET`\n+|`STRING`\n+a|`io.debezium.data.EnumSet` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`YEAR[(2\\|4)]`\n+|`INT32`\n+|`io.debezium.time.Year`\n+\n+|`TIMESTAMP[(M)]`\n+|`STRING`\n+a|`io.debezium.time.ZonedTimestamp` +\n+In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision. MySQL allows `M` to be in the range of `0-6`.\n+\n+|===\n+\n+[id=\"mysql-temporal-types\"]\n+=== Temporal types\n+\n+Excluding the `TIMESTAMP` data type, MySQL temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema. \n+\n+MySQL allows zero-values for `DATE, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values. The MySQL connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.\n+\n+.Temporal values without time zones\n+The `DATETIME` type represents a local date and time such as \"2018-01-13 09:48:27\". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column\u2019s precision by using UTC. The `TIMESTAMP` type represents a timestamp without time zone information. It is converted by MySQL from the server (or session\u2019s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:\n+\n+* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.\n+* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.\n+\n+Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session\u2019s) current time zone. The time zone will be queried from the server by default. If this fails, it must be specified explicitly by the database `serverTimezone` MySQL configuration option. For example, if the database\u2019s time zone (either globally or configured for the connector by means of the `serverTimezone` option) is \"America/Los_Angeles\", the TIMESTAMP value \"2018-06-20 06:37:03\" is represented by a `ZonedTimestamp` with the value \"2018-06-20T13:37:03Z\".\n+\n+The time zone of the JVM running Kafka Connect and Debezium does not affect these conversions.\n+\n+More details about properties related to termporal values are in the documentation for {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+time.precision.mode=adaptive_time_microseconds(default)::\n+The MySQL connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.\n++\n+.Mappings when `time.precision.mode=adaptive_time_microseconds`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`io.debezium.time.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`io.debezium.time.MicroTime` +\n+Represents the time value in microseconds and does not include time zone information. MySQL allows `M` to be in the range of `0-6`.\n+\n+|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`\n+|`INT64`\n+a|`io.debezium.time.Timestamp` +\n+Represents the number of milliseconds past the epoch and does not include time zone information.\n+\n+|`DATETIME(4), DATETIME(5), DATETIME(6)`\n+|`INT64`\n+a|`io.debezium.time.MicroTimestamp` +\n+Represents the number of microseconds past the epoch and does not include time zone information.\n+\n+|===\n+\n+time.precision.mode=connect::\n+The MySQL connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.\n++\n+.Mappings when `time.precision.mode=connect`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`org.apache.kafka.connect.data.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Time` +\n+Represents the time value in microseconds since midnight and does not include time zone information.\n+\n+|`DATETIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Timestamp` +\n+Represents the number of milliseconds since the epoch, and does not include time zone information.\n+\n+|===\n+\n+[id=\"mysql-decimal-types\"]\n+=== Decimal types\n+\n+{prodname} connectors handle decimals according to the setting of the {link-prefix}:{link-mysql-connector}#mysql-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property]. \n+\n+decimal.handling.mode=precise::\n++\n+.Mappings when `decimal.handing.mode=precise`\n+[cols=\"30%a,15%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|`DECIMAL[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|===\n+\n+decimal.handling.mode=double::\n++\n+.Mappings when `decimal.handing.mode=double`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|===\n+\n+decimal.handling.mode=string::\n++\n+.Mappings when `decimal.handing.mode=string`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|===\n+\n+[id=\"mysql-boolean-values\"]\n+=== Boolean values\n+\n+MySQL handles the `BOOLEAN` value internally in a specific way.\n+The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.\n+When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.\n+During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.\n+\n+ifdef::community[]\n+The operator can configure the out-of-the-box {link-prefix}:{link-custom-converters}[`TinyIntOneToBooleanConverter` custom converter] that would either map all `TINYINT(1)` columns to `BOOLEAN` or if the `selector` parameter is set then a subset of columns could be enumerated using comma-separated regular expressions.\n+endif::community[]\n+\n+Following is an example configuration:\n+\n+----\n+converters=boolean\n+boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter\n+boolean.selector=db1.table1.*, db1.table2.column1\n+----\n+\n+[id=\"mysql-spatial-types\"]\n+=== Spatial types\n+\n+Currently, the {prodname} MySQL connector supports the following spatial data types.\n+\n+.Description of spatial type mappings\n+[cols=\"35%a,15%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`GEOMETRY, +\n+LINESTRING, +\n+POLYGON, +\n+MULTIPOINT, +\n+MULTILINESTRING, +\n+MULTIPOLYGON, +\n+GEOMETRYCOLLECTION`\n+|`STRUCT`\n+a|`io.debezium.data.geometry.Geometry` +\n+Contains a structure with two fields:\n+\n+* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure\n+* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.\n+\n+|===\n+\n+// Type: assembly\n+// ModuleID: setting-up-mysql-to-run-a-debezium-connector\n+// Title: Setting up MySQL to run a {prodname} connector\n+[[setting-up-mysql]]\n+== Set up\n+\n+Some MySQL setup tasks are required before you can install and run a {prodname} connector. \n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:creating-a-mysql-user-for-a-debezium-connector[]\n+* xref:enabling-the-mysql-binlog-for-debezium[]\n+* xref:enabling-mysql-gtids-for-debezium[]\n+* xref:configuring-mysql-session-timeouts-for-debezium[]\n+* xref:enabling-query-log-events-for-debezium-mysql-connectors[]\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: creating-a-mysql-user-for-a-debezium-connector\n+// Title: Creating a MySQL user for a {prodname} connector\n+[[mysql-creating-user]]\n+=== Creating a user \n+\n+A {prodname} MySQL connector requires a MySQL user account. This MySQL user must have appropriate permissions on all databases for which the {prodname} MySQL connector captures changes.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+\n+.Procedure\n+\n+. Create the MySQL user:\n++\n+[source,SQL]\n+----\n+mysql> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';\n+----\n+\n+. Grant the required permissions to the user:\n++\n+[source,SQL]\n+----\n+mysql> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n+----\n++\n+The table below describes the permissions. \n++\n+IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK_TABLES` permissions to the user that you create. See {link-prefix}:{link-mysql-connector}#mysql-snapshots[snapshots] for more details.\n+\n+. Finalize the user's permissions:\n++\n+[source,SQL]\n+----\n+mysql> FLUSH PRIVILEGES;\n+----\n+\n+[[permissions-explained-mysql-connector]]\n+.Descriptions of user permissions\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Keyword |Description\n+\n+|`SELECT`\n+|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.\n+\n+|`RELOAD`\n+|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.\n+\n+|`SHOW DATABASES`\n+|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.\n+\n+|`REPLICATION SLAVE`\n+|Enables the connector to connect to and read the MySQL server binlog.\n+\n+|`REPLICATION CLIENT`\n+a|Enables the connector the use of the following statements:\n+\n+* `SHOW MASTER STATUS`\n+* `SHOW SLAVE STATUS`\n+* `SHOW BINARY LOGS`\n+\n+The connector always requires this.\n+\n+|`ON`\n+|Identifies the database to which the permissions apply.\n+\n+|`TO 'user'`\n+|Specifies the user to grant the permissions to.\n+\n+|`IDENTIFIED BY 'password'`\n+|Specifies the user's MySQL password.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-the-mysql-binlog-for-debezium\n+// Title: Enabling the MySQL binlog for {prodname}\n+[[enable-mysql-binlog]]\n+=== Enabling the binlog \n+\n+You must enable binary logging for MySQL replication. The binary logs record transaction updates for replication tools to propagate changes. \n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Appropriate MySQL user privileges.\n+\n+.Procedure\n+\n+. Check whether the `log-bin` option is already on:\n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+. If it is `OFF`, configure your MySQL server configuration file with the following properties, which are described in the table below:\n++\n+[source,properties]\n+----\n+server-id         = 223344 \n+log_bin           = mysql-bin \n+binlog_format     = ROW \n+binlog_row_image  = FULL \n+expire_logs_days  = 10 \n+----\n+\n+. Confirm your changes by checking the binlog status once more: \n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+[[binlog-configuration-properties-mysql-connector]]\n+.Descriptions of MySQL binlog configuration properties\n+[cols=\"1,4\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Description\n+\n+|`server-id`\n+|The value for the `server-id` must be unique for each server and replication client in the MySQL cluster. During MySQL connector set up, {prodname} assigns a unique server ID to the connector.\n+\n+|`log_bin`\n+|The value of `log_bin` is the base name of the sequence of binlog files.\n+\n+|`binlog_format`\n+|The `binlog-format` must be set to `ROW` or `row`.\n+\n+|`binlog_row_image`\n+|The `binlog_row_image` must be set to `FULL` or `full`.\n+\n+|`expire_logs_days`\n+|This is the number of days for automatic binlog file removal. The default is `0`, which means no automatic removal. Set the value to match the needs of your environment. See {link-prefix}:{link-mysql-connector}#mysql-purges-binlog-files-used-by-debezium[MySQL purges binlog files].\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-mysql-gtids-for-debezium\n+// Title: Enabling MySQL Global Transaction Identifiers for {prodname}\n+[[enable-mysql-gtids]]\n+=== Enabling GTIDs\n+\n+Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.\n+\n+GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Enable `gtid_mode`:\n++\n+[source,SQL]\n+----\n+mysql> gtid_mode=ON\n+----\n+\n+. Enable `enforce_gtid_consistency`:\n++\n+[source,SQL]\n+----\n+mysql> enforce_gtid_consistency=ON\n+----\n+\n+. Confirm the changes:\n++\n+[source,SQL]\n+----\n+mysql> show global variables like '%GTID%';\n+----\n+\n+.Result\n+[source,SQL]\n+----\n++--------------------------+-------+\n+| Variable_name            | Value |\n++--------------------------+-------+\n+| enforce_gtid_consistency | ON    |\n+| gtid_mode                | ON    |\n++--------------------------+-------+\n+----\n+\n+.Descriptions of GTID options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`gtid_mode`\n+a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|`enforce_gtid_consistency`\n+a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|===\n+\n+\n+// Type: procedure\n+// ModuleID: configuring-mysql-session-timeouts-for-debezium\n+// Title: Configuring MySQL session timesouts for {prodname}\n+[[mysql-session-timeouts]]\n+=== Configuring session timeouts\n+\n+When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read. You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your MySQL configuration file.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Configure `interactive_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> interactive_timeout=<duration-in-seconds>\n+----\n+\n+. Configure `wait_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> wait_timeout=<duration-in-seconds>\n+----\n+\n+.Descriptions of MySQL session timeout options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`interactive_timeout`\n+a|The number of seconds the server waits for activity on an interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL's documentation] for more details.\n+\n+|`wait_timeout`\n+a|The number of seconds the server waits for activity on a non-interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_wait_timeout[MySQL's documentation] for more details.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors\n+// Title: Enabling query log events for {prodname} MySQL connectors\n+[[enable-query-log-events]]\n+=== Enabling query log events \n+\n+You might want to see the original `SQL` statement for each binlog event. Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.\n+\n+This option is available in MySQL 5.6 and later.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowlede of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+* Enable `binlog_rows_query_log_events`:\n++\n+[source,SQL]\n+----\n+mysql> binlog_rows_query_log_events=ON\n+----\n++\n+`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.\n++\n+** `ON` = enabled\n+** `OFF` = disabled\n+\n+// Type: assembly\n+// ModuleID: deploying-debezium-mysql-connectors\n+// Title: Deploying {prodname} MySQL connectors\n+[[mysql-deploying-a-connector]]\n+== Deployment\n+\n+To deploy a {prodname} MySQL connector, install the {prodname} MySQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:installing-debezium-mysql-connectors[]\n+* xref:debezium-mysql-connector-configuration-example[]\n+* xref:adding-debezium-mysql-connector-configuration-to-kafka-connect[]\n+* xref:descriptions-of-debezium-mysql-connector-configuration-properties[]\n+endif::product[]\n+\n+// Type: procedure\n+// Title: Installing {prodname} MySQL connectors\n+[id=\"installing-debezium-mysql-connectors\"]\n+=== Installing\n+\n+To install a {prodname} MySQL connector, download the connector archive, extract it to your Kafka Connect environment, and ensure that the plug-ins parent directory is specified in your Kafka Connect environment.\n+\n+.Prerequisites\n+\n+* link:https://zookeeper.apache.org/[Zookeeper], link:http://kafka.apache.org/[Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.\n+* MySQL Server is installed and set up for {prodname}.\n+\n+.Procedure\n+\n+ifdef::product[]\n+. Download the link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[{prodname} MySQL connector].\n+endif::product[]\n+ifdef::community[]\n+ifeval::['{page-version}' == 'master']\n+. Download the {prodname} link:{link-mysql-plugin-snapshot}[MySQL connector plug-in].\n+endif::[]\n+ifeval::['{page-version}' != 'master']\n+. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].\n+endif::[]\n+endif::community[]\n+. Extract the files into your Kafka Connect environment.\n+. Add the plug-ins parent directory to your Kafka Connect `plugin.path`:\n++\n+[source]\n+----\n+plugin.path=/kafka/connect\n+----\n++\n+The above example assumes that you extracted the {prodname} MySQL connector into the `/kafka/connect/debezium-connector-mysql` path.\n+\n+. Restart your Kafka Connect process. This ensures that the new JAR files are picked up.\n+\n+// Type: concept\n+// ModuleID: debezium-mysql-connector-configuration-example\n+// Title: {prodname} MySQL connector configuration example\n+[[mysql-example-configuration]]\n+=== Connector configuration example\n+\n+ifdef::community[]\n+Typically, you configure a {prodname} MySQL connector in a `.json` file that sets configuration properties for the connector. Following is an example configuration for a MySQL connector that connects to a MySQL server on port 3306 at 192.168.99.100, whose logical name is `fullfillment`.\n+\n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,json]\n+----\n+{\n+  \"name\": \"inventory-connector\", // <1>\n+  \"config\": {\n+    \"connector.class\": \"io.debezium.connector.mysql.MySqlConnector\", // <2>\n+    \"database.hostname\": \"192.168.99.100\", // <3>\n+    \"database.port\": \"3306\", // <4>\n+    \"database.user\": \"debezium-user\", // <5>\n+    \"database.password\": \"debezium-user-pw\", // <6>\n+    \"database.server.id\": \"184054\", <7>\n+    \"database.server.name\": \"fullfillment\", // <8>\n+    \"database.whitelist\": \"inventory\", // <9>\n+    \"database.history.kafka.bootstrap.servers\": \"kafka:9092\", // <10>\n+    \"database.history.kafka.topic\": \"dbhistory.fullfillment\", // <11>\n+    \"include.schema.changes\": \"true\" // <12>\n+  }\n+}\n+----\n+<1> Connector's name when registered with the Kafka Connect service.\n+<2> Connector's class name.\n+<3> MySQL server address.\n+<4> MySQL server port number.\n+<5> MySQL user with the appropriate privileges.\n+<6> MySQL user's password.\n+<7> Unique ID of the connector.\n+<8> Logical name of the MySQL server or cluster.\n+<9> List of databases hosted by the specified server.\n+<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database history topic.\n+<11> Name of the database history topic. This topic is for internal use only and should not be used by consumers. \n+<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers. \n+endif::community[]\n+\n+ifdef::product[]\n+\n+Typically, you configure a {prodname} MySQL connector in a `.yaml` file that sets connector configuration properties. Following is an example of the configuration for a MySQL connector that connects to a MySQL server on port 3306 and captures changes to the `inventory` database. \n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,yaml,options=\"nowrap\"]\n+----\n+  apiVersion: kafka.strimzi.io/v1beta1\n+  kind: KafkaConnector\n+  metadata:\n+    name: inventory-connector  // <1>\n+    labels:\n+      strimzi.io/cluster: my-connect-cluster\n+  spec:\n+    class: io.debezium.connector.mysql.MySqlConnector\n+    tasksMax: 1  // <2>\n+    config:  // <3>\n+      database.hostname: mysql  // <4>\n+      database.port: 3306\n+      database.user: debezium\n+      database.password: dbz\n+      database.server.id: 184054  // <5>\n+      database.server.name: dbserver1  // <5>\n+      database.whitelist: inventory  // <6>\n+      database.history.kafka.bootstrap.servers: my-cluster-kafka-bootstrap:9092  // <7>\n+      database.history.kafka.topic: schema-changes.inventory  // <7>\n+----\n+\n+.Descriptions of connector configuration settings\n+[cols=\"1,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Item |Description\n+\n+|1\n+|The name of the connector.\n+\n+|2\n+|Only one task should operate at any one time.\n+Because the MySQL connector reads the MySQL server\u2019s `binlog`,\n+using a single connector task ensures proper order and event handling.\n+The Kafka Connect service uses connectors to start one or more tasks that do the work,\n+and it automatically distributes the running tasks across the cluster of Kafka Connect services.\n+If any of the services stop or crash,\n+those tasks will be redistributed to running services.\n+\n+|3\n+|The connector\u2019s configuration.\n+\n+|4\n+|The database host, which is the name of the container running the MySQL server (`mysql`).\n+\n+|5\n+|A unique server ID and name.\n+The server name is the logical identifier for the MySQL server or cluster of servers.\n+This name is used as the prefix for all Kafka topics.\n+\n+|6\n+|Changes in only the `inventory` database are captured.\n+\n+|7\n+|The connector stores the history of the database schemas in Kafka using this broker (the same broker to which you are sending events) and topic name.\n+Upon restart, the connector recovers the schemas of the database that existed at the point in time in the binlog when the connector should begin reading.\n+\n+|===\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: adding-debezium-mysql-connector-configuration-to-kafka-connect\n+// Title: Adding {prodname} MySQL connector configuration to Kafka Connect\n+[[mysql-adding-configuration]]\n+=== Adding connector configuration \n+ifdef::community[]\n+To start running a MySQL connector, configure a connector and add the configuration to your Kafka Connect cluster. \n+\n+.Prerequisites\n+\n+* {link-prefix}:{link-mysql-connector}#setting-up-mysql[MySQL server] is \n+set up for a {prodname} connector.\n+\n+* {prodname} MySQL connector is installed. \n+\n+.Procedure\n+\n+. Create a configuration for the MySQL connector.\n+\n+. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster. \n+\n+endif::community[]\n+\n+ifdef::product[]\n+You can use a provided {prodname} container to deploy a {prodname} MySQL connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment. \n+\n+.Prerequisites\n+\n+* Podman or Docker is installed.\n+* You have sufficient rights to create and manage containers.\n+* You downloaded the {prodname} MySQL connector archive. \n+\n+.Procedure\n+\n+. Extract the {prodname} MySQL connector archive to create a directory structure for the connector plug-in, for example: \n++\n+[subs=\"+macros\"]\n+----\n+pass:quotes[*tree ./my-plugins/*]\n+./my-plugins/\n+\u251c\u2500\u2500 debezium-connector-mysql\n+\u2502   \u251c\u2500\u2500 ...\n+----\n+\n+. Create and publish a custom image for running your {prodname} connector:\n+\n+.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:\n++\n+[subs=\"+macros,+attributes\"]\n+----\n+FROM {DockerKafkaConnect}\n+USER root:root\n+pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]\n+USER 1001\n+----\n++\n+Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.\n+\n+.. Build the container image. For example, if you saved the `Dockerfile` that you created in the previous step as `debezium-container-for-mysql`, and if `Dockerfile` is in the current directory, then you would run the following command:\n++\n+`podman build -t debezium-container-for-mysql:latest .`\n+\n+.. Push your custom image to your container registry, for example:\n++\n+`podman push debezium-container-for-mysql:latest`\n+\n+.. Point to the new container image. Do one of the following:\n++\n+* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:\n++\n+[source,yaml,subs=\"+attributes\"]\n+----\n+apiVersion: {KafkaConnectApiVersion}\n+kind: KafkaConnector\n+metadata:\n+  name: my-connect-cluster\n+spec:\n+  #...\n+  image: debezium-container-for-mysql\n+----\n++\n+* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.\n+\n+. Create a `KafkaConnector` custom resource that defines your {prodname} MySQL connector instance. See {LinkDebeziumUserGuide}#mysql-example-configuration[the connector configuration example].\n+\n+. Apply the connector instance, for example: \n++\n+`oc apply -f inventory-connector.yaml`\n++\n+This registers `inventory-connector` and the connector starts to run against the `inventory` database.\n+\n+. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.\n+\n+.. Display the Kafka Connect log output:\n++\n+[source,shell,options=\"nowrap\"]\n+----\n+oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)\n+----\n+\n+.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines: \n++\n+[source,shell,options=\"nowrap\"]\n+----\n+... INFO Starting snapshot for ...\n+... INFO Snapshot is using user 'debezium' ... \n+----\n+\n+endif::product[]\n+\n+.Results\n+\n+When the connector starts, it {link-prefix}:{link-mysql-connector}#mysql-snapshots[performs a consistent snapshot] of the MySQL databases that the connector is configured for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics. \n+\n+// Type: reference\n+// ModuleID: descriptions-of-debezium-mysql-connector-configuration-properties\n+// Title: Description of {prodname} MySQL connector configuration properties\n+[[mysql-connector-properties]]\n+=== Connector properties\n+\n+The {prodname} MySQL connector has numerous configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:\n+\n+* xref:mysql-required-connector-configuration-properties[Required connector configuration properties]\n+* xref:mysql-advanced-connector-configuration-properties[Advanced connector configuration properties]\n+* xref:mysql-pass-through-configuration-properties[Pass-through configuration properties]\n+\n+[id=\"mysql-required-connector-configuration-properties\"]\n+The following configuration properties are _required_ unless a default value is available.\n+\n+.Required MySQL connector configuration properties\n+[cols=\"33%a,17%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Default |Description\n+\n+|[[mysql-property-name]]<<mysql-property-name, `name`>>\n+|\n+|Unique name for the connector. Attempting to register again with the same name fails. This property is required by all Kafka Connect connectors.\n+\n+|[[mysql-property-connector-class]]<<mysql-property-connector-class, `connector.class`>>\n+|\n+|The name of the Java class for the connector. Always specify  `io.debezium{zwsp}.connector.mysql.MySqlConnector` for the MySQL connector.\n+\n+|[[mysql-property-tasks-max]]<<mysql-property-tasks-max, `tasks.max`>>\n+|`1`\n+|The maximum number of tasks that should be created for this connector. The MySQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.\n+\n+|[[mysql-property-database-hostname]]<<mysql-property-database-hostname, `database.hostname`>>\n+|\n+|IP address or host name of the MySQL database server.\n+\n+|[[mysql-property-database-port]]<<mysql-property-database-port, `database.port`>>\n+|`3306`\n+|Integer port number of the MySQL database server.\n+\n+|[[mysql-property-database-user]]<<mysql-property-database-user, `database.user`>>\n+|\n+|Name of the MySQL database to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-password]]<<mysql-property-database-password, `database.password`>>\n+|\n+|Password to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-server-name]]<<mysql-property-database-server-name, `database.server.name`>>\n+|\n+|Logical name that identifies and provides a namespace for the particular MySQL database server/cluster in which {prodname} is capturing changes. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector.\n+Only alphanumeric characters and underscores are allowed in this name.\n+\n+|[[mysql-property-database-server-id]]<<mysql-property-database-server-id, `database.server.id`>>\n+|_random_\n+|A numeric ID of this database client, which must be unique across all currently-running database processes in the MySQL cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog. By default, a random number between 5400 and 6400 is generated, though the recommendation is to explicitly set a value.  \n+\n+|[[mysql-property-database-history-kafka-topic]]<<mysql-property-database-history-kafka-topic, `database.history.kafka{zwsp}.topic`>>\n+|\n+|The full name of the Kafka topic where the connector stores the database schema history.\n+\n+|[[mysql-property-database-history-kafka-bootstrap-servers]]<<mysql-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap{zwsp}.servers`>>\n+|\n+|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.\n+\n+|[[mysql-property-database-whitelist]]\n+[[mysql-property-database-include-list]]<<mysql-property-database-include-list, `database.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of the databases for which to capture changes. The connector does not capture changes in any database whose name is not in `database.include.list`. By default, the connector captures changes in all databases. \n+Do not also set the `database.exclude.list` connector confiuration property.\n+\n+|[[mysql-property-database-blacklist]]\n+[[mysql-property-database-exclude-list]]<<mysql-property-database-exclude-list, `database.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of databases for which you do not want to capture changes. The connector captures changes in any database whose name is not in the `database.exclude.list`. \n+Do not also set the `database.include.list` connector configuration property.\n+\n+|[[mysql-property-table-whitelist]]\n+[[mysql-property-table-include-list]]<<mysql-property-table-include-list, `table.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture. The connector does not capture changes in any table not included in `table.include.list`. Each identifier is of the form _databaseName_._tableName_. By default, the connector captures changes in every non-system table in each database whose changes are being captured.\n+Do not also specify the `table.exclude.list` connector configuration property.\n+\n+|[[mysql-property-table-blacklist]]\n+[[mysql-property-table-exclude-list]]<<mysql-property-table-exclude-list, `table.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture. The connector captures changes in any table not included in `table.exclude.list`. Each identifier is of the form _databaseName_._tableName_.\n+Do not also specify the `table.include.list` connector configuration property.\n+\n+|[[mysql-property-column-blacklist]]\n+[[mysql-property-column-exclude-list]]<<mysql-property-column-exclude-list, `column.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-include-list]]<<mysql-property-column-include-list, `column.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-truncate-to-length-chars]]<<mysql-property-column-truncate-to-length-chars, `column.truncate.to{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be truncated in the change event record values if the field values are longer than the specified number of characters. You can configure multiple properties with different lengths in a single configuration. The length must be a positive integer. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-with-length-chars]]<<mysql-property-column-mask-with-length-chars, `column.mask.with{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be replaced in the change event message values with a field value consisting of the specified number of asterisk (`*`) characters. You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-hash]]<<mysql-property-column-mask-hash, `column.mask{zwsp}.hash._hashAlgorithm_{zwsp}.with.salt._salt_`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in the change event record values. Pseudonyms consist of the hashed value obtained by applying the algorithm `_hashAlgorithm_` and salt `_salt_`. +\n+ +\n+Based on the hash function used, referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n+The hash result is automatically shortened to the length of the column. +\n+ +\n+You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. For example: +\n+ +\n+`column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName` +\n+ +\n+`CzQMA0cB5K` is a randomly selected salt.\n+ +\n+Depending on the configured `_hashAlgorithm_`, the selected `_salt_`, and the actual data set, the resulting masked data set might not be completely anonymized.\n+\n+|[[mysql-property-column-propagate-source-type]]<<mysql-property-column-propagate-source-type, `column.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+\n+`pass:[_]pass:[_]{prodname}.source.column.type` \n+\n+`pass:[_]pass:[_]{prodname}.source.column.length` \n+ \n+`pass:[_]pass:[_]{prodname}.source.column.scale` \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified names for columns are of one of these forms: \n+\n+_databaseName_._tableName_._columnName_ \n+\n+_databaseName_._schemaName_._tableName_._columnName_\n+\n+|[[mysql-property-datatype-propagate-source-type]]<<mysql-property-datatype-propagate-source-type, `datatype.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+ \n+`pass:[_]pass:[_]debezium.source.column.type`  \n+\n+`pass:[_]pass:[_]debezium.source.column.length`\n+\n+`pass:[_]pass:[_]debezium.source.column.scale`  \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified data type names are of one of these forms: \n+\n+_databaseName_._tableName_._typeName_ \n+\n+_databaseName_._schemaName_._tableName_._typeName_ \n+ \n+See {link-prefix}:{link-mysql-connector}#mysql-data-types[how MySQL connectors map data types] for the list of MySQL-specific data type names.\n+\n+|[[mysql-property-time-precision-mode]]<<mysql-property-time-precision-mode, `time.precision.mode`>>\n+|`adaptive_time{zwsp}_microseconds`\n+|Time, date, and timestamps can be represented with different kinds of precision, including: +\n+ +\n+`adaptive_time_microseconds` (the default) captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +\n+ +\n+ifdef::community[]\n+`adaptive` (deprecated) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +\n+endif::community[]\n+ +\n+`connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.\n+\n+|[[mysql-property-decimal-handling-mode]]<<mysql-property-decimal-handling-mode,`decimal.handling.mode`>>\n+|`precise`\n+|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +\n+ +\n+`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +\n+ +\n+`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +\n+ +\n+`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.\n+\n+|[[mysql-property-bigint-unsigned-handling-mode]]<<mysql-property-bigint-unsigned-handling-mode, `bigint.unsigned{zwsp}.handling.mode`>>\n+|`long`\n+|Specifies how BIGINT UNSIGNED columns should be represented in change events. Possible settings are: +\n+ +\n+ `long` represents values by using Java's `long`, which might not offer the precision but which is easy to use in consumers. `long` is usually the preferred setting. +\n+ +\n+`precise` uses `java.math.BigDecimal` to represent values, which are encoded in the change events by using a binary representation and Kafka Connect's `org.apache.kafka.connect.data.Decimal` type. Use this setting when working with values larger than 2^63, because these values cannot be conveyed by using `long`.\n+\n+|[[mysql-property-include-schema-changes]]<<mysql-property-include-schema-changes, `include.schema{zwsp}.changes`>>\n+|`true`\n+|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded by using a key that contains the database name and whose value includes the DDL statement(s). This is independent of how the connector internally records database history. \n+\n+|[[mysql-property-include-query]]<<mysql-property-include-query, `include.query`>>\n+|`false`\n+|Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +\n+ +\n+If you set this option to `true` then you must also configure MySQL with the `binlog_rows_query_log_events` option set to `ON`. When `include.query` is `true`, the query is not present for events that the snapshot process generates. +\n+ +\n+Setting `include.query`to `true` might expose tables or fields explicitly excluded or masked by including the original SQL statement in the change event. For this reason, the default setting is `false`.\n+\n+|[[mysql-property-event-processing-failure-handling-mode]]<<mysql-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to exceptions during deserialization of binlog events. +\n+ +\n+`fail` propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and then skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-inconsistent-schema-handling-mode]]<<mysql-property-inconsistent-schema-handling-mode, `inconsistent.schema{zwsp}.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to binlog events that relate to tables that are not present in internal schema representation. That is, the internal representation is not consistent with the database. +\n+ +\n+`fail` throws an exception that indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-max-queue-size]]<<mysql-property-max-queue-size, `max.queue.size`>>\n+|`8192`\n+|Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the binlog reader when, for example, writes to Kafka are slow or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified by the `max.batch.size` property.\n+\n+|[[mysql-property-max-batch-size]]<<mysql-property-max-batch-size, `max.batch.size`>>\n+|`2048`\n+|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.\n+\n+|[[mysql-property-poll-interval-ms]]<<mysql-property-poll-interval-ms, `poll.interval.ms`>>\n+|`1000`\n+|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.\n+\n+|[[mysql-property-connect-timeout-ms]]<<mysql-property-connect-timeout-ms, `connect.timeout.ms`>>\n+|`30000`\n+|A positive integer value that specifies the maximum time in milliseconds this connector should wait after trying to connect to the MySQL database server before timing out. Defaults to 30 seconds.\n+\n+|[[mysql-property-gtid-source-includes]]<<mysql-property-gtid-source-includes, `gtid.source.includes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that match one of these include patterns are used.\n+Do not also specify a setting for `gtid.source.excludes`.\n+\n+|[[mysql-property-gtid-source-excludes]]<<mysql-property-gtid-source-excludes, `gtid.source.excludes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that do not match any of these exclude patterns are used. Do not also specify a value for `gtid.source.includes`.\n+\n+ifdef::community[]\n+|[[mysql-property-gtid-new-channel-position]]<<mysql-property-gtid-new-channel-position, `gtid.new.channel.position`>> +\n+_deprecated and scheduled for removal_\n+|`earliest`\n+|When set to `latest`, when the connector sees a new GTID channel, it starts consuming from the last executed transaction in that GTID channel. If set to `earliest` (default), the connector starts reading that channel from the first available (not purged) GTID position. `earliest` is useful when you have an active-passive MySQL setup where {prodname} is connected to the primary server. In this case, during failover, the replica with the new UUID (and GTID channel) starts receiving writes before {prodname} is connected. These writes would be lost when using `latest`.\n+endif::community[]\n+\n+|[[mysql-property-tombstones-on-delete]]<<mysql-property-tombstones-on-delete, `tombstones.on.delete`>>\n+|`true`\n+|Controls whether a delete event is followed by a tombstone event. +\n+ +\n+`true`  - a delete operation is represented by a delete event and a subsequent tombstone event.  +\n+ +\n+`false` - only a delete event is emitted. +\n+ +\n+After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row. \n+\n+|[[mysql-property-message-key-columns]]<<mysql-property-message-key-columns, `message.key.columns`>>\n+|_empty string_\n+|A semicolon separated list of tables with regular expressions that match table column names. The connector maps values in matching columns to key fields in change event records that it sends to Kafka topics. This is useful when a table does not have a primary key, or when you want to order change event records in a Kafka topic according to a field that is not a primary key. +\n+ +\n+Separate entries with semicolons. Insert a colon between the fully-qualified table name and its regular expression. The format (shown with spaces for clarity only) is: +\n+ +\n+_database-name_ `.` _table-name_ `:` _regexp_ `;` ... +\n+ +\n+For example: +\n+ +\n+`dbA.table_a:regex_1;dbB.table_b:regex_2;dbC.table_c:regex_3` +\n+ +\n+If `table_a` has an `id` column, and `regex_1` is `^i` (matches any column that starts with `i`), the connector maps the value in the `id` column of `table_a` to a key field in change events that the connector sends to Kafka. \n+\n+|[[mysql-property-binary-handling-mode]]<<mysql-property-binary-handling-mode,`binary.handling.mode`>>\n+|bytes\n+|Specifies how binary columns, for example, `blob`, `binary`, `varbinary`, should be represented in change events. Possible settings:  +\n+ +\n+`bytes` represents binary data as a byte array. +\n+ +\n+`base64` represents binary data as a base64-encoded String. +\n+ +\n+`hex` represents binary data as a hex-encoded (base16) String.\n+\n+|===\n+\n+[id=\"mysql-advanced-connector-configuration-properties\"]\n+.Advanced MySQL connector configuration properties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NzQ5MQ=="}, "originalCommit": null, "originalPosition": 2214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjI5OA==", "bodyText": "Oh, great! I meant to bring this up. I don't see how you changed the rendering, but yes, we needed to somehow distinguish the\n.This is a section title \nheadings. So thanks for taking care of that!", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499722298", "createdAt": "2020-10-05T16:24:21Z", "author": {"login": "TovaCohen"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>\n+* <<mysql-update-events,_update_ events>>\n+* <<mysql-primary-key-updates,Primary key updates>>\n+* <<mysql-delete-events,_delete_ events>>\n+* <<mysql-tombstone-events,Tombstone events>>\n+\n+// Type: continue\n+[id=\"mysql-create-events\"]\n+=== _create_ events\n+\n+The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { // <1>\n+    \"type\": \"struct\",\n+    \"fields\": [\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", // <2>\n+        \"field\": \"before\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", \n+        \"field\": \"after\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"connector\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ],\n+        \"optional\": false,\n+        \"name\": \"io.debezium.connector.mysql.Source\", // <3>\n+        \"field\": \"source\"\n+      },\n+      {\n+        \"type\": \"string\",\n+        \"optional\": false,\n+        \"field\": \"op\"\n+      },\n+      {\n+        \"type\": \"int64\",\n+        \"optional\": true,\n+        \"field\": \"ts_ms\"\n+      }\n+    ],\n+    \"optional\": false,\n+    \"name\": \"mysql-server-1.inventory.customers.Envelope\" // <4>\n+  },\n+  \"payload\": { // <5>\n+    \"op\": \"c\", // <6>\n+    \"ts_ms\": 1465491411815, // <7>\n+    \"before\": null, // <8>\n+    \"after\": { // <9>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <10>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 0,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')\"\n+    }\n+  }\n+}\n+----\n+\n+.Descriptions of _create_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table. \n+\n+|2\n+|`name`\n+a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +\n+ +\n+`mysql-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +\n+ +\n+Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database. This means that when using the {link-prefix}:{link-avro-serialization}[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.\n+\n+|3\n+|`name`\n+|`io.debezium.connector.mysql.Source` is the schema for the payload's `source` field. This schema is specific to the MySQL connector. The connector uses it for all events that it generates. \n+\n+|4\n+|`name`\n+|`mysql-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `mysql-server-1` is the connector name, `inventory` is the database, and `customers` is the table.\n+\n+|5\n+|`payload`\n+|The value's actual data. This is the information that the change event is providing. +\n+ +\n+It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.\n+However, by using the {link-prefix}:{link-avro-serialization}[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.\n+\n+|6\n+|`op`\n+a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are: \n+\n+* `c` = create\n+* `u` = update\n+* `d` = delete\n+* `r` = read (applies to only snapshots)\n+\n+|7\n+|`ts_ms`\n+a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|8\n+|`before`\n+| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content. \n+\n+|9\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.\n+\n+|10\n+|`source`\n+a| Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the new row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|===\n+\n+// Type: continue\n+[id=\"mysql-update-events\"]\n+=== _update_ events\n+\n+The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": { // <2>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 484,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"UPDATE customers SET first_name='Anne Marie' WHERE id=1004\"\n+    },\n+    \"op\": \"u\", // <4>\n+    \"ts_ms\": 1465581029523 \n+  }\n+}\n+----\n+\n+.Descriptions of _update_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`\n+\n+|2\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`. \n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.\n+\n+|===\n+\n+[NOTE]\n+====\n+Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a {link-prefix}:{link-mysql-connector}#mysql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section. \n+====\n+\n+// Type: continue\n+[id=\"mysql-primary-key-updates\"]\n+=== Primary key updates\n+\n+An `UPDATE` operation that changes a row's primary key field(s) is known\n+as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change: \n+\n+* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.\n+\n+* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.\n+\n+// Type: continue\n+[id=\"mysql-delete-events\"]\n+=== _delete_ events\n+\n+The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:  \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": null, // <2>\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 805,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"DELETE FROM customers WHERE id=1004\"\n+    },\n+    \"op\": \"d\", // <4>\n+    \"ts_ms\": 1465581902461 // <5>\n+  }\n+}\n+----\n+\n+.Descriptions of _delete_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.\n+\n+|2\n+|`after`\n+| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.\n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.\n+\n+|5\n+|`ts_ms`\n+a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|===\n+\n+A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.\n+\n+MySQL connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.\n+\n+// Type: continue\n+[id=\"mysql-tombstone-events\"]\n+=== Tombstone events\n+When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}\u2019s MySQL connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.\n+\n+// Type: reference\n+// ModuleID: how-debezium-mysql-connectors-map-data-types\n+// Title: How {prodname} MySQL connectors map data types\n+[[mysql-data-types]]\n+== Data type mappings\n+\n+The {prodname} MySQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. The MySQL data type of that column dictates how {prodname} represents the value in the event.\n+\n+Columns that store strings are defined in MySQL with a character set and collation. The MySQL connector uses the column's character set when reading the binary representation of the column values in the binlog events. \n+\n+The connector can map MySQL data types to both _literal_ and _semantic_ types.\n+\n+* *Literal type*: how the value is represented using Kafka Connect schema types\n+* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name)\n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:mysql-basic-types[]\n+* xref:mysql-temporal-types[]\n+* xref:mysql-decimal-types[]\n+* xref:mysql-boolean-values[]\n+* xref:mysql-spatial-types[]\n+\n+endif::product[]\n+\n+[id=\"mysql-basic-types\"]\n+=== Basic types\n+\n+The following table shows how the connector maps basic MySQL data types.\n+\n+.Descriptions of basic type mappings\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`BOOLEAN, BOOL`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(1)`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(>1)`\n+|`BYTES`\n+a|`io.debezium.data.Bits` +\n+The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +\n+`numBytes = n/8 + (n%8== 0 ? 0 : 1)`\n+\n+|`TINYINT`\n+|`INT16`\n+a|_n/a_\n+\n+|`SMALLINT[(M)]`\n+|`INT16`\n+a|_n/a_\n+\n+|`MEDIUMINT[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`INT, INTEGER[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`BIGINT[(M)]`\n+|`INT64`\n+a|_n/a_\n+\n+|`REAL[(M,D)]`\n+|`FLOAT32`\n+a|_n/a_\n+\n+|`FLOAT[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DOUBLE[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`CHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`VARCHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`BINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`VARBINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`BLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`MEDIUMBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`MEDIUMTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`LONGBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`LONGTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`JSON`\n+|`STRING`\n+a|`io.debezium.data.Json` +\n+Contains the string representation of a `JSON` document, array, or scalar.\n+\n+|`ENUM`\n+|`STRING`\n+a|`io.debezium.data.Enum` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`SET`\n+|`STRING`\n+a|`io.debezium.data.EnumSet` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`YEAR[(2\\|4)]`\n+|`INT32`\n+|`io.debezium.time.Year`\n+\n+|`TIMESTAMP[(M)]`\n+|`STRING`\n+a|`io.debezium.time.ZonedTimestamp` +\n+In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision. MySQL allows `M` to be in the range of `0-6`.\n+\n+|===\n+\n+[id=\"mysql-temporal-types\"]\n+=== Temporal types\n+\n+Excluding the `TIMESTAMP` data type, MySQL temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema. \n+\n+MySQL allows zero-values for `DATE, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values. The MySQL connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.\n+\n+.Temporal values without time zones\n+The `DATETIME` type represents a local date and time such as \"2018-01-13 09:48:27\". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column\u2019s precision by using UTC. The `TIMESTAMP` type represents a timestamp without time zone information. It is converted by MySQL from the server (or session\u2019s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:\n+\n+* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.\n+* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.\n+\n+Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session\u2019s) current time zone. The time zone will be queried from the server by default. If this fails, it must be specified explicitly by the database `serverTimezone` MySQL configuration option. For example, if the database\u2019s time zone (either globally or configured for the connector by means of the `serverTimezone` option) is \"America/Los_Angeles\", the TIMESTAMP value \"2018-06-20 06:37:03\" is represented by a `ZonedTimestamp` with the value \"2018-06-20T13:37:03Z\".\n+\n+The time zone of the JVM running Kafka Connect and Debezium does not affect these conversions.\n+\n+More details about properties related to termporal values are in the documentation for {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+time.precision.mode=adaptive_time_microseconds(default)::\n+The MySQL connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.\n++\n+.Mappings when `time.precision.mode=adaptive_time_microseconds`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`io.debezium.time.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`io.debezium.time.MicroTime` +\n+Represents the time value in microseconds and does not include time zone information. MySQL allows `M` to be in the range of `0-6`.\n+\n+|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`\n+|`INT64`\n+a|`io.debezium.time.Timestamp` +\n+Represents the number of milliseconds past the epoch and does not include time zone information.\n+\n+|`DATETIME(4), DATETIME(5), DATETIME(6)`\n+|`INT64`\n+a|`io.debezium.time.MicroTimestamp` +\n+Represents the number of microseconds past the epoch and does not include time zone information.\n+\n+|===\n+\n+time.precision.mode=connect::\n+The MySQL connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.\n++\n+.Mappings when `time.precision.mode=connect`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`org.apache.kafka.connect.data.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Time` +\n+Represents the time value in microseconds since midnight and does not include time zone information.\n+\n+|`DATETIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Timestamp` +\n+Represents the number of milliseconds since the epoch, and does not include time zone information.\n+\n+|===\n+\n+[id=\"mysql-decimal-types\"]\n+=== Decimal types\n+\n+{prodname} connectors handle decimals according to the setting of the {link-prefix}:{link-mysql-connector}#mysql-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property]. \n+\n+decimal.handling.mode=precise::\n++\n+.Mappings when `decimal.handing.mode=precise`\n+[cols=\"30%a,15%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|`DECIMAL[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|===\n+\n+decimal.handling.mode=double::\n++\n+.Mappings when `decimal.handing.mode=double`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|===\n+\n+decimal.handling.mode=string::\n++\n+.Mappings when `decimal.handing.mode=string`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|===\n+\n+[id=\"mysql-boolean-values\"]\n+=== Boolean values\n+\n+MySQL handles the `BOOLEAN` value internally in a specific way.\n+The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.\n+When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.\n+During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.\n+\n+ifdef::community[]\n+The operator can configure the out-of-the-box {link-prefix}:{link-custom-converters}[`TinyIntOneToBooleanConverter` custom converter] that would either map all `TINYINT(1)` columns to `BOOLEAN` or if the `selector` parameter is set then a subset of columns could be enumerated using comma-separated regular expressions.\n+endif::community[]\n+\n+Following is an example configuration:\n+\n+----\n+converters=boolean\n+boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter\n+boolean.selector=db1.table1.*, db1.table2.column1\n+----\n+\n+[id=\"mysql-spatial-types\"]\n+=== Spatial types\n+\n+Currently, the {prodname} MySQL connector supports the following spatial data types.\n+\n+.Description of spatial type mappings\n+[cols=\"35%a,15%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`GEOMETRY, +\n+LINESTRING, +\n+POLYGON, +\n+MULTIPOINT, +\n+MULTILINESTRING, +\n+MULTIPOLYGON, +\n+GEOMETRYCOLLECTION`\n+|`STRUCT`\n+a|`io.debezium.data.geometry.Geometry` +\n+Contains a structure with two fields:\n+\n+* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure\n+* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.\n+\n+|===\n+\n+// Type: assembly\n+// ModuleID: setting-up-mysql-to-run-a-debezium-connector\n+// Title: Setting up MySQL to run a {prodname} connector\n+[[setting-up-mysql]]\n+== Set up\n+\n+Some MySQL setup tasks are required before you can install and run a {prodname} connector. \n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:creating-a-mysql-user-for-a-debezium-connector[]\n+* xref:enabling-the-mysql-binlog-for-debezium[]\n+* xref:enabling-mysql-gtids-for-debezium[]\n+* xref:configuring-mysql-session-timeouts-for-debezium[]\n+* xref:enabling-query-log-events-for-debezium-mysql-connectors[]\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: creating-a-mysql-user-for-a-debezium-connector\n+// Title: Creating a MySQL user for a {prodname} connector\n+[[mysql-creating-user]]\n+=== Creating a user \n+\n+A {prodname} MySQL connector requires a MySQL user account. This MySQL user must have appropriate permissions on all databases for which the {prodname} MySQL connector captures changes.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+\n+.Procedure\n+\n+. Create the MySQL user:\n++\n+[source,SQL]\n+----\n+mysql> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';\n+----\n+\n+. Grant the required permissions to the user:\n++\n+[source,SQL]\n+----\n+mysql> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n+----\n++\n+The table below describes the permissions. \n++\n+IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK_TABLES` permissions to the user that you create. See {link-prefix}:{link-mysql-connector}#mysql-snapshots[snapshots] for more details.\n+\n+. Finalize the user's permissions:\n++\n+[source,SQL]\n+----\n+mysql> FLUSH PRIVILEGES;\n+----\n+\n+[[permissions-explained-mysql-connector]]\n+.Descriptions of user permissions\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Keyword |Description\n+\n+|`SELECT`\n+|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.\n+\n+|`RELOAD`\n+|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.\n+\n+|`SHOW DATABASES`\n+|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.\n+\n+|`REPLICATION SLAVE`\n+|Enables the connector to connect to and read the MySQL server binlog.\n+\n+|`REPLICATION CLIENT`\n+a|Enables the connector the use of the following statements:\n+\n+* `SHOW MASTER STATUS`\n+* `SHOW SLAVE STATUS`\n+* `SHOW BINARY LOGS`\n+\n+The connector always requires this.\n+\n+|`ON`\n+|Identifies the database to which the permissions apply.\n+\n+|`TO 'user'`\n+|Specifies the user to grant the permissions to.\n+\n+|`IDENTIFIED BY 'password'`\n+|Specifies the user's MySQL password.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-the-mysql-binlog-for-debezium\n+// Title: Enabling the MySQL binlog for {prodname}\n+[[enable-mysql-binlog]]\n+=== Enabling the binlog \n+\n+You must enable binary logging for MySQL replication. The binary logs record transaction updates for replication tools to propagate changes. \n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Appropriate MySQL user privileges.\n+\n+.Procedure\n+\n+. Check whether the `log-bin` option is already on:\n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+. If it is `OFF`, configure your MySQL server configuration file with the following properties, which are described in the table below:\n++\n+[source,properties]\n+----\n+server-id         = 223344 \n+log_bin           = mysql-bin \n+binlog_format     = ROW \n+binlog_row_image  = FULL \n+expire_logs_days  = 10 \n+----\n+\n+. Confirm your changes by checking the binlog status once more: \n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+[[binlog-configuration-properties-mysql-connector]]\n+.Descriptions of MySQL binlog configuration properties\n+[cols=\"1,4\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Description\n+\n+|`server-id`\n+|The value for the `server-id` must be unique for each server and replication client in the MySQL cluster. During MySQL connector set up, {prodname} assigns a unique server ID to the connector.\n+\n+|`log_bin`\n+|The value of `log_bin` is the base name of the sequence of binlog files.\n+\n+|`binlog_format`\n+|The `binlog-format` must be set to `ROW` or `row`.\n+\n+|`binlog_row_image`\n+|The `binlog_row_image` must be set to `FULL` or `full`.\n+\n+|`expire_logs_days`\n+|This is the number of days for automatic binlog file removal. The default is `0`, which means no automatic removal. Set the value to match the needs of your environment. See {link-prefix}:{link-mysql-connector}#mysql-purges-binlog-files-used-by-debezium[MySQL purges binlog files].\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-mysql-gtids-for-debezium\n+// Title: Enabling MySQL Global Transaction Identifiers for {prodname}\n+[[enable-mysql-gtids]]\n+=== Enabling GTIDs\n+\n+Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.\n+\n+GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Enable `gtid_mode`:\n++\n+[source,SQL]\n+----\n+mysql> gtid_mode=ON\n+----\n+\n+. Enable `enforce_gtid_consistency`:\n++\n+[source,SQL]\n+----\n+mysql> enforce_gtid_consistency=ON\n+----\n+\n+. Confirm the changes:\n++\n+[source,SQL]\n+----\n+mysql> show global variables like '%GTID%';\n+----\n+\n+.Result\n+[source,SQL]\n+----\n++--------------------------+-------+\n+| Variable_name            | Value |\n++--------------------------+-------+\n+| enforce_gtid_consistency | ON    |\n+| gtid_mode                | ON    |\n++--------------------------+-------+\n+----\n+\n+.Descriptions of GTID options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`gtid_mode`\n+a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|`enforce_gtid_consistency`\n+a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|===\n+\n+\n+// Type: procedure\n+// ModuleID: configuring-mysql-session-timeouts-for-debezium\n+// Title: Configuring MySQL session timesouts for {prodname}\n+[[mysql-session-timeouts]]\n+=== Configuring session timeouts\n+\n+When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read. You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your MySQL configuration file.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Configure `interactive_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> interactive_timeout=<duration-in-seconds>\n+----\n+\n+. Configure `wait_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> wait_timeout=<duration-in-seconds>\n+----\n+\n+.Descriptions of MySQL session timeout options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`interactive_timeout`\n+a|The number of seconds the server waits for activity on an interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL's documentation] for more details.\n+\n+|`wait_timeout`\n+a|The number of seconds the server waits for activity on a non-interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_wait_timeout[MySQL's documentation] for more details.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors\n+// Title: Enabling query log events for {prodname} MySQL connectors\n+[[enable-query-log-events]]\n+=== Enabling query log events \n+\n+You might want to see the original `SQL` statement for each binlog event. Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.\n+\n+This option is available in MySQL 5.6 and later.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowlede of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+* Enable `binlog_rows_query_log_events`:\n++\n+[source,SQL]\n+----\n+mysql> binlog_rows_query_log_events=ON\n+----\n++\n+`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.\n++\n+** `ON` = enabled\n+** `OFF` = disabled\n+\n+// Type: assembly\n+// ModuleID: deploying-debezium-mysql-connectors\n+// Title: Deploying {prodname} MySQL connectors\n+[[mysql-deploying-a-connector]]\n+== Deployment\n+\n+To deploy a {prodname} MySQL connector, install the {prodname} MySQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:installing-debezium-mysql-connectors[]\n+* xref:debezium-mysql-connector-configuration-example[]\n+* xref:adding-debezium-mysql-connector-configuration-to-kafka-connect[]\n+* xref:descriptions-of-debezium-mysql-connector-configuration-properties[]\n+endif::product[]\n+\n+// Type: procedure\n+// Title: Installing {prodname} MySQL connectors\n+[id=\"installing-debezium-mysql-connectors\"]\n+=== Installing\n+\n+To install a {prodname} MySQL connector, download the connector archive, extract it to your Kafka Connect environment, and ensure that the plug-ins parent directory is specified in your Kafka Connect environment.\n+\n+.Prerequisites\n+\n+* link:https://zookeeper.apache.org/[Zookeeper], link:http://kafka.apache.org/[Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.\n+* MySQL Server is installed and set up for {prodname}.\n+\n+.Procedure\n+\n+ifdef::product[]\n+. Download the link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[{prodname} MySQL connector].\n+endif::product[]\n+ifdef::community[]\n+ifeval::['{page-version}' == 'master']\n+. Download the {prodname} link:{link-mysql-plugin-snapshot}[MySQL connector plug-in].\n+endif::[]\n+ifeval::['{page-version}' != 'master']\n+. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].\n+endif::[]\n+endif::community[]\n+. Extract the files into your Kafka Connect environment.\n+. Add the plug-ins parent directory to your Kafka Connect `plugin.path`:\n++\n+[source]\n+----\n+plugin.path=/kafka/connect\n+----\n++\n+The above example assumes that you extracted the {prodname} MySQL connector into the `/kafka/connect/debezium-connector-mysql` path.\n+\n+. Restart your Kafka Connect process. This ensures that the new JAR files are picked up.\n+\n+// Type: concept\n+// ModuleID: debezium-mysql-connector-configuration-example\n+// Title: {prodname} MySQL connector configuration example\n+[[mysql-example-configuration]]\n+=== Connector configuration example\n+\n+ifdef::community[]\n+Typically, you configure a {prodname} MySQL connector in a `.json` file that sets configuration properties for the connector. Following is an example configuration for a MySQL connector that connects to a MySQL server on port 3306 at 192.168.99.100, whose logical name is `fullfillment`.\n+\n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,json]\n+----\n+{\n+  \"name\": \"inventory-connector\", // <1>\n+  \"config\": {\n+    \"connector.class\": \"io.debezium.connector.mysql.MySqlConnector\", // <2>\n+    \"database.hostname\": \"192.168.99.100\", // <3>\n+    \"database.port\": \"3306\", // <4>\n+    \"database.user\": \"debezium-user\", // <5>\n+    \"database.password\": \"debezium-user-pw\", // <6>\n+    \"database.server.id\": \"184054\", <7>\n+    \"database.server.name\": \"fullfillment\", // <8>\n+    \"database.whitelist\": \"inventory\", // <9>\n+    \"database.history.kafka.bootstrap.servers\": \"kafka:9092\", // <10>\n+    \"database.history.kafka.topic\": \"dbhistory.fullfillment\", // <11>\n+    \"include.schema.changes\": \"true\" // <12>\n+  }\n+}\n+----\n+<1> Connector's name when registered with the Kafka Connect service.\n+<2> Connector's class name.\n+<3> MySQL server address.\n+<4> MySQL server port number.\n+<5> MySQL user with the appropriate privileges.\n+<6> MySQL user's password.\n+<7> Unique ID of the connector.\n+<8> Logical name of the MySQL server or cluster.\n+<9> List of databases hosted by the specified server.\n+<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database history topic.\n+<11> Name of the database history topic. This topic is for internal use only and should not be used by consumers. \n+<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers. \n+endif::community[]\n+\n+ifdef::product[]\n+\n+Typically, you configure a {prodname} MySQL connector in a `.yaml` file that sets connector configuration properties. Following is an example of the configuration for a MySQL connector that connects to a MySQL server on port 3306 and captures changes to the `inventory` database. \n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,yaml,options=\"nowrap\"]\n+----\n+  apiVersion: kafka.strimzi.io/v1beta1\n+  kind: KafkaConnector\n+  metadata:\n+    name: inventory-connector  // <1>\n+    labels:\n+      strimzi.io/cluster: my-connect-cluster\n+  spec:\n+    class: io.debezium.connector.mysql.MySqlConnector\n+    tasksMax: 1  // <2>\n+    config:  // <3>\n+      database.hostname: mysql  // <4>\n+      database.port: 3306\n+      database.user: debezium\n+      database.password: dbz\n+      database.server.id: 184054  // <5>\n+      database.server.name: dbserver1  // <5>\n+      database.whitelist: inventory  // <6>\n+      database.history.kafka.bootstrap.servers: my-cluster-kafka-bootstrap:9092  // <7>\n+      database.history.kafka.topic: schema-changes.inventory  // <7>\n+----\n+\n+.Descriptions of connector configuration settings\n+[cols=\"1,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Item |Description\n+\n+|1\n+|The name of the connector.\n+\n+|2\n+|Only one task should operate at any one time.\n+Because the MySQL connector reads the MySQL server\u2019s `binlog`,\n+using a single connector task ensures proper order and event handling.\n+The Kafka Connect service uses connectors to start one or more tasks that do the work,\n+and it automatically distributes the running tasks across the cluster of Kafka Connect services.\n+If any of the services stop or crash,\n+those tasks will be redistributed to running services.\n+\n+|3\n+|The connector\u2019s configuration.\n+\n+|4\n+|The database host, which is the name of the container running the MySQL server (`mysql`).\n+\n+|5\n+|A unique server ID and name.\n+The server name is the logical identifier for the MySQL server or cluster of servers.\n+This name is used as the prefix for all Kafka topics.\n+\n+|6\n+|Changes in only the `inventory` database are captured.\n+\n+|7\n+|The connector stores the history of the database schemas in Kafka using this broker (the same broker to which you are sending events) and topic name.\n+Upon restart, the connector recovers the schemas of the database that existed at the point in time in the binlog when the connector should begin reading.\n+\n+|===\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: adding-debezium-mysql-connector-configuration-to-kafka-connect\n+// Title: Adding {prodname} MySQL connector configuration to Kafka Connect\n+[[mysql-adding-configuration]]\n+=== Adding connector configuration \n+ifdef::community[]\n+To start running a MySQL connector, configure a connector and add the configuration to your Kafka Connect cluster. \n+\n+.Prerequisites\n+\n+* {link-prefix}:{link-mysql-connector}#setting-up-mysql[MySQL server] is \n+set up for a {prodname} connector.\n+\n+* {prodname} MySQL connector is installed. \n+\n+.Procedure\n+\n+. Create a configuration for the MySQL connector.\n+\n+. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster. \n+\n+endif::community[]\n+\n+ifdef::product[]\n+You can use a provided {prodname} container to deploy a {prodname} MySQL connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment. \n+\n+.Prerequisites\n+\n+* Podman or Docker is installed.\n+* You have sufficient rights to create and manage containers.\n+* You downloaded the {prodname} MySQL connector archive. \n+\n+.Procedure\n+\n+. Extract the {prodname} MySQL connector archive to create a directory structure for the connector plug-in, for example: \n++\n+[subs=\"+macros\"]\n+----\n+pass:quotes[*tree ./my-plugins/*]\n+./my-plugins/\n+\u251c\u2500\u2500 debezium-connector-mysql\n+\u2502   \u251c\u2500\u2500 ...\n+----\n+\n+. Create and publish a custom image for running your {prodname} connector:\n+\n+.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:\n++\n+[subs=\"+macros,+attributes\"]\n+----\n+FROM {DockerKafkaConnect}\n+USER root:root\n+pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]\n+USER 1001\n+----\n++\n+Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.\n+\n+.. Build the container image. For example, if you saved the `Dockerfile` that you created in the previous step as `debezium-container-for-mysql`, and if `Dockerfile` is in the current directory, then you would run the following command:\n++\n+`podman build -t debezium-container-for-mysql:latest .`\n+\n+.. Push your custom image to your container registry, for example:\n++\n+`podman push debezium-container-for-mysql:latest`\n+\n+.. Point to the new container image. Do one of the following:\n++\n+* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:\n++\n+[source,yaml,subs=\"+attributes\"]\n+----\n+apiVersion: {KafkaConnectApiVersion}\n+kind: KafkaConnector\n+metadata:\n+  name: my-connect-cluster\n+spec:\n+  #...\n+  image: debezium-container-for-mysql\n+----\n++\n+* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.\n+\n+. Create a `KafkaConnector` custom resource that defines your {prodname} MySQL connector instance. See {LinkDebeziumUserGuide}#mysql-example-configuration[the connector configuration example].\n+\n+. Apply the connector instance, for example: \n++\n+`oc apply -f inventory-connector.yaml`\n++\n+This registers `inventory-connector` and the connector starts to run against the `inventory` database.\n+\n+. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.\n+\n+.. Display the Kafka Connect log output:\n++\n+[source,shell,options=\"nowrap\"]\n+----\n+oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)\n+----\n+\n+.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines: \n++\n+[source,shell,options=\"nowrap\"]\n+----\n+... INFO Starting snapshot for ...\n+... INFO Snapshot is using user 'debezium' ... \n+----\n+\n+endif::product[]\n+\n+.Results\n+\n+When the connector starts, it {link-prefix}:{link-mysql-connector}#mysql-snapshots[performs a consistent snapshot] of the MySQL databases that the connector is configured for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics. \n+\n+// Type: reference\n+// ModuleID: descriptions-of-debezium-mysql-connector-configuration-properties\n+// Title: Description of {prodname} MySQL connector configuration properties\n+[[mysql-connector-properties]]\n+=== Connector properties\n+\n+The {prodname} MySQL connector has numerous configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:\n+\n+* xref:mysql-required-connector-configuration-properties[Required connector configuration properties]\n+* xref:mysql-advanced-connector-configuration-properties[Advanced connector configuration properties]\n+* xref:mysql-pass-through-configuration-properties[Pass-through configuration properties]\n+\n+[id=\"mysql-required-connector-configuration-properties\"]\n+The following configuration properties are _required_ unless a default value is available.\n+\n+.Required MySQL connector configuration properties\n+[cols=\"33%a,17%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Default |Description\n+\n+|[[mysql-property-name]]<<mysql-property-name, `name`>>\n+|\n+|Unique name for the connector. Attempting to register again with the same name fails. This property is required by all Kafka Connect connectors.\n+\n+|[[mysql-property-connector-class]]<<mysql-property-connector-class, `connector.class`>>\n+|\n+|The name of the Java class for the connector. Always specify  `io.debezium{zwsp}.connector.mysql.MySqlConnector` for the MySQL connector.\n+\n+|[[mysql-property-tasks-max]]<<mysql-property-tasks-max, `tasks.max`>>\n+|`1`\n+|The maximum number of tasks that should be created for this connector. The MySQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.\n+\n+|[[mysql-property-database-hostname]]<<mysql-property-database-hostname, `database.hostname`>>\n+|\n+|IP address or host name of the MySQL database server.\n+\n+|[[mysql-property-database-port]]<<mysql-property-database-port, `database.port`>>\n+|`3306`\n+|Integer port number of the MySQL database server.\n+\n+|[[mysql-property-database-user]]<<mysql-property-database-user, `database.user`>>\n+|\n+|Name of the MySQL database to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-password]]<<mysql-property-database-password, `database.password`>>\n+|\n+|Password to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-server-name]]<<mysql-property-database-server-name, `database.server.name`>>\n+|\n+|Logical name that identifies and provides a namespace for the particular MySQL database server/cluster in which {prodname} is capturing changes. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector.\n+Only alphanumeric characters and underscores are allowed in this name.\n+\n+|[[mysql-property-database-server-id]]<<mysql-property-database-server-id, `database.server.id`>>\n+|_random_\n+|A numeric ID of this database client, which must be unique across all currently-running database processes in the MySQL cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog. By default, a random number between 5400 and 6400 is generated, though the recommendation is to explicitly set a value.  \n+\n+|[[mysql-property-database-history-kafka-topic]]<<mysql-property-database-history-kafka-topic, `database.history.kafka{zwsp}.topic`>>\n+|\n+|The full name of the Kafka topic where the connector stores the database schema history.\n+\n+|[[mysql-property-database-history-kafka-bootstrap-servers]]<<mysql-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap{zwsp}.servers`>>\n+|\n+|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.\n+\n+|[[mysql-property-database-whitelist]]\n+[[mysql-property-database-include-list]]<<mysql-property-database-include-list, `database.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of the databases for which to capture changes. The connector does not capture changes in any database whose name is not in `database.include.list`. By default, the connector captures changes in all databases. \n+Do not also set the `database.exclude.list` connector confiuration property.\n+\n+|[[mysql-property-database-blacklist]]\n+[[mysql-property-database-exclude-list]]<<mysql-property-database-exclude-list, `database.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of databases for which you do not want to capture changes. The connector captures changes in any database whose name is not in the `database.exclude.list`. \n+Do not also set the `database.include.list` connector configuration property.\n+\n+|[[mysql-property-table-whitelist]]\n+[[mysql-property-table-include-list]]<<mysql-property-table-include-list, `table.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture. The connector does not capture changes in any table not included in `table.include.list`. Each identifier is of the form _databaseName_._tableName_. By default, the connector captures changes in every non-system table in each database whose changes are being captured.\n+Do not also specify the `table.exclude.list` connector configuration property.\n+\n+|[[mysql-property-table-blacklist]]\n+[[mysql-property-table-exclude-list]]<<mysql-property-table-exclude-list, `table.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture. The connector captures changes in any table not included in `table.exclude.list`. Each identifier is of the form _databaseName_._tableName_.\n+Do not also specify the `table.include.list` connector configuration property.\n+\n+|[[mysql-property-column-blacklist]]\n+[[mysql-property-column-exclude-list]]<<mysql-property-column-exclude-list, `column.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-include-list]]<<mysql-property-column-include-list, `column.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-truncate-to-length-chars]]<<mysql-property-column-truncate-to-length-chars, `column.truncate.to{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be truncated in the change event record values if the field values are longer than the specified number of characters. You can configure multiple properties with different lengths in a single configuration. The length must be a positive integer. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-with-length-chars]]<<mysql-property-column-mask-with-length-chars, `column.mask.with{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be replaced in the change event message values with a field value consisting of the specified number of asterisk (`*`) characters. You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-hash]]<<mysql-property-column-mask-hash, `column.mask{zwsp}.hash._hashAlgorithm_{zwsp}.with.salt._salt_`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in the change event record values. Pseudonyms consist of the hashed value obtained by applying the algorithm `_hashAlgorithm_` and salt `_salt_`. +\n+ +\n+Based on the hash function used, referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n+The hash result is automatically shortened to the length of the column. +\n+ +\n+You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. For example: +\n+ +\n+`column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName` +\n+ +\n+`CzQMA0cB5K` is a randomly selected salt.\n+ +\n+Depending on the configured `_hashAlgorithm_`, the selected `_salt_`, and the actual data set, the resulting masked data set might not be completely anonymized.\n+\n+|[[mysql-property-column-propagate-source-type]]<<mysql-property-column-propagate-source-type, `column.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+\n+`pass:[_]pass:[_]{prodname}.source.column.type` \n+\n+`pass:[_]pass:[_]{prodname}.source.column.length` \n+ \n+`pass:[_]pass:[_]{prodname}.source.column.scale` \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified names for columns are of one of these forms: \n+\n+_databaseName_._tableName_._columnName_ \n+\n+_databaseName_._schemaName_._tableName_._columnName_\n+\n+|[[mysql-property-datatype-propagate-source-type]]<<mysql-property-datatype-propagate-source-type, `datatype.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+ \n+`pass:[_]pass:[_]debezium.source.column.type`  \n+\n+`pass:[_]pass:[_]debezium.source.column.length`\n+\n+`pass:[_]pass:[_]debezium.source.column.scale`  \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified data type names are of one of these forms: \n+\n+_databaseName_._tableName_._typeName_ \n+\n+_databaseName_._schemaName_._tableName_._typeName_ \n+ \n+See {link-prefix}:{link-mysql-connector}#mysql-data-types[how MySQL connectors map data types] for the list of MySQL-specific data type names.\n+\n+|[[mysql-property-time-precision-mode]]<<mysql-property-time-precision-mode, `time.precision.mode`>>\n+|`adaptive_time{zwsp}_microseconds`\n+|Time, date, and timestamps can be represented with different kinds of precision, including: +\n+ +\n+`adaptive_time_microseconds` (the default) captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +\n+ +\n+ifdef::community[]\n+`adaptive` (deprecated) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +\n+endif::community[]\n+ +\n+`connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.\n+\n+|[[mysql-property-decimal-handling-mode]]<<mysql-property-decimal-handling-mode,`decimal.handling.mode`>>\n+|`precise`\n+|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +\n+ +\n+`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +\n+ +\n+`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +\n+ +\n+`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.\n+\n+|[[mysql-property-bigint-unsigned-handling-mode]]<<mysql-property-bigint-unsigned-handling-mode, `bigint.unsigned{zwsp}.handling.mode`>>\n+|`long`\n+|Specifies how BIGINT UNSIGNED columns should be represented in change events. Possible settings are: +\n+ +\n+ `long` represents values by using Java's `long`, which might not offer the precision but which is easy to use in consumers. `long` is usually the preferred setting. +\n+ +\n+`precise` uses `java.math.BigDecimal` to represent values, which are encoded in the change events by using a binary representation and Kafka Connect's `org.apache.kafka.connect.data.Decimal` type. Use this setting when working with values larger than 2^63, because these values cannot be conveyed by using `long`.\n+\n+|[[mysql-property-include-schema-changes]]<<mysql-property-include-schema-changes, `include.schema{zwsp}.changes`>>\n+|`true`\n+|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded by using a key that contains the database name and whose value includes the DDL statement(s). This is independent of how the connector internally records database history. \n+\n+|[[mysql-property-include-query]]<<mysql-property-include-query, `include.query`>>\n+|`false`\n+|Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +\n+ +\n+If you set this option to `true` then you must also configure MySQL with the `binlog_rows_query_log_events` option set to `ON`. When `include.query` is `true`, the query is not present for events that the snapshot process generates. +\n+ +\n+Setting `include.query`to `true` might expose tables or fields explicitly excluded or masked by including the original SQL statement in the change event. For this reason, the default setting is `false`.\n+\n+|[[mysql-property-event-processing-failure-handling-mode]]<<mysql-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to exceptions during deserialization of binlog events. +\n+ +\n+`fail` propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and then skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-inconsistent-schema-handling-mode]]<<mysql-property-inconsistent-schema-handling-mode, `inconsistent.schema{zwsp}.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to binlog events that relate to tables that are not present in internal schema representation. That is, the internal representation is not consistent with the database. +\n+ +\n+`fail` throws an exception that indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-max-queue-size]]<<mysql-property-max-queue-size, `max.queue.size`>>\n+|`8192`\n+|Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the binlog reader when, for example, writes to Kafka are slow or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified by the `max.batch.size` property.\n+\n+|[[mysql-property-max-batch-size]]<<mysql-property-max-batch-size, `max.batch.size`>>\n+|`2048`\n+|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.\n+\n+|[[mysql-property-poll-interval-ms]]<<mysql-property-poll-interval-ms, `poll.interval.ms`>>\n+|`1000`\n+|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.\n+\n+|[[mysql-property-connect-timeout-ms]]<<mysql-property-connect-timeout-ms, `connect.timeout.ms`>>\n+|`30000`\n+|A positive integer value that specifies the maximum time in milliseconds this connector should wait after trying to connect to the MySQL database server before timing out. Defaults to 30 seconds.\n+\n+|[[mysql-property-gtid-source-includes]]<<mysql-property-gtid-source-includes, `gtid.source.includes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that match one of these include patterns are used.\n+Do not also specify a setting for `gtid.source.excludes`.\n+\n+|[[mysql-property-gtid-source-excludes]]<<mysql-property-gtid-source-excludes, `gtid.source.excludes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that do not match any of these exclude patterns are used. Do not also specify a value for `gtid.source.includes`.\n+\n+ifdef::community[]\n+|[[mysql-property-gtid-new-channel-position]]<<mysql-property-gtid-new-channel-position, `gtid.new.channel.position`>> +\n+_deprecated and scheduled for removal_\n+|`earliest`\n+|When set to `latest`, when the connector sees a new GTID channel, it starts consuming from the last executed transaction in that GTID channel. If set to `earliest` (default), the connector starts reading that channel from the first available (not purged) GTID position. `earliest` is useful when you have an active-passive MySQL setup where {prodname} is connected to the primary server. In this case, during failover, the replica with the new UUID (and GTID channel) starts receiving writes before {prodname} is connected. These writes would be lost when using `latest`.\n+endif::community[]\n+\n+|[[mysql-property-tombstones-on-delete]]<<mysql-property-tombstones-on-delete, `tombstones.on.delete`>>\n+|`true`\n+|Controls whether a delete event is followed by a tombstone event. +\n+ +\n+`true`  - a delete operation is represented by a delete event and a subsequent tombstone event.  +\n+ +\n+`false` - only a delete event is emitted. +\n+ +\n+After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row. \n+\n+|[[mysql-property-message-key-columns]]<<mysql-property-message-key-columns, `message.key.columns`>>\n+|_empty string_\n+|A semicolon separated list of tables with regular expressions that match table column names. The connector maps values in matching columns to key fields in change event records that it sends to Kafka topics. This is useful when a table does not have a primary key, or when you want to order change event records in a Kafka topic according to a field that is not a primary key. +\n+ +\n+Separate entries with semicolons. Insert a colon between the fully-qualified table name and its regular expression. The format (shown with spaces for clarity only) is: +\n+ +\n+_database-name_ `.` _table-name_ `:` _regexp_ `;` ... +\n+ +\n+For example: +\n+ +\n+`dbA.table_a:regex_1;dbB.table_b:regex_2;dbC.table_c:regex_3` +\n+ +\n+If `table_a` has an `id` column, and `regex_1` is `^i` (matches any column that starts with `i`), the connector maps the value in the `id` column of `table_a` to a key field in change events that the connector sends to Kafka. \n+\n+|[[mysql-property-binary-handling-mode]]<<mysql-property-binary-handling-mode,`binary.handling.mode`>>\n+|bytes\n+|Specifies how binary columns, for example, `blob`, `binary`, `varbinary`, should be represented in change events. Possible settings:  +\n+ +\n+`bytes` represents binary data as a byte array. +\n+ +\n+`base64` represents binary data as a base64-encoded String. +\n+ +\n+`hex` represents binary data as a hex-encoded (base16) String.\n+\n+|===\n+\n+[id=\"mysql-advanced-connector-configuration-properties\"]\n+.Advanced MySQL connector configuration properties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NzQ5MQ=="}, "originalCommit": null, "originalPosition": 2214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg3NjAxOA==", "bodyText": "This is handled automatically by our CSS used by Antora in our website build process; so this is entirely transparent to your PR and only deals specifically with the upstream HTML generation step.", "url": "https://github.com/debezium/debezium/pull/1864#discussion_r499876018", "createdAt": "2020-10-05T21:13:49Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/mysql.adoc", "diffHunk": "@@ -6,20 +9,2563 @@\n :context: debezium\n \n [id=\"debezium-connector-for-mysql\"]\n-= {prodname} Connector for MySQL\n+= {prodname} connector for MySQL\n \n-MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas and the data within tables. MySQL uses the binlog for replication and recovery.\n+MySQL has a binary log (binlog) that records all operations in the order in which they are committed to the database. This includes changes to table schemas as well as changes to the data in tables. MySQL uses the binlog for replication and recovery.\n \n-The {prodname} MySQL connector reads the binlog and produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations and records the change events in a Kafka topic. Client applications read those Kafka topics.\n+The {prodname} MySQL connector reads the binlog, produces change events for row-level `INSERT`, `UPDATE`, and `DELETE` operations, and emits the change events to Kafka topics. Client applications read those Kafka topics.\n \n As MySQL is typically set up to purge binlogs after a specified period of time, the MySQL connector performs an initial _consistent snapshot_ of each of your databases. The MySQL connector reads the binlog from the point at which the snapshot was made.\n \n-The following sections provide more detailed information on how the {prodname} MySQL connector functions, instructs you on how to set it up, as well as deploy and troubleshoot the connector.\n+ifdef::product[]\n+Information and procedures for using a {prodname} MySQL connector are organized as follows:\n+\n+* xref:how-debezium-mysql-connectors-work[]\n+* xref:descriptions-of-debezium-mysql-connector-data-change-events[]\n+* xref:how-debezium-mysql-connectors-map-data-types[]\n+* xref:setting-up-mysql-to-run-a-debezium-connector[]\n+* xref:deploying-debezium-mysql-connectors[]\n+* xref:monitoring-debezium-mysql-connector-performance[]\n+* xref:how-debezium-mysql-connectors-handle-faults-and-problems[]\n+\n+endif::product[]\n+\n+// Type: assembly\n+// ModuleID: how-debezium-mysql-connectors-work\n+// Title: How {prodname} MySQL connectors work\n+[[how-the-mysql-connector-works]]\n+== How the connector works\n+\n+To optimally configure and run a {prodname} MySQL connector, it is helpful to understand how the connector tracks the structure of tables, exposes schema changes, performs snapshots, and determines Kafka topic names. An overview of the MySQL topologies that the connector supports is useful for planning your application. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:how-debezium-mysql-connectors-handle-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-expose-database-schema-changes[]\n+* xref:how-debezium-mysql-connectors-perform-database-snapshots[]\n+* xref:default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records[]\n+* xref:mysql-topologies-supported-by-debezium-connectors[]\n+\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-handle-database-schema-changes\n+// Title: How {prodname} MySQL connectors handle database schema changes\n+[[mysql-schema-history-topic]]\n+=== Schema history topic\n+\n+When a database client queries a database, the client uses the database\u2019s current schema. However, the database schema can be changed at any time, which means that the connector must be able to identify what the schema was at the time each insert, update, or delete operation was recorded. Also, a connector cannot just use the current schema because the connector might be processing events that are relatively old and may have been recorded before the tables' schemas were changed. \n+\n+To handle this, MySQL includes in the binlog not only the row-level changes to the data, but also the DDL statements that are applied to the database. As the connector reads the binlog and comes across these DDL statements, it parses them and updates an in-memory representation of each table\u2019s schema. The connector uses this schema representation to identify the structure of the tables at the time of each insert, update, or delete operation and to produce the appropriate change event. In a separate database history Kafka topic, the connector records all DDL statements along with the position in the binlog where each DDL statement appeared.\n+\n+When the connector restarts after having crashed or been stopped gracefully, the connector starts reading the binlog from a specific position, that is, from a specific point in time. The connector rebuilds the table structures that existed at this point in time by reading the database history Kafka topic and parsing all DDL statements up to the point in the binlog where the connector is starting.\n+\n+This database history topic is for connector use only. The connector can optionally See {link-prefix}:{link-mysql-connector}#mysql-schema-change-topic[emit schema change events to a different topic that is intended for consumer applications].\n+\n+When the MySQL connector captures changes in a table to which a schema change tool such as `gh-ost` or `pt-online-schema-change` is applied there are helper tables created during the migration process. The connector needs to be configured to capture change to these helper tables. If consumers do not need the records generated for helper tables then a simple message transform can be applied to filter them out.\n+\n+See {link-prefix}:{link-mysql-connector}#mysql-topic-names[default names for topics] that receive {prodname} event records.\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-expose-database-schema-changes\n+// Title: How {prodname} MySQL connectors expose database schema changes\n+[id=\"mysql-schema-change-topic\"]\n+=== Schema change topic\n+\n+You can configure a {prodname} MySQL connector to produce schema change events that include all DDL statements applied to databases in the MySQL server. The connector emits these events to a Kafka topic named _serverName_ where _serverName_ is the name of the connector as specified by the `database.server.name` connector configuration property.\n+\n+If you choose to use _schema change events_, ensure that you consume records from the schema change topic. The database history topic is for connector use only. \n+\n+IMPORTANT: A global order for events emitted to the schema change topic is vital. Therefore, you must not partition the database history topic. This means that you must specify a partition count of `1` when creating the database history topic. When relying on auto topic creation, make sure that Kafka\u2019s `num.partitions` configuration option, which specifies the default number of partitions, is set to `1`.\n+\n+Each record that the connector emits to the schema change topic contains a message key that includes the name of the connected database when the DDL statement was applied, for example: \n+\n+[source,json,subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeKey\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\"\n+  }\n+}\n+----\n+\n+The schema change event record value contains a structure that includes the DDL statements, the name of the database to which the statements were applied, and the position in the binlog where the statements appeared, for example: \n+\n+[source,json,subs=\"attributes\"]\n+----\n+{\n+  \"schema\": {\n+    \"type\": \"struct\",\n+    \"name\": \"io.debezium.connector.mysql.SchemaChangeValue\",\n+    \"optional\": false,\n+    \"fields\": [\n+      {\n+        \"field\": \"databaseName\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"ddl\",\n+        \"type\": \"string\",\n+        \"optional\": false\n+      },\n+      {\n+        \"field\": \"source\",\n+        \"type\": \"struct\",\n+        \"name\": \"io.debezium.connector.mysql.Source\",\n+        \"optional\": false,\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ]\n+      }\n+    ]\n+  },\n+  \"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(512), weight FLOAT ); ALTER TABLE products AUTO_INCREMENT = 101;\",\n+    \"source\" : {\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"server_id\": 0,\n+      \"ts_sec\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"snapshot\": true,\n+      \"thread\": null,\n+      \"db\": null,\n+      \"table\": null,\n+      \"query\": null\n+    }\n+  }\n+}\n+----\n+\n+The `ddl` field might contain multiple DDL statements. Each statement applies to the database in the `databaseName` field. The statements appear in the order in which they were applied to the database. The `source` field is structured exactly as a standard data change event written to table-specific topics. This field is useful to correlate events on different topics.\n+\n+[source,json,subs=\"+attributes\"]\n+----\n+....\n+\"payload\": {\n+    \"databaseName\": \"inventory\",\n+    \"ddl\": \"CREATE TABLE products ( id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,...)\",\n+    \"source\" : {\n+        ...\n+    }\n+}\n+....\n+----\n+\n+A client can submit multiple DDL statements to be applied to multiple databases. If MySQL applies them atomically, the connector takes the DDL statements in order, groups them by database, and creates a schema change event for each group. If MySQL applies them individually, the connector creates a separate schema change event for each statement.\n+\n+See also: {link-prefix}:{link-mysql-connector}#mysql-schema-history-topic[schema history topic].\n+\n+// Type: concept\n+// ModuleID: how-debezium-mysql-connectors-perform-database-snapshots\n+// Title: How {prodname} MySQL connectors perform database snapshots\n+[[mysql-snapshots]]\n+=== Snapshots\n+\n+When a {prodname} MySQL connector is first started, it performs an initial _consistent snapshot_ of your database. The following flow describes how the connector creates this snapshot. This flow is for the default snapshot mode, which is `initial`. For information about other snapshot modes, see the {link-prefix}:{link-mysql-connector}#mysql-property-snapshot-mode[MySQL connector `snapshot.mode` configuration property].\n+\n+.Workflow for performing an initial snapshot with a global read lock\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+a| Grabs a global read lock that blocks _writes_ by other database clients. +\n+ + \n+The snapshot itself does not prevent other clients from applying DDL that might interfere with the connector's attempt to read the binlog position and table schemas. The connector keeps the global read lock while it reads the binlog position, and releases the lock as described in a later step.\n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+a|Reads the current binlog position.\n+\n+|4\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes.\n+\n+|5\n+a|Releases the global read lock. Other database clients can now write to the database.\n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements. \n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+Connector restarts::\n+If the connector fails, stops, or is rebalanced while performing the _initial snapshot_, then after the connector restarts, it performs a new snapshot. After that _intial snapshot_ is completed, the {prodname} MySQL connector restarts from the same position in the binlog so it does not miss any updates.\n++\n+If the connector stops for long enough, MySQL could purge old binlog files and the connector's position would be lost. If the position is lost, the connector reverts to the _initial snapshot_ for its starting position. For more tips on troubleshooting the {prodname} MySQL connector, see {link-prefix}:{link-mysql-connector}#mysql-when-things-go-wrong[behavior when things go wrong].\n+\n+Global read locks not allowed::\n+Some environments do not allow global read locks. If the {prodname} MySQL connector detects that global read locks are not permitted, the connector uses table-level locks instead and performs a snapshot with this method. This requires the database user for the {prodname} connector to have `LOCK_TABLES` privileges. \n++\n+.Workflow for performing an initial snapshot with table-level locks\n+[cols=\"1,9\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Step |Action\n+\n+|1\n+|Obtains table-level locks. \n+\n+|2\n+a|Starts a transaction with link:https://dev.mysql.com/doc/refman/{mysql-version}/en/innodb-consistent-read.html[repeatable read semantics] to ensure that all subsequent reads within the transaction are done against the _consistent snapshot_.\n+\n+|3\n+|Reads and filters the names of the databases and tables.\n+\n+|4\n+a|Reads the current binlog position.\n+\n+|5\n+a|Reads the schema of the databases and tables for which the connector is configured to capture changes. \n+\n+|6\n+a|If applicable, writes the DDL changes to the schema change topic, including all necessary `DROP...` and `CREATE...` DDL statements.\n+\n+|7\n+a|Scans the database tables. For each row, the connector emits `CREATE` events to the relevant table-specific Kafka topics.\n+\n+|8\n+a|Commits the transaction.\n+\n+|9\n+|Releases the table-level locks.\n+\n+|10\n+a|Records the completed snapshot in the connector offsets.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: default-names-of-kafka-topics-that-receive-debezium-mysql-change-event-records\n+// Title: Default names of Kafka topics that receive {prodname} MySQL change event records\n+[[mysql-topic-names]]\n+=== Topic names\n+\n+The default behavior is that a {prodname} MySQL connector writes events for all `INSERT`, `UPDATE`, and `DELETE` operations in one table to one Kafka topic. The Kafka topic naming convention is as follows:\n+\n+_serverName.databaseName.tableName_\n+\n+Suppose that `fulfillment` is the server name, `inventory` is the database name, and the database contains tables named `orders`, `customers`, and `products`. The {prodname} MySQL connector emits events to three Kafka topics, one for each table in the database:\n+\n+----\n+fulfillment.inventory.orders\n+fulfillment.inventory.customers\n+fulfillment.inventory.products\n+----\n+\n+// Type: concept\n+// ModuleID: mysql-topologies-supported-by-debezium-connectors\n+// Title: MySQL topologies supported by {prodname} connectors\n+[id=\"supported-mysql-topologies\"]\n+=== Supported MySQL topologies\n+\n+The {prodname} MySQL connector supports the following MySQL topologies:\n+\n+Standalone::\n+When a single MySQL server is used, the server must have the binlog enabled (_and optionally GTIDs enabled_) so the {prodname} MySQL connector can monitor the server. This is often acceptable, since the binary log can also be used as an incremental link:https://dev.mysql.com/doc/refman/{mysql-version}/en/backup-methods.html[backup]. In this case, the MySQL connector always connects to and follows this standalone MySQL server instance.\n+\n+Primary and replica::\n+The {prodname} MySQL connector can follow one of the primary servers or one of the replicas (_if that replica has its binlog enabled_), but the connector sees changes in only the cluster that is visible to that server. Generally, this is not a problem except for the multi-primary topologies.\n++\n+The connector records its position in the server\u2019s binlog, which is different on each server in the cluster. Therefore, the connector must follow just one MySQL server instance. If that server fails, that server must be restarted or recovered before the connector can continue.\n+\n+High available clusters::\n+A variety of link:https://dev.mysql.com/doc/mysql-ha-scalability/en/[high availability] solutions exist for MySQL, and they make it significantly easier to tolerate and almost immediately recover from problems and failures. Most HA MySQL clusters use GTIDs so that replicas are able to keep track of all changes on any of the primary servers.\n+\n+Multi-primary::\n+link:https://dev.mysql.com/doc/refman/{mysql-version}/en/mysql-cluster-replication-multi-source.html[Network Database (NDB) cluster replication] uses one or more MySQL replica nodes that each replicate from multiple primary servers. This is a powerful way to aggregate the replication of multiple MySQL clusters. This topology requires the use of GTIDs.\n++\n+A {prodname} MySQL connector can use these multi-primary MySQL replicas as sources, and can fail over to different multi-primary MySQL replicas as long as the new replica is caught up to the old replica. That is, the new replica has all transactions that were seen on the first replica. This works even if the connector is using only a subset of databases and/or tables, as the connector can be configured to include or exclude specific GTID sources when attempting to reconnect to a new multi-primary MySQL replica and find the correct position in the binlog.\n+\n+Hosted::\n+There is support for the {prodname} MySQL connector to use hosted options such as Amazon RDS and Amazon Aurora.\n++\n+Because these hosted options do not allow a global read lock, table-level locks are used to create the _consistent snapshot_.\n+\n+// Type: assembly\n+// ModuleID: descriptions-of-debezium-mysql-connector-data-change-events\n+// Title: Descriptions of {prodname} MySQL connector data change events\n+[[mysql-events]]\n+== Data change events\n+\n+The {prodname} MySQL connector generates a data change event for each row-level `INSERT`, `UPDATE`, and `DELETE` operation. Each event contains a key and a value. The structure of the key and the value depends on the table that was changed. \n+\n+{prodname} and Kafka Connect are designed around _continuous streams of event messages_. However, the structure of these events may change over time, which can be difficult for consumers to handle. To address this, each event contains the schema for its content or, if you are using a schema registry, a schema ID that a consumer can use to obtain the schema from the registry. This makes each event self-contained. \n+\n+The following skeleton JSON shows the basic four parts of a change event. However, how you configure the Kafka Connect converter that you choose to use in your application determines the representation of these four parts in change events. A `schema` field is in a change event only when you configure the converter to produce it. Likewise, the event key and event payload are in a change event only if you configure a converter to produce it. If you use the JSON converver and you configure it to produce all four basic change event parts, change events have this structure: \n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { //<1>\n+   ...\n+  },\n+ \"payload\": { //<2>\n+   ...\n+ },\n+ \"schema\": { //<3> \n+   ...\n+ },\n+ \"payload\": { //<4>\n+   ...\n+ },\n+}\n+----\n+\n+.Overview of change event basic content\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The first `schema` field is part of the event key. It specifies a Kafka Connect schema that describes what is in the event key's `payload` portion. In other words, the first `schema` field describes the structure of the primary key, or the unique key if the table does not have a primary key, for the table that was changed. +\n+ +\n+It is possible to override the table's primary key by setting the {link-prefix}:{link-mysql-connector}#mysql-property-message-key-columns[`message.key.columns` connector configuration property]. In this case, the first schema field describes the structure of the key identified by that property.\n+\n+|2\n+|`payload`\n+|The first `payload` field is part of the event key. It has the structure described by the previous `schema` field and it contains the key for the row that was changed. \n+\n+|3\n+|`schema`\n+|The second `schema` field is part of the event value. It specifies the Kafka Connect schema that describes what is in the event value's `payload` portion. In other words, the second `schema` describes the structure of the row that was changed. Typically, this schema contains nested schemas. \n+\n+|4\n+|`payload`\n+|The second `payload` field is part of the event value. It has the structure described by the previous `schema` field and it contains the actual data for the row that was changed.\n+\n+|===\n+\n+By default, the connector streams change event records to topics with names that are the same as the event's originating table. See {link-prefix}:{link-mysql-connector}#mysql-topic-names[topic names].\n+\n+[WARNING]\n+====\n+The MySQL connector ensures that all Kafka Connect schema names adhere to the link:http://avro.apache.org/docs/current/spec.html#names[Avro schema name format]. This means that the logical server name must start with a Latin letter or an underscore, that is, a-z, A-Z, or pass:[_]. Each remaining character in the logical server name and each character in the database and table names must be a Latin letter, a digit, or an underscore, that is, a-z, A-Z, 0-9, or pass:[_]. If there is an invalid character it is replaced with an underscore character.\n+\n+This can lead to unexpected conflicts if the logical server name, a database name, or a table name contains invalid characters, and the only characters that distinguish names from one another are invalid and thus replaced with underscores.\n+====\n+\n+ifdef::product[]\n+More details are in the following topics:\n+\n+* xref:about-keys-in-debezium-mysql-change-events[]\n+* xref:about-values-in-debezium-mysql-change-events[]\n+endif::product[]\n+\n+// Type: concept\n+// ModuleID: about-keys-in-debezium-mysql-change-events\n+// Title: About keys in {prodname} mysql change events\n+[[mysql-change-event-keys]]\n+=== Change event keys\n+\n+A change event's key contains the schema for the changed table's key and the changed row's actual key. Both the schema and its corresponding payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n+\n+Consider the following `customers` table, which is followed by an example of a change event key for this table. \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+Every change event that captures a change to the `customers` table has the same event key schema. For as long as the `customers` table has the previous definition, every change event that captures a change to the `customers` table has the following key structure. In JSON, it looks like this:\n+\n+[source,json,index=0]\n+----\n+{\n+ \"schema\": { <1>\n+    \"type\": \"struct\",\n+    \"name\": \"mysql-server-1.inventory.customers.Key\", <2>\n+    \"optional\": false, <3>\n+    \"fields\": [ <4>\n+      {\n+        \"field\": \"id\",\n+        \"type\": \"int32\",\n+        \"optional\": false\n+      }\n+    ]\n+  },\n+ \"payload\": { <5>\n+    \"id\": 1001\n+  }\n+}\n+----\n+\n+.Description of change event key\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The schema portion of the key specifies a Kafka Connect schema that describes what is in the key's `payload` portion. \n+\n+|2\n+|`mysql-server-1.inventory.customers.Key`\n+a|Name of the schema that defines the structure of the key's payload. This schema describes the structure of the primary key for the table that was changed. Key schema names have the format _connector-name_._database-name_._table-name_.`Key`. In this example: + \n+\n+* `mysql-server-1` is the name of the connector that generated this event. + \n+* `inventory` is the database that contains the table that was changed. +\n+* `customers` is the table that was updated.\n+\n+|3\n+|`optional`\n+|Indicates whether the event key must contain a value in its `payload` field. In this example, a value in the key's payload is required. A value in the key's payload field is optional when a table does not have a primary key.\n+\n+|4\n+|`fields` \n+|Specifies each field that is expected in the `payload`, including each field's name, type, and whether it is required.\n+\n+|5\n+|`payload`\n+|Contains the key for the row for which this change event was generated. In this example, the key, contains a single `id` field whose value is `1001`.\n+\n+|===\n+\n+// Type: concept\n+// ModuleID: about-values-in-debezium-mysql-change-events\n+// Title: About values in {prodname} MySQL change events\n+[[mysql-change-event-values]]\n+=== Change event values\n+\n+The value in a change event is a bit more complicated than the key. Like the key, the value has a `schema` section and a `payload` section. The `schema` section contains the schema that describes the `Envelope` structure of the `payload` section, including its nested fields. Change events for operations that create, update or delete data all have a value payload with an envelope structure. \n+\n+Consider the same sample table that was used to show an example of a change event key: \n+\n+[source,sql]\n+----\n+CREATE TABLE customers (\n+  id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,\n+  first_name VARCHAR(255) NOT NULL,\n+  last_name VARCHAR(255) NOT NULL,\n+  email VARCHAR(255) NOT NULL UNIQUE KEY\n+) AUTO_INCREMENT=1001;\n+----\n+\n+The value portion of a change event for a change to this table is described for: \n+\n+* <<mysql-create-events,_create_ events>>\n+* <<mysql-update-events,_update_ events>>\n+* <<mysql-primary-key-updates,Primary key updates>>\n+* <<mysql-delete-events,_delete_ events>>\n+* <<mysql-tombstone-events,Tombstone events>>\n+\n+// Type: continue\n+[id=\"mysql-create-events\"]\n+=== _create_ events\n+\n+The following example shows the value portion of a change event that the connector generates for an operation that creates data in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { // <1>\n+    \"type\": \"struct\",\n+    \"fields\": [\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", // <2>\n+        \"field\": \"before\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"first_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"last_name\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"email\"\n+          }\n+        ],\n+        \"optional\": true,\n+        \"name\": \"mysql-server-1.inventory.customers.Value\", \n+        \"field\": \"after\"\n+      },\n+      {\n+        \"type\": \"struct\",\n+        \"fields\": [\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"version\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"connector\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"name\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"ts_sec\"\n+          },\n+          {\n+            \"type\": \"boolean\",\n+            \"optional\": true,\n+            \"default\": false,\n+            \"field\": \"snapshot\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"db\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"table\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"server_id\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"gtid\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": false,\n+            \"field\": \"file\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": false,\n+            \"field\": \"pos\"\n+          },\n+          {\n+            \"type\": \"int32\",\n+            \"optional\": false,\n+            \"field\": \"row\"\n+          },\n+          {\n+            \"type\": \"int64\",\n+            \"optional\": true,\n+            \"field\": \"thread\"\n+          },\n+          {\n+            \"type\": \"string\",\n+            \"optional\": true,\n+            \"field\": \"query\"\n+          }\n+        ],\n+        \"optional\": false,\n+        \"name\": \"io.debezium.connector.mysql.Source\", // <3>\n+        \"field\": \"source\"\n+      },\n+      {\n+        \"type\": \"string\",\n+        \"optional\": false,\n+        \"field\": \"op\"\n+      },\n+      {\n+        \"type\": \"int64\",\n+        \"optional\": true,\n+        \"field\": \"ts_ms\"\n+      }\n+    ],\n+    \"optional\": false,\n+    \"name\": \"mysql-server-1.inventory.customers.Envelope\" // <4>\n+  },\n+  \"payload\": { // <5>\n+    \"op\": \"c\", // <6>\n+    \"ts_ms\": 1465491411815, // <7>\n+    \"before\": null, // <8>\n+    \"after\": { // <9>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <10>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 0,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 0,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 154,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"INSERT INTO customers (first_name, last_name, email) VALUES ('Anne', 'Kretchmar', 'annek@noanswer.org')\"\n+    }\n+  }\n+}\n+----\n+\n+.Descriptions of _create_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`schema`\n+|The value's schema, which describes the structure of the value's payload. A change event's value schema is the same in every change event that the connector generates for a particular table. \n+\n+|2\n+|`name`\n+a|In the `schema` section, each `name` field specifies the schema for a field in the value's payload. +\n+ +\n+`mysql-server-1.inventory.customers.Value` is the schema for the payload's `before` and `after` fields. This schema is specific to the `customers` table. +\n+ +\n+Names of schemas for `before` and `after` fields are of the form `_logicalName_._tableName_.Value`, which ensures that the schema name is unique in the database. This means that when using the {link-prefix}:{link-avro-serialization}[Avro converter], the resulting Avro schema for each table in each logical source has its own evolution and history.\n+\n+|3\n+|`name`\n+|`io.debezium.connector.mysql.Source` is the schema for the payload's `source` field. This schema is specific to the MySQL connector. The connector uses it for all events that it generates. \n+\n+|4\n+|`name`\n+|`mysql-server-1.inventory.customers.Envelope` is the schema for the overall structure of the payload, where `mysql-server-1` is the connector name, `inventory` is the database, and `customers` is the table.\n+\n+|5\n+|`payload`\n+|The value's actual data. This is the information that the change event is providing. +\n+ +\n+It may appear that the JSON representations of the events are much larger than the rows they describe. This is because the JSON representation must include the schema and the payload portions of the message.\n+However, by using the {link-prefix}:{link-avro-serialization}[Avro converter], you can significantly decrease the size of the messages that the connector streams to Kafka topics.\n+\n+|6\n+|`op`\n+a| Mandatory string that describes the type of operation that caused the connector to generate the event. In this example, `c` indicates that the operation created a row. Valid values are: \n+\n+* `c` = create\n+* `u` = update\n+* `d` = delete\n+* `r` = read (applies to only snapshots)\n+\n+|7\n+|`ts_ms`\n+a| Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|8\n+|`before`\n+| An optional field that specifies the state of the row before the event occurred. When the `op` field is `c` for create, as it is in this example, the `before` field is `null` since this change event is for new content. \n+\n+|9\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. In this example, the `after` field contains the values of the new row's `id`, `first_name`, `last_name`, and `email` columns.\n+\n+|10\n+|`source`\n+a| Mandatory field that describes the source metadata for the event. This field contains information that you can use to compare this event with other events, with regard to the origin of the events, the order in which the events occurred, and whether events were part of the same transaction. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the new row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|===\n+\n+// Type: continue\n+[id=\"mysql-update-events\"]\n+=== _update_ events\n+\n+The value of a change event for an update in the sample `customers` table has the same schema as a _create_ event for that table. Likewise, the event value's payload has the same structure. However, the event value payload contains different values in an _update_ event. Here is an example of a change event value in an event that the connector generates for an update in the `customers` table: \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": { // <2>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"name\": \"mysql-server-1\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 484,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"UPDATE customers SET first_name='Anne Marie' WHERE id=1004\"\n+    },\n+    \"op\": \"u\", // <4>\n+    \"ts_ms\": 1465581029523 \n+  }\n+}\n+----\n+\n+.Descriptions of _update_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|An optional field that specifies the state of the row before the event occurred. In an _update_ event value, the `before` field contains a field for each table column and the value that was in that column before the database commit. In this example, the `first_name` value is `Anne.`\n+\n+|2\n+|`after`\n+| An optional field that specifies the state of the row after the event occurred. You can compare the `before` and `after` structures to determine what the update to this row was. In the example, the `first_name` value is now `Anne Marie`. \n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. The `source` field structure has the same fields as in a _create_ event, but some values are different, for example, the sample _update_ event is from a different position in the binlog. The source metadata includes: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. In an _update_ event value, the `op` field value is `u`, signifying that this row changed because of an update.\n+\n+|===\n+\n+[NOTE]\n+====\n+Updating the columns for a row's primary/unique key changes the value of the row's key. When a key changes, {prodname} outputs _three_ events: a `DELETE` event and a {link-prefix}:{link-mysql-connector}#mysql-tombstone-events[tombstone event] with the old key for the row, followed by an event with the new key for the row. Details are in the next section. \n+====\n+\n+// Type: continue\n+[id=\"mysql-primary-key-updates\"]\n+=== Primary key updates\n+\n+An `UPDATE` operation that changes a row's primary key field(s) is known\n+as a primary key change. For a primary key change, in place of an `UPDATE` event record, the connector emits a `DELETE` event record for the old key and a `CREATE` event record for the new (updated) key. These events have the usual structure and content, and in addition, each one has a message header related to the primary key change: \n+\n+* The `DELETE` event record has `__debezium.newkey` as a message header. The value of this header is the new primary key for the updated row.\n+\n+* The `CREATE` event record has `__debezium.oldkey` as a message header. The value of this header is the previous (old) primary key that the updated row had.\n+\n+// Type: continue\n+[id=\"mysql-delete-events\"]\n+=== _delete_ events\n+\n+The value in a _delete_ change event has the same `schema` portion as _create_ and _update_ events for the same table. The `payload` portion in a _delete_ event for the sample `customers` table looks like this:  \n+\n+[source,json,options=\"nowrap\",subs=\"+attributes\"]\n+----\n+{\n+  \"schema\": { ... },\n+  \"payload\": {\n+    \"before\": { // <1>\n+      \"id\": 1004,\n+      \"first_name\": \"Anne Marie\",\n+      \"last_name\": \"Kretchmar\",\n+      \"email\": \"annek@noanswer.org\"\n+    },\n+    \"after\": null, // <2>\n+    \"source\": { // <3>\n+      \"version\": \"{debezium-version}\",\n+      \"connector\": \"mysql\",\n+      \"name\": \"mysql-server-1\",\n+      \"ts_sec\": 1465581,\n+      \"snapshot\": false,\n+      \"db\": \"inventory\",\n+      \"table\": \"customers\",\n+      \"server_id\": 223344,\n+      \"gtid\": null,\n+      \"file\": \"mysql-bin.000003\",\n+      \"pos\": 805,\n+      \"row\": 0,\n+      \"thread\": 7,\n+      \"query\": \"DELETE FROM customers WHERE id=1004\"\n+    },\n+    \"op\": \"d\", // <4>\n+    \"ts_ms\": 1465581902461 // <5>\n+  }\n+}\n+----\n+\n+.Descriptions of _delete_ event value fields\n+[cols=\"1,2,7\",options=\"header\"]\n+|===\n+|Item |Field name |Description\n+\n+|1\n+|`before`\n+|Optional field that specifies the state of the row before the event occurred. In a _delete_ event value, the `before` field contains the values that were in the row before it was deleted with the database commit.\n+\n+|2\n+|`after`\n+| Optional field that specifies the state of the row after the event occurred. In a _delete_ event value, the `after` field is `null`, signifying that the row no longer exists.\n+\n+|3\n+|`source`\n+a|Mandatory field that describes the source metadata for the event. In a _delete_ event value, the `source` field structure is the same as for _create_ and _update_ events for the same table. Many `source` field values are also the same. In a _delete_ event value, the `ts_ms` and `pos` field values, as well as other values, might have changed. But the `source` field in a _delete_ event value provides the same metadata: \n+\n+* {prodname} version\n+* Connector name\n+* binlog name where the event was recorded\n+* binlog position\n+* Row within the event\n+* If the event was part of a snapshot\n+* Name of the database and table that contain the updated row\n+* ID of the MySQL thread that created the event (non-snapshot only)\n+* MySQL server ID (if available)\n+* Timestamp\n+\n+If the {link-prefix}:{link-mysql-connector}#enable-query-log-events[`binlog_rows_query_log_events`] MySQL configuration option is enabled and the connector configuration `include.query` property is enabled, the `source` field also provides the `query` field, which contains the original SQL statement that caused the change event.\n+\n+|4\n+|`op`\n+a|Mandatory string that describes the type of operation. The `op` field value is `d`, signifying that this row was deleted.\n+\n+|5\n+|`ts_ms`\n+a|Optional field that displays the time at which the connector processed the event. The time is based on the system clock in the JVM running the Kafka Connect task.\n+\n+|===\n+\n+A _delete_ change event record provides a consumer with the information it needs to process the removal of this row. The old values are included because some consumers might require them in order to properly handle the removal.\n+\n+MySQL connector events are designed to work with link:{link-kafka-docs}/#compaction[Kafka log compaction]. Log compaction enables removal of some older messages as long as at least the most recent message for every key is kept. This lets Kafka reclaim storage space while ensuring that the topic contains a complete data set and can be used for reloading key-based state.\n+\n+// Type: continue\n+[id=\"mysql-tombstone-events\"]\n+=== Tombstone events\n+When a row is deleted, the _delete_ event value still works with log compaction, because Kafka can remove all earlier messages that have that same key. However, for Kafka to remove all messages that have that same key, the message value must be `null`. To make this possible, after {prodname}\u2019s MySQL connector emits a _delete_ event, the connector emits a special tombstone event that has the same key but a `null` value.\n+\n+// Type: reference\n+// ModuleID: how-debezium-mysql-connectors-map-data-types\n+// Title: How {prodname} MySQL connectors map data types\n+[[mysql-data-types]]\n+== Data type mappings\n+\n+The {prodname} MySQL connector represents changes to rows with events that are structured like the table in which the row exists. The event contains a field for each column value. The MySQL data type of that column dictates how {prodname} represents the value in the event.\n+\n+Columns that store strings are defined in MySQL with a character set and collation. The MySQL connector uses the column's character set when reading the binary representation of the column values in the binlog events. \n+\n+The connector can map MySQL data types to both _literal_ and _semantic_ types.\n+\n+* *Literal type*: how the value is represented using Kafka Connect schema types\n+* *Semantic type*: how the Kafka Connect schema captures the meaning of the field (schema name)\n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:mysql-basic-types[]\n+* xref:mysql-temporal-types[]\n+* xref:mysql-decimal-types[]\n+* xref:mysql-boolean-values[]\n+* xref:mysql-spatial-types[]\n+\n+endif::product[]\n+\n+[id=\"mysql-basic-types\"]\n+=== Basic types\n+\n+The following table shows how the connector maps basic MySQL data types.\n+\n+.Descriptions of basic type mappings\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`BOOLEAN, BOOL`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(1)`\n+|`BOOLEAN`\n+a|_n/a_\n+\n+|`BIT(>1)`\n+|`BYTES`\n+a|`io.debezium.data.Bits` +\n+The `length` schema parameter contains an integer that represents the number of bits. The `byte[]` contains the bits in _little-endian_ form and is sized to contain the specified number of bits. For example, where `n` is bits: +\n+`numBytes = n/8 + (n%8== 0 ? 0 : 1)`\n+\n+|`TINYINT`\n+|`INT16`\n+a|_n/a_\n+\n+|`SMALLINT[(M)]`\n+|`INT16`\n+a|_n/a_\n+\n+|`MEDIUMINT[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`INT, INTEGER[(M)]`\n+|`INT32`\n+a|_n/a_\n+\n+|`BIGINT[(M)]`\n+|`INT64`\n+a|_n/a_\n+\n+|`REAL[(M,D)]`\n+|`FLOAT32`\n+a|_n/a_\n+\n+|`FLOAT[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DOUBLE[(M,D)]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`CHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`VARCHAR(M)]`\n+|`STRING`\n+a|_n/a_\n+\n+|`BINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`VARBINARY(M)]`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TINYTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`BLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`TEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`MEDIUMBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`MEDIUMTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`LONGBLOB`\n+|`BYTES` or `STRING`\n+a|_n/a_ +\n+Either the raw bytes (the default), a base64-encoded String, or a hex-encoded String, based on the {link-prefix}:{link-mysql-connector}#mysql-property-binary-handling-mode[`binary.handling.mode`] connector configuration property setting.\n+\n+|`LONGTEXT`\n+|`STRING`\n+a|_n/a_\n+\n+|`JSON`\n+|`STRING`\n+a|`io.debezium.data.Json` +\n+Contains the string representation of a `JSON` document, array, or scalar.\n+\n+|`ENUM`\n+|`STRING`\n+a|`io.debezium.data.Enum` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`SET`\n+|`STRING`\n+a|`io.debezium.data.EnumSet` +\n+The `allowed` schema parameter contains the comma-separated list of allowed values.\n+\n+|`YEAR[(2\\|4)]`\n+|`INT32`\n+|`io.debezium.time.Year`\n+\n+|`TIMESTAMP[(M)]`\n+|`STRING`\n+a|`io.debezium.time.ZonedTimestamp` +\n+In link:https://www.iso.org/iso-8601-date-and-time-format.html[ISO 8601] format with microsecond precision. MySQL allows `M` to be in the range of `0-6`.\n+\n+|===\n+\n+[id=\"mysql-temporal-types\"]\n+=== Temporal types\n+\n+Excluding the `TIMESTAMP` data type, MySQL temporal types depend on the value of the `time.precision.mode` connector configuration property. For `TIMESTAMP` columns whose default value is specified as `CURRENT_TIMESTAMP` or `NOW`, the value `1970-01-01 00:00:00` is used as the default value in the Kafka Connect schema. \n+\n+MySQL allows zero-values for `DATE, `DATETIME`, and `TIMESTAMP` columns because zero-values are sometimes preferred over null values. The MySQL connector represents zero-values as null values when the column definition allows null values, or as the epoch day when the column does not allow null values.\n+\n+.Temporal values without time zones\n+The `DATETIME` type represents a local date and time such as \"2018-01-13 09:48:27\". As you can see, there is no time zone information. Such columns are converted into epoch milliseconds or microseconds based on the column\u2019s precision by using UTC. The `TIMESTAMP` type represents a timestamp without time zone information. It is converted by MySQL from the server (or session\u2019s) current time zone into UTC when writing and from UTC into the server (or session's) current time zone when reading back the value. For example:\n+\n+* `DATETIME` with a value of `2018-06-20 06:37:03` becomes `1529476623000`.\n+* `TIMESTAMP` with a value of `2018-06-20 06:37:03` becomes `2018-06-20T13:37:03Z`.\n+\n+Such columns are converted into an equivalent `io.debezium.time.ZonedTimestamp` in UTC based on the server (or session\u2019s) current time zone. The time zone will be queried from the server by default. If this fails, it must be specified explicitly by the database `serverTimezone` MySQL configuration option. For example, if the database\u2019s time zone (either globally or configured for the connector by means of the `serverTimezone` option) is \"America/Los_Angeles\", the TIMESTAMP value \"2018-06-20 06:37:03\" is represented by a `ZonedTimestamp` with the value \"2018-06-20T13:37:03Z\".\n+\n+The time zone of the JVM running Kafka Connect and Debezium does not affect these conversions.\n+\n+More details about properties related to termporal values are in the documentation for {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+time.precision.mode=adaptive_time_microseconds(default)::\n+The MySQL connector determines the literal type and semantic type based on the column's data type definition so that events represent exactly the values in the database. All time fields are in microseconds. Only positive `TIME` field values in the range of `00:00:00.000000` to `23:59:59.999999` can be captured correctly.\n++\n+.Mappings when `time.precision.mode=adaptive_time_microseconds`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`io.debezium.time.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`io.debezium.time.MicroTime` +\n+Represents the time value in microseconds and does not include time zone information. MySQL allows `M` to be in the range of `0-6`.\n+\n+|`DATETIME, DATETIME(0), DATETIME(1), DATETIME(2), DATETIME(3)`\n+|`INT64`\n+a|`io.debezium.time.Timestamp` +\n+Represents the number of milliseconds past the epoch and does not include time zone information.\n+\n+|`DATETIME(4), DATETIME(5), DATETIME(6)`\n+|`INT64`\n+a|`io.debezium.time.MicroTimestamp` +\n+Represents the number of microseconds past the epoch and does not include time zone information.\n+\n+|===\n+\n+time.precision.mode=connect::\n+The MySQL connector uses defined Kafka Connect logical types. This approach is less precise than the default approach and the events could be less precise if the database column has a _fractional second precision_ value of greater than `3`. Values in only the range of `00:00:00.000` to `23:59:59.999` can be handled. Set `time.precision.mode=connect` only if you can ensure that the `TIME` values in your tables never exceed the supported ranges. The `connect` setting is expected to be removed in a future version of {prodname}.\n++\n+.Mappings when `time.precision.mode=connect`\n+[cols=\"25%a,20%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`DATE`\n+|`INT32`\n+a|`org.apache.kafka.connect.data.Date` +\n+Represents the number of days since the epoch.\n+\n+|`TIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Time` +\n+Represents the time value in microseconds since midnight and does not include time zone information.\n+\n+|`DATETIME[(M)]`\n+|`INT64`\n+a|`org.apache.kafka.connect.data.Timestamp` +\n+Represents the number of milliseconds since the epoch, and does not include time zone information.\n+\n+|===\n+\n+[id=\"mysql-decimal-types\"]\n+=== Decimal types\n+\n+{prodname} connectors handle decimals according to the setting of the {link-prefix}:{link-mysql-connector}#mysql-property-decimal-handling-mode[`decimal.handling.mode` connector configuration property]. \n+\n+decimal.handling.mode=precise::\n++\n+.Mappings when `decimal.handing.mode=precise`\n+[cols=\"30%a,15%a,55%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|`DECIMAL[(M[,D])]`\n+|`BYTES`\n+a|`org.apache.kafka.connect.data.Decimal` +\n+The `scale` schema parameter contains an integer that represents how many digits the decimal point shifted.\n+\n+|===\n+\n+decimal.handling.mode=double::\n++\n+.Mappings when `decimal.handing.mode=double`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`FLOAT64`\n+a|_n/a_\n+\n+|===\n+\n+decimal.handling.mode=string::\n++\n+.Mappings when `decimal.handing.mode=string`\n+[cols=\"30%a,30%a,40%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`NUMERIC[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|`DECIMAL[(M[,D])]`\n+|`STRING`\n+a|_n/a_\n+\n+|===\n+\n+[id=\"mysql-boolean-values\"]\n+=== Boolean values\n+\n+MySQL handles the `BOOLEAN` value internally in a specific way.\n+The `BOOLEAN` column is internally mapped to the `TINYINT(1)` data type.\n+When the table is created during streaming then it uses proper `BOOLEAN` mapping as {prodname} receives the original DDL.\n+During snapshots, {prodname} executes `SHOW CREATE TABLE` to obtain table definitions that return `TINYINT(1)` for both `BOOLEAN` and `TINYINT(1)` columns. {prodname} then has no way to obtain the original type mapping and so maps to `TINYINT(1)`.\n+\n+ifdef::community[]\n+The operator can configure the out-of-the-box {link-prefix}:{link-custom-converters}[`TinyIntOneToBooleanConverter` custom converter] that would either map all `TINYINT(1)` columns to `BOOLEAN` or if the `selector` parameter is set then a subset of columns could be enumerated using comma-separated regular expressions.\n+endif::community[]\n+\n+Following is an example configuration:\n+\n+----\n+converters=boolean\n+boolean.type=io.debezium.connector.mysql.converters.TinyIntOneToBooleanConverter\n+boolean.selector=db1.table1.*, db1.table2.column1\n+----\n+\n+[id=\"mysql-spatial-types\"]\n+=== Spatial types\n+\n+Currently, the {prodname} MySQL connector supports the following spatial data types.\n+\n+.Description of spatial type mappings\n+[cols=\"35%a,15%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|MySQL type |Literal type |Semantic type\n+\n+|`GEOMETRY, +\n+LINESTRING, +\n+POLYGON, +\n+MULTIPOINT, +\n+MULTILINESTRING, +\n+MULTIPOLYGON, +\n+GEOMETRYCOLLECTION`\n+|`STRUCT`\n+a|`io.debezium.data.geometry.Geometry` +\n+Contains a structure with two fields:\n+\n+* `srid (INT32`: spatial reference system ID that defines the type of geometry object stored in the structure\n+* `wkb (BYTES)`: binary representation of the geometry object encoded in the Well-Known-Binary (wkb) format. See the link:https://www.opengeospatial.org/standards/sfa[Open Geospatial Consortium] for more details.\n+\n+|===\n+\n+// Type: assembly\n+// ModuleID: setting-up-mysql-to-run-a-debezium-connector\n+// Title: Setting up MySQL to run a {prodname} connector\n+[[setting-up-mysql]]\n+== Set up\n+\n+Some MySQL setup tasks are required before you can install and run a {prodname} connector. \n+\n+ifdef::product[]\n+Details are in the following sections:\n+\n+* xref:creating-a-mysql-user-for-a-debezium-connector[]\n+* xref:enabling-the-mysql-binlog-for-debezium[]\n+* xref:enabling-mysql-gtids-for-debezium[]\n+* xref:configuring-mysql-session-timeouts-for-debezium[]\n+* xref:enabling-query-log-events-for-debezium-mysql-connectors[]\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: creating-a-mysql-user-for-a-debezium-connector\n+// Title: Creating a MySQL user for a {prodname} connector\n+[[mysql-creating-user]]\n+=== Creating a user \n+\n+A {prodname} MySQL connector requires a MySQL user account. This MySQL user must have appropriate permissions on all databases for which the {prodname} MySQL connector captures changes.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+\n+.Procedure\n+\n+. Create the MySQL user:\n++\n+[source,SQL]\n+----\n+mysql> CREATE USER 'user'@'localhost' IDENTIFIED BY 'password';\n+----\n+\n+. Grant the required permissions to the user:\n++\n+[source,SQL]\n+----\n+mysql> GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password';\n+----\n++\n+The table below describes the permissions. \n++\n+IMPORTANT: If using a hosted option such as Amazon RDS or Amazon Aurora that does not allow a global read lock, table-level locks are used to create the _consistent snapshot_. In this case, you need to also grant `LOCK_TABLES` permissions to the user that you create. See {link-prefix}:{link-mysql-connector}#mysql-snapshots[snapshots] for more details.\n+\n+. Finalize the user's permissions:\n++\n+[source,SQL]\n+----\n+mysql> FLUSH PRIVILEGES;\n+----\n+\n+[[permissions-explained-mysql-connector]]\n+.Descriptions of user permissions\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Keyword |Description\n+\n+|`SELECT`\n+|Enables the connector to select rows from tables in databases. This is used only when performing a snapshot.\n+\n+|`RELOAD`\n+|Enables the connector the use of the `FLUSH` statement to clear or reload internal caches, flush tables, or acquire locks. This is used only when performing a snapshot.\n+\n+|`SHOW DATABASES`\n+|Enables the connector to see database names by issuing the `SHOW DATABASE` statement. This is used only when performing a snapshot.\n+\n+|`REPLICATION SLAVE`\n+|Enables the connector to connect to and read the MySQL server binlog.\n+\n+|`REPLICATION CLIENT`\n+a|Enables the connector the use of the following statements:\n+\n+* `SHOW MASTER STATUS`\n+* `SHOW SLAVE STATUS`\n+* `SHOW BINARY LOGS`\n+\n+The connector always requires this.\n+\n+|`ON`\n+|Identifies the database to which the permissions apply.\n+\n+|`TO 'user'`\n+|Specifies the user to grant the permissions to.\n+\n+|`IDENTIFIED BY 'password'`\n+|Specifies the user's MySQL password.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-the-mysql-binlog-for-debezium\n+// Title: Enabling the MySQL binlog for {prodname}\n+[[enable-mysql-binlog]]\n+=== Enabling the binlog \n+\n+You must enable binary logging for MySQL replication. The binary logs record transaction updates for replication tools to propagate changes. \n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Appropriate MySQL user privileges.\n+\n+.Procedure\n+\n+. Check whether the `log-bin` option is already on:\n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+. If it is `OFF`, configure your MySQL server configuration file with the following properties, which are described in the table below:\n++\n+[source,properties]\n+----\n+server-id         = 223344 \n+log_bin           = mysql-bin \n+binlog_format     = ROW \n+binlog_row_image  = FULL \n+expire_logs_days  = 10 \n+----\n+\n+. Confirm your changes by checking the binlog status once more: \n++\n+[source,SQL]\n+----\n+mysql> SELECT variable_value as \"BINARY LOGGING STATUS (log-bin) ::\"\n+FROM information_schema.global_variables WHERE variable_name='log_bin';\n+----\n+\n+[[binlog-configuration-properties-mysql-connector]]\n+.Descriptions of MySQL binlog configuration properties\n+[cols=\"1,4\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Description\n+\n+|`server-id`\n+|The value for the `server-id` must be unique for each server and replication client in the MySQL cluster. During MySQL connector set up, {prodname} assigns a unique server ID to the connector.\n+\n+|`log_bin`\n+|The value of `log_bin` is the base name of the sequence of binlog files.\n+\n+|`binlog_format`\n+|The `binlog-format` must be set to `ROW` or `row`.\n+\n+|`binlog_row_image`\n+|The `binlog_row_image` must be set to `FULL` or `full`.\n+\n+|`expire_logs_days`\n+|This is the number of days for automatic binlog file removal. The default is `0`, which means no automatic removal. Set the value to match the needs of your environment. See {link-prefix}:{link-mysql-connector}#mysql-purges-binlog-files-used-by-debezium[MySQL purges binlog files].\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-mysql-gtids-for-debezium\n+// Title: Enabling MySQL Global Transaction Identifiers for {prodname}\n+[[enable-mysql-gtids]]\n+=== Enabling GTIDs\n+\n+Global transaction identifiers (GTIDs) uniquely identify transactions that occur on a server within a cluster. Though not required for a {prodname} MySQL connector, using GTIDs simplifies replication and enables you to more easily confirm if primary and replica servers are consistent.\n+\n+GTIDs are available in MySQL 5.6.5 and later. See the link:https://dev.mysql.com/doc/refman/{mysql-version}/en/replication-options-gtids.html#option_mysqld_gtid-mode[MySQL documentation] for more details.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Enable `gtid_mode`:\n++\n+[source,SQL]\n+----\n+mysql> gtid_mode=ON\n+----\n+\n+. Enable `enforce_gtid_consistency`:\n++\n+[source,SQL]\n+----\n+mysql> enforce_gtid_consistency=ON\n+----\n+\n+. Confirm the changes:\n++\n+[source,SQL]\n+----\n+mysql> show global variables like '%GTID%';\n+----\n+\n+.Result\n+[source,SQL]\n+----\n++--------------------------+-------+\n+| Variable_name            | Value |\n++--------------------------+-------+\n+| enforce_gtid_consistency | ON    |\n+| gtid_mode                | ON    |\n++--------------------------+-------+\n+----\n+\n+.Descriptions of GTID options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`gtid_mode`\n+a|Boolean that specifies whether GTID mode of the MySQL server is enabled or not.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|`enforce_gtid_consistency`\n+a|Boolean that specifies whether the server enforces GTID consistency by allowing the execution of statements that can be logged in a transactionally safe manner. Required when using GTIDs.\n+\n+* `ON` = enabled\n+* `OFF` = disabled\n+\n+|===\n+\n+\n+// Type: procedure\n+// ModuleID: configuring-mysql-session-timeouts-for-debezium\n+// Title: Configuring MySQL session timesouts for {prodname}\n+[[mysql-session-timeouts]]\n+=== Configuring session timeouts\n+\n+When an initial consistent snapshot is made for large databases, your established connection could timeout while the tables are being read. You can prevent this behavior by configuring `interactive_timeout` and `wait_timeout` in your MySQL configuration file.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowledge of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+. Configure `interactive_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> interactive_timeout=<duration-in-seconds>\n+----\n+\n+. Configure `wait_timeout`:\n++\n+[source,SQL]\n+----\n+mysql> wait_timeout=<duration-in-seconds>\n+----\n+\n+.Descriptions of MySQL session timeout options\n+[cols=\"3,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Option |Description\n+\n+|`interactive_timeout`\n+a|The number of seconds the server waits for activity on an interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_interactive_timeout[MySQL's documentation] for more details.\n+\n+|`wait_timeout`\n+a|The number of seconds the server waits for activity on a non-interactive connection before closing it. See link:https://dev.mysql.com/doc/refman/{mysql-version}/en/server-system-variables.html#sysvar_wait_timeout[MySQL's documentation] for more details.\n+\n+|===\n+\n+// Type: procedure\n+// ModuleID: enabling-query-log-events-for-debezium-mysql-connectors\n+// Title: Enabling query log events for {prodname} MySQL connectors\n+[[enable-query-log-events]]\n+=== Enabling query log events \n+\n+You might want to see the original `SQL` statement for each binlog event. Enabling the `binlog_rows_query_log_events` option in the MySQL configuration file allows you to do this.\n+\n+This option is available in MySQL 5.6 and later.\n+\n+.Prerequisites\n+\n+* A MySQL server.\n+* Basic knowlede of SQL commands.\n+* Access to the MySQL configuration file.\n+\n+.Procedure\n+\n+* Enable `binlog_rows_query_log_events`:\n++\n+[source,SQL]\n+----\n+mysql> binlog_rows_query_log_events=ON\n+----\n++\n+`binlog_rows_query_log_events` is set to a value that enables/disables support for including the original `SQL` statement in the binlog entry.\n++\n+** `ON` = enabled\n+** `OFF` = disabled\n+\n+// Type: assembly\n+// ModuleID: deploying-debezium-mysql-connectors\n+// Title: Deploying {prodname} MySQL connectors\n+[[mysql-deploying-a-connector]]\n+== Deployment\n+\n+To deploy a {prodname} MySQL connector, install the {prodname} MySQL connector archive, configure the connector, and start the connector by adding its configuration to Kafka Connect. \n+\n+ifdef::product[]\n+Details are in the following topics:\n+\n+* xref:installing-debezium-mysql-connectors[]\n+* xref:debezium-mysql-connector-configuration-example[]\n+* xref:adding-debezium-mysql-connector-configuration-to-kafka-connect[]\n+* xref:descriptions-of-debezium-mysql-connector-configuration-properties[]\n+endif::product[]\n+\n+// Type: procedure\n+// Title: Installing {prodname} MySQL connectors\n+[id=\"installing-debezium-mysql-connectors\"]\n+=== Installing\n+\n+To install a {prodname} MySQL connector, download the connector archive, extract it to your Kafka Connect environment, and ensure that the plug-ins parent directory is specified in your Kafka Connect environment.\n+\n+.Prerequisites\n+\n+* link:https://zookeeper.apache.org/[Zookeeper], link:http://kafka.apache.org/[Kafka], and link:{link-kafka-docs}.html#connect[Kafka Connect] are installed.\n+* MySQL Server is installed and set up for {prodname}.\n+\n+.Procedure\n+\n+ifdef::product[]\n+. Download the link:https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?product=red.hat.integration&downloadType=distributions[{prodname} MySQL connector].\n+endif::product[]\n+ifdef::community[]\n+ifeval::['{page-version}' == 'master']\n+. Download the {prodname} link:{link-mysql-plugin-snapshot}[MySQL connector plug-in].\n+endif::[]\n+ifeval::['{page-version}' != 'master']\n+. Download the {prodname} link:https://repo1.maven.org/maven2/io/debezium/debezium-connector-mysql/{debezium-version}/debezium-connector-mysql-{debezium-version}-plugin.tar.gz[MySQL connector plug-in].\n+endif::[]\n+endif::community[]\n+. Extract the files into your Kafka Connect environment.\n+. Add the plug-ins parent directory to your Kafka Connect `plugin.path`:\n++\n+[source]\n+----\n+plugin.path=/kafka/connect\n+----\n++\n+The above example assumes that you extracted the {prodname} MySQL connector into the `/kafka/connect/debezium-connector-mysql` path.\n+\n+. Restart your Kafka Connect process. This ensures that the new JAR files are picked up.\n+\n+// Type: concept\n+// ModuleID: debezium-mysql-connector-configuration-example\n+// Title: {prodname} MySQL connector configuration example\n+[[mysql-example-configuration]]\n+=== Connector configuration example\n+\n+ifdef::community[]\n+Typically, you configure a {prodname} MySQL connector in a `.json` file that sets configuration properties for the connector. Following is an example configuration for a MySQL connector that connects to a MySQL server on port 3306 at 192.168.99.100, whose logical name is `fullfillment`.\n+\n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,json]\n+----\n+{\n+  \"name\": \"inventory-connector\", // <1>\n+  \"config\": {\n+    \"connector.class\": \"io.debezium.connector.mysql.MySqlConnector\", // <2>\n+    \"database.hostname\": \"192.168.99.100\", // <3>\n+    \"database.port\": \"3306\", // <4>\n+    \"database.user\": \"debezium-user\", // <5>\n+    \"database.password\": \"debezium-user-pw\", // <6>\n+    \"database.server.id\": \"184054\", <7>\n+    \"database.server.name\": \"fullfillment\", // <8>\n+    \"database.whitelist\": \"inventory\", // <9>\n+    \"database.history.kafka.bootstrap.servers\": \"kafka:9092\", // <10>\n+    \"database.history.kafka.topic\": \"dbhistory.fullfillment\", // <11>\n+    \"include.schema.changes\": \"true\" // <12>\n+  }\n+}\n+----\n+<1> Connector's name when registered with the Kafka Connect service.\n+<2> Connector's class name.\n+<3> MySQL server address.\n+<4> MySQL server port number.\n+<5> MySQL user with the appropriate privileges.\n+<6> MySQL user's password.\n+<7> Unique ID of the connector.\n+<8> Logical name of the MySQL server or cluster.\n+<9> List of databases hosted by the specified server.\n+<10> List of Kafka brokers that the connector uses to write and recover DDL statements to the database history topic.\n+<11> Name of the database history topic. This topic is for internal use only and should not be used by consumers. \n+<12> Flag that specifies if the connector should generate events for DDL changes and emit them to the `fulfillment` schema change topic for use by consumers. \n+endif::community[]\n+\n+ifdef::product[]\n+\n+Typically, you configure a {prodname} MySQL connector in a `.yaml` file that sets connector configuration properties. Following is an example of the configuration for a MySQL connector that connects to a MySQL server on port 3306 and captures changes to the `inventory` database. \n+For details, see {link-prefix}:{link-mysql-connector}#mysql-connector-properties[MySQL connector configuration properties].\n+\n+[source,yaml,options=\"nowrap\"]\n+----\n+  apiVersion: kafka.strimzi.io/v1beta1\n+  kind: KafkaConnector\n+  metadata:\n+    name: inventory-connector  // <1>\n+    labels:\n+      strimzi.io/cluster: my-connect-cluster\n+  spec:\n+    class: io.debezium.connector.mysql.MySqlConnector\n+    tasksMax: 1  // <2>\n+    config:  // <3>\n+      database.hostname: mysql  // <4>\n+      database.port: 3306\n+      database.user: debezium\n+      database.password: dbz\n+      database.server.id: 184054  // <5>\n+      database.server.name: dbserver1  // <5>\n+      database.whitelist: inventory  // <6>\n+      database.history.kafka.bootstrap.servers: my-cluster-kafka-bootstrap:9092  // <7>\n+      database.history.kafka.topic: schema-changes.inventory  // <7>\n+----\n+\n+.Descriptions of connector configuration settings\n+[cols=\"1,7\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Item |Description\n+\n+|1\n+|The name of the connector.\n+\n+|2\n+|Only one task should operate at any one time.\n+Because the MySQL connector reads the MySQL server\u2019s `binlog`,\n+using a single connector task ensures proper order and event handling.\n+The Kafka Connect service uses connectors to start one or more tasks that do the work,\n+and it automatically distributes the running tasks across the cluster of Kafka Connect services.\n+If any of the services stop or crash,\n+those tasks will be redistributed to running services.\n+\n+|3\n+|The connector\u2019s configuration.\n+\n+|4\n+|The database host, which is the name of the container running the MySQL server (`mysql`).\n+\n+|5\n+|A unique server ID and name.\n+The server name is the logical identifier for the MySQL server or cluster of servers.\n+This name is used as the prefix for all Kafka topics.\n+\n+|6\n+|Changes in only the `inventory` database are captured.\n+\n+|7\n+|The connector stores the history of the database schemas in Kafka using this broker (the same broker to which you are sending events) and topic name.\n+Upon restart, the connector recovers the schemas of the database that existed at the point in time in the binlog when the connector should begin reading.\n+\n+|===\n+\n+endif::product[]\n+\n+// Type: procedure\n+// ModuleID: adding-debezium-mysql-connector-configuration-to-kafka-connect\n+// Title: Adding {prodname} MySQL connector configuration to Kafka Connect\n+[[mysql-adding-configuration]]\n+=== Adding connector configuration \n+ifdef::community[]\n+To start running a MySQL connector, configure a connector and add the configuration to your Kafka Connect cluster. \n+\n+.Prerequisites\n+\n+* {link-prefix}:{link-mysql-connector}#setting-up-mysql[MySQL server] is \n+set up for a {prodname} connector.\n+\n+* {prodname} MySQL connector is installed. \n+\n+.Procedure\n+\n+. Create a configuration for the MySQL connector.\n+\n+. Use the link:{link-kafka-docs}/#connect_rest[Kafka Connect REST API] to add that connector configuration to your Kafka Connect cluster. \n+\n+endif::community[]\n+\n+ifdef::product[]\n+You can use a provided {prodname} container to deploy a {prodname} MySQL connector. In this procedure, you build a custom Kafka Connect container image for {prodname}, configure the {prodname} connector as needed, and then add your connector configuration to your Kafka Connect environment. \n+\n+.Prerequisites\n+\n+* Podman or Docker is installed.\n+* You have sufficient rights to create and manage containers.\n+* You downloaded the {prodname} MySQL connector archive. \n+\n+.Procedure\n+\n+. Extract the {prodname} MySQL connector archive to create a directory structure for the connector plug-in, for example: \n++\n+[subs=\"+macros\"]\n+----\n+pass:quotes[*tree ./my-plugins/*]\n+./my-plugins/\n+\u251c\u2500\u2500 debezium-connector-mysql\n+\u2502   \u251c\u2500\u2500 ...\n+----\n+\n+. Create and publish a custom image for running your {prodname} connector:\n+\n+.. Create a new `Dockerfile` by using `{DockerKafkaConnect}` as the base image. In the following example, you would replace _my-plugins_ with the name of your plug-ins directory:\n++\n+[subs=\"+macros,+attributes\"]\n+----\n+FROM {DockerKafkaConnect}\n+USER root:root\n+pass:quotes[COPY _./my-plugins/_ /opt/kafka/plugins/]\n+USER 1001\n+----\n++\n+Before Kafka Connect starts running the connector, Kafka Connect loads any third-party plug-ins that are in the `/opt/kafka/plugins` directory.\n+\n+.. Build the container image. For example, if you saved the `Dockerfile` that you created in the previous step as `debezium-container-for-mysql`, and if `Dockerfile` is in the current directory, then you would run the following command:\n++\n+`podman build -t debezium-container-for-mysql:latest .`\n+\n+.. Push your custom image to your container registry, for example:\n++\n+`podman push debezium-container-for-mysql:latest`\n+\n+.. Point to the new container image. Do one of the following:\n++\n+* Edit the `spec.image` property of the `KafkaConnector` custom resource. If set, this property overrides the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable in the Cluster Operator. For example:\n++\n+[source,yaml,subs=\"+attributes\"]\n+----\n+apiVersion: {KafkaConnectApiVersion}\n+kind: KafkaConnector\n+metadata:\n+  name: my-connect-cluster\n+spec:\n+  #...\n+  image: debezium-container-for-mysql\n+----\n++\n+* In the `install/cluster-operator/050-Deployment-strimzi-cluster-operator.yaml` file, edit the `STRIMZI_DEFAULT_KAFKA_CONNECT_IMAGE` variable to point to the new container image and reinstall the Cluster Operator. If you edit this file you must apply it to your OpenShift cluster.\n+\n+. Create a `KafkaConnector` custom resource that defines your {prodname} MySQL connector instance. See {LinkDebeziumUserGuide}#mysql-example-configuration[the connector configuration example].\n+\n+. Apply the connector instance, for example: \n++\n+`oc apply -f inventory-connector.yaml`\n++\n+This registers `inventory-connector` and the connector starts to run against the `inventory` database.\n+\n+. Verify that the connector was created and has started to capture changes in the specified database. You can verify the connector instance by watching the Kafka Connect log output as, for example, `inventory-connector` starts.\n+\n+.. Display the Kafka Connect log output:\n++\n+[source,shell,options=\"nowrap\"]\n+----\n+oc logs $(oc get pods -o name -l strimzi.io/name=my-connect-cluster-connect)\n+----\n+\n+.. Review the log output to verify that the initial snapshot has been executed. You should see something like the following lines: \n++\n+[source,shell,options=\"nowrap\"]\n+----\n+... INFO Starting snapshot for ...\n+... INFO Snapshot is using user 'debezium' ... \n+----\n+\n+endif::product[]\n+\n+.Results\n+\n+When the connector starts, it {link-prefix}:{link-mysql-connector}#mysql-snapshots[performs a consistent snapshot] of the MySQL databases that the connector is configured for. The connector then starts generating data change events for row-level operations and streaming change event records to Kafka topics. \n+\n+// Type: reference\n+// ModuleID: descriptions-of-debezium-mysql-connector-configuration-properties\n+// Title: Description of {prodname} MySQL connector configuration properties\n+[[mysql-connector-properties]]\n+=== Connector properties\n+\n+The {prodname} MySQL connector has numerous configuration properties that you can use to achieve the right connector behavior for your application. Many properties have default values. Information about the properties is organized as follows:\n+\n+* xref:mysql-required-connector-configuration-properties[Required connector configuration properties]\n+* xref:mysql-advanced-connector-configuration-properties[Advanced connector configuration properties]\n+* xref:mysql-pass-through-configuration-properties[Pass-through configuration properties]\n+\n+[id=\"mysql-required-connector-configuration-properties\"]\n+The following configuration properties are _required_ unless a default value is available.\n+\n+.Required MySQL connector configuration properties\n+[cols=\"33%a,17%a,50%a\",options=\"header\",subs=\"+attributes\"]\n+|===\n+|Property |Default |Description\n+\n+|[[mysql-property-name]]<<mysql-property-name, `name`>>\n+|\n+|Unique name for the connector. Attempting to register again with the same name fails. This property is required by all Kafka Connect connectors.\n+\n+|[[mysql-property-connector-class]]<<mysql-property-connector-class, `connector.class`>>\n+|\n+|The name of the Java class for the connector. Always specify  `io.debezium{zwsp}.connector.mysql.MySqlConnector` for the MySQL connector.\n+\n+|[[mysql-property-tasks-max]]<<mysql-property-tasks-max, `tasks.max`>>\n+|`1`\n+|The maximum number of tasks that should be created for this connector. The MySQL connector always uses a single task and therefore does not use this value, so the default is always acceptable.\n+\n+|[[mysql-property-database-hostname]]<<mysql-property-database-hostname, `database.hostname`>>\n+|\n+|IP address or host name of the MySQL database server.\n+\n+|[[mysql-property-database-port]]<<mysql-property-database-port, `database.port`>>\n+|`3306`\n+|Integer port number of the MySQL database server.\n+\n+|[[mysql-property-database-user]]<<mysql-property-database-user, `database.user`>>\n+|\n+|Name of the MySQL database to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-password]]<<mysql-property-database-password, `database.password`>>\n+|\n+|Password to use when connecting to the MySQL database server.\n+\n+|[[mysql-property-database-server-name]]<<mysql-property-database-server-name, `database.server.name`>>\n+|\n+|Logical name that identifies and provides a namespace for the particular MySQL database server/cluster in which {prodname} is capturing changes. The logical name should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector.\n+Only alphanumeric characters and underscores are allowed in this name.\n+\n+|[[mysql-property-database-server-id]]<<mysql-property-database-server-id, `database.server.id`>>\n+|_random_\n+|A numeric ID of this database client, which must be unique across all currently-running database processes in the MySQL cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog. By default, a random number between 5400 and 6400 is generated, though the recommendation is to explicitly set a value.  \n+\n+|[[mysql-property-database-history-kafka-topic]]<<mysql-property-database-history-kafka-topic, `database.history.kafka{zwsp}.topic`>>\n+|\n+|The full name of the Kafka topic where the connector stores the database schema history.\n+\n+|[[mysql-property-database-history-kafka-bootstrap-servers]]<<mysql-property-database-history-kafka-bootstrap-servers, `database.history{zwsp}.kafka.bootstrap{zwsp}.servers`>>\n+|\n+|A list of host/port pairs that the connector uses for establishing an initial connection to the Kafka cluster. This connection is used for retrieving database schema history previously stored by the connector, and for writing each DDL statement read from the source database. Each pair should point to the same Kafka cluster used by the Kafka Connect process.\n+\n+|[[mysql-property-database-whitelist]]\n+[[mysql-property-database-include-list]]<<mysql-property-database-include-list, `database.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of the databases for which to capture changes. The connector does not capture changes in any database whose name is not in `database.include.list`. By default, the connector captures changes in all databases. \n+Do not also set the `database.exclude.list` connector confiuration property.\n+\n+|[[mysql-property-database-blacklist]]\n+[[mysql-property-database-exclude-list]]<<mysql-property-database-exclude-list, `database.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the names of databases for which you do not want to capture changes. The connector captures changes in any database whose name is not in the `database.exclude.list`. \n+Do not also set the `database.include.list` connector configuration property.\n+\n+|[[mysql-property-table-whitelist]]\n+[[mysql-property-table-include-list]]<<mysql-property-table-include-list, `table.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers of tables whose changes you want to capture. The connector does not capture changes in any table not included in `table.include.list`. Each identifier is of the form _databaseName_._tableName_. By default, the connector captures changes in every non-system table in each database whose changes are being captured.\n+Do not also specify the `table.exclude.list` connector configuration property.\n+\n+|[[mysql-property-table-blacklist]]\n+[[mysql-property-table-exclude-list]]<<mysql-property-table-exclude-list, `table.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match fully-qualified table identifiers for tables whose changes you do not want to capture. The connector captures changes in any table not included in `table.exclude.list`. Each identifier is of the form _databaseName_._tableName_.\n+Do not also specify the `table.include.list` connector configuration property.\n+\n+|[[mysql-property-column-blacklist]]\n+[[mysql-property-column-exclude-list]]<<mysql-property-column-exclude-list, `column.exclude.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to exclude from change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-include-list]]<<mysql-property-column-include-list, `column.include.list`>>\n+|_empty string_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns to include in change event record values. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-truncate-to-length-chars]]<<mysql-property-column-truncate-to-length-chars, `column.truncate.to{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be truncated in the change event record values if the field values are longer than the specified number of characters. You can configure multiple properties with different lengths in a single configuration. The length must be a positive integer. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-with-length-chars]]<<mysql-property-column-mask-with-length-chars, `column.mask.with{zwsp}._length_.chars`>>\n+|_n/a_\n+|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be replaced in the change event message values with a field value consisting of the specified number of asterisk (`*`) characters. You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_.\n+\n+|[[mysql-property-column-mask-hash]]<<mysql-property-column-mask-hash, `column.mask{zwsp}.hash._hashAlgorithm_{zwsp}.with.salt._salt_`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of character-based columns whose values should be pseudonyms in the change event record values. Pseudonyms consist of the hashed value obtained by applying the algorithm `_hashAlgorithm_` and salt `_salt_`. +\n+ +\n+Based on the hash function used, referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n+The hash result is automatically shortened to the length of the column. +\n+ +\n+You can configure multiple properties with different lengths in a single configuration. Each length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_. For example: +\n+ +\n+`column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName` +\n+ +\n+`CzQMA0cB5K` is a randomly selected salt.\n+ +\n+Depending on the configured `_hashAlgorithm_`, the selected `_salt_`, and the actual data set, the resulting masked data set might not be completely anonymized.\n+\n+|[[mysql-property-column-propagate-source-type]]<<mysql-property-column-propagate-source-type, `column.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the fully-qualified names of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+\n+`pass:[_]pass:[_]{prodname}.source.column.type` \n+\n+`pass:[_]pass:[_]{prodname}.source.column.length` \n+ \n+`pass:[_]pass:[_]{prodname}.source.column.scale` \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified names for columns are of one of these forms: \n+\n+_databaseName_._tableName_._columnName_ \n+\n+_databaseName_._schemaName_._tableName_._columnName_\n+\n+|[[mysql-property-datatype-propagate-source-type]]<<mysql-property-datatype-propagate-source-type, `datatype.propagate{zwsp}.source.type`>>\n+|_n/a_\n+a|An optional, comma-separated list of regular expressions that match the database-specific data type name of columns whose original type and length should be added as a parameter to the corresponding field schemas in the emitted change event records. These schema parameters: \n+ \n+`pass:[_]pass:[_]debezium.source.column.type`  \n+\n+`pass:[_]pass:[_]debezium.source.column.length`\n+\n+`pass:[_]pass:[_]debezium.source.column.scale`  \n+\n+are used to propagate the original type name and length for variable-width types, respectively. This is useful to properly size corresponding columns in sink databases. Fully-qualified data type names are of one of these forms: \n+\n+_databaseName_._tableName_._typeName_ \n+\n+_databaseName_._schemaName_._tableName_._typeName_ \n+ \n+See {link-prefix}:{link-mysql-connector}#mysql-data-types[how MySQL connectors map data types] for the list of MySQL-specific data type names.\n+\n+|[[mysql-property-time-precision-mode]]<<mysql-property-time-precision-mode, `time.precision.mode`>>\n+|`adaptive_time{zwsp}_microseconds`\n+|Time, date, and timestamps can be represented with different kinds of precision, including: +\n+ +\n+`adaptive_time_microseconds` (the default) captures the date, datetime and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type, with the exception of TIME type fields, which are always captured as microseconds. +\n+ +\n+ifdef::community[]\n+`adaptive` (deprecated) captures the time and timestamp values exactly as in the database using either millisecond, microsecond, or nanosecond precision values based on the database column's type. +\n+endif::community[]\n+ +\n+`connect` always represents time and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which use millisecond precision regardless of the database columns' precision.\n+\n+|[[mysql-property-decimal-handling-mode]]<<mysql-property-decimal-handling-mode,`decimal.handling.mode`>>\n+|`precise`\n+|Specifies how the connector should handle values for `DECIMAL` and `NUMERIC` columns: +\n+ +\n+`precise` (the default) represents them precisely using `java.math.BigDecimal` values represented in change events in a binary form. +\n+ +\n+`double` represents them using `double` values, which may result in a loss of precision but is easier to use. +\n+ +\n+`string` encodes values as formatted strings, which is easy to consume but  semantic information about the real type is lost.\n+\n+|[[mysql-property-bigint-unsigned-handling-mode]]<<mysql-property-bigint-unsigned-handling-mode, `bigint.unsigned{zwsp}.handling.mode`>>\n+|`long`\n+|Specifies how BIGINT UNSIGNED columns should be represented in change events. Possible settings are: +\n+ +\n+ `long` represents values by using Java's `long`, which might not offer the precision but which is easy to use in consumers. `long` is usually the preferred setting. +\n+ +\n+`precise` uses `java.math.BigDecimal` to represent values, which are encoded in the change events by using a binary representation and Kafka Connect's `org.apache.kafka.connect.data.Decimal` type. Use this setting when working with values larger than 2^63, because these values cannot be conveyed by using `long`.\n+\n+|[[mysql-property-include-schema-changes]]<<mysql-property-include-schema-changes, `include.schema{zwsp}.changes`>>\n+|`true`\n+|Boolean value that specifies whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change is recorded by using a key that contains the database name and whose value includes the DDL statement(s). This is independent of how the connector internally records database history. \n+\n+|[[mysql-property-include-query]]<<mysql-property-include-query, `include.query`>>\n+|`false`\n+|Boolean value that specifies whether the connector should include the original SQL query that generated the change event. +\n+ +\n+If you set this option to `true` then you must also configure MySQL with the `binlog_rows_query_log_events` option set to `ON`. When `include.query` is `true`, the query is not present for events that the snapshot process generates. +\n+ +\n+Setting `include.query`to `true` might expose tables or fields explicitly excluded or masked by including the original SQL statement in the change event. For this reason, the default setting is `false`.\n+\n+|[[mysql-property-event-processing-failure-handling-mode]]<<mysql-property-event-processing-failure-handling-mode, `event.processing{zwsp}.failure.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to exceptions during deserialization of binlog events. +\n+ +\n+`fail` propagates the exception, which indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and then skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-inconsistent-schema-handling-mode]]<<mysql-property-inconsistent-schema-handling-mode, `inconsistent.schema{zwsp}.handling.mode`>>\n+|`fail`\n+|Specifies how the connector should react to binlog events that relate to tables that are not present in internal schema representation. That is, the internal representation is not consistent with the database. +\n+ +\n+`fail` throws an exception that indicates the problematic event and its binlog offset, and causes the connector to stop. +\n+ +\n+`warn` logs the problematic event and its binlog offset and skips the event. +\n+ +\n+`skip` passes over the problematic event and does not log anything.\n+\n+|[[mysql-property-max-queue-size]]<<mysql-property-max-queue-size, `max.queue.size`>>\n+|`8192`\n+|Positive integer value that specifies the maximum size of the blocking queue into which change events read from the database log are placed before they are written to Kafka. This queue can provide backpressure to the binlog reader when, for example, writes to Kafka are slow or if Kafka is not available. Events that appear in the queue are not included in the offsets periodically recorded by this connector. Defaults to 8192, and should always be larger than the maximum batch size specified by the `max.batch.size` property.\n+\n+|[[mysql-property-max-batch-size]]<<mysql-property-max-batch-size, `max.batch.size`>>\n+|`2048`\n+|Positive integer value that specifies the maximum size of each batch of events that should be processed during each iteration of this connector. Defaults to 2048.\n+\n+|[[mysql-property-poll-interval-ms]]<<mysql-property-poll-interval-ms, `poll.interval.ms`>>\n+|`1000`\n+|Positive integer value that specifies the number of milliseconds the connector should wait for new change events to appear before it starts processing a batch of events. Defaults to 1000 milliseconds, or 1 second.\n+\n+|[[mysql-property-connect-timeout-ms]]<<mysql-property-connect-timeout-ms, `connect.timeout.ms`>>\n+|`30000`\n+|A positive integer value that specifies the maximum time in milliseconds this connector should wait after trying to connect to the MySQL database server before timing out. Defaults to 30 seconds.\n+\n+|[[mysql-property-gtid-source-includes]]<<mysql-property-gtid-source-includes, `gtid.source.includes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that match one of these include patterns are used.\n+Do not also specify a setting for `gtid.source.excludes`.\n+\n+|[[mysql-property-gtid-source-excludes]]<<mysql-property-gtid-source-excludes, `gtid.source.excludes`>>\n+|\n+|A comma-separated list of regular expressions that match source UUIDs in the GTID set used to find the binlog position in the MySQL server. Only the GTID ranges that have sources that do not match any of these exclude patterns are used. Do not also specify a value for `gtid.source.includes`.\n+\n+ifdef::community[]\n+|[[mysql-property-gtid-new-channel-position]]<<mysql-property-gtid-new-channel-position, `gtid.new.channel.position`>> +\n+_deprecated and scheduled for removal_\n+|`earliest`\n+|When set to `latest`, when the connector sees a new GTID channel, it starts consuming from the last executed transaction in that GTID channel. If set to `earliest` (default), the connector starts reading that channel from the first available (not purged) GTID position. `earliest` is useful when you have an active-passive MySQL setup where {prodname} is connected to the primary server. In this case, during failover, the replica with the new UUID (and GTID channel) starts receiving writes before {prodname} is connected. These writes would be lost when using `latest`.\n+endif::community[]\n+\n+|[[mysql-property-tombstones-on-delete]]<<mysql-property-tombstones-on-delete, `tombstones.on.delete`>>\n+|`true`\n+|Controls whether a delete event is followed by a tombstone event. +\n+ +\n+`true`  - a delete operation is represented by a delete event and a subsequent tombstone event.  +\n+ +\n+`false` - only a delete event is emitted. +\n+ +\n+After a source record is deleted, emitting a tombstone event (the default behavior) allows Kafka to completely delete all events that pertain to the key of the deleted row. \n+\n+|[[mysql-property-message-key-columns]]<<mysql-property-message-key-columns, `message.key.columns`>>\n+|_empty string_\n+|A semicolon separated list of tables with regular expressions that match table column names. The connector maps values in matching columns to key fields in change event records that it sends to Kafka topics. This is useful when a table does not have a primary key, or when you want to order change event records in a Kafka topic according to a field that is not a primary key. +\n+ +\n+Separate entries with semicolons. Insert a colon between the fully-qualified table name and its regular expression. The format (shown with spaces for clarity only) is: +\n+ +\n+_database-name_ `.` _table-name_ `:` _regexp_ `;` ... +\n+ +\n+For example: +\n+ +\n+`dbA.table_a:regex_1;dbB.table_b:regex_2;dbC.table_c:regex_3` +\n+ +\n+If `table_a` has an `id` column, and `regex_1` is `^i` (matches any column that starts with `i`), the connector maps the value in the `id` column of `table_a` to a key field in change events that the connector sends to Kafka. \n+\n+|[[mysql-property-binary-handling-mode]]<<mysql-property-binary-handling-mode,`binary.handling.mode`>>\n+|bytes\n+|Specifies how binary columns, for example, `blob`, `binary`, `varbinary`, should be represented in change events. Possible settings:  +\n+ +\n+`bytes` represents binary data as a byte array. +\n+ +\n+`base64` represents binary data as a base64-encoded String. +\n+ +\n+`hex` represents binary data as a hex-encoded (base16) String.\n+\n+|===\n+\n+[id=\"mysql-advanced-connector-configuration-properties\"]\n+.Advanced MySQL connector configuration properties", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NzQ5MQ=="}, "originalCommit": null, "originalPosition": 2214}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4118, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}