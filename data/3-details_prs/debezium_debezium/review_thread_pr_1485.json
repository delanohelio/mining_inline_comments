{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NDMxOTI4", "number": 1485, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo1NzoxNlrOD7NWWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo1ODoxNlrOD7NXsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDExMjkxOnYy", "diffSide": "RIGHT", "path": "documentation/modules/ROOT/pages/connectors/sqlserver.adoc", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo1NzoxNlrOGTZF7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzoxODo1NFrOGV5TBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzI0Nw==", "bodyText": "So can I indeed capture changes from multiple databases with a single connector instance? // CC @jpechane", "url": "https://github.com/debezium/debezium/pull/1485#discussion_r422987247", "createdAt": "2020-05-11T11:57:16Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/sqlserver.adoc", "diffHunk": "@@ -1430,11 +1430,11 @@ Note that primary key columns are always included in the event's key, also if bl\n Based on the used hash function referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n The hash is automatically shortened to the length of the column.\n \n-Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_.\n+Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._schemaName_._tableName_._columnName_.\n \n Example:\n \n-    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName\n+    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = testDB.dbo.orders.customerName, testDB.dbo.shipment.customerName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1fbfaa11e506ac2f6b7b0c1e50d6f321e7490a2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NDY0OA==", "bodyText": "No we can't.  In SQL Server we specifically use the database.dbname configuration option to drive which database the driver connects to and all subsequent queries we use to fetch object information is based on the name returned from select db_name().  Therefore, its not possible for the connector to monitor different objects from varying databases even if they exist in the same database server instance from what I can see.\nWhen we fetch the list of change tables, we build the TableId and use the database name as the catalog portion of the identifier.  So for matching purposes, the column.mask.xxx options would need to either use a regex for explicit string matches that follow the form of <catalog>.<schema>.<table>.<column>.", "url": "https://github.com/debezium/debezium/pull/1485#discussion_r424684648", "createdAt": "2020-05-13T19:37:40Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/sqlserver.adoc", "diffHunk": "@@ -1430,11 +1430,11 @@ Note that primary key columns are always included in the event's key, also if bl\n Based on the used hash function referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n The hash is automatically shortened to the length of the column.\n \n-Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_.\n+Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._schemaName_._tableName_._columnName_.\n \n Example:\n \n-    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName\n+    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = testDB.dbo.orders.customerName, testDB.dbo.shipment.customerName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzI0Nw=="}, "originalCommit": {"oid": "a1fbfaa11e506ac2f6b7b0c1e50d6f321e7490a2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxMjAzOQ==", "bodyText": "Therefore, its not possible for the connector to monitor different objects from varying databases\n\nOk, that's what I thought.\n\nwould need to either use a regex for explicit string matches that follow the form of <catalog>.<schema>.<table>.<column>\n\nBut what's the purpose/benefit of adding the catalog part, if it's constant and the same for all cases when looking at a single connector? We also don't require the database name in case of Postgres (which is a comparable situation).", "url": "https://github.com/debezium/debezium/pull/1485#discussion_r425612039", "createdAt": "2020-05-15T07:18:54Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/sqlserver.adoc", "diffHunk": "@@ -1430,11 +1430,11 @@ Note that primary key columns are always included in the event's key, also if bl\n Based on the used hash function referential integrity is kept while data is pseudonymized. Supported hash functions are described in the {link-java7-standard-names}[MessageDigest section] of the Java Cryptography Architecture Standard Algorithm Name Documentation.\n The hash is automatically shortened to the length of the column.\n \n-Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._tableName_._columnName_, or _databaseName_._schemaName_._tableName_._columnName_.\n+Multiple properties with different lengths can be used in a single configuration, although in each the length must be a positive integer or zero. Fully-qualified names for columns are of the form _databaseName_._schemaName_._tableName_._columnName_.\n \n Example:\n \n-    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = inventory.orders.customerName, inventory.shipment.customerName\n+    column.mask.hash.SHA-256.with.salt.CzQMA0cB5K = testDB.dbo.orders.customerName, testDB.dbo.shipment.customerName", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzI0Nw=="}, "originalCommit": {"oid": "a1fbfaa11e506ac2f6b7b0c1e50d6f321e7490a2"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNDExNjMzOnYy", "diffSide": "RIGHT", "path": "documentation/modules/ROOT/pages/connectors/oracle.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxMTo1ODoxNlrOGTZIAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1NjoxMFrOGVBTBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4Nzc3OQ==", "bodyText": "IIRC, the connector is already scoped for a single PDB, right? Does it then actually make sense to require the PDB name for these FQNs?", "url": "https://github.com/debezium/debezium/pull/1485#discussion_r422987779", "createdAt": "2020-05-11T11:58:16Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/oracle.adoc", "diffHunk": "@@ -1210,15 +1210,15 @@ Emitting the tombstone event (the default behavior) allows Kafka to completely d\n |_empty string_\n | A semi-colon list of regular expressions that match fully-qualified tables and columns to map a primary key. +\n Each item (regular expression) must match the `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n-Fully-qualified tables could be defined as `DB_NAME.TABLE_NAME` or `SCHEMA_NAME.TABLE_NAME`, depending on the specific connector.\n+Fully-qualified tables could be defined as _pdbName_._schemaName_._tableName_.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1fbfaa11e506ac2f6b7b0c1e50d6f321e7490a2"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NDUzNA==", "bodyText": "That's a good question.  If my understanding of the code is accurate, this boils down to the call in ColumnMappers#fullyQualifiedColumnName where the call to ColumnId#toString takes the string representation of the TableId and appends .<columnName>.\nPerhaps the best of both worlds might be to introduce some logic that when we return the expected string comparison value if a schema is part of the TableId, we omit the catalog portion from the return value and use schema.table.column; where-as if a schema is not part of the TableId and a catalog is that we use catalog.table.column format.\nThis would preserve the catalog behavior with MySQL where there is no schema and would otherwise work for the other relational connectors that specify a schema value, some with and some without the catalog value.\n@jpechane Do you have any suggestions or thoughts here?", "url": "https://github.com/debezium/debezium/pull/1485#discussion_r424694534", "createdAt": "2020-05-13T19:56:10Z", "author": {"login": "Naros"}, "path": "documentation/modules/ROOT/pages/connectors/oracle.adoc", "diffHunk": "@@ -1210,15 +1210,15 @@ Emitting the tombstone event (the default behavior) allows Kafka to completely d\n |_empty string_\n | A semi-colon list of regular expressions that match fully-qualified tables and columns to map a primary key. +\n Each item (regular expression) must match the `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n-Fully-qualified tables could be defined as `DB_NAME.TABLE_NAME` or `SCHEMA_NAME.TABLE_NAME`, depending on the specific connector.\n+Fully-qualified tables could be defined as _pdbName_._schemaName_._tableName_.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4Nzc3OQ=="}, "originalCommit": {"oid": "a1fbfaa11e506ac2f6b7b0c1e50d6f321e7490a2"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4318, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}