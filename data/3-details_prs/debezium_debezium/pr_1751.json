{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2NTA4MTE0", "number": 1751, "title": "DBZ-2338 Base WAL position detection on commit LSNs", "bodyText": "https://issues.redhat.com/browse/DBZ-2338\nhttps://issues.redhat.com/browse/DBZ-2200\nhttps://issues.redhat.com/browse/DBZ-2397", "createdAt": "2020-08-12T04:58:32Z", "url": "https://github.com/debezium/debezium/pull/1751", "merged": true, "mergeCommit": {"oid": "03a11efd8e914d4aaf8c504ccbf14b2211f296ee"}, "closed": true, "closedAt": "2020-08-24T19:16:38Z", "author": {"login": "jpechane"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-HdbeAFqTQ2NTcxNjkyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCG_kggH2gAyNDY2NTA4MTE0Ojk5YjgzNzVhMjAwZjQyMmQ2ODBjNWFjYTU0MGYwYzAzMDQzMmNiOTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzE2OTIy", "url": "https://github.com/debezium/debezium/pull/1751#pullrequestreview-465716922", "createdAt": "2020-08-12T08:50:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo1MDo1MVrOG_X_eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo1MDo1MVrOG_X_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw==", "bodyText": "Wasn't DBZ-2200, also focused on the PG connector, intended to have a more abstract implementation in debezium-core that fits different connector needs? Something like SourceOffset<T extends Comparable> or something?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469106553", "createdAt": "2020-08-12T08:50:51Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzU1Mjk0", "url": "https://github.com/debezium/debezium/pull/1751#pullrequestreview-465755294", "createdAt": "2020-08-12T09:41:54Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0MTo1NFrOG_Z2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NTo0MlrOG_Z_NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNjk5MQ==", "bodyText": "How about enabling Lsn#valueOf() itself to handle and return null?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469136991", "createdAt": "2020-08-12T09:41:54Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresOffsetContext.java", "diffHunk": "@@ -171,8 +171,10 @@ private Long readOptionalLong(Map<String, ?> offset, String key) {\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         public OffsetContext load(Map<String, ?> offset) {\n-            final Long lsn = readOptionalLong(offset, SourceInfo.LSN_KEY);\n-            final Long lastCompletelyProcessedLsn = readOptionalLong(offset, LAST_COMPLETELY_PROCESSED_LSN_KEY);\n+            final Long lsnAsLong = readOptionalLong(offset, SourceInfo.LSN_KEY);\n+            final Lsn lsn = (lsnAsLong == null) ? null : Lsn.valueOf(lsnAsLong);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNzUzMA==", "bodyText": "Ok, I really hope we don't miss this somewhere.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469137530", "createdAt": "2020-08-12T09:42:47Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresSourceInfoStructMaker.java", "diffHunk": "@@ -45,7 +45,7 @@ public Struct struct(SourceInfo sourceInfo) {\n             result.put(SourceInfo.TXID_KEY, sourceInfo.txId());\n         }\n         if (sourceInfo.lsn() != null) {\n-            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn());\n+            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn().asLong());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTAxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);\n          \n          \n            \n                        assertNotEquals(\"LSN should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139019", "createdAt": "2020-08-12T09:45:16Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1235,9 +1236,9 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if client's lsn is not flushed yet\n             SlotState slotState = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushLsn = slotState.slotLastFlushedLsn();\n+            final Lsn flushLsn = slotState.slotLastFlushedLsn();\n             // serverLsn is the latest server lsn and is equal to insert statement lsn\n-            long serverLsn = postgresConnection.currentXLogLocation();\n+            final Lsn serverLsn = Lsn.valueOf(postgresConnection.currentXLogLocation());\n             assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTA4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);\n          \n          \n            \n                        assertTrue(\"LSN should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139083", "createdAt": "2020-08-12T09:45:25Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1254,8 +1255,8 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if flushed lsn is equal to or greater than server lsn\n             SlotState slotStateAfterHeartbeat = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n-            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn >= serverLsn);\n+            final Lsn flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n+            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTI1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();\n          \n          \n            \n                    AtomicReference<Lsn> lastReceivedLsn = new AtomicReference<>();", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139252", "createdAt": "2020-08-12T09:45:42Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/connection/ReplicationConnectionIT.java", "diffHunk": "@@ -180,9 +180,9 @@ public void shouldReceiveMissedChangesWhileDown() throws Exception {\n     @Test\n     public void shouldResumeFromLastReceivedLSN() throws Exception {\n         String slotName = \"test\";\n-        AtomicLong lastReceivedLSN = new AtomicLong(0);\n-        startInsertStop(slotName, stream -> lastReceivedLSN.compareAndSet(0, stream.lastReceivedLsn()));\n-        assertTrue(lastReceivedLSN.get() > 0);\n+        AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "99560bc6312576426607690bebb17ca81b5dae0f", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/99560bc6312576426607690bebb17ca81b5dae0f", "committedDate": "2020-08-21T12:30:55Z", "message": "DBZ-2200 Introduce LLSN domain type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5d96d20e6b584ed90e0bf010563723a517470c4", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/d5d96d20e6b584ed90e0bf010563723a517470c4", "committedDate": "2020-08-21T12:32:53Z", "message": "DBZ-2338 Base WAL position detection on commit LSNs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3eb98ca18ace191f46ddc4796b413833c86a0ef9", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/3eb98ca18ace191f46ddc4796b413833c86a0ef9", "committedDate": "2020-08-21T12:32:53Z", "message": "DBZ-2338 Support for pgoutput"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e478a5da54f3fdbd4b42297201e4519878280f3", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/3e478a5da54f3fdbd4b42297201e4519878280f3", "committedDate": "2020-08-21T12:32:53Z", "message": "DBZ-2338 Minor corrections\n\nCo-authored-by: Gunnar Morling <gunnar.morling@googlemail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/9c7c9c2aad3061efeb4859844b1ef49f59cf3f98", "committedDate": "2020-08-21T12:32:53Z", "message": "DBZ-2397 Test for restart in tx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "committedDate": "2020-08-21T13:13:16Z", "message": "DBZ-2338 Skip initial statements on reconnect"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7", "committedDate": "2020-08-21T13:13:16Z", "message": "DBZ-2338 Skip initial statements on reconnect"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMDM2MjM2", "url": "https://github.com/debezium/debezium/pull/1751#pullrequestreview-473036236", "createdAt": "2020-08-23T19:31:20Z", "commit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMToyMFrOHFPVFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMToyMFrOHFPVFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw==", "bodyText": "Why does keepalive need to be disabled to commit the current transaction?  Asking because PostgresTaskContext#refreshSchema called on https://github.com/debezium/debezium/pull/1751/files#diff-dff0ff397d3f72ba1319e51a37ace1adL118 here performs a commit but does not disable keepalive.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475256087", "createdAt": "2020-08-23T19:31:20Z", "author": {"login": "grantcooksey"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,45 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);\n+                walPosition = new WalPositionLocator(offsetContext.lastCommitLsn(), lsn);\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn, walPosition));\n             }\n             else {\n-                LOGGER.info(\"no previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming());\n+                LOGGER.info(\"No previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n+                walPosition = new WalPositionLocator();\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(walPosition));\n             }\n             // for large dbs, the refresh of schema can take too much time\n             // such that the connection times out. We must enable keep\n             // alive to ensure that it doesn't time out\n-            final ReplicationStream stream = this.replicationStream.get();\n+            ReplicationStream stream = this.replicationStream.get();\n             stream.startKeepAlive(Executors.newSingleThreadExecutor());\n \n             // refresh the schema so we have a latest view of the DB tables\n             taskContext.refreshSchema(connection, true);\n \n             this.lastCompletelyProcessedLsn = replicationStream.get().startLsn();\n \n-            int noMessageIterations = 0;\n-            while (context.isRunning()) {\n-\n-                boolean receivedMessage = stream.readPending(message -> {\n-                    final Long lsn = stream.lastReceivedLsn();\n-\n-                    if (message.isLastEventForLsn()) {\n-                        lastCompletelyProcessedLsn = lsn;\n-                    }\n-\n-                    // Tx BEGIN/END event\n-                    if (message.isTransactionalMessage()) {\n-                        if (!connectorConfig.shouldProvideTransactionMetadata()) {\n-                            LOGGER.trace(\"Received transactional message {}\", message);\n-                            // Don't skip on BEGIN message as it would flush LSN for the whole transaction\n-                            // too early\n-                            if (message.getOperation() == Operation.COMMIT) {\n-                                skipMessage(lsn);\n-                            }\n-                            return;\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), null,\n-                                taskContext.getSlotXmin(connection));\n-                        if (message.getOperation() == Operation.BEGIN) {\n-                            dispatcher.dispatchTransactionStartedEvent(Long.toString(message.getTransactionId()), offsetContext);\n-                        }\n-                        else if (message.getOperation() == Operation.COMMIT) {\n-                            dispatcher.dispatchTransactionCommittedEvent(offsetContext);\n-                        }\n-                        maybeWarnAboutGrowingWalBacklog(true);\n-                        return;\n-                    }\n-                    // DML event\n-                    else {\n-                        TableId tableId = null;\n-                        if (message.getOperation() != Operation.NOOP) {\n-                            tableId = PostgresSchema.parse(message.getTable());\n-                            Objects.requireNonNull(tableId);\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), tableId,\n-                                taskContext.getSlotXmin(connection));\n-\n-                        boolean dispatched = (message.getOperation() == Operation.NOOP) ? false\n-                                : dispatcher.dispatchDataChangeEvent(\n-                                        tableId,\n-                                        new PostgresChangeRecordEmitter(\n-                                                offsetContext,\n-                                                clock,\n-                                                connectorConfig,\n-                                                schema,\n-                                                connection,\n-                                                message));\n-\n-                        maybeWarnAboutGrowingWalBacklog(dispatched);\n-                    }\n-                });\n-\n-                if (receivedMessage) {\n-                    noMessageIterations = 0;\n+            if (walPosition.searchingEnabled()) {\n+                searchWalPosition(context, stream, walPosition);\n+                stream.stopKeepAlive();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1af7eb1d8f850218bfcdfe949cd84824636d01f8", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/1af7eb1d8f850218bfcdfe949cd84824636d01f8", "committedDate": "2020-08-24T04:34:29Z", "message": "DBZ-2338 Log exception; restart keepalive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/4f91d032459c2bb24126d361c84432a8f349948c", "committedDate": "2020-08-24T05:17:34Z", "message": "DBZ-2338 Flush LSNs on tx boundaries"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNDU2OTgy", "url": "https://github.com/debezium/debezium/pull/1751#pullrequestreview-473456982", "createdAt": "2020-08-24T13:21:08Z", "commit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTowOVrOHFj_HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyODo0OFrOHFkRtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDUyNA==", "bodyText": "Was changing the log level of this from debug to info intentional?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475594524", "createdAt": "2020-08-24T13:21:09Z", "author": {"login": "Naros"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,46 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ==", "bodyText": "Would it be possible to use queryAndMap here in order to avoid the AtomicReference usage?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475599285", "createdAt": "2020-08-24T13:28:48Z", "author": {"login": "Naros"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -219,7 +218,7 @@ protected void initReplicationSlot() throws SQLException, InterruptedException {\n                 this.createReplicationSlot();\n             }\n \n-            AtomicLong xlogStart = new AtomicLong();\n+            final AtomicReference<Lsn> xlogStart = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99b8375a200f422d680c5aca540f0c030432cb94", "author": {"user": {"login": "jpechane", "name": "Jiri Pechanec"}}, "url": "https://github.com/debezium/debezium/commit/99b8375a200f422d680c5aca540f0c030432cb94", "committedDate": "2020-08-24T18:33:57Z", "message": "DBZ-2338 Atomic is not necessary"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2377, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}