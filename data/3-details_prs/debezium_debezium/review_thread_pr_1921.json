{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDM1OTM1", "number": 1921, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo0OTo1M1rOEzuCgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMjo0N1rOE0qdnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjY3MTM5OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo0OTo1M1rOHrH5sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo0OTo1M1rOHrH5sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MDI3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                if (!actualRecords.keySet().contains(record.topic())) {\n          \n          \n            \n                                                if (!actualRecords.containsKey(record.topic())) {", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r514980272", "createdAt": "2020-10-30T09:49:53Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -1094,9 +1097,33 @@ public void shouldRegularlyFlushLsnWithTxMonitoring() throws InterruptedExceptio\n             for (int i = 2; i <= recordCount + 2; i++) {\n                 TestHelper.execute(INSERT_STMT);\n \n-                final SourceRecords actualRecords = consumeRecordsByTopic(3);\n-                assertThat(actualRecords.topics().size()).isEqualTo(2);\n-                assertThat(actualRecords.recordsForTopic(topicName(\"s1.a\")).size()).isEqualTo(1);\n+                final Map<String, List<SourceRecord>> actualRecords = new HashMap<>();\n+                try {\n+                    Awaitility.await()\n+                            .atMost(5 * TestHelper.waitTimeForRecords(), TimeUnit.SECONDS)\n+                            .until(() -> {\n+                                // consume all available records\n+                                List<SourceRecord> records = new LinkedList<>();\n+                                consumeAvailableRecords(records::add);\n+\n+                                // capture all topics\n+                                for (SourceRecord record : records) {\n+                                    if (!actualRecords.keySet().contains(record.topic())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjUzOTUyOnYy", "diffSide": "RIGHT", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNToxMTowNlrOHsgc8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNToxMTowNlrOHsgc8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzMTA5MA==", "bodyText": "SHould not the assert call isTransactionRecord method instead of chekcing the topic name?", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516431090", "createdAt": "2020-11-03T05:11:06Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -640,6 +781,13 @@ protected void assertNoRecordsToConsume() {\n         assertThat(consumedLines.isEmpty()).isTrue();\n     }\n \n+    /**\n+     * Assert that there are only transaction topic records to be consumed.\n+     */\n+    protected void assertOnlyTransactionRecordsToConsume() {\n+        consumedLines.iterator().forEachRemaining(r -> assertThat(r.topic()).endsWith(\".transaction\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU2ODUzOnYy", "diffSide": "RIGHT", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMDo1MVrOHsgsuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMDo1MVrOHsgsuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTEyOQ==", "bodyText": "Even if it is not strictly necessary I'd prefer to process even the incoming tx BEGIN to ensure symmetry between BEGIN/END messages.", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435129", "createdAt": "2020-11-03T05:30:51Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    debug(record);\n+                }\n+                else if (Testing.Print.isEnabled()) {\n+                    Testing.print(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    print(record);\n+                }\n+                if (assertRecords) {\n+                    VerifyRecord.isValid(record);\n+                }\n+            }\n+            else {\n+                if (++nullReturn >= breakAfterNulls) {\n+                    return recordsConsumed;\n+                }\n+            }\n+        }\n+\n+        while (!endTransactions.isEmpty()) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.END.name())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU2OTcxOnYy", "diffSide": "RIGHT", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMTo0MVrOHsgtVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMTo0MVrOHsgtVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTI4NQ==", "bodyText": "Could the log messages here and down contain also information about endTransactions?", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435285", "createdAt": "2020-11-03T05:31:41Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjU3MTE5OnYy", "diffSide": "RIGHT", "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMjo0N1rOHsguNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMjo0N1rOHsguNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTUwOA==", "bodyText": "Here it would be great to assert that the DML message txId is present in endTransactions", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435508", "createdAt": "2020-11-03T05:32:47Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 87}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4147, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}