{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MTU3ODU0", "number": 1322, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoyMTo1MlrODms0cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1NjowMlrODm4nvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTA2ODAzOnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoyMTo1MlrOF0RBJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNToxOTo0MVrOF0Tylg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0OTA5Mw==", "bodyText": "Do you also need to change this a few lines down?\nthis.lastCompletelyProcessedLsn = offsetContext.lsn();", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390349093", "createdAt": "2020-03-10T14:21:52Z", "author": {"login": "cjbooms"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -92,7 +96,7 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n-            if (offsetContext.hasLastKnownPosition()) {\n+            if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n                 final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n                 if (LOGGER.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM1NjI0OQ==", "bodyText": "@cjbooms I know about this one, I am still trying to find out how to propagate the value from PostgreReplicationStream. But thanks for reminder I forgot to mark this PR as WIP", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390356249", "createdAt": "2020-03-10T14:31:00Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -92,7 +96,7 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n-            if (offsetContext.hasLastKnownPosition()) {\n+            if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n                 final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n                 if (LOGGER.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0OTA5Mw=="}, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NDUxOA==", "bodyText": "@cjbooms Should be fixed now", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390394518", "createdAt": "2020-03-10T15:19:41Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -92,7 +96,7 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n-            if (offsetContext.hasLastKnownPosition()) {\n+            if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n                 final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n                 if (LOGGER.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0OTA5Mw=="}, "originalCommit": null, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMDk5NjM2OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1Mzo0MlrOF0j0mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1Mzo0MlrOF0j0mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1NzE3OQ==", "bodyText": "This looks good to me. I had hoped you could instead create an initial empty context here, but my attempt to do so caused test failures.", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390657179", "createdAt": "2020-03-10T22:53:42Z", "author": {"login": "cjbooms"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -78,6 +79,9 @@ public PostgresStreamingChangeEventSource(PostgresConnectorConfig connectorConfi\n         this.clock = clock;\n         this.schema = schema;\n         this.offsetContext = (offsetContext != null) ? offsetContext : PostgresOffsetContext.initialContext(connectorConfig, connection, clock);\n+        // replication slot could exist at the time of starting Debezium so we will stream from the position in the slot\n+        // instead of the last position in the database\n+        this.hasStartLsnStoredInContext = (offsetContext != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAwMTU2OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1NjowMlrOF0j3xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo1NDozOFrOF1iGuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1Nzk5MA==", "bodyText": "In fact I think you will always get one duplicate record re-emitted due to this logic, which disables skipping of the first flushed record:\n        boolean skipFirstFlushRecord = true;\n        initConnection();\n\n        connect();\n        if (offset == null || offset <= 0) {\n            offset = defaultStartingPos;\n            skipFirstFlushRecord = false;\n        }", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390657990", "createdAt": "2020-03-10T22:56:02Z", "author": {"login": "cjbooms"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1613,6 +1616,39 @@ public void stopInTheMiddleOfTxAndResume() throws Exception {\n         }\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1730\")\n+    public void shouldStartConsumingFromSlotLocation() throws Exception {\n+        Testing.Print.enable();\n+\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, false)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), true);\n+        waitForStreamingToStart();\n+\n+        consumer = testConsumer(1);\n+        executeAndWait(\"INSERT INTO test_table (text) VALUES ('insert2')\");\n+        consumer.remove();\n+\n+        stopConnector();\n+        TestHelper.execute(\n+                \"INSERT INTO test_table (text) VALUES ('insert3');\",\n+                \"INSERT INTO test_table (text) VALUES ('insert4')\");\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, true)\n+                .with(PostgresConnectorConfig.SNAPSHOT_MODE, PostgresConnectorConfig.SnapshotMode.NEVER)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), false);\n+\n+        consumer.expects(2);\n+        consumer.await(TestHelper.waitTimeForRecords() * 5, TimeUnit.SECONDS);\n+\n+        // We cannot guarantee the flush timing so it is possible that insert2 record will be redelivered\n+        Assertions.assertThat(((Struct) consumer.remove().value()).getStruct(\"after\").getString(\"text\")).isIn(Collect.unmodifiableSet(\"insert2\", \"insert3\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgyNzAxOA==", "bodyText": "@jpechane, any thoughts on this one?", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390827018", "createdAt": "2020-03-11T09:04:10Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1613,6 +1616,39 @@ public void stopInTheMiddleOfTxAndResume() throws Exception {\n         }\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1730\")\n+    public void shouldStartConsumingFromSlotLocation() throws Exception {\n+        Testing.Print.enable();\n+\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, false)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), true);\n+        waitForStreamingToStart();\n+\n+        consumer = testConsumer(1);\n+        executeAndWait(\"INSERT INTO test_table (text) VALUES ('insert2')\");\n+        consumer.remove();\n+\n+        stopConnector();\n+        TestHelper.execute(\n+                \"INSERT INTO test_table (text) VALUES ('insert3');\",\n+                \"INSERT INTO test_table (text) VALUES ('insert4')\");\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, true)\n+                .with(PostgresConnectorConfig.SNAPSHOT_MODE, PostgresConnectorConfig.SnapshotMode.NEVER)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), false);\n+\n+        consumer.expects(2);\n+        consumer.await(TestHelper.waitTimeForRecords() * 5, TimeUnit.SECONDS);\n+\n+        // We cannot guarantee the flush timing so it is possible that insert2 record will be redelivered\n+        Assertions.assertThat(((Struct) consumer.remove().value()).getStruct(\"after\").getString(\"text\")).isIn(Collect.unmodifiableSet(\"insert2\", \"insert3\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1Nzk5MA=="}, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgzMjIwNw==", "bodyText": "@gunnarmorling The problem is that this is important in case of snapthot -> streaming transition. I'd prefer to keep it as is and log a follow-up issue if we want to get it in 1.1.0.CR1. Otherwise we can return back to it later.", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390832207", "createdAt": "2020-03-11T09:13:47Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1613,6 +1616,39 @@ public void stopInTheMiddleOfTxAndResume() throws Exception {\n         }\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1730\")\n+    public void shouldStartConsumingFromSlotLocation() throws Exception {\n+        Testing.Print.enable();\n+\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, false)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), true);\n+        waitForStreamingToStart();\n+\n+        consumer = testConsumer(1);\n+        executeAndWait(\"INSERT INTO test_table (text) VALUES ('insert2')\");\n+        consumer.remove();\n+\n+        stopConnector();\n+        TestHelper.execute(\n+                \"INSERT INTO test_table (text) VALUES ('insert3');\",\n+                \"INSERT INTO test_table (text) VALUES ('insert4')\");\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, true)\n+                .with(PostgresConnectorConfig.SNAPSHOT_MODE, PostgresConnectorConfig.SnapshotMode.NEVER)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), false);\n+\n+        consumer.expects(2);\n+        consumer.await(TestHelper.waitTimeForRecords() * 5, TimeUnit.SECONDS);\n+\n+        // We cannot guarantee the flush timing so it is possible that insert2 record will be redelivered\n+        Assertions.assertThat(((Struct) consumer.remove().value()).getStruct(\"after\").getString(\"text\")).isIn(Collect.unmodifiableSet(\"insert2\", \"insert3\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1Nzk5MA=="}, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg4Njk0NA==", "bodyText": "Re-processing the confirmed_flush_lsn is not a problem for me at all.\nI was just suggesting that your test could possibly be more explicit. Maybe in the future you could make it available as a config option, but it's not important for me now.", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r390886944", "createdAt": "2020-03-11T10:49:46Z", "author": {"login": "cjbooms"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1613,6 +1616,39 @@ public void stopInTheMiddleOfTxAndResume() throws Exception {\n         }\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1730\")\n+    public void shouldStartConsumingFromSlotLocation() throws Exception {\n+        Testing.Print.enable();\n+\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, false)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), true);\n+        waitForStreamingToStart();\n+\n+        consumer = testConsumer(1);\n+        executeAndWait(\"INSERT INTO test_table (text) VALUES ('insert2')\");\n+        consumer.remove();\n+\n+        stopConnector();\n+        TestHelper.execute(\n+                \"INSERT INTO test_table (text) VALUES ('insert3');\",\n+                \"INSERT INTO test_table (text) VALUES ('insert4')\");\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, true)\n+                .with(PostgresConnectorConfig.SNAPSHOT_MODE, PostgresConnectorConfig.SnapshotMode.NEVER)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), false);\n+\n+        consumer.expects(2);\n+        consumer.await(TestHelper.waitTimeForRecords() * 5, TimeUnit.SECONDS);\n+\n+        // We cannot guarantee the flush timing so it is possible that insert2 record will be redelivered\n+        Assertions.assertThat(((Struct) consumer.remove().value()).getStruct(\"after\").getString(\"text\")).isIn(Collect.unmodifiableSet(\"insert2\", \"insert3\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1Nzk5MA=="}, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3NzYyNA==", "bodyText": "@cjbooms - I just improved the test description. In fact we cannot do anything about this as the offset loss is the same as doing snapshot never mode and cannot be separated without intorducing a new snapshot mode or config option.\nAs this is a real corner case I'd keep it as is.", "url": "https://github.com/debezium/debezium/pull/1322#discussion_r391677624", "createdAt": "2020-03-12T14:54:38Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1613,6 +1616,39 @@ public void stopInTheMiddleOfTxAndResume() throws Exception {\n         }\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1730\")\n+    public void shouldStartConsumingFromSlotLocation() throws Exception {\n+        Testing.Print.enable();\n+\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, false)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), true);\n+        waitForStreamingToStart();\n+\n+        consumer = testConsumer(1);\n+        executeAndWait(\"INSERT INTO test_table (text) VALUES ('insert2')\");\n+        consumer.remove();\n+\n+        stopConnector();\n+        TestHelper.execute(\n+                \"INSERT INTO test_table (text) VALUES ('insert3');\",\n+                \"INSERT INTO test_table (text) VALUES ('insert4')\");\n+        startConnector(config -> config\n+                .with(PostgresConnectorConfig.DROP_SLOT_ON_STOP, true)\n+                .with(PostgresConnectorConfig.SNAPSHOT_MODE, PostgresConnectorConfig.SnapshotMode.NEVER)\n+                .with(EmbeddedEngine.OFFSET_STORAGE, MemoryOffsetBackingStore.class), false);\n+\n+        consumer.expects(2);\n+        consumer.await(TestHelper.waitTimeForRecords() * 5, TimeUnit.SECONDS);\n+\n+        // We cannot guarantee the flush timing so it is possible that insert2 record will be redelivered\n+        Assertions.assertThat(((Struct) consumer.remove().value()).getStruct(\"after\").getString(\"text\")).isIn(Collect.unmodifiableSet(\"insert2\", \"insert3\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1Nzk5MA=="}, "originalCommit": {"oid": "b5f2db3be47a35d1761accb694b38e6718f0e2db"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4447, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}