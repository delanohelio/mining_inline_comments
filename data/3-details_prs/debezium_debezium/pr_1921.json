{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNDM1OTM1", "number": 1921, "title": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring", "bodyText": "https://issues.redhat.com/browse/DBZ-2704\nThis fix addresses the specific test failure; however as mentioned in the Jira; I think we may need a follow-up that may only apply to PostgreSQL to deal with empty transactions, e.g. BEGIN/END messages without any DML operations.", "createdAt": "2020-10-29T17:18:55Z", "url": "https://github.com/debezium/debezium/pull/1921", "merged": true, "mergeCommit": {"oid": "6c34a6e3f27f1248b74a9a8040b9068c6be36f57"}, "closed": true, "closedAt": "2020-11-04T05:15:17Z", "author": {"login": "Naros"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXjqCMgFqTUyMDUxMzcwNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY8YwrAH2gAyNTEyNDM1OTM1OjJiMDZmMDI1MjVlY2I0NTFlNmE5YTk2ODQ1YzM0OWIyZTg4M2EyNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNTEzNzA3", "url": "https://github.com/debezium/debezium/pull/1921#pullrequestreview-520513707", "createdAt": "2020-10-30T09:49:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo0OTo1M1rOHrH5sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTo0OTo1M1rOHrH5sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MDI3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                if (!actualRecords.keySet().contains(record.topic())) {\n          \n          \n            \n                                                if (!actualRecords.containsKey(record.topic())) {", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r514980272", "createdAt": "2020-10-30T09:49:53Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -1094,9 +1097,33 @@ public void shouldRegularlyFlushLsnWithTxMonitoring() throws InterruptedExceptio\n             for (int i = 2; i <= recordCount + 2; i++) {\n                 TestHelper.execute(INSERT_STMT);\n \n-                final SourceRecords actualRecords = consumeRecordsByTopic(3);\n-                assertThat(actualRecords.topics().size()).isEqualTo(2);\n-                assertThat(actualRecords.recordsForTopic(topicName(\"s1.a\")).size()).isEqualTo(1);\n+                final Map<String, List<SourceRecord>> actualRecords = new HashMap<>();\n+                try {\n+                    Awaitility.await()\n+                            .atMost(5 * TestHelper.waitTimeForRecords(), TimeUnit.SECONDS)\n+                            .until(() -> {\n+                                // consume all available records\n+                                List<SourceRecord> records = new LinkedList<>();\n+                                consumeAvailableRecords(records::add);\n+\n+                                // capture all topics\n+                                for (SourceRecord record : records) {\n+                                    if (!actualRecords.keySet().contains(record.topic())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "author": {"user": {"login": "Naros", "name": "Chris Cranford"}}, "url": "https://github.com/debezium/debezium/commit/c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "committedDate": "2020-11-02T16:54:18Z", "message": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "author": {"user": {"login": "Naros", "name": "Chris Cranford"}}, "url": "https://github.com/debezium/debezium/commit/c8f0bd9dd67acc3bde0f1c39f812c0d675e16480", "committedDate": "2020-11-02T16:54:18Z", "message": "DBZ-2704 Fix test failure - PostgresConnectorIT#shouldRegularlyFlushLsnWithTxMonitoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTkzMDUw", "url": "https://github.com/debezium/debezium/pull/1921#pullrequestreview-522193050", "createdAt": "2020-11-03T05:11:06Z", "commit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNToxMTowNlrOHsgc8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTozMjo0N1rOHsguNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzMTA5MA==", "bodyText": "SHould not the assert call isTransactionRecord method instead of chekcing the topic name?", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516431090", "createdAt": "2020-11-03T05:11:06Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -640,6 +781,13 @@ protected void assertNoRecordsToConsume() {\n         assertThat(consumedLines.isEmpty()).isTrue();\n     }\n \n+    /**\n+     * Assert that there are only transaction topic records to be consumed.\n+     */\n+    protected void assertOnlyTransactionRecordsToConsume() {\n+        consumedLines.iterator().forEachRemaining(r -> assertThat(r.topic()).endsWith(\".transaction\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTEyOQ==", "bodyText": "Even if it is not strictly necessary I'd prefer to process even the incoming tx BEGIN to ensure symmetry between BEGIN/END messages.", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435129", "createdAt": "2020-11-03T05:30:51Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    debug(record);\n+                }\n+                else if (Testing.Print.isEnabled()) {\n+                    Testing.print(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"\n+                            + (numberOfRecords - recordsConsumed) + \" more)\");\n+                    print(record);\n+                }\n+                if (assertRecords) {\n+                    VerifyRecord.isValid(record);\n+                }\n+            }\n+            else {\n+                if (++nullReturn >= breakAfterNulls) {\n+                    return recordsConsumed;\n+                }\n+            }\n+        }\n+\n+        while (!endTransactions.isEmpty()) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.END.name())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTI4NQ==", "bodyText": "Could the log messages here and down contain also information about endTransactions?", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435285", "createdAt": "2020-11-03T05:31:41Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;\n+                }\n+                if (recordConsumer != null) {\n+                    recordConsumer.accept(record);\n+                }\n+                if (Testing.Debug.isEnabled()) {\n+                    Testing.debug(\"Consumed record \" + recordsConsumed + \" / \" + numberOfRecords + \" (\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNTUwOA==", "bodyText": "Here it would be great to assert that the DML message txId is present in endTransactions", "url": "https://github.com/debezium/debezium/pull/1921#discussion_r516435508", "createdAt": "2020-11-03T05:32:47Z", "author": {"login": "jpechane"}, "path": "debezium-embedded/src/test/java/io/debezium/embedded/AbstractConnectorTest.java", "diffHunk": "@@ -500,6 +503,144 @@ protected SourceRecords consumeRecordsByTopic(int numRecords, boolean assertReco\n         return records;\n     }\n \n+    /**\n+     * Try to consume and capture exactly the specified number of Dml records from the connector.\n+     *\n+     * While transaction metadata topic records are captured by this method, the {@code numDmlRecords} should not\n+     * include the expected number of records emitted to the transaction topic.\n+     *\n+     * @param numDmlRecords the number of Dml records that should be consumed\n+     * @return the collector to which the records were captured; never null\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected SourceRecords consumeDmlRecordsByTopic(int numDmlRecords) throws InterruptedException {\n+        SourceRecords records = new SourceRecords();\n+        consumeDmlRecordsByTopic(numDmlRecords, records::add);\n+        return records;\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     * For slower connectors it is possible to receive no records form the connector at most 3 times in a row\n+     * till the waiting is terminated.\n+     *\n+     * @param numberDmlRecords the number of Dml records that should be consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberDmlRecords, Consumer<SourceRecord> recordConsumer) throws InterruptedException {\n+        return consumeDmlRecordsByTopic(numberDmlRecords, 3, recordConsumer, true);\n+    }\n+\n+    /**\n+     * Try to consume the specified number of records from the connector, calling the given function for each, and return the\n+     * actual number of Dml records that were consumed.\n+     *\n+     * For slower connectors it is possible to receive no records from the connector at most 3 times in a row\n+     * until the waiting is terminated.  Additionally, while this method will consume and append transaction metadata\n+     * topic records to the consumer, the returned value only considers Dml records.\n+     *\n+     * @param numberOfRecords the number of Dml records that should be consumed\n+     * @param breakAfterNulls the number of allowed run when no records are consumed\n+     * @param recordConsumer the function that should be called for each consumed record\n+     * @param assertRecords true if records serialization should be verified\n+     * @return the actual number of Dml records that were consumed\n+     * @throws InterruptedException if the thread was interrupted while waiting for a record to be returned\n+     */\n+    protected int consumeDmlRecordsByTopic(int numberOfRecords, int breakAfterNulls, Consumer<SourceRecord> recordConsumer, boolean assertRecords)\n+            throws InterruptedException {\n+        int recordsConsumed = 0;\n+        int nullReturn = 0;\n+        Set<String> endTransactions = new LinkedHashSet<>();\n+        while (recordsConsumed < numberOfRecords) {\n+            SourceRecord record = consumedLines.poll(pollTimeoutInMs, TimeUnit.MILLISECONDS);\n+            if (record != null) {\n+                nullReturn = 0;\n+                if (isTransactionRecord(record)) {\n+                    final Struct value = (Struct) record.value();\n+                    final String status = value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_STATUS_KEY);\n+                    if (status.equals(TransactionStatus.BEGIN.name())) {\n+                        endTransactions.add(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                    else {\n+                        endTransactions.remove(value.getString(TransactionMonitor.DEBEZIUM_TRANSACTION_ID_KEY));\n+                    }\n+                }\n+                else {\n+                    ++recordsConsumed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8f0bd9dd67acc3bde0f1c39f812c0d675e16480"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b06f02525ecb451e6a9a96845c349b2e883a256", "author": {"user": {"login": "Naros", "name": "Chris Cranford"}}, "url": "https://github.com/debezium/debezium/commit/2b06f02525ecb451e6a9a96845c349b2e883a256", "committedDate": "2020-11-03T17:12:46Z", "message": "DBZ-2704 Suggested fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2349, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}