{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDU5MzU3", "number": 1343, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NDowM1rODonIHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMToyODoyNlrODrK6hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTEwNjg0OnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NDowM1rOF3Q1bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NDowM1rOF3Q1bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MTgyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void shouldEmitOldkeyHeaderOnPrimaryKeyUpdate() throws Exception {\n          \n          \n            \n                public void shouldEmitOldKeyHeaderOnPrimaryKeyUpdate() throws Exception {", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393491820", "createdAt": "2020-03-17T07:44:03Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "diffHunk": "@@ -1983,4 +2014,57 @@ private void waitForStreamingRunning(String serverName) throws InterruptedExcept\n         final List<SourceRecord> uc = records.recordsForTopic(RO_DATABASE.topicForTable(\"Products\"));\n         return uc != null ? uc : records.recordsForTopic(RO_DATABASE.topicForTable(\"products\"));\n     }\n+\n+    @Test\n+    @FixFor(\"DBZ-1531\")\n+    public void shouldEmitOldkeyHeaderOnPrimaryKeyUpdate() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTExMDI4OnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NTozMVrOF3Q3ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1MzowMFrOF3S1iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjM4Mg==", "bodyText": "Ok, so that's still WIP, right :)\nBtw. IIRC you mentioned via DM that it couldn't be done for MySQL because it would send DELETE + UPDATE by itself. If true indeed, it seems there should be no test for MySQL to begin with?", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393492382", "createdAt": "2020-03-17T07:45:31Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "diffHunk": "@@ -1983,4 +2014,57 @@ private void waitForStreamingRunning(String serverName) throws InterruptedExcept\n         final List<SourceRecord> uc = records.recordsForTopic(RO_DATABASE.topicForTable(\"Products\"));\n         return uc != null ? uc : records.recordsForTopic(RO_DATABASE.topicForTable(\"products\"));\n     }\n+\n+    @Test\n+    @FixFor(\"DBZ-1531\")\n+    public void shouldEmitOldkeyHeaderOnPrimaryKeyUpdate() throws Exception {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.NEVER)\n+                .build();\n+\n+        // Start the connector ...\n+        start(MySqlConnector.class, config);\n+\n+        // ---------------------------------------------------------------------------------------------------------------\n+        // Consume all of the events due to startup and initialization of the database\n+        // ---------------------------------------------------------------------------------------------------------------\n+        SourceRecords records = consumeRecordsByTopic(INITIAL_EVENT_COUNT); // 6 DDL changes\n+        assertThat(records.recordsForTopic(DATABASE.topicForTable(\"orders\")).size()).isEqualTo(5);\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET order_number=10303 WHERE order_number=10003\");\n+            }\n+        }\n+        // Consume the update of the PK, which is one insert followed by a delete followed by a tombstone ...\n+        records = consumeRecordsByTopic(3);\n+        List<SourceRecord> updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+\n+        assertThat(updates.size()).isEqualTo(3);\n+\n+        SourceRecord deleteRecord = updates.get(0);\n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers\n+        Header keyPKUpdateHeader = getPKUpdateNewKeyHeader(deleteRecord);\n+        assertEquals(Integer.valueOf(10303), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        SourceRecord insertRecord = updates.get(2);\n+        assertEquals(1, insertRecord.headers().size()); // to be removed/updated once we set additional headers\n+        keyPKUpdateHeader = getPKUpdateOldKeyHeader(insertRecord);\n+        assertEquals(Integer.valueOf(10003), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET quantity=5 WHERE order_number=10004\");\n+            }\n+        }\n+        records = consumeRecordsByTopic(5);\n+        updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+        assertThat(updates.size()).isEqualTo(1);\n+\n+        SourceRecord updateRecord = updates.get(0);\n+        assertEquals(0, updateRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMTE1Mw==", "bodyText": "You are mistaken here, did you read my last comment? \ud83e\udd14\nI said that SQL Server isn't possible (commented above), not MysQL. I indeed wrote you that MySQL is done too.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393521153", "createdAt": "2020-03-17T08:46:43Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "diffHunk": "@@ -1983,4 +2014,57 @@ private void waitForStreamingRunning(String serverName) throws InterruptedExcept\n         final List<SourceRecord> uc = records.recordsForTopic(RO_DATABASE.topicForTable(\"Products\"));\n         return uc != null ? uc : records.recordsForTopic(RO_DATABASE.topicForTable(\"products\"));\n     }\n+\n+    @Test\n+    @FixFor(\"DBZ-1531\")\n+    public void shouldEmitOldkeyHeaderOnPrimaryKeyUpdate() throws Exception {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.NEVER)\n+                .build();\n+\n+        // Start the connector ...\n+        start(MySqlConnector.class, config);\n+\n+        // ---------------------------------------------------------------------------------------------------------------\n+        // Consume all of the events due to startup and initialization of the database\n+        // ---------------------------------------------------------------------------------------------------------------\n+        SourceRecords records = consumeRecordsByTopic(INITIAL_EVENT_COUNT); // 6 DDL changes\n+        assertThat(records.recordsForTopic(DATABASE.topicForTable(\"orders\")).size()).isEqualTo(5);\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET order_number=10303 WHERE order_number=10003\");\n+            }\n+        }\n+        // Consume the update of the PK, which is one insert followed by a delete followed by a tombstone ...\n+        records = consumeRecordsByTopic(3);\n+        List<SourceRecord> updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+\n+        assertThat(updates.size()).isEqualTo(3);\n+\n+        SourceRecord deleteRecord = updates.get(0);\n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers\n+        Header keyPKUpdateHeader = getPKUpdateNewKeyHeader(deleteRecord);\n+        assertEquals(Integer.valueOf(10303), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        SourceRecord insertRecord = updates.get(2);\n+        assertEquals(1, insertRecord.headers().size()); // to be removed/updated once we set additional headers\n+        keyPKUpdateHeader = getPKUpdateOldKeyHeader(insertRecord);\n+        assertEquals(Integer.valueOf(10003), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET quantity=5 WHERE order_number=10004\");\n+            }\n+        }\n+        records = consumeRecordsByTopic(5);\n+        updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+        assertThat(updates.size()).isEqualTo(1);\n+\n+        SourceRecord updateRecord = updates.get(0);\n+        assertEquals(0, updateRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjM4Mg=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyNDYxOQ==", "bodyText": "Ah, I see, I mixed this up then. Thanks for clarifying.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393524619", "createdAt": "2020-03-17T08:53:00Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "diffHunk": "@@ -1983,4 +2014,57 @@ private void waitForStreamingRunning(String serverName) throws InterruptedExcept\n         final List<SourceRecord> uc = records.recordsForTopic(RO_DATABASE.topicForTable(\"Products\"));\n         return uc != null ? uc : records.recordsForTopic(RO_DATABASE.topicForTable(\"products\"));\n     }\n+\n+    @Test\n+    @FixFor(\"DBZ-1531\")\n+    public void shouldEmitOldkeyHeaderOnPrimaryKeyUpdate() throws Exception {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.NEVER)\n+                .build();\n+\n+        // Start the connector ...\n+        start(MySqlConnector.class, config);\n+\n+        // ---------------------------------------------------------------------------------------------------------------\n+        // Consume all of the events due to startup and initialization of the database\n+        // ---------------------------------------------------------------------------------------------------------------\n+        SourceRecords records = consumeRecordsByTopic(INITIAL_EVENT_COUNT); // 6 DDL changes\n+        assertThat(records.recordsForTopic(DATABASE.topicForTable(\"orders\")).size()).isEqualTo(5);\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET order_number=10303 WHERE order_number=10003\");\n+            }\n+        }\n+        // Consume the update of the PK, which is one insert followed by a delete followed by a tombstone ...\n+        records = consumeRecordsByTopic(3);\n+        List<SourceRecord> updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+\n+        assertThat(updates.size()).isEqualTo(3);\n+\n+        SourceRecord deleteRecord = updates.get(0);\n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers\n+        Header keyPKUpdateHeader = getPKUpdateNewKeyHeader(deleteRecord);\n+        assertEquals(Integer.valueOf(10303), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        SourceRecord insertRecord = updates.get(2);\n+        assertEquals(1, insertRecord.headers().size()); // to be removed/updated once we set additional headers\n+        keyPKUpdateHeader = getPKUpdateOldKeyHeader(insertRecord);\n+        assertEquals(Integer.valueOf(10003), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET quantity=5 WHERE order_number=10004\");\n+            }\n+        }\n+        records = consumeRecordsByTopic(5);\n+        updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+        assertThat(updates.size()).isEqualTo(1);\n+\n+        SourceRecord updateRecord = updates.get(0);\n+        assertEquals(0, updateRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjM4Mg=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTExNDA5OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NzowMFrOF3Q5yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOToyMDozNVrOF3Tx5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjkzOQ==", "bodyText": "I'm a bit confused by these. Are these TODO markers for later (after this PR), or are you planning to address them as part of this PR?", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393492939", "createdAt": "2020-03-17T07:47:00Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -693,6 +710,11 @@ public void shouldReceiveChangesForUpdatesWithPKChanges() throws Exception {\n         assertEquals(topicName, deleteRecord.topic());\n         VerifyRecord.isValidDelete(deleteRecord, PK_FIELD, 1);\n \n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMjc1OQ==", "bodyText": "yes and no, they are there for future me (and you) after this PR. When we decide to add more headers in the future, this comparison will fail because total header count will be more than 1.\nI thought it might be a good idea to first check if there are headers (could also change to >1, but == 1 was more strict for now) before checking the respective header directly.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393522759", "createdAt": "2020-03-17T08:49:38Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -693,6 +710,11 @@ public void shouldReceiveChangesForUpdatesWithPKChanges() throws Exception {\n         assertEquals(topicName, deleteRecord.topic());\n         VerifyRecord.isValidDelete(deleteRecord, PK_FIELD, 1);\n \n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjkzOQ=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyNDQwMw==", "bodyText": "Ok, I see. I'd suggest to remove those comments then, as they are confusing IMO. It's expected that existing tests needs adjustment after changes down the road. Right now it sounds a bit as if there's a loose end.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393524403", "createdAt": "2020-03-17T08:52:37Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -693,6 +710,11 @@ public void shouldReceiveChangesForUpdatesWithPKChanges() throws Exception {\n         assertEquals(topicName, deleteRecord.topic());\n         VerifyRecord.isValidDelete(deleteRecord, PK_FIELD, 1);\n \n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjkzOQ=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzNDk0MA==", "bodyText": "Remove comments or remove the these asserts, or rephrase?\nDon't you think that people working on adding headers in the future will get failing tests and need a lot of time to figure out that they should just update or remove that comparison to 1? I put it because I thought it could annoy future me? But maybe I am too careful here?", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393534940", "createdAt": "2020-03-17T09:11:44Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -693,6 +710,11 @@ public void shouldReceiveChangesForUpdatesWithPKChanges() throws Exception {\n         assertEquals(topicName, deleteRecord.topic());\n         VerifyRecord.isValidDelete(deleteRecord, PK_FIELD, 1);\n \n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjkzOQ=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0MDA3MA==", "bodyText": "Generally speaking, I think if someone adds a feature introducing a new header down the road, they'd quite quickly see why this assertion is failing. But taking a step back, let's just remove the assertion. You assert on the actual header value on the next line anyways, and that's what matters for this test here. It does't really need to be concerned with other headers being present.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393540070", "createdAt": "2020-03-17T09:20:35Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -693,6 +710,11 @@ public void shouldReceiveChangesForUpdatesWithPKChanges() throws Exception {\n         assertEquals(topicName, deleteRecord.topic());\n         VerifyRecord.isValidDelete(deleteRecord, PK_FIELD, 1);\n \n+        assertEquals(1, deleteRecord.headers().size()); // to be removed/updated once we set additional headers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MjkzOQ=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTExNTU5OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNzo0NzozNlrOF3Q6uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMTowMTowOFrOF7V4fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng==", "bodyText": "Is this going to be addressed as part of this PR?", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393493176", "createdAt": "2020-03-17T07:47:36Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyNjQ4OA==", "bodyText": "I think it shouldn't. What do you suggest?\nFrom my point it's just a helper when you create a new Connector implementation and you use a ChangeRecordEmitter that's not capable of creating headers (that doesn't implement the new signature of changeRecord(...), then you get warned. Especially when you provide a ChangeRecordEmitter as Lambda or anon class that might be helpful?\nOther alternative would be a extended interface to ChangeRecordEmitter, like ChangeRecordWithHeadersEmitter.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393526488", "createdAt": "2020-03-17T08:56:19Z", "author": {"login": "rk3rn3r"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0Mjk1OA==", "bodyText": "I'd prefer this to be a plain interface method, i.e. non-defaulted. Receiver is a callback interface that's implemented by Debezium core, not connectors. Hence there shouldn't be a case where implementations don't support headers.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393542958", "createdAt": "2020-03-17T09:25:34Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU3NTM2Mg==", "bodyText": "But ChangeRecordEmitter is implemented by Connectors and they are the callers for receiver which is the nested interface. And there are already Connectors that can't physically support the header we are sending now (so they don't have any need for headers. yet.)\nShouldn't it be optional for them to choose if they send with headers or without?\nThen we have 2 options:\n\nlike I did now: one method with two signatures in one interface, where the one with headers is optional (comes with default implementation), the default implementation in debezium-core offers both, but Connectors can implement their own ChangeRecordEmitter with their own Receiver and freely choose if they send with or without headers (they just need to make sure in their Reiceiver they provide an implementation with headers)\ntwo interfaces Receiver and ReceiverWithHeaders: currently Receiver is only implemented in debezium-core, but everyone could provide it's own receiver because its not closed (open-close-principle). I think we can't assume everyone is using our base implementation in debezium-core, that's why I think this option might be a bad choice. also it comes with many more code changes, the default implementation in debezium-core gets complex as it needs implementation for void emitChangeRecords(DataCollectionSchema schema, Receiver receiver) and for void emitChangeRecords(DataCollectionSchema schema, ReceiverWithHeaders receiver).\n\nIf you want no one to implement Receiver interface we should extract it from ChangeRecordEmitter and make private/package-private.\nAlternative:\n\nmake providing headers mandatory for Receicer#changeRecord() and send null as default in all cases where there's nothing to send (but this is a breaking change, I want to avoid this because Receiver and ChangeRecordEmitter are public and this would be an API break, or am I wrong here?", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393575362", "createdAt": "2020-03-17T10:21:49Z", "author": {"login": "rk3rn3r"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyODQ5NQ==", "bodyText": "Receiver is not meant to be implemented by connectors, only by core. About ChangeRecordEmitter, changing that could be considered breaking, but so far we didn't consider any APIs/SPIs geared towards connector implementors as public contracts. I.e. we don't (yet) pursue a model with a stable API to be used by connector implementors unbeknownst to us.\nI'd simply change the Receiver method (adding the headers param) and adjust all existing emitter implementations. Either passing the headers, or null if they can't. Let's not overcomplicate things :)", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r394228495", "createdAt": "2020-03-18T10:01:19Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc2ODgyOQ==", "bodyText": "I'll remove the default implementation, it's not really required any longer.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r397768829", "createdAt": "2020-03-25T11:01:08Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/spi/ChangeRecordEmitter.java", "diffHunk": "@@ -30,6 +31,20 @@\n     OffsetContext getOffset();\n \n     public interface Receiver {\n-        void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException;\n+        void changeRecord(DataCollectionSchema schema,\n+                          Operation operation,\n+                          Object key, Struct value,\n+                          OffsetContext offset)\n+                throws InterruptedException;\n+\n+        default void changeRecord(DataCollectionSchema schema,\n+                                  Operation operation,\n+                                  Object key, Struct value,\n+                                  OffsetContext offset,\n+                                  ConnectHeaders headers)\n+                throws InterruptedException {\n+            throw new RuntimeException(\"Not implemented yet in \" + this.getClass().getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5MzE3Ng=="}, "originalCommit": {"oid": "86d6494aedda966c379b8e00a495050c93e233d0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTM4NjI2OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/RelationalChangeRecordEmitter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOToxNTozNVrOF3TmpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwOTo1NzowNlrOF39oKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzNzE4OA==", "bodyText": "what do you think about the const name and the header field name?\nI was also thinking about pk-update-ref-oldkey and  pk-update-ref-oldkey or similar, or namespacing it somehow with debezium?\n(applies also to next line)", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r393537188", "createdAt": "2020-03-17T09:15:35Z", "author": {"login": "rk3rn3r"}, "path": "debezium-core/src/main/java/io/debezium/relational/RelationalChangeRecordEmitter.java", "diffHunk": "@@ -25,6 +26,9 @@\n  */\n public abstract class RelationalChangeRecordEmitter extends AbstractChangeRecordEmitter<TableSchema> {\n \n+    public static final String PK_UPDATE_OLDKEY_FIELD = \"oldkey\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61bd7f850f8cb8d749bb577af0dcc55217e734a4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyNTcwNg==", "bodyText": "No opinion on the const name. Regarding header field names, that's a good point. We use \"__debezium.\" as a prefix in some other places, so might be a good idea here, too.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r394225706", "createdAt": "2020-03-18T09:57:06Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/RelationalChangeRecordEmitter.java", "diffHunk": "@@ -25,6 +26,9 @@\n  */\n public abstract class RelationalChangeRecordEmitter extends AbstractChangeRecordEmitter<TableSchema> {\n \n+    public static final String PK_UPDATE_OLDKEY_FIELD = \"oldkey\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzNzE4OA=="}, "originalCommit": {"oid": "61bd7f850f8cb8d749bb577af0dcc55217e734a4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NTg0OTU4OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/pipeline/EventDispatcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMTowMjowMFrOF7V6Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMTowMjowMFrOF7V6Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc2OTMxOQ==", "bodyText": "The formatting (line wrapping) changes mixed with actual code changes make it a bit harder to grasp than needed. Better to keep these things separate.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r397769319", "createdAt": "2020-03-25T11:02:00Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/pipeline/EventDispatcher.java", "diffHunk": "@@ -255,17 +262,27 @@ public void dispatchTransactionMessage(SourceRecord record) throws InterruptedEx\n     private final class StreamingChangeRecordReceiver implements ChangeRecordEmitter.Receiver {\n \n         @Override\n-        public void changeRecord(DataCollectionSchema dataCollectionSchema, Operation operation, Object key, Struct value, OffsetContext offsetContext)\n+        public void changeRecord(DataCollectionSchema dataCollectionSchema,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a07473f20405a53cb2d83e19d5c92a6b129737db"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NTk0MTgzOnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMToyODoyNlrOF7WyhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMToyODoyNlrOF7WyhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc4MzY4NA==", "bodyText": "That's unused. I'll expand a bit to assert the header isn't present for this record.", "url": "https://github.com/debezium/debezium/pull/1343#discussion_r397783684", "createdAt": "2020-03-25T11:28:26Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlConnectorIT.java", "diffHunk": "@@ -1983,4 +2012,54 @@ private void waitForStreamingRunning(String serverName) throws InterruptedExcept\n         final List<SourceRecord> uc = records.recordsForTopic(RO_DATABASE.topicForTable(\"Products\"));\n         return uc != null ? uc : records.recordsForTopic(RO_DATABASE.topicForTable(\"products\"));\n     }\n+\n+    @Test\n+    @FixFor(\"DBZ-1531\")\n+    public void shouldEmitHeadersOnPrimaryKeyUpdate() throws Exception {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.NEVER)\n+                .build();\n+\n+        // Start the connector ...\n+        start(MySqlConnector.class, config);\n+\n+        // ---------------------------------------------------------------------------------------------------------------\n+        // Consume all of the events due to startup and initialization of the database\n+        // ---------------------------------------------------------------------------------------------------------------\n+        SourceRecords records = consumeRecordsByTopic(INITIAL_EVENT_COUNT); // 6 DDL changes\n+        assertThat(records.recordsForTopic(DATABASE.topicForTable(\"orders\")).size()).isEqualTo(5);\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET order_number=10303 WHERE order_number=10003\");\n+            }\n+        }\n+        // Consume the update of the PK, which is one insert followed by a delete followed by a tombstone ...\n+        records = consumeRecordsByTopic(3);\n+        List<SourceRecord> updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+\n+        assertThat(updates.size()).isEqualTo(3);\n+\n+        SourceRecord deleteRecord = updates.get(0);\n+        Header keyPKUpdateHeader = getPKUpdateNewKeyHeader(deleteRecord);\n+        assertEquals(Integer.valueOf(10303), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        SourceRecord insertRecord = updates.get(2);\n+        keyPKUpdateHeader = getPKUpdateOldKeyHeader(insertRecord);\n+        assertEquals(Integer.valueOf(10003), ((Struct) keyPKUpdateHeader.value()).getInt32(\"order_number\"));\n+\n+        try (MySQLConnection db = MySQLConnection.forTestDatabase(DATABASE.getDatabaseName());) {\n+            try (JdbcConnection connection = db.connect()) {\n+                connection.execute(\"UPDATE orders SET quantity=5 WHERE order_number=10004\");\n+            }\n+        }\n+        records = consumeRecordsByTopic(5);\n+        updates = records.recordsForTopic(DATABASE.topicForTable(\"orders\"));\n+        assertThat(updates.size()).isEqualTo(1);\n+\n+        SourceRecord updateRecord = updates.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a07473f20405a53cb2d83e19d5c92a6b129737db"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4462, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}