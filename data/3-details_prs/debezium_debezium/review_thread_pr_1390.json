{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MTMyNjEx", "number": 1390, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjo1NDoyN1rODu_ZbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODozODoxMVrODvsQuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNTk5Nzg4OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjo1NDoyN1rOGBJ-ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzo0MTowMlrOGBLVAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTE4OQ==", "bodyText": "Could you use ExecutorService instead? It should be the preferred way for async task execution.", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403865189", "createdAt": "2020-04-06T06:54:27Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NjMxNA==", "bodyText": "@gunnarmorling I tend to disagree here - the thread is fire and forget. If we want to do the same with the Executor we would need to provide a ThreadFactory that does exactly the same - create a thread and set it to daemon and then we should close it to ensure a smmetry in the code. I believe this is a more pragmatic solution given its intent", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403876314", "createdAt": "2020-04-06T07:19:10Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTE4OQ=="}, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4MTM3OQ==", "bodyText": "The point on thread factory is a good one actually, as it ensures right naming of the thread. See Threads.newSingleThreadExecutor().", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403881379", "createdAt": "2020-04-06T07:29:18Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTE4OQ=="}, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzM2Mg==", "bodyText": "@gunnarmorling ThreadFactory ensure naming only if setName is explictly called on the created thread which was done even before. Anyway I've added new commit with rewrite to executors API.", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403887362", "createdAt": "2020-04-06T07:41:02Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTE4OQ=="}, "originalCommit": null, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjAwMjA4OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjo1NTo1MFrOGBKA8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoxOTozMVrOGBKqcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTg0MQ==", "bodyText": "Can you change it to static LOGGER while at it?", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403865841", "createdAt": "2020-04-06T06:55:50Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {\n+            try (AdminClient admin = AdminClient.create(this.producerConfig.asProperties())) {\n+\n+                Set<ConfigResource> resources = Collections.singleton(new ConfigResource(ConfigResource.Type.TOPIC, topicName));\n+                final Map<ConfigResource, Config> configs = admin.describeConfigs(resources).all().get(\n+                        KAFKA_QUERY_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+                if (configs.size() != 1) {\n+                    logger.info(\"Expected one topic '{}' to match the query but got {}\", topicName, configs.values().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NjQ2Ng==", "bodyText": "Done", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403876466", "createdAt": "2020-04-06T07:19:31Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,6 +327,71 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        final Thread t = new Thread((Runnable) () -> {\n+            try (AdminClient admin = AdminClient.create(this.producerConfig.asProperties())) {\n+\n+                Set<ConfigResource> resources = Collections.singleton(new ConfigResource(ConfigResource.Type.TOPIC, topicName));\n+                final Map<ConfigResource, Config> configs = admin.describeConfigs(resources).all().get(\n+                        KAFKA_QUERY_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+                if (configs.size() != 1) {\n+                    logger.info(\"Expected one topic '{}' to match the query but got {}\", topicName, configs.values().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NTg0MQ=="}, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjAwNzE0OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNjo1NzozM1rOGBKD3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNzoxOToyMFrOGBKqGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NjU5MQ==", "bodyText": "Let's use Duration.of(5 , ChronoUnit.YEARS), as per the general preference for using the semantical temporal types of Java 8.", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403866591", "createdAt": "2020-04-06T06:57:33Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -56,6 +58,16 @@\n @NotThreadSafe\n public class KafkaDatabaseHistory extends AbstractDatabaseHistory {\n \n+    private static final String CLEANUP_POLICY_NAME = \"cleanup.policy\";\n+    private static final String CLEANUP_POLICY_VALUE = \"delete\";\n+    private static final String RETENTION_MS_NAME = \"retention.ms\";\n+    private static final long RETENTION_MS_MAX = Long.MAX_VALUE;\n+    private static final long RETENTION_MS_MIN = 157_680_000_000L; // 5 years", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg3NjM3Ng==", "bodyText": "Done", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403876376", "createdAt": "2020-04-06T07:19:20Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -56,6 +58,16 @@\n @NotThreadSafe\n public class KafkaDatabaseHistory extends AbstractDatabaseHistory {\n \n+    private static final String CLEANUP_POLICY_NAME = \"cleanup.policy\";\n+    private static final String CLEANUP_POLICY_VALUE = \"delete\";\n+    private static final String RETENTION_MS_NAME = \"retention.ms\";\n+    private static final long RETENTION_MS_MAX = Long.MAX_VALUE;\n+    private static final long RETENTION_MS_MIN = 157_680_000_000L; // 5 years", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg2NjU5MQ=="}, "originalCommit": null, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjMzNTk5OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozNDowM1rOGBNKZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo0NTozOFrOGBNmHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxNzQxMw==", "bodyText": "Days, not years?", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403917413", "createdAt": "2020-04-06T08:34:03Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -56,6 +63,18 @@\n @NotThreadSafe\n public class KafkaDatabaseHistory extends AbstractDatabaseHistory {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaDatabaseHistory.class);\n+\n+    private static final String CLEANUP_POLICY_NAME = \"cleanup.policy\";\n+    private static final String CLEANUP_POLICY_VALUE = \"delete\";\n+    private static final String RETENTION_MS_NAME = \"retention.ms\";\n+    private static final long RETENTION_MS_MAX = Long.MAX_VALUE;\n+    private static final long RETENTION_MS_MIN = Duration.of(5, ChronoUnit.DAYS).toMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyNDUwOQ==", "bodyText": "Damn autocomplete, fixed", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403924509", "createdAt": "2020-04-06T08:45:38Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -56,6 +63,18 @@\n @NotThreadSafe\n public class KafkaDatabaseHistory extends AbstractDatabaseHistory {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(KafkaDatabaseHistory.class);\n+\n+    private static final String CLEANUP_POLICY_NAME = \"cleanup.policy\";\n+    private static final String CLEANUP_POLICY_VALUE = \"delete\";\n+    private static final String RETENTION_MS_NAME = \"retention.ms\";\n+    private static final long RETENTION_MS_MAX = Long.MAX_VALUE;\n+    private static final long RETENTION_MS_MIN = Duration.of(5, ChronoUnit.DAYS).toMillis();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxNzQxMw=="}, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjMzODU0OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozNDo0NVrOGBNL6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODozNDo0NVrOGBNL6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxNzgwMw==", "bodyText": "Why not using our own Threads factory? It takes care of the naming and should be the one facility for spawning new threads.", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r403917803", "createdAt": "2020-04-06T08:34:45Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -128,11 +147,21 @@\n     private volatile KafkaProducer<String, String> producer;\n     private int maxRecoveryAttempts;\n     private Duration pollInterval;\n+    private final ExecutorService checkTopicSettingsExecutor;\n+\n+    public KafkaDatabaseHistory() {\n+        checkTopicSettingsExecutor = Executors.newSingleThreadExecutor((r) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDQ2NDQ3OnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNjozNTozNlrOGB016g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwODowODowNFrOGB32uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2NzUzMA==", "bodyText": "Why are these two Fields now? Wouldn't it suffice to pass in the values when constructing the history object? I.e. when is there a need to configure this differently than for the connector itself?", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r404567530", "createdAt": "2020-04-07T06:35:36Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -108,8 +129,24 @@\n             .withDefault(100)\n             .withValidation(Field::isInteger);\n \n+    public static final Field CONNECTOR_CLASS = Field.create(CONFIGURATION_FIELD_PREFIX_STRING + \"connector.class\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "318d7be5195f359ae41016bc7c92e5342ad8826f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYxNjg4OQ==", "bodyText": "@gunnarmorling  The history obejct is constructed using Configuration.getInstance so it is not possible to pass params to the constructor. We would need to modify the signature of configure method but that would mean that we will push thses values to the implementations that does not need them", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r404616889", "createdAt": "2020-04-07T08:08:04Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -108,8 +129,24 @@\n             .withDefault(100)\n             .withValidation(Field::isInteger);\n \n+    public static final Field CONNECTOR_CLASS = Field.create(CONFIGURATION_FIELD_PREFIX_STRING + \"connector.class\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2NzUzMA=="}, "originalCommit": {"oid": "318d7be5195f359ae41016bc7c92e5342ad8826f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzM0ODQwOnYy", "diffSide": "RIGHT", "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxODozODoxMVrOGCRBjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0MDo1MFrOGCiwlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyOTI2MA==", "bodyText": "Ok, last comment on this PR, promised :) Can we move the shutdown right to the topic check (with awaitTermination()), so we don't keep it running for all the time.", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r405029260", "createdAt": "2020-04-07T18:38:11Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,8 +364,76 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        if (checkTopicSettingsExecutor == null) {\n+            return;\n+        }\n+        checkTopicSettingsExecutor.execute(() -> {\n+            try (AdminClient admin = AdminClient.create(this.producerConfig.asProperties())) {\n+\n+                Set<ConfigResource> resources = Collections.singleton(new ConfigResource(ConfigResource.Type.TOPIC, topicName));\n+                final Map<ConfigResource, Config> configs = admin.describeConfigs(resources).all().get(\n+                        KAFKA_QUERY_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+                if (configs.size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, configs.values().size());\n+                    return;\n+                }\n+                final Config topic = configs.values().iterator().next();\n+                if (topic == null) {\n+                    LOGGER.info(\"Could not get config for topic '{}'\", topic);\n+                    return;\n+                }\n+\n+                final String cleanupPolicy = topic.get(CLEANUP_POLICY_NAME).value();\n+                if (!CLEANUP_POLICY_VALUE.equals(cleanupPolicy)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, CLEANUP_POLICY_NAME, CLEANUP_POLICY_VALUE,\n+                            cleanupPolicy);\n+                    return;\n+                }\n+\n+                final String retentionBytes = topic.get(RETENTION_BYTES_NAME).value();\n+                if (retentionBytes != null && Long.parseLong(retentionBytes) != UNLIMITED_VALUE) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, RETENTION_BYTES_NAME, UNLIMITED_VALUE, retentionBytes);\n+                    return;\n+                }\n+\n+                final String retentionMs = topic.get(RETENTION_MS_NAME).value();\n+                if (retentionMs != null && (Long.parseLong(retentionMs) != UNLIMITED_VALUE && Long.parseLong(retentionMs) < RETENTION_MS_MIN)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' or greater than '{}' (5 years) but is '{}'\", topicName, RETENTION_MS_NAME,\n+                            UNLIMITED_VALUE, RETENTION_MS_MIN, retentionMs);\n+                    return;\n+                }\n+\n+                final DescribeTopicsResult result = admin.describeTopics(Collections.singleton(topicName));\n+                if (result.values().size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, result.values().size());\n+                    return;\n+                }\n+                final TopicDescription topicDesc = result.values().values().iterator().next().get();\n+                if (topicDesc == null) {\n+                    LOGGER.info(\"Could not get description for topic '{}'\", topicName);\n+                    return;\n+                }\n+\n+                final int partitions = topicDesc.partitions().size();\n+                if (partitions != PARTITION_COUNT) {\n+                    LOGGER.warn(\"Database history topic '{}' should have one partiton but has '{}'\", topicName, partitions);\n+                    return;\n+                }\n+\n+                LOGGER.info(\"Database history topic '{}' has correct settings\", topicName);\n+            }\n+            catch (Throwable e) {\n+                LOGGER.info(\"Attempted to validate database history topic but failed\", e);\n+            }\n+        });\n+    }\n+\n     @Override\n     public synchronized void stop() {\n+        if (checkTopicSettingsExecutor != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9c7d1166804297fe9b2a8ea37fe8293a5e223e3"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxMDYyMQ==", "bodyText": "@gunnarmorling Done, but I don't believe you ;-)", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r405310621", "createdAt": "2020-04-08T07:23:22Z", "author": {"login": "jpechane"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,8 +364,76 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        if (checkTopicSettingsExecutor == null) {\n+            return;\n+        }\n+        checkTopicSettingsExecutor.execute(() -> {\n+            try (AdminClient admin = AdminClient.create(this.producerConfig.asProperties())) {\n+\n+                Set<ConfigResource> resources = Collections.singleton(new ConfigResource(ConfigResource.Type.TOPIC, topicName));\n+                final Map<ConfigResource, Config> configs = admin.describeConfigs(resources).all().get(\n+                        KAFKA_QUERY_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+                if (configs.size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, configs.values().size());\n+                    return;\n+                }\n+                final Config topic = configs.values().iterator().next();\n+                if (topic == null) {\n+                    LOGGER.info(\"Could not get config for topic '{}'\", topic);\n+                    return;\n+                }\n+\n+                final String cleanupPolicy = topic.get(CLEANUP_POLICY_NAME).value();\n+                if (!CLEANUP_POLICY_VALUE.equals(cleanupPolicy)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, CLEANUP_POLICY_NAME, CLEANUP_POLICY_VALUE,\n+                            cleanupPolicy);\n+                    return;\n+                }\n+\n+                final String retentionBytes = topic.get(RETENTION_BYTES_NAME).value();\n+                if (retentionBytes != null && Long.parseLong(retentionBytes) != UNLIMITED_VALUE) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, RETENTION_BYTES_NAME, UNLIMITED_VALUE, retentionBytes);\n+                    return;\n+                }\n+\n+                final String retentionMs = topic.get(RETENTION_MS_NAME).value();\n+                if (retentionMs != null && (Long.parseLong(retentionMs) != UNLIMITED_VALUE && Long.parseLong(retentionMs) < RETENTION_MS_MIN)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' or greater than '{}' (5 years) but is '{}'\", topicName, RETENTION_MS_NAME,\n+                            UNLIMITED_VALUE, RETENTION_MS_MIN, retentionMs);\n+                    return;\n+                }\n+\n+                final DescribeTopicsResult result = admin.describeTopics(Collections.singleton(topicName));\n+                if (result.values().size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, result.values().size());\n+                    return;\n+                }\n+                final TopicDescription topicDesc = result.values().values().iterator().next().get();\n+                if (topicDesc == null) {\n+                    LOGGER.info(\"Could not get description for topic '{}'\", topicName);\n+                    return;\n+                }\n+\n+                final int partitions = topicDesc.partitions().size();\n+                if (partitions != PARTITION_COUNT) {\n+                    LOGGER.warn(\"Database history topic '{}' should have one partiton but has '{}'\", topicName, partitions);\n+                    return;\n+                }\n+\n+                LOGGER.info(\"Database history topic '{}' has correct settings\", topicName);\n+            }\n+            catch (Throwable e) {\n+                LOGGER.info(\"Attempted to validate database history topic but failed\", e);\n+            }\n+        });\n+    }\n+\n     @Override\n     public synchronized void stop() {\n+        if (checkTopicSettingsExecutor != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyOTI2MA=="}, "originalCommit": {"oid": "f9c7d1166804297fe9b2a8ea37fe8293a5e223e3"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMxOTgyOA==", "bodyText": "Let me see... ;-)", "url": "https://github.com/debezium/debezium/pull/1390#discussion_r405319828", "createdAt": "2020-04-08T07:40:50Z", "author": {"login": "gunnarmorling"}, "path": "debezium-core/src/main/java/io/debezium/relational/history/KafkaDatabaseHistory.java", "diffHunk": "@@ -314,8 +364,76 @@ public boolean exists() {\n         return exists;\n     }\n \n+    private void checkTopicSettings(String topicName) {\n+        if (checkTopicSettingsExecutor == null) {\n+            return;\n+        }\n+        checkTopicSettingsExecutor.execute(() -> {\n+            try (AdminClient admin = AdminClient.create(this.producerConfig.asProperties())) {\n+\n+                Set<ConfigResource> resources = Collections.singleton(new ConfigResource(ConfigResource.Type.TOPIC, topicName));\n+                final Map<ConfigResource, Config> configs = admin.describeConfigs(resources).all().get(\n+                        KAFKA_QUERY_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n+                if (configs.size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, configs.values().size());\n+                    return;\n+                }\n+                final Config topic = configs.values().iterator().next();\n+                if (topic == null) {\n+                    LOGGER.info(\"Could not get config for topic '{}'\", topic);\n+                    return;\n+                }\n+\n+                final String cleanupPolicy = topic.get(CLEANUP_POLICY_NAME).value();\n+                if (!CLEANUP_POLICY_VALUE.equals(cleanupPolicy)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, CLEANUP_POLICY_NAME, CLEANUP_POLICY_VALUE,\n+                            cleanupPolicy);\n+                    return;\n+                }\n+\n+                final String retentionBytes = topic.get(RETENTION_BYTES_NAME).value();\n+                if (retentionBytes != null && Long.parseLong(retentionBytes) != UNLIMITED_VALUE) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' but is '{}'\", topicName, RETENTION_BYTES_NAME, UNLIMITED_VALUE, retentionBytes);\n+                    return;\n+                }\n+\n+                final String retentionMs = topic.get(RETENTION_MS_NAME).value();\n+                if (retentionMs != null && (Long.parseLong(retentionMs) != UNLIMITED_VALUE && Long.parseLong(retentionMs) < RETENTION_MS_MIN)) {\n+                    LOGGER.warn(\"Database history topic '{}' option '{}' should be '{}' or greater than '{}' (5 years) but is '{}'\", topicName, RETENTION_MS_NAME,\n+                            UNLIMITED_VALUE, RETENTION_MS_MIN, retentionMs);\n+                    return;\n+                }\n+\n+                final DescribeTopicsResult result = admin.describeTopics(Collections.singleton(topicName));\n+                if (result.values().size() != 1) {\n+                    LOGGER.info(\"Expected one topic '{}' to match the query but got {}\", topicName, result.values().size());\n+                    return;\n+                }\n+                final TopicDescription topicDesc = result.values().values().iterator().next().get();\n+                if (topicDesc == null) {\n+                    LOGGER.info(\"Could not get description for topic '{}'\", topicName);\n+                    return;\n+                }\n+\n+                final int partitions = topicDesc.partitions().size();\n+                if (partitions != PARTITION_COUNT) {\n+                    LOGGER.warn(\"Database history topic '{}' should have one partiton but has '{}'\", topicName, partitions);\n+                    return;\n+                }\n+\n+                LOGGER.info(\"Database history topic '{}' has correct settings\", topicName);\n+            }\n+            catch (Throwable e) {\n+                LOGGER.info(\"Attempted to validate database history topic but failed\", e);\n+            }\n+        });\n+    }\n+\n     @Override\n     public synchronized void stop() {\n+        if (checkTopicSettingsExecutor != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyOTI2MA=="}, "originalCommit": {"oid": "f9c7d1166804297fe9b2a8ea37fe8293a5e223e3"}, "originalPosition": 301}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4371, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}