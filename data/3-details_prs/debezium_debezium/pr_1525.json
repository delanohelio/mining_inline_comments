{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMzkwMDUy", "number": 1525, "title": "DBZ-1813 Restrict the set of tables with a publication when using pgoutput", "bodyText": "https://issues.redhat.com/projects/DBZ/issues/DBZ-1813\n@gunnarmorling I havn't implemented the tests yet, but wanted to run this by you first before embarking on that. If you like this implementation I can work on adding in some unit tests that show the different modes.", "createdAt": "2020-05-21T14:40:16Z", "url": "https://github.com/debezium/debezium/pull/1525", "merged": true, "mergeCommit": {"oid": "d7b3f0a7fbffd87d17c9c20bd6087b5f7999c0d3"}, "closed": true, "closedAt": "2020-06-05T04:24:26Z", "author": {"login": "brbrown25"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjeu3BABqjMzNjA5NTU0MTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoAXTDABqjM0MDc2MzU1MzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTgzOTIy", "url": "https://github.com/debezium/debezium/pull/1525#pullrequestreview-416983922", "createdAt": "2020-05-22T15:06:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTowNjozMFrOGZaiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNToxMjozNlrOGZau0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwMjM3NA==", "bodyText": "Actually it's whitelist + blacklist together. Perhaps \"filter\" or \"filtered\"?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429302374", "createdAt": "2020-05-22T15:06:30Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresConnectorConfig.java", "diffHunk": "@@ -592,6 +592,84 @@ public static SchemaRefreshMode parse(String value) {\n             .withDescription(\"The name of the Postgres 10+ publication used for streaming changes from a plugin.\" +\n                     \"Defaults to '\" + ReplicationConnection.Builder.DEFAULT_PUBLICATION_NAME + \"'\");\n \n+    public enum AutoCreateMode implements EnumeratedValue {\n+        /**\n+         * No Publication will be created, it's expected the user\n+         * has already created the publication.\n+         */\n+        DISABLED(\"disabled\"),\n+        /**\n+         * Enable publication for all tables.\n+         */\n+        ALL_TABLES(\"all_tables\"),\n+        /**\n+         * Enable publication on a specific set of tables.\n+         */\n+        WHITELIST(\"whitelist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTEzNA==", "bodyText": "This needs to consider also the table blacklist as well as database blacklist/whitelist. I suppose this was always an implicit assumption on my end during the conversations, sorry for not being more clear on that. You can take a look at RelationalSnapshotChangeEventSource.determineCapturedTables(RelationalSnapshotContext) to see how that's handled during snapshotting using the TableFilter contract.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429305134", "createdAt": "2020-05-22T15:11:48Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresTaskContext.java", "diffHunk": "@@ -111,6 +111,8 @@ protected ReplicationConnection createReplicationConnection(boolean exportSnapsh\n         return ReplicationConnection.builder(config.jdbcConfig())\n                 .withSlot(config.slotName())\n                 .withPublication(config.publicationName())\n+                .withTableWhitelist(config.tableWhitelist())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwNTU1NQ==", "bodyText": "As per above, this probably should receive TableFilter instead.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r429305555", "createdAt": "2020-05-22T15:12:36Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/ReplicationConnection.java", "diffHunk": "@@ -133,6 +133,24 @@ static String format(long lsn) {\n          */\n         Builder withPublication(final String publicationName);\n \n+        /**\n+         * Sets the publication tables to watch for the PG logical publication\n+         *\n+         * @param tableWhitelist the tables the publication is subscribed to, may not be null.\n+         * @return this instance\n+         * @see #config.tableWhitelist()\n+         */\n+        Builder withTableWhitelist(final String tableWhitelist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNTY1OTQ0", "url": "https://github.com/debezium/debezium/pull/1525#pullrequestreview-422565944", "createdAt": "2020-06-02T10:59:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMDo1OTo1OVrOGdsjog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzoyMzozN1rOGdxXnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MTkwNg==", "bodyText": "What's the purpose of this sorting step?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433791906", "createdAt": "2020-06-02T10:59:59Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> sort(Set<TableId> capturedTables) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2NzIzOA==", "bodyText": "Shouldn't this be handled further below, in the swich block? It seems we'd trigger this exception in case the publication already exists?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433867238", "createdAt": "2020-06-02T13:18:32Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODA4MQ==", "bodyText": "The name is a bit misleading, perhaps simply filter()?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433868081", "createdAt": "2020-06-02T13:19:48Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg2ODIwMw==", "bodyText": "Why is the context parameter needed here?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433868203", "createdAt": "2020-06-02T13:19:59Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -117,38 +136,97 @@ private PostgresReplicationConnection(Configuration config,\n \n     protected void initPublication() {\n         if (PostgresConnectorConfig.LogicalDecoder.PGOUTPUT.equals(plugin)) {\n-            LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n-            try {\n-                String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n-                try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n-                    if (rs.next()) {\n-                        Long count = rs.getLong(1);\n-                        if (count == 0L) {\n-                            LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n-                        }\n-                        else {\n-                            LOGGER.trace(\n-                                    \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n-                                            \"and will be used by the plugin\",\n-                                    publicationName, plugin, database());\n+            if (PostgresConnectorConfig.AutoCreateMode.DISABLED.equals(publicationAutocreateMode)) {\n+                throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+            }\n+            else {\n+                LOGGER.info(\"Initializing PgOutput logical decoder publication\");\n+                try {\n+                    String selectPublication = String.format(\"SELECT COUNT(1) FROM pg_publication WHERE pubname = '%s'\", publicationName);\n+                    try (Statement stmt = pgConnection().createStatement(); ResultSet rs = stmt.executeQuery(selectPublication)) {\n+                        if (rs.next()) {\n+                            Long count = rs.getLong(1);\n+                            if (count == 0L) {\n+                                LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n+                                switch (publicationAutocreateMode) {\n+                                    case ALL_TABLES:\n+                                        // Publication doesn't exist, create it.\n+                                        stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                                        break;\n+                                    case FILTERED:\n+                                        try {\n+                                            Set<TableId> tablesToCapture = determineCapturedTables(new RelationalSnapshotChangeEventSource.RelationalSnapshotContext(\"\"));\n+                                            String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                            // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString));\n+                                        }\n+                                        catch (Exception e) {\n+                                            LOGGER.error(\"Unable to create publication for \");\n+                                        }\n+                                        break;\n+                                }\n+                            }\n+                            else {\n+                                LOGGER.trace(\n+                                        \"A logical publication named '{}' for plugin '{}' and database '{}' is already active on the server \" +\n+                                                \"and will be used by the plugin\",\n+                                        publicationName, plugin, database());\n+                            }\n                         }\n                     }\n                 }\n+                catch (SQLException e) {\n+                    throw new JdbcConnectionException(e);\n+                }\n+\n+                // This is what ties the publication definition to the replication stream\n+                streamParams.put(\"proto_version\", 1);\n+                streamParams.put(\"publication_names\", publicationName);\n             }\n-            catch (SQLException e) {\n-                throw new JdbcConnectionException(e);\n-            }\n+        }\n+    }\n+\n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> sort(Set<TableId> capturedTables) throws Exception {\n+        String value = config().getString(RelationalDatabaseConnectorConfig.TABLE_WHITELIST);\n+        if (value != null) {\n+            return Strings.listOfRegex(value, Pattern.CASE_INSENSITIVE)\n+                    .stream()\n+                    .flatMap(pattern -> toTableIds(capturedTables, pattern))\n+                    .collect(Collectors.toCollection(LinkedHashSet::new));\n+        }\n+        return capturedTables\n+                .stream()\n+                .sorted()\n+                .collect(Collectors.toCollection(LinkedHashSet::new));\n+    }\n+\n+    private Set<TableId> determineCapturedTables(RelationalSnapshotChangeEventSource.RelationalSnapshotContext ctx) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3MDc0OA==", "bodyText": "Would be better to avoid those formatting changes. The formatter will flag/revert them anyways, and if it doesn't, it adds some unneccessary noise to the PR.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r433870748", "createdAt": "2020-06-02T13:23:37Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -218,8 +219,7 @@ public void shouldSupportSSLParameters() throws Exception {\n         });\n         if (TestHelper.shouldSSLConnectionFail()) {\n             assertConnectorNotRunning();\n-        }\n-        else {\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzA4ODc2", "url": "https://github.com/debezium/debezium/pull/1525#pullrequestreview-423708876", "createdAt": "2020-06-03T16:03:55Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjowMzo1NVrOGei5bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjo1MjozOVrOGek4hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MjIyMA==", "bodyText": "There seems to be missing something after \"for\". More importantly, though, did you consciously decide to not propagate that exception? I think it'd be better to just let it bubble up (wrapped in a ConnectException with some contextual information), thus stopping connector start-up.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434682220", "createdAt": "2020-06-03T16:03:55Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -125,12 +144,29 @@ protected void initPublication() {\n                         Long count = rs.getLong(1);\n                         if (count == 0L) {\n                             LOGGER.info(\"Creating new publication '{}' for plugin '{}'\", publicationName, plugin);\n-                            // Publication doesn't exist, create it.\n-                            // todo: DBZ-766 - Change this to be restricted based on configured whitelist tables?\n-                            // For situations where no publication exists, we likely cannot create it for all tables.\n-                            // This is because postgres requires certain super user permissions to use \"ALL TABLES\".\n-                            // We should restrict this to the configured tables here.\n-                            stmt.execute(String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName));\n+                            switch (publicationAutocreateMode) {\n+                                case DISABLED:\n+                                    throw new ConnectException(\"Publication autocreation is disabled, please create one and restart the connector.\");\n+                                case ALL_TABLES:\n+                                    createPublicationStmt = String.format(\"CREATE PUBLICATION %s FOR ALL TABLES;\", publicationName);\n+                                    LOGGER.info(\"Creating Publication with statement '{}'\", createPublicationStmt);\n+                                    // Publication doesn't exist, create it.\n+                                    stmt.execute(createPublicationStmt);\n+                                    break;\n+                                case FILTERED:\n+                                    try {\n+                                        Set<TableId> tablesToCapture = determineCapturedTables();\n+                                        String tableFilterString = tablesToCapture.stream().map(TableId::toDoubleQuotedString).collect(Collectors.joining(\", \"));\n+                                        createPublicationStmt = String.format(\"CREATE PUBLICATION %s FOR TABLE %s;\", publicationName, tableFilterString);\n+                                        LOGGER.info(\"Creating Publication with statement '{}'\", createPublicationStmt);\n+                                        // Publication doesn't exist, create it but restrict to the tableFilter.\n+                                        stmt.execute(createPublicationStmt);\n+                                    }\n+                                    catch (Exception e) {\n+                                        LOGGER.error(\"Unable to create publication for \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDIxMg==", "bodyText": "Hum, I think I've asked about it before, but why is this explicit check against TABLE_WHITELIST done here? It shouldn't be needed, given you already apply the data collection filter above. Is it some sort of left-over perhaps?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434710212", "createdAt": "2020-06-03T16:45:26Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -151,6 +187,42 @@ protected void initPublication() {\n         }\n     }\n \n+    private Stream<TableId> toTableIds(Set<TableId> tableIds, Pattern pattern) {\n+        return tableIds\n+                .stream()\n+                .filter(tid -> pattern.asPredicate().test(tid.toString()))\n+                .sorted();\n+    }\n+\n+    private Set<TableId> determineCapturedTables() throws Exception {\n+        Set<TableId> allTableIds = this.connect().readTableNames(pgConnection().getCatalog(), null, null, new String[]{ \"TABLE\" });\n+\n+        Set<TableId> capturedTables = new HashSet<>();\n+\n+        String value = config().getString(RelationalDatabaseConnectorConfig.TABLE_WHITELIST);\n+\n+        for (TableId tableId : allTableIds) {\n+            if (tableFilter.dataCollectionFilter().isIncluded(tableId)) {\n+                LOGGER.trace(\"Adding table {} to the list of captured tables\", tableId);\n+                capturedTables.add(tableId);\n+            }\n+            else {\n+                LOGGER.trace(\"Ignoring table {} as it's not included in the filter configuration\", tableId);\n+            }\n+        }\n+\n+        if (value != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTAzMw==", "bodyText": "Could you change the test so that multiple tables are matched? Seems like a critical thing to get right, set up the publication for more than one table.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434711033", "createdAt": "2020-06-03T16:46:46Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/PostgresConnectorIT.java", "diffHunk": "@@ -1628,6 +1630,126 @@ public void shouldOutputRecordsInCloudEventsFormat() throws Exception {\n         stopConnector();\n     }\n \n+    @Test\n+    @FixFor(\"DBZ-1813\")\n+    @SkipWhenDecoderPluginNameIsNot(value = SkipWhenDecoderPluginNameIsNot.DecoderPluginName.PGOUTPUT, reason = \"Publication configuration only valid for PGOUTPUT decoder\")\n+    public void shouldConfigureSubscriptionsForAllTablesByDefault() throws Exception {\n+        // This captures all logged messages, allowing us to verify log message was written.\n+        final LogInterceptor logInterceptor = new LogInterceptor();\n+\n+        TestHelper.dropAllSchemas();\n+        TestHelper.dropPublication(\"cdc\");\n+        TestHelper.executeDDL(\"postgres_create_tables.ddl\");\n+\n+        Configuration.Builder configBuilder = TestHelper.defaultConfig()\n+                .with(PostgresConnectorConfig.PUBLICATION_NAME, \"cdc\");\n+\n+        start(PostgresConnector.class, configBuilder.build());\n+        assertConnectorIsRunning();\n+        waitForAvailableRecords(100, TimeUnit.MILLISECONDS);\n+\n+        stopConnector(value -> assertTrue(\n+                logInterceptor.containsMessage(\"Creating Publication with statement 'CREATE PUBLICATION cdc FOR ALL TABLES;'\") &&\n+                        logInterceptor.containsMessage(\"Creating new publication 'cdc' for plugin 'PGOUTPUT'\")));\n+        assertTrue(TestHelper.publicationExists(\"cdc\"));\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-1813\")\n+    @SkipWhenDecoderPluginNameIsNot(value = SkipWhenDecoderPluginNameIsNot.DecoderPluginName.PGOUTPUT, reason = \"Publication configuration only valid for PGOUTPUT decoder\")\n+    public void shouldConfigureSubscriptionsFromTableFilters() throws Exception {\n+        // This captures all logged messages, allowing us to verify log message was written.\n+        final LogInterceptor logInterceptor = new LogInterceptor();\n+\n+        TestHelper.dropAllSchemas();\n+        TestHelper.dropPublication(\"cdc\");\n+        TestHelper.executeDDL(\"postgres_create_tables.ddl\");\n+\n+        Configuration.Builder configBuilder = TestHelper.defaultConfig()\n+                .with(PostgresConnectorConfig.PUBLICATION_NAME, \"cdc\")\n+                .with(PostgresConnectorConfig.TABLE_WHITELIST, \"public.numeric_table\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTY5OA==", "bodyText": "Could you clarify that this option only applies when pgoutput is used? Also, perhaps a link to upstream Postgres docs on the concept of publications?", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434711698", "createdAt": "2020-06-03T16:47:47Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMjYzNQ==", "bodyText": "Let's avoid the notion of \"current\" behavior, as it won't be clear to the future reader:\n\nIf no publication exists, the connector will create a new publication for all tables. Note this requires xyz grants. If the publication already exists, it will be used.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434712635", "createdAt": "2020-06-03T16:49:13Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.\n+_disabled_ - The connector will not attempt to create a publication at all. The expectation is\n+that the user has created the publication up-front. If the publication isn't found to exist upon\n+startup, the connector will throw an exception and stop.\n+_all_tables_ - This acts like the current behavior where if the publication does not exist the", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMzczNg==", "bodyText": "If no publication exists, the connector will create a new publication for all those tables matching the current filter configuration (see table/database whitelist/blacklist properties). If the publication already exists, it will be used.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434713736", "createdAt": "2020-06-03T16:50:57Z", "author": {"login": "gunnarmorling"}, "path": "documentation/modules/ROOT/pages/connectors/postgresql.adoc", "diffHunk": "@@ -1892,6 +1892,18 @@ See the {link-prefix}:{link-postgresql-connector}#postgresql-data-types[list of\n Each item (regular expression) must match the fully-qualified `<fully-qualified table>:<a comma-separated list of columns>` representing the custom key. +\n Fully-qualified tables could be defined as _schemaName_._tableName_.\n \n+|[[postgresql-publication-autocreate-mode]]<<postgresql-publication-autocreate-mode, `publication.autocreate.mode`>>\n+|_all_tables_\n+|Determine how creation of a publication should work, the default is all_tables.\n+_disabled_ - The connector will not attempt to create a publication at all. The expectation is\n+that the user has created the publication up-front. If the publication isn't found to exist upon\n+startup, the connector will throw an exception and stop.\n+_all_tables_ - This acts like the current behavior where if the publication does not exist the\n+connector will create the publication for all tables. If the publication exists, we will use it.\n+i.e `CREATE PUBLICATION <publication_name> FOR ALL TABLES;`\n+_filtered_ - This would create the publication for matching tables only", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxNDc1Nw==", "bodyText": "Same comment on \"current\" as further below.", "url": "https://github.com/debezium/debezium/pull/1525#discussion_r434714757", "createdAt": "2020-06-03T16:52:39Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresConnectorConfig.java", "diffHunk": "@@ -592,6 +592,83 @@ public static SchemaRefreshMode parse(String value) {\n             .withDescription(\"The name of the Postgres 10+ publication used for streaming changes from a plugin.\" +\n                     \"Defaults to '\" + ReplicationConnection.Builder.DEFAULT_PUBLICATION_NAME + \"'\");\n \n+    public enum AutoCreateMode implements EnumeratedValue {\n+        /**\n+         * No Publication will be created, it's expected the user\n+         * has already created the publication.\n+         */\n+        DISABLED(\"disabled\"),\n+        /**\n+         * Enable publication for all tables.\n+         */\n+        ALL_TABLES(\"all_tables\"),\n+        /**\n+         * Enable publication on a specific set of tables.\n+         */\n+        FILTERED(\"filtered\");\n+\n+        private final String value;\n+\n+        AutoCreateMode(String value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public String getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Determine if the supplied value is one of the predefined options.\n+         *\n+         * @param value the configuration property value; may not be null\n+         * @return the matching option, or null if no match is found\n+         */\n+        public static AutoCreateMode parse(String value) {\n+            if (value == null) {\n+                return null;\n+            }\n+            value = value.trim();\n+            for (AutoCreateMode option : AutoCreateMode.values()) {\n+                if (option.getValue().equalsIgnoreCase(value)) {\n+                    return option;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        /**\n+         * Determine if the supplied value is one of the predefined options.\n+         *\n+         * @param value        the configuration property value; may not be null\n+         * @param defaultValue the default value; may be null\n+         * @return the matching option, or null if no match is found and the non-null default is invalid\n+         */\n+        public static AutoCreateMode parse(String value, String defaultValue) {\n+            AutoCreateMode mode = parse(value);\n+            if (mode == null && defaultValue != null) {\n+                mode = parse(defaultValue);\n+            }\n+            return mode;\n+        }\n+    }\n+\n+    public static final Field PUBLICATION_AUTOCREATE_MODE = Field.create(\"publication.autocreate.mode\")\n+            .withDisplayName(\"Publication Auto Create Mode\")\n+            .withEnum(AutoCreateMode.class, AutoCreateMode.ALL_TABLES)\n+            .withWidth(Width.MEDIUM)\n+            .withImportance(Importance.MEDIUM)\n+            .withDescription(\n+                    \"Determine how creation of a publication should work, the default is all_tables.\" +\n+                            \"DISABLED - The connector will not attempt to create a publication at all. The expectation is \" +\n+                            \"that the user has created the publication up-front. If the publication isn't found to exist upon \" +\n+                            \"startup, the connector will throw an exception and stop.\" +\n+                            \"ALL_TABLES - This acts like the current behavior where if the publication does not exist the \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfa3e166b8219999a6969bbad0775c247dce96f0", "author": {"user": {"login": "brbrown25", "name": "Brandon Brown"}}, "url": "https://github.com/debezium/debezium/commit/dfa3e166b8219999a6969bbad0775c247dce96f0", "committedDate": "2020-06-04T16:08:19Z", "message": "DBZ-1813 Adding ability to configure pgoutput publication based on table filters\ndefined."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7323b56d7d2b8fda3792a68d9fc469b35e1e80c2", "author": {"user": {"login": "gunnarmorling", "name": "Gunnar Morling"}}, "url": "https://github.com/debezium/debezium/commit/7323b56d7d2b8fda3792a68d9fc469b35e1e80c2", "committedDate": "2020-06-04T16:08:19Z", "message": "DBZ-1813 Stabiling test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26df1eba19cb6fbd226b84fcfaaa029a7b909458", "author": {"user": {"login": "gunnarmorling", "name": "Gunnar Morling"}}, "url": "https://github.com/debezium/debezium/commit/26df1eba19cb6fbd226b84fcfaaa029a7b909458", "committedDate": "2020-06-04T16:08:19Z", "message": "DBZ-1813 Misc. clean-up;\n\n* Removing unused method\n* Simplifying tests\n* Avoiding deprecated code"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "26df1eba19cb6fbd226b84fcfaaa029a7b909458", "author": {"user": {"login": "gunnarmorling", "name": "Gunnar Morling"}}, "url": "https://github.com/debezium/debezium/commit/26df1eba19cb6fbd226b84fcfaaa029a7b909458", "committedDate": "2020-06-04T16:08:19Z", "message": "DBZ-1813 Misc. clean-up;\n\n* Removing unused method\n* Simplifying tests\n* Avoiding deprecated code"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2682, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}