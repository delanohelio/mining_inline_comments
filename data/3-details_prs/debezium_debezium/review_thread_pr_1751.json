{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2NTA4MTE0", "number": 1751, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo1MDo1MVrOEXiJiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyODo0OFrOEbkLQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTEyMjAwOnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwODo1MDo1MVrOG_X_eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxMDowODoxNlrOG_avNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw==", "bodyText": "Wasn't DBZ-2200, also focused on the PG connector, intended to have a more abstract implementation in debezium-core that fits different connector needs? Something like SourceOffset<T extends Comparable> or something?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469106553", "createdAt": "2020-08-12T08:50:51Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDg5NA==", "bodyText": "No, at least that's not what I had in mind when logging this. This really was focused on having such Lsn type for PG instead of representing it with Long.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469134894", "createdAt": "2020-08-12T09:38:40Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0MjM5NQ==", "bodyText": "I meant when we were talking about the task. At least that what I understood. Does it makes sense to have it in debezium-core?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469142395", "createdAt": "2020-08-12T09:51:18Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MTU0Mw==", "bodyText": "It doesn't make sense to have Lsn in core, as it's PG-specific. I'm not sure whether one could finda more generic abstraction which still would be useful tbh. In any case I don't think it's something we need to concern ourselves with right now. When it comes to (simple-ish) refactorings, I'd suggest rather to look at https://issues.redhat.com/browse/DBZ-2420 (unification of JDBC connection props) or the filter handling unification.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469151543", "createdAt": "2020-08-12T10:08:16Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/Lsn.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.postgresql.connection;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.postgresql.replication.LogSequenceNumber;\n+\n+/**\n+ * Abstraction of PostgreSQL log sequence number, adapted from\n+ * {@link org.postgresql.replication.LogSequenceNumber}.\n+ *\n+ * @author Jiri Pechanec\n+ *\n+ */\n+public class Lsn implements Comparable<Lsn> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNjU1Mw=="}, "originalCommit": null, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMxNzgwOnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresOffsetContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0MTo1NFrOG_Z2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0MTo1NFrOG_Z2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNjk5MQ==", "bodyText": "How about enabling Lsn#valueOf() itself to handle and return null?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469136991", "createdAt": "2020-08-12T09:41:54Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresOffsetContext.java", "diffHunk": "@@ -171,8 +171,10 @@ private Long readOptionalLong(Map<String, ?> offset, String key) {\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         public OffsetContext load(Map<String, ?> offset) {\n-            final Long lsn = readOptionalLong(offset, SourceInfo.LSN_KEY);\n-            final Long lastCompletelyProcessedLsn = readOptionalLong(offset, LAST_COMPLETELY_PROCESSED_LSN_KEY);\n+            final Long lsnAsLong = readOptionalLong(offset, SourceInfo.LSN_KEY);\n+            final Lsn lsn = (lsnAsLong == null) ? null : Lsn.valueOf(lsnAsLong);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMyMTMzOnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresSourceInfoStructMaker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0Mjo0N1rOG_Z4eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0Mjo0N1rOG_Z4eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNzUzMA==", "bodyText": "Ok, I really hope we don't miss this somewhere.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469137530", "createdAt": "2020-08-12T09:42:47Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresSourceInfoStructMaker.java", "diffHunk": "@@ -45,7 +45,7 @@ public Struct struct(SourceInfo sourceInfo) {\n             result.put(SourceInfo.TXID_KEY, sourceInfo.txId());\n         }\n         if (sourceInfo.lsn() != null) {\n-            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn());\n+            result.put(SourceInfo.LSN_KEY, sourceInfo.lsn().asLong());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMzMTU5OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NToxNlrOG_Z-Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NToxNlrOG_Z-Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTAxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);\n          \n          \n            \n                        assertNotEquals(\"LSN should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139019", "createdAt": "2020-08-12T09:45:16Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1235,9 +1236,9 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if client's lsn is not flushed yet\n             SlotState slotState = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushLsn = slotState.slotLastFlushedLsn();\n+            final Lsn flushLsn = slotState.slotLastFlushedLsn();\n             // serverLsn is the latest server lsn and is equal to insert statement lsn\n-            long serverLsn = postgresConnection.currentXLogLocation();\n+            final Lsn serverLsn = Lsn.valueOf(postgresConnection.currentXLogLocation());\n             assertNotEquals(\"lsn should not be flushed until heartbeat is produced\", serverLsn, flushLsn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMzMTk0OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NToyNVrOG_Z-iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NToyNVrOG_Z-iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTA4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);\n          \n          \n            \n                        assertTrue(\"LSN should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139083", "createdAt": "2020-08-12T09:45:25Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/RecordsStreamProducerIT.java", "diffHunk": "@@ -1254,8 +1255,8 @@ public void shouldReceiveHeartbeatAlsoWhenChangingNonWhitelistedTable() throws E\n \n             // check if flushed lsn is equal to or greater than server lsn\n             SlotState slotStateAfterHeartbeat = postgresConnection.getReplicationSlotState(Builder.DEFAULT_SLOT_NAME, TestHelper.decoderPlugin().getPostgresPluginName());\n-            long flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n-            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn >= serverLsn);\n+            final Lsn flushedLsn = slotStateAfterHeartbeat.slotLastFlushedLsn();\n+            assertTrue(\"lsn should be flushed when heartbeat is produced\", flushedLsn.compareTo(serverLsn) >= 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMTMzMzA3OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/connection/ReplicationConnectionIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NTo0MlrOG_Z_NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTo0NTo0MlrOG_Z_NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzOTI1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();\n          \n          \n            \n                    AtomicReference<Lsn> lastReceivedLsn = new AtomicReference<>();", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r469139252", "createdAt": "2020-08-12T09:45:42Z", "author": {"login": "gunnarmorling"}, "path": "debezium-connector-postgres/src/test/java/io/debezium/connector/postgresql/connection/ReplicationConnectionIT.java", "diffHunk": "@@ -180,9 +180,9 @@ public void shouldReceiveMissedChangesWhileDown() throws Exception {\n     @Test\n     public void shouldResumeFromLastReceivedLSN() throws Exception {\n         String slotName = \"test\";\n-        AtomicLong lastReceivedLSN = new AtomicLong(0);\n-        startInsertStop(slotName, stream -> lastReceivedLSN.compareAndSet(0, stream.lastReceivedLsn()));\n-        assertTrue(lastReceivedLSN.get() > 0);\n+        AtomicReference<Lsn> lastReceivedLSN = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA5NjA1OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMToyMFrOHFPVFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNDoyNDozN1rOHFUI9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw==", "bodyText": "Why does keepalive need to be disabled to commit the current transaction?  Asking because PostgresTaskContext#refreshSchema called on https://github.com/debezium/debezium/pull/1751/files#diff-dff0ff397d3f72ba1319e51a37ace1adL118 here performs a commit but does not disable keepalive.", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475256087", "createdAt": "2020-08-23T19:31:20Z", "author": {"login": "grantcooksey"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,45 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);\n+                walPosition = new WalPositionLocator(offsetContext.lastCommitLsn(), lsn);\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn, walPosition));\n             }\n             else {\n-                LOGGER.info(\"no previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming());\n+                LOGGER.info(\"No previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n+                walPosition = new WalPositionLocator();\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(walPosition));\n             }\n             // for large dbs, the refresh of schema can take too much time\n             // such that the connection times out. We must enable keep\n             // alive to ensure that it doesn't time out\n-            final ReplicationStream stream = this.replicationStream.get();\n+            ReplicationStream stream = this.replicationStream.get();\n             stream.startKeepAlive(Executors.newSingleThreadExecutor());\n \n             // refresh the schema so we have a latest view of the DB tables\n             taskContext.refreshSchema(connection, true);\n \n             this.lastCompletelyProcessedLsn = replicationStream.get().startLsn();\n \n-            int noMessageIterations = 0;\n-            while (context.isRunning()) {\n-\n-                boolean receivedMessage = stream.readPending(message -> {\n-                    final Long lsn = stream.lastReceivedLsn();\n-\n-                    if (message.isLastEventForLsn()) {\n-                        lastCompletelyProcessedLsn = lsn;\n-                    }\n-\n-                    // Tx BEGIN/END event\n-                    if (message.isTransactionalMessage()) {\n-                        if (!connectorConfig.shouldProvideTransactionMetadata()) {\n-                            LOGGER.trace(\"Received transactional message {}\", message);\n-                            // Don't skip on BEGIN message as it would flush LSN for the whole transaction\n-                            // too early\n-                            if (message.getOperation() == Operation.COMMIT) {\n-                                skipMessage(lsn);\n-                            }\n-                            return;\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), null,\n-                                taskContext.getSlotXmin(connection));\n-                        if (message.getOperation() == Operation.BEGIN) {\n-                            dispatcher.dispatchTransactionStartedEvent(Long.toString(message.getTransactionId()), offsetContext);\n-                        }\n-                        else if (message.getOperation() == Operation.COMMIT) {\n-                            dispatcher.dispatchTransactionCommittedEvent(offsetContext);\n-                        }\n-                        maybeWarnAboutGrowingWalBacklog(true);\n-                        return;\n-                    }\n-                    // DML event\n-                    else {\n-                        TableId tableId = null;\n-                        if (message.getOperation() != Operation.NOOP) {\n-                            tableId = PostgresSchema.parse(message.getTable());\n-                            Objects.requireNonNull(tableId);\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), tableId,\n-                                taskContext.getSlotXmin(connection));\n-\n-                        boolean dispatched = (message.getOperation() == Operation.NOOP) ? false\n-                                : dispatcher.dispatchDataChangeEvent(\n-                                        tableId,\n-                                        new PostgresChangeRecordEmitter(\n-                                                offsetContext,\n-                                                clock,\n-                                                connectorConfig,\n-                                                schema,\n-                                                connection,\n-                                                message));\n-\n-                        maybeWarnAboutGrowingWalBacklog(dispatched);\n-                    }\n-                });\n-\n-                if (receivedMessage) {\n-                    noMessageIterations = 0;\n+            if (walPosition.searchingEnabled()) {\n+                searchWalPosition(context, stream, walPosition);\n+                stream.stopKeepAlive();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMzNDkwMQ==", "bodyText": "Hi, in this case it is not due to the commit but due to the reconnect that is few lines later down", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475334901", "createdAt": "2020-08-24T04:24:37Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,45 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);\n+                walPosition = new WalPositionLocator(offsetContext.lastCommitLsn(), lsn);\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn, walPosition));\n             }\n             else {\n-                LOGGER.info(\"no previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming());\n+                LOGGER.info(\"No previous LSN found in Kafka, streaming from the latest xlogpos or flushed LSN...\");\n+                walPosition = new WalPositionLocator();\n+                replicationStream.compareAndSet(null, replicationConnection.startStreaming(walPosition));\n             }\n             // for large dbs, the refresh of schema can take too much time\n             // such that the connection times out. We must enable keep\n             // alive to ensure that it doesn't time out\n-            final ReplicationStream stream = this.replicationStream.get();\n+            ReplicationStream stream = this.replicationStream.get();\n             stream.startKeepAlive(Executors.newSingleThreadExecutor());\n \n             // refresh the schema so we have a latest view of the DB tables\n             taskContext.refreshSchema(connection, true);\n \n             this.lastCompletelyProcessedLsn = replicationStream.get().startLsn();\n \n-            int noMessageIterations = 0;\n-            while (context.isRunning()) {\n-\n-                boolean receivedMessage = stream.readPending(message -> {\n-                    final Long lsn = stream.lastReceivedLsn();\n-\n-                    if (message.isLastEventForLsn()) {\n-                        lastCompletelyProcessedLsn = lsn;\n-                    }\n-\n-                    // Tx BEGIN/END event\n-                    if (message.isTransactionalMessage()) {\n-                        if (!connectorConfig.shouldProvideTransactionMetadata()) {\n-                            LOGGER.trace(\"Received transactional message {}\", message);\n-                            // Don't skip on BEGIN message as it would flush LSN for the whole transaction\n-                            // too early\n-                            if (message.getOperation() == Operation.COMMIT) {\n-                                skipMessage(lsn);\n-                            }\n-                            return;\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), null,\n-                                taskContext.getSlotXmin(connection));\n-                        if (message.getOperation() == Operation.BEGIN) {\n-                            dispatcher.dispatchTransactionStartedEvent(Long.toString(message.getTransactionId()), offsetContext);\n-                        }\n-                        else if (message.getOperation() == Operation.COMMIT) {\n-                            dispatcher.dispatchTransactionCommittedEvent(offsetContext);\n-                        }\n-                        maybeWarnAboutGrowingWalBacklog(true);\n-                        return;\n-                    }\n-                    // DML event\n-                    else {\n-                        TableId tableId = null;\n-                        if (message.getOperation() != Operation.NOOP) {\n-                            tableId = PostgresSchema.parse(message.getTable());\n-                            Objects.requireNonNull(tableId);\n-                        }\n-\n-                        offsetContext.updateWalPosition(lsn, lastCompletelyProcessedLsn, message.getCommitTime(), message.getTransactionId(), tableId,\n-                                taskContext.getSlotXmin(connection));\n-\n-                        boolean dispatched = (message.getOperation() == Operation.NOOP) ? false\n-                                : dispatcher.dispatchDataChangeEvent(\n-                                        tableId,\n-                                        new PostgresChangeRecordEmitter(\n-                                                offsetContext,\n-                                                clock,\n-                                                connectorConfig,\n-                                                schema,\n-                                                connection,\n-                                                message));\n-\n-                        maybeWarnAboutGrowingWalBacklog(dispatched);\n-                    }\n-                });\n-\n-                if (receivedMessage) {\n-                    noMessageIterations = 0;\n+            if (walPosition.searchingEnabled()) {\n+                searchWalPosition(context, stream, walPosition);\n+                stream.stopKeepAlive();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA4Nw=="}, "originalCommit": {"oid": "c49a5a73b0e9d88f20e1ce8b0dfa82addedb52a7"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzM2NTY2OnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTowOVrOHFj_HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyMTowOVrOHFj_HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5NDUyNA==", "bodyText": "Was changing the log level of this from debug to info intentional?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475594524", "createdAt": "2020-08-24T13:21:09Z", "author": {"login": "Naros"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/PostgresStreamingChangeEventSource.java", "diffHunk": "@@ -96,103 +97,46 @@ public void execute(ChangeEventSourceContext context) throws InterruptedExceptio\n         }\n \n         try {\n+            final WalPositionLocator walPosition;\n             if (hasStartLsnStoredInContext) {\n                 // start streaming from the last recorded position in the offset\n-                final Long lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n-                if (LOGGER.isDebugEnabled()) {\n-                    LOGGER.debug(\"retrieved latest position from stored offset '{}'\", ReplicationConnection.format(lsn));\n-                }\n-                replicationStream.compareAndSet(null, replicationConnection.startStreaming(lsn));\n+                final Lsn lsn = offsetContext.lastCompletelyProcessedLsn() != null ? offsetContext.lastCompletelyProcessedLsn() : offsetContext.lsn();\n+                LOGGER.info(\"Retrieved latest position from stored offset '{}'\", lsn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MzM5NzEzOnYy", "diffSide": "RIGHT", "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxMzoyODo0OFrOHFkRtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODozNDozMFrOHFxgMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ==", "bodyText": "Would it be possible to use queryAndMap here in order to avoid the AtomicReference usage?", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475599285", "createdAt": "2020-08-24T13:28:48Z", "author": {"login": "Naros"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -219,7 +218,7 @@ protected void initReplicationSlot() throws SQLException, InterruptedException {\n                 this.createReplicationSlot();\n             }\n \n-            AtomicLong xlogStart = new AtomicLong();\n+            final AtomicReference<Lsn> xlogStart = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNTk4NA==", "bodyText": "Done, thanks!", "url": "https://github.com/debezium/debezium/pull/1751#discussion_r475815984", "createdAt": "2020-08-24T18:34:30Z", "author": {"login": "jpechane"}, "path": "debezium-connector-postgres/src/main/java/io/debezium/connector/postgresql/connection/PostgresReplicationConnection.java", "diffHunk": "@@ -219,7 +218,7 @@ protected void initReplicationSlot() throws SQLException, InterruptedException {\n                 this.createReplicationSlot();\n             }\n \n-            AtomicLong xlogStart = new AtomicLong();\n+            final AtomicReference<Lsn> xlogStart = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5OTI4NQ=="}, "originalCommit": {"oid": "4f91d032459c2bb24126d361c84432a8f349948c"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4169, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}