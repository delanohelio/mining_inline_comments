{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NTI3MjQ2", "number": 1673, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo0NDozM1rOEMKK3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowNTo0MlrOEMKpLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTg0OTg5OnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo0NDozM1rOGuHAWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxNToyMVrOGufUwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng==", "bodyText": "these 2 lines can be confusing.  especially when getFloat64 and getString behave differently (see below)", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451002456", "createdAt": "2020-07-07T16:44:33Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTcyMA==", "bodyText": "Maybe we need to fix BigDecimal handling?", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451015720", "createdAt": "2020-07-07T17:06:50Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDA1Mg==", "bodyText": "You can use getWithoutDefault method", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380052", "createdAt": "2020-07-08T08:40:59Z", "author": {"login": "jpechane"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMDg5Ng==", "bodyText": "oh yes! omg. really, I just learned about that different default value behavior of get(). I would expect the opposite behaviour. get() comes without default and there is getWithDefault()... very interesting.", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451400896", "createdAt": "2020-07-08T09:15:21Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjQ1Ng=="}, "originalCommit": null, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTkxOTY2OnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowMzozNlrOGuHsyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOToxNjowNlrOGufWeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ==", "bodyText": "getString returns the \"real\" value, which is null. accessing the field with getBytes() isn't working here.", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451013835", "createdAt": "2020-07-07T17:03:36Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(15.28000);\n+    }\n+\n+    private void assertStringChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getString(\"A\").trim()).isEqualTo(\"1.33\");\n+        Assertions.assertThat(change.getString(\"B\").trim()).isEqualTo(\"-2.111\");\n+        Assertions.assertThat(change.getString(\"C\").trim()).isEqualTo(\"3.44400\");\n+        Assertions.assertThat(change.getString(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a String ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDY1OQ==", "bodyText": "getBytes would work only if the schema would be BYTES - but it is String", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380659", "createdAt": "2020-07-08T08:41:52Z", "author": {"login": "jpechane"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(15.28000);\n+    }\n+\n+    private void assertStringChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getString(\"A\").trim()).isEqualTo(\"1.33\");\n+        Assertions.assertThat(change.getString(\"B\").trim()).isEqualTo(\"-2.111\");\n+        Assertions.assertThat(change.getString(\"C\").trim()).isEqualTo(\"3.44400\");\n+        Assertions.assertThat(change.getString(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a String ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ=="}, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMTMzOA==", "bodyText": "I still want raw bytes! ;)", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451401338", "createdAt": "2020-07-08T09:16:06Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(15.28000);\n+    }\n+\n+    private void assertStringChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getString(\"A\").trim()).isEqualTo(\"1.33\");\n+        Assertions.assertThat(change.getString(\"B\").trim()).isEqualTo(\"-2.111\");\n+        Assertions.assertThat(change.getString(\"C\").trim()).isEqualTo(\"3.44400\");\n+        Assertions.assertThat(change.getString(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a String ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxMzgzNQ=="}, "originalCommit": null, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTkyMjEzOnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowNDowN1rOGuHuJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowNDowN1rOGuHuJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNDE4Mw==", "bodyText": "getFloat64 returns the \"real\" value, which is null. accessing the field with getBytes() isn't working here.", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451014183", "createdAt": "2020-07-07T17:04:07Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MySqlDecimalIT.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Debezium Authors.\n+ *\n+ * Licensed under the Apache Software License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.debezium.connector.mysql;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+import java.math.BigDecimal;\n+import java.nio.file.Path;\n+import java.sql.SQLException;\n+import java.util.List;\n+\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.connect.source.SourceRecord;\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.debezium.config.Configuration;\n+import io.debezium.doc.FixFor;\n+import io.debezium.embedded.AbstractConnectorTest;\n+import io.debezium.relational.RelationalDatabaseConnectorConfig;\n+import io.debezium.util.Testing;\n+\n+/**\n+ * Verify correct DECIMAL handling with different types of io.debezium.relational.RelationalDatabaseConnectorConfig.DecimalHandlingMode.\n+ *\n+ * @author Ren\u00e9 Kerner\n+ */\n+public class MySqlDecimalIT extends AbstractConnectorTest {\n+\n+    private static final String TABLE_NAME = \"DBZ730\";\n+\n+    private static final Path DB_HISTORY_PATH = Testing.Files.createTestingPath(\"file-db-history-decimal.txt\")\n+            .toAbsolutePath();\n+    private final UniqueDatabase DATABASE = new UniqueDatabase(\"decimaldb\", \"decimal_test\")\n+            .withDbHistoryPath(DB_HISTORY_PATH);\n+\n+    private Configuration config;\n+\n+    @Before\n+    public void beforeEach() {\n+        stopConnector();\n+        DATABASE.createAndInitialize();\n+        initializeConnectorTestFramework();\n+        Testing.Files.delete(DB_HISTORY_PATH);\n+    }\n+\n+    @After\n+    public void afterEach() {\n+        try {\n+            stopConnector();\n+        }\n+        finally {\n+            Testing.Files.delete(DB_HISTORY_PATH);\n+        }\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testPreciseDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.PRECISE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertBigDecimalChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testDoubleDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertDoubleChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    @Test\n+    @FixFor(\"DBZ-730\")\n+    public void testStringDecimalHandlingMode() throws SQLException, InterruptedException {\n+        config = DATABASE.defaultConfig()\n+                .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n+                .with(MySqlConnectorConfig.TABLE_WHITELIST, DATABASE.qualifiedTableName(TABLE_NAME))\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.STRING)\n+                .build();\n+\n+        start(MySqlConnector.class, config);\n+\n+        assertStringChangeRecord(consumeInsert());\n+\n+        stopConnector();\n+    }\n+\n+    private SourceRecord consumeInsert() throws InterruptedException {\n+        final int numDatabase = 2;\n+        final int numTables = 4;\n+        final int numOthers = 1;\n+\n+        SourceRecords records = consumeRecordsByTopic(numDatabase + numTables + numOthers);\n+\n+        assertThat(records).isNotNull();\n+\n+        List<SourceRecord> events = records.recordsForTopic(DATABASE.topicForTable(TABLE_NAME));\n+        assertThat(events).hasSize(1);\n+\n+        return events.get(0);\n+    }\n+\n+    private void assertBigDecimalChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.get(\"A\")).isEqualTo(new BigDecimal(\"1.33\"));\n+        Assertions.assertThat(change.get(\"B\")).isEqualTo(new BigDecimal(\"-2.111\"));\n+        Assertions.assertThat(change.get(\"C\")).isEqualTo(new BigDecimal(\"3.44400\"));\n+        Assertions.assertThat(change.get(\"D\")).isEqualTo(new BigDecimal(\"15.28000\")); // returns the default value\n+        Assertions.assertThat(change.getBytes(\"D\")).isNull(); // returns the real value, which is null\n+\n+        Assertions.assertThat(record.valueSchema().field(\"after\").schema().field(\"D\").schema().defaultValue())\n+                .isEqualTo(new BigDecimal(\"15.28000\"));\n+    }\n+\n+    private void assertDoubleChangeRecord(SourceRecord record) {\n+        Assertions.assertThat(record).isNotNull();\n+        final Struct change = ((Struct) record.value()).getStruct(\"after\");\n+\n+        Assertions.assertThat(change.getFloat64(\"A\")).isEqualTo(1.33);\n+        Assertions.assertThat(change.getFloat64(\"B\")).isEqualTo(-2.111);\n+        Assertions.assertThat(change.getFloat64(\"C\")).isEqualTo(3.44400);\n+        Assertions.assertThat(change.getFloat64(\"D\")).isNull(); // returns the real value, not field's default value\n+        // Assertions.assertThat(change.getBytes(\"D\")).isNull(); // seems it's not possible to call getBytes on a Double ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMTkyNzUwOnYy", "diffSide": "RIGHT", "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MysqlDefaultValueIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNzowNTo0M1rOGuHxjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo0MjoxNVrOGueGlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTA1NA==", "bodyText": "isn't this the correct config value?\nis it okay to change the parameter with that PR?", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451015054", "createdAt": "2020-07-07T17:05:43Z", "author": {"login": "rk3rn3r"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MysqlDefaultValueIT.java", "diffHunk": "@@ -525,7 +526,7 @@ public void realTest() throws InterruptedException {\n     public void numericAndDecimalToDoubleTest() throws InterruptedException {\n         config = DATABASE.defaultConfig()\n                 .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n-                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, JdbcValueConverters.DecimalMode.DOUBLE)\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4MDg4Nw==", "bodyText": "Yes, that's ok", "url": "https://github.com/debezium/debezium/pull/1673#discussion_r451380887", "createdAt": "2020-07-08T08:42:15Z", "author": {"login": "jpechane"}, "path": "debezium-connector-mysql/src/test/java/io/debezium/connector/mysql/MysqlDefaultValueIT.java", "diffHunk": "@@ -525,7 +526,7 @@ public void realTest() throws InterruptedException {\n     public void numericAndDecimalToDoubleTest() throws InterruptedException {\n         config = DATABASE.defaultConfig()\n                 .with(MySqlConnectorConfig.SNAPSHOT_MODE, MySqlConnectorConfig.SnapshotMode.INITIAL)\n-                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, JdbcValueConverters.DecimalMode.DOUBLE)\n+                .with(MySqlConnectorConfig.DECIMAL_HANDLING_MODE, RelationalDatabaseConnectorConfig.DecimalHandlingMode.DOUBLE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAxNTA1NA=="}, "originalCommit": null, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4223, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}