{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTE0MDYw", "number": 664, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDo0NDoxNVrODmU89g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDo0NDo1NFrODmU-Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTE1NzY2OnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDo0NDoxNVrOFzrmCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTowOToyM1rOFzsqlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNTk0Nw==", "bodyText": "Instead of using a defer, I suggest that you use fromCallable. This would handle the case if claimBatch threw an exception.", "url": "https://github.com/CMSgov/dpc-app/pull/664#discussion_r389735947", "createdAt": "2020-03-09T14:44:15Z", "author": {"login": "RickHawesUSDS"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "diffHunk": "@@ -110,21 +111,38 @@ public Boolean isRunning() {\n      * The main run-loop of the engine.\n      */\n     protected void pollQueue() {\n-        queueRunning.set(true);\n-        subscribe = Observable.fromCallable(() -> this.queue.claimBatch(aggregatorID))\n-                .doOnNext(job -> logger.trace(\"Polling queue for job\"))\n-                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n-                .onErrorResumeNext(Observable.empty()) // Keep the queue running on error\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+        this.subscribe = this.createQueueObserver()\n                 .repeatWhen(completed -> {\n-                    logger.debug(String.format(\"No job, polling again in %d milliseconds\", operationsConfig.getPollingFrequency()));\n+                    logger.debug(String.format(\"Configuring queue to poll every %d milliseconds\", operationsConfig.getPollingFrequency()));\n                     return completed.delay(operationsConfig.getPollingFrequency(), TimeUnit.MILLISECONDS);\n                 })\n-                .subscribe(this::processJobBatch, error -> {\n-                    logger.error(\"Fatal error processing the queue! Queue processing is stopping!\", error);\n-                    queueRunning.set(false);\n-                });\n+                .doOnEach(item -> logger.trace(\"Processing item: \" + item.toString()))\n+                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n+                .retry()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .subscribe(\n+                        this::processJobBatch,\n+                        error -> {\n+                            logger.error(\"Error processing queue. Exiting...\", error);\n+                            queueRunning.set(false);\n+                        },\n+                        () -> {\n+                            logger.info(\"Finished processing queue. Exiting...\");\n+                            queueRunning.set(false);\n+                        }\n+                );\n+    }\n+\n+    /**\n+     * Creates an observer to monitor the queue\n+     */\n+    private Observable<Optional<JobQueueBatch>> createQueueObserver() {\n+        // Create using defer. This ensures that no events are omitted before a subscriber connects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cfd6869f06431066f082592f93cdded1fbf74c1"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1MzQ5Mg==", "bodyText": "Changed.", "url": "https://github.com/CMSgov/dpc-app/pull/664#discussion_r389753492", "createdAt": "2020-03-09T15:09:23Z", "author": {"login": "ronaldheft-usds"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "diffHunk": "@@ -110,21 +111,38 @@ public Boolean isRunning() {\n      * The main run-loop of the engine.\n      */\n     protected void pollQueue() {\n-        queueRunning.set(true);\n-        subscribe = Observable.fromCallable(() -> this.queue.claimBatch(aggregatorID))\n-                .doOnNext(job -> logger.trace(\"Polling queue for job\"))\n-                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n-                .onErrorResumeNext(Observable.empty()) // Keep the queue running on error\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+        this.subscribe = this.createQueueObserver()\n                 .repeatWhen(completed -> {\n-                    logger.debug(String.format(\"No job, polling again in %d milliseconds\", operationsConfig.getPollingFrequency()));\n+                    logger.debug(String.format(\"Configuring queue to poll every %d milliseconds\", operationsConfig.getPollingFrequency()));\n                     return completed.delay(operationsConfig.getPollingFrequency(), TimeUnit.MILLISECONDS);\n                 })\n-                .subscribe(this::processJobBatch, error -> {\n-                    logger.error(\"Fatal error processing the queue! Queue processing is stopping!\", error);\n-                    queueRunning.set(false);\n-                });\n+                .doOnEach(item -> logger.trace(\"Processing item: \" + item.toString()))\n+                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n+                .retry()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .subscribe(\n+                        this::processJobBatch,\n+                        error -> {\n+                            logger.error(\"Error processing queue. Exiting...\", error);\n+                            queueRunning.set(false);\n+                        },\n+                        () -> {\n+                            logger.info(\"Finished processing queue. Exiting...\");\n+                            queueRunning.set(false);\n+                        }\n+                );\n+    }\n+\n+    /**\n+     * Creates an observer to monitor the queue\n+     */\n+    private Observable<Optional<JobQueueBatch>> createQueueObserver() {\n+        // Create using defer. This ensures that no events are omitted before a subscriber connects", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNTk0Nw=="}, "originalCommit": {"oid": "4cfd6869f06431066f082592f93cdded1fbf74c1"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTE2MDU5OnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDo0NDo1NFrOFzrn2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNToxMjozNlrOFzszOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjQwOA==", "bodyText": "What happens if claimBatch throws an exception? I believe you need a try-catch here.", "url": "https://github.com/CMSgov/dpc-app/pull/664#discussion_r389736408", "createdAt": "2020-03-09T14:44:54Z", "author": {"login": "RickHawesUSDS"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "diffHunk": "@@ -110,21 +111,38 @@ public Boolean isRunning() {\n      * The main run-loop of the engine.\n      */\n     protected void pollQueue() {\n-        queueRunning.set(true);\n-        subscribe = Observable.fromCallable(() -> this.queue.claimBatch(aggregatorID))\n-                .doOnNext(job -> logger.trace(\"Polling queue for job\"))\n-                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n-                .onErrorResumeNext(Observable.empty()) // Keep the queue running on error\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+        this.subscribe = this.createQueueObserver()\n                 .repeatWhen(completed -> {\n-                    logger.debug(String.format(\"No job, polling again in %d milliseconds\", operationsConfig.getPollingFrequency()));\n+                    logger.debug(String.format(\"Configuring queue to poll every %d milliseconds\", operationsConfig.getPollingFrequency()));\n                     return completed.delay(operationsConfig.getPollingFrequency(), TimeUnit.MILLISECONDS);\n                 })\n-                .subscribe(this::processJobBatch, error -> {\n-                    logger.error(\"Fatal error processing the queue! Queue processing is stopping!\", error);\n-                    queueRunning.set(false);\n-                });\n+                .doOnEach(item -> logger.trace(\"Processing item: \" + item.toString()))\n+                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n+                .retry()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .subscribe(\n+                        this::processJobBatch,\n+                        error -> {\n+                            logger.error(\"Error processing queue. Exiting...\", error);\n+                            queueRunning.set(false);\n+                        },\n+                        () -> {\n+                            logger.info(\"Finished processing queue. Exiting...\");\n+                            queueRunning.set(false);\n+                        }\n+                );\n+    }\n+\n+    /**\n+     * Creates an observer to monitor the queue\n+     */\n+    private Observable<Optional<JobQueueBatch>> createQueueObserver() {\n+        // Create using defer. This ensures that no events are omitted before a subscriber connects\n+        return Observable.defer(() -> {\n+            logger.trace(\"Polling queue for job...\");\n+            return Observable.just(this.queue.claimBatch(this.aggregatorID));\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cfd6869f06431066f082592f93cdded1fbf74c1"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc1NTcwNg==", "bodyText": "The claimBatchException test (https://github.com/CMSgov/dpc-app/pull/664/files#diff-418a41c6b353afb120cabe81362f9772R97) validates the queue resumes processing and a try/catch is not needed.\nThe retry call (https://github.com/CMSgov/dpc-app/pull/664/files#diff-55cd831b5f1a3adf606630144e38cf13R121) in the observer chain picks up the exception and calls the observer to re-call claimBatch. Additionally, the error message is logged out with the doOnError call (https://github.com/CMSgov/dpc-app/pull/664/files#diff-55cd831b5f1a3adf606630144e38cf13R120).", "url": "https://github.com/CMSgov/dpc-app/pull/664#discussion_r389755706", "createdAt": "2020-03-09T15:12:36Z", "author": {"login": "ronaldheft-usds"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "diffHunk": "@@ -110,21 +111,38 @@ public Boolean isRunning() {\n      * The main run-loop of the engine.\n      */\n     protected void pollQueue() {\n-        queueRunning.set(true);\n-        subscribe = Observable.fromCallable(() -> this.queue.claimBatch(aggregatorID))\n-                .doOnNext(job -> logger.trace(\"Polling queue for job\"))\n-                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n-                .onErrorResumeNext(Observable.empty()) // Keep the queue running on error\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n+        this.subscribe = this.createQueueObserver()\n                 .repeatWhen(completed -> {\n-                    logger.debug(String.format(\"No job, polling again in %d milliseconds\", operationsConfig.getPollingFrequency()));\n+                    logger.debug(String.format(\"Configuring queue to poll every %d milliseconds\", operationsConfig.getPollingFrequency()));\n                     return completed.delay(operationsConfig.getPollingFrequency(), TimeUnit.MILLISECONDS);\n                 })\n-                .subscribe(this::processJobBatch, error -> {\n-                    logger.error(\"Fatal error processing the queue! Queue processing is stopping!\", error);\n-                    queueRunning.set(false);\n-                });\n+                .doOnEach(item -> logger.trace(\"Processing item: \" + item.toString()))\n+                .doOnError(error -> logger.error(\"Unable to complete job.\", error))\n+                .retry()\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .subscribe(\n+                        this::processJobBatch,\n+                        error -> {\n+                            logger.error(\"Error processing queue. Exiting...\", error);\n+                            queueRunning.set(false);\n+                        },\n+                        () -> {\n+                            logger.info(\"Finished processing queue. Exiting...\");\n+                            queueRunning.set(false);\n+                        }\n+                );\n+    }\n+\n+    /**\n+     * Creates an observer to monitor the queue\n+     */\n+    private Observable<Optional<JobQueueBatch>> createQueueObserver() {\n+        // Create using defer. This ensures that no events are omitted before a subscriber connects\n+        return Observable.defer(() -> {\n+            logger.trace(\"Polling queue for job...\");\n+            return Observable.just(this.queue.claimBatch(this.aggregatorID));\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczNjQwOA=="}, "originalCommit": {"oid": "4cfd6869f06431066f082592f93cdded1fbf74c1"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4904, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}