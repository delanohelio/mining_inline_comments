{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MTQyMDQ4", "number": 753, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyODoxMlrODyjn4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNDo0MTo1NFrOD1lmeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MzM5MDQzOnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/dao/RosterDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyODoxMlrOGGq7lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNToyODoxMlrOGGq7lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY0ODAyMQ==", "bodyText": "Would it be more flexible to pass in the Patient and Practitioner UUIDs so they don't have to be parsed out of the reference strings?", "url": "https://github.com/CMSgov/dpc-app/pull/753#discussion_r409648021", "createdAt": "2020-04-16T15:28:12Z", "author": {"login": "em1"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/dao/RosterDAO.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package gov.cms.dpc.aggregation.dao;\n+\n+import gov.cms.dpc.common.entities.*;\n+import gov.cms.dpc.common.hibernate.attribution.DPCManagedSessionFactory;\n+import gov.cms.dpc.fhir.FHIRExtractors;\n+import io.dropwizard.hibernate.AbstractDAO;\n+import org.hibernate.query.Query;\n+\n+import javax.inject.Inject;\n+import javax.persistence.criteria.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class RosterDAO extends AbstractDAO<RosterEntity> {\n+\n+    @Inject\n+    public RosterDAO(DPCManagedSessionFactory factory) {\n+        super(factory.getSessionFactory());\n+    }\n+\n+    public boolean withinRoster(UUID organizationID, String providerID, String patientReference) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a264beba5ea2d919ce04402af0f80250826491ab"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTAxODg5OnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/dao/RosterDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMTozOTowNlrOGHhjLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMTozOTowNlrOGHhjLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU0Mjg5Mg==", "bodyText": "Method ambiguousIDPredicates has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/CMSgov/dpc-app/pull/753#discussion_r410542892", "createdAt": "2020-04-18T01:39:06Z", "author": {"login": "codeclimate"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/dao/RosterDAO.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package gov.cms.dpc.aggregation.dao;\n+\n+import gov.cms.dpc.common.entities.*;\n+import gov.cms.dpc.common.hibernate.attribution.DPCManagedSessionFactory;\n+import io.dropwizard.hibernate.AbstractDAO;\n+import org.hibernate.query.Query;\n+\n+import javax.inject.Inject;\n+import javax.persistence.criteria.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+public class RosterDAO extends AbstractDAO<RosterEntity> {\n+\n+    @Inject\n+    public RosterDAO(DPCManagedSessionFactory factory) {\n+        super(factory.getSessionFactory());\n+    }\n+\n+    public UUID retrieveProviderIDFromRoster(UUID organizationID, UUID ambiguousID, String patientMBI) {\n+        // Build a selection query to get records from the database\n+        final CriteriaBuilder builder = currentSession().getCriteriaBuilder();\n+        final CriteriaQuery<UUID> query = builder.createQuery(UUID.class);\n+        final Root<RosterEntity> root = query.from(RosterEntity.class);\n+\n+        query.select(root.get(RosterEntity_.ATTRIBUTED_PROVIDER).get(ProviderEntity_.ID));\n+        query.where(ambiguousIDPredicates(builder, root, organizationID, ambiguousID, patientMBI).toArray(new Predicate[0]));\n+\n+\n+        Query<UUID> q = currentSession().createQuery(query);\n+        return q.getSingleResult();\n+    }\n+\n+    private List<Predicate> ambiguousIDPredicates(CriteriaBuilder builder, Root<RosterEntity> root, UUID organizationID, UUID ambiguousID, String patientMBI) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f83f7f6669b36b547f110d61452b2c31f31c17cd"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzAxOTEyOnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/JobBatchProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMTo1OTo0NVrOGH9g4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMTo1OTo0NVrOGH9g4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMTA1OA==", "bodyText": "Method bufferAndWrite has 5 arguments (exceeds 4 allowed). Consider refactoring.", "url": "https://github.com/CMSgov/dpc-app/pull/753#discussion_r411001058", "createdAt": "2020-04-19T21:59:45Z", "author": {"login": "codeclimate"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/JobBatchProcessor.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package gov.cms.dpc.aggregation.engine;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricRegistry;\n+import gov.cms.dpc.bluebutton.client.BlueButtonClient;\n+import gov.cms.dpc.common.utils.MetricMaker;\n+import gov.cms.dpc.queue.IJobQueue;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.queue.models.JobQueueBatchFile;\n+import io.reactivex.Flowable;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.hl7.fhir.dstu3.model.Resource;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+import org.reactivestreams.Publisher;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+public class JobBatchProcessor {\n+\n+    private final BlueButtonClient bbclient;\n+    private final OperationsConfig operationsConfig;\n+    private final FhirContext fhirContext;\n+    private final Meter resourceMeter;\n+    private final Meter operationalOutcomeMeter;\n+\n+    @Inject\n+    public JobBatchProcessor(BlueButtonClient bbclient, FhirContext fhirContext, MetricRegistry metricRegistry, OperationsConfig operationsConfig) {\n+        this.bbclient = bbclient;\n+        this.fhirContext = fhirContext;\n+        this.operationsConfig = operationsConfig;\n+\n+        // Metrics\n+        final var metricFactory = new MetricMaker(metricRegistry, JobBatchProcessor.class);\n+        resourceMeter = metricFactory.registerMeter(\"resourceFetched\");\n+        operationalOutcomeMeter = metricFactory.registerMeter(\"operationalOutcomes\");\n+    }\n+\n+    /**\n+     * Processes a partial of a job batch. Marks the partial as completed upon processing\n+     *\n+     * @param job       - the job to process\n+     * @param patientID - The current patient id processing\n+     */\n+    public List<JobQueueBatchFile> processJobBatchPartial(UUID aggregatorID, IJobQueue queue, JobQueueBatch job, String patientID) {\n+        final var results = Flowable.fromIterable(job.getResourceTypes())\n+                .map(resourceType -> fetchResource(job, patientID, resourceType))\n+                .flatMap(result -> writeResource(job, result.getRight(), result.getLeft().flatMap(Flowable::fromIterable)))\n+                .toList()\n+                .blockingGet(); // Wait on the main thread until completion\n+        queue.completePartialBatch(job, aggregatorID);\n+        return results;\n+    }\n+\n+    /**\n+     * Fetch and write a specific resource type\n+     *\n+     * @param job          context\n+     * @param resourceType to process\n+     */\n+    public Pair<Flowable<List<Resource>>, ResourceType> fetchResource(JobQueueBatch job, String patientID, ResourceType resourceType) {\n+        // Make this flow hot (ie. only called once) when multiple subscribers attach\n+        final var fetcher = new ResourceFetcher(bbclient, job.getJobID(), job.getBatchID(), resourceType, operationsConfig);\n+        return Pair.of(fetcher.fetchResources(patientID), resourceType);\n+    }\n+\n+    private Flowable<JobQueueBatchFile> writeResource(JobQueueBatch job, ResourceType resourceType, Flowable<Resource> flow) {\n+        var connectableMixedFlow = flow.publish().autoConnect(2);\n+        // Batch the non-error resources into files\n+        final var resourceCount = new AtomicInteger();\n+        final var sequenceCount = new AtomicInteger();\n+        job.getJobQueueFileLatest(resourceType).ifPresent(file -> {\n+            resourceCount.set(file.getCount());\n+            sequenceCount.set(file.getSequence());\n+        });\n+        final var writer = new ResourceWriter(fhirContext, job, resourceType, operationsConfig);\n+        final Flowable<JobQueueBatchFile> resourceFlow = connectableMixedFlow.compose((upstream) -> bufferAndWrite(upstream, writer, resourceCount, sequenceCount, resourceMeter));\n+\n+        // Batch the error resources into files\n+        final var errorResourceCount = new AtomicInteger();\n+        final var errorSequenceCount = new AtomicInteger();\n+        job.getJobQueueFileLatest(ResourceType.OperationOutcome).ifPresent(file -> {\n+            errorResourceCount.set(file.getCount());\n+            errorSequenceCount.set(file.getSequence());\n+        });\n+        final var errorWriter = new ResourceWriter(fhirContext, job, ResourceType.OperationOutcome, operationsConfig);\n+        final Flowable<JobQueueBatchFile> outcomeFlow = connectableMixedFlow.compose((upstream) -> bufferAndWrite(upstream, errorWriter, errorResourceCount, errorSequenceCount, operationalOutcomeMeter));\n+\n+        // Merge the resultant flows\n+        return resourceFlow.mergeWith(outcomeFlow);\n+    }\n+\n+    /**\n+     * This part of the flow chain buffers resources and writes them in batches to a file\n+     *\n+     * @param writer        - the writer to use\n+     * @param resourceCount - the number of resources in the current file\n+     * @param sequenceCount - the sequence counter\n+     * @param meter         - a meter on the number of resources\n+     * @return a transformed flow\n+     */\n+    private Publisher<JobQueueBatchFile> bufferAndWrite(Flowable<Resource> upstream, ResourceWriter writer, AtomicInteger resourceCount, AtomicInteger sequenceCount, Meter meter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1b067d106d534305eed89f45bb525ad8e5613cf"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTE3MTc2OnYy", "diffSide": "RIGHT", "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNDo0MTo1NFrOGLGINw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNDo0MTo1NFrOGLGINw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI4NzkyNw==", "bodyText": "If we know for sure the ID is a rosterID, do we need to go to the trouble of using an ambiguousID parameter to getProviderIDFromRoster()?  Why not call it rosterID?", "url": "https://github.com/CMSgov/dpc-app/pull/753#discussion_r414287927", "createdAt": "2020-04-24T04:41:54Z", "author": {"login": "dhgreene"}, "path": "dpc-aggregation/src/main/java/gov/cms/dpc/aggregation/engine/AggregationEngine.java", "diffHunk": "@@ -195,12 +177,38 @@ protected void processJobBatch(JobQueueBatch job) {\n         }\n     }\n \n+    private Optional<String> processPatient(JobQueueBatch job, String patientId) {\n+        if (isValidLookBack(job, patientId)) {\n+            jobBatchProcessor.processJobBatchPartial(aggregatorID, queue, job, patientId);\n+        }\n+        // Stop processing when no patients or early shutdown\n+        return this.isRunning() ? job.fetchNextPatient(aggregatorID) : Optional.empty();\n+    }\n+\n+    private boolean isValidLookBack(JobQueueBatch job, String patientId) {\n+        boolean result = false;\n+        //job.getProviderID is really not providerID, it is the rosterID, see createJob in GroupResource export for confirmation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62680c53cdb8c4d60269b1daaff90d36ce6e874e"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4860, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}