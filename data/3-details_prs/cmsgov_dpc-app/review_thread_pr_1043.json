{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NTA4OTkz", "number": 1043, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo1MzowNVrOEjwHKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo1MzowNVrOEjwHKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTIzODgzOnYy", "diffSide": "RIGHT", "path": "dpcclient/lib/pki.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo1MzowNVrOHSSOBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo1MzowNVrOHSSOBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzNDkxNg==", "bodyText": "Function SaveDPCKeyPair has 5 return statements (exceeds 4 allowed).", "url": "https://github.com/CMSgov/dpc-app/pull/1043#discussion_r488934916", "createdAt": "2020-09-15T19:53:05Z", "author": {"login": "codeclimate"}, "path": "dpcclient/lib/pki.go", "diffHunk": "@@ -0,0 +1,106 @@\n+package lib\n+\n+import (\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"crypto/x509\"\n+\t\"encoding/pem\"\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// https://dpc.cms.gov/docs, 'Uploading a public key' section. The first public key must be uploaded via the web UI.\n+// Thereafter, public keys can be managed via the API Key endpoint\n+const RsaKeyMinBits = 4096\n+\n+// GenRSAKeyPair generates a suitably-sized private key for use with DPC, returning both the private key\n+// and the associated public key. Note that no pass phrase is associated with the private key. Further note\n+// that the private key is in PKCS1 form, but the public key is in PKIX form. This is directly in response\n+// to DPC requirements; DPC only understands PKIX format for public keys.\n+// https://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file\n+func GenRSAKeyPair() (*rsa.PrivateKey, *rsa.PublicKey, error) {\n+\tpriv, err := rsa.GenerateKey(rand.Reader, RsaKeyMinBits)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\treturn priv, &priv.PublicKey, nil\n+}\n+\n+func savePrivateKey(prefix string, key *rsa.PrivateKey) error {\n+\tconvertedKey := x509.MarshalPKCS1PrivateKey(key)\n+\tif convertedKey == nil {\n+\t\treturn errors.New(\"could not marshall private key to x509 PKCS1 form\")\n+\t}\n+\tprivateKeyBytes := pem.EncodeToMemory(\n+\t\t&pem.Block{\n+\t\t\tType:  \"RSA PRIVATE KEY\",\n+\t\t\tBytes: convertedKey,\n+\t\t},\n+\t)\n+\tif err := WriteSmallFile(fmt.Sprintf(\"%s-private.pem\", prefix), privateKeyBytes); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func savePublicKey(prefix string, key *rsa.PublicKey) error {\n+\tconvertedKey, err := x509.MarshalPKIXPublicKey(key)\n+\tif convertedKey == nil || err != nil {\n+\t\treturn errors.New(\"could not marshall public key to x509 PKIX form\")\n+\t}\n+\tpublicKeyBytes := pem.EncodeToMemory(&pem.Block{\n+\t\tType:  \"PUBLIC KEY\",\n+\t\tBytes: convertedKey,\n+\t})\n+\tif err := WriteSmallFile(fmt.Sprintf(\"%s-public.pem\", prefix), publicKeyBytes); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// SaveDPCKeyPair saves an RSA Key Pair to files, first checking that it is valid for use with DPC.\n+// The prefix string should contain any path elements either relative to the working directory or absolute.\n+// Two files will be created using the prefix --- prefix-private.pem and prefix-public.pem ---\n+// with the obvious contents.\n+func SaveDPCKeyPair(prefix string, private *rsa.PrivateKey, public *rsa.PublicKey) error {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980e764ff4674edcd56bca3ee9f7937a80c61097"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 81, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}