{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjcyOTI5", "number": 674, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDoyOTo1OFrODmc7OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDoyOTo1OFrODmc7OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjQ2MzkyOnYy", "diffSide": "RIGHT", "path": "dpc-queue/src/test/java/gov/cms/dpc/queue/DistributedBatchQueueTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDoyOTo1OFrOFz4QNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDoyOTo1OFrOFz4QNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0MzM0OA==", "bodyText": "Would it be possible to use a public constant from the distributed queue module instead of a hardcoded 15 minutes?", "url": "https://github.com/CMSgov/dpc-app/pull/674#discussion_r389943348", "createdAt": "2020-03-09T20:29:58Z", "author": {"login": "RickHawesUSDS"}, "path": "dpc-queue/src/test/java/gov/cms/dpc/queue/DistributedBatchQueueTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package gov.cms.dpc.queue;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import gov.cms.dpc.common.hibernate.queue.DPCQueueManagedSessionFactory;\n+import gov.cms.dpc.queue.models.JobQueueBatch;\n+import gov.cms.dpc.testing.BufferedLoggerHandler;\n+import org.hibernate.Session;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.Transaction;\n+import org.hibernate.cfg.Configuration;\n+import org.hl7.fhir.dstu3.model.ResourceType;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.time.OffsetDateTime;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@ExtendWith(BufferedLoggerHandler.class)\n+public class DistributedBatchQueueTest {\n+\n+    private final UUID aggregatorID = UUID.randomUUID();\n+    private SessionFactory sessionFactory;\n+    private DistributedBatchQueue queue;\n+\n+    @BeforeEach\n+    void setUp() {\n+        final Configuration conf = new Configuration();\n+        sessionFactory = conf.configure().buildSessionFactory();\n+        queue = new DistributedBatchQueue(new DPCQueueManagedSessionFactory(sessionFactory), 100, new MetricRegistry());\n+    }\n+\n+    @AfterEach\n+    void shutdown() {\n+        try (final Session session = sessionFactory.openSession()) {\n+            final Transaction tx = session.beginTransaction();\n+            try {\n+                session.createQuery(\"delete from job_queue_batch_file\").executeUpdate();\n+                session.createQuery(\"delete from job_queue_batch\").executeUpdate();\n+            } finally {\n+                tx.commit();\n+            }\n+        }\n+        sessionFactory.close();\n+    }\n+\n+    @Test\n+    void handleStuckBatchWithClaim() {\n+        // One organization id for both jobs\n+        final UUID orgID = UUID.randomUUID();\n+\n+        // Add a job\n+        var jobID = queue.createJob(orgID, \"test-provider-1\", List.of(\"test-patient-1\", \"test-patient-2\"), Collections.singletonList(ResourceType.Patient));\n+\n+        // Work the job\n+        Optional<JobQueueBatch> workBatch = queue.claimBatch(aggregatorID);\n+        assertTrue(workBatch.isPresent(), \"Should have a job to work\");\n+        final UUID firstBatchID = workBatch.orElseThrow().getBatchID();\n+\n+        // Add a file on the batch\n+        workBatch.get().addJobQueueFile(ResourceType.Patient, 0, 1);\n+        queue.completePartialBatch(workBatch.get(), aggregatorID);\n+\n+        // Check that the persisted job is RUNNING\n+        final Optional<JobQueueBatch> runningJobOptional = queue.getBatch(firstBatchID);\n+        assertTrue(runningJobOptional.isPresent(), \"Should have a running job\");\n+        runningJobOptional.ifPresent(runningJob -> {\n+            assertEquals(JobStatus.RUNNING, runningJob.getStatus(), \"Should be in the RUNNING state\");\n+            assertEquals(1, runningJob.getJobQueueBatchFiles().size(), \"Should have 1 file on the running job\");\n+            assertTrue(runningJob.getJobQueueFile(ResourceType.Patient).isPresent(), \"Should have a patient job file\");\n+        });\n+\n+        // Simulate a stuck job by modifying the update_time\n+        try (final Session session = sessionFactory.openSession()) {\n+            final Transaction tx = session.beginTransaction();\n+            try {\n+                session.createQuery(\"update job_queue_batch set updateTime = :updateTime where jobID = :jobID\")\n+                        .setParameter(\"jobID\", jobID)\n+                        .setParameter(\"updateTime\", OffsetDateTime.now().minusMinutes(15))\n+                        .executeUpdate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d249a823274cc6db187fae1e12302d923bf8fb09"}, "originalPosition": 86}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4911, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}