{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NzMyMjAx", "number": 2715, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDoyNzowNlrOEYphQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMjowMTozNFrOEYqAYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgxNTM3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/StreamAddressSpace.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDoyNzowNlrOHBGTvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo1Mjo1MVrOHBG5dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMzk4MA==", "bodyText": "*returns a", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470913980", "createdAt": "2020-08-15T00:27:06Z", "author": {"login": "PavelZaytsev"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/StreamAddressSpace.java", "diffHunk": "@@ -41,10 +41,36 @@ public StreamAddressSpace(long trimMark, Roaring64NavigableMap addressMap) {\n         this.addressMap = addressMap;\n     }\n \n+    public StreamAddressSpace() {\n+        this.addressMap = Roaring64NavigableMap.bitmapOf();\n+        this.trimMark = Address.NON_ADDRESS;\n+    }\n+\n     public Roaring64NavigableMap getAddressMap() {\n         return addressMap;\n     }\n \n+    /**\n+     * Merges b into a and returns b as the final result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ff11ef0b2aa2d4d7ef8f9536b89726124accc7f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMzYzOQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470923639", "createdAt": "2020-08-15T01:52:51Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/StreamAddressSpace.java", "diffHunk": "@@ -41,10 +41,36 @@ public StreamAddressSpace(long trimMark, Roaring64NavigableMap addressMap) {\n         this.addressMap = addressMap;\n     }\n \n+    public StreamAddressSpace() {\n+        this.addressMap = Roaring64NavigableMap.bitmapOf();\n+        this.trimMark = Address.NON_ADDRESS;\n+    }\n+\n     public Roaring64NavigableMap getAddressMap() {\n         return addressMap;\n     }\n \n+    /**\n+     * Merges b into a and returns b as the final result.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMzk4MA=="}, "originalCommit": {"oid": "1ff11ef0b2aa2d4d7ef8f9536b89726124accc7f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgxNzc5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDoyOTo0M1rOHBGVHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo0MToyOFrOHBG1LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDMzMg==", "bodyText": "This can be moved to the first line.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470914332", "createdAt": "2020-08-15T00:29:43Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjU0MA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470922540", "createdAt": "2020-08-15T01:41:28Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDMzMg=="}, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgyNDUwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDozNjoyNlrOHBGYtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo0NDowMlrOHBG2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTI1Mg==", "bodyText": "AtomicLong is cleaner than array.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470915252", "createdAt": "2020-08-15T00:36:26Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());\n+        return segments.stream()\n+                .map(Layout.LayoutSegment::getFirstStripe)\n+                .map(Layout.LayoutStripe::getLogServers)\n+                .map(strip -> strip.get(0))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Compute the max tail across the first node of each segment in the layout\n+     * on the same epoch.\n      *\n      * @param runtimeLayout current RuntimeLayout\n      * @return Log global tail\n      */\n     public static long getLogTail(RuntimeLayout runtimeLayout) {\n-        long globalLogTail = Address.NON_EXIST;\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse response = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogTail());\n-                globalLogTail = Long.max(globalLogTail, response.getLogTail());\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long globalLogTail = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogTail())\n+                .map(CFUtils::getUninterruptibly)\n+                .mapToLong(TailsResponse::getLogTail)\n+                .max().orElseThrow(NoSuchElementException::new);\n \n+        log.debug(\"getLogTail: nodes selected {} global tail {}\",\n+                segmentsHeadNodes,globalLogTail);\n         return globalLogTail;\n     }\n \n     /**\n      * Fetches the max global log tail and all stream tails from the log unit cluster. This depends on the mode of\n      * replication being used.\n-     * CHAIN: Block on fetch of global log tail from the head log unit in every stripe.\n-     * QUORUM: Block on fetch of global log tail from a majority in every stripe.\n-     *\n+     * CHAIN: Block on fetch of global log tail from the head log unit in every segment.*\n      * @param runtimeLayout current RuntimeLayout\n-     * @return The max global log tail obtained from the log unit servers.\n+     * @return The max global log tail and max global tails across all segments\n      */\n     public static TailsResponse getAllTails(RuntimeLayout runtimeLayout) {\n-        Set<TailsResponse> luResponses = new HashSet<>();\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n \n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the tail of the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getAllTails());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        long[] globalTail = {Address.NON_EXIST};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjgwNg==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470922806", "createdAt": "2020-08-15T01:44:02Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());\n+        return segments.stream()\n+                .map(Layout.LayoutSegment::getFirstStripe)\n+                .map(Layout.LayoutStripe::getLogServers)\n+                .map(strip -> strip.get(0))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Compute the max tail across the first node of each segment in the layout\n+     * on the same epoch.\n      *\n      * @param runtimeLayout current RuntimeLayout\n      * @return Log global tail\n      */\n     public static long getLogTail(RuntimeLayout runtimeLayout) {\n-        long globalLogTail = Address.NON_EXIST;\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse response = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogTail());\n-                globalLogTail = Long.max(globalLogTail, response.getLogTail());\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long globalLogTail = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogTail())\n+                .map(CFUtils::getUninterruptibly)\n+                .mapToLong(TailsResponse::getLogTail)\n+                .max().orElseThrow(NoSuchElementException::new);\n \n+        log.debug(\"getLogTail: nodes selected {} global tail {}\",\n+                segmentsHeadNodes,globalLogTail);\n         return globalLogTail;\n     }\n \n     /**\n      * Fetches the max global log tail and all stream tails from the log unit cluster. This depends on the mode of\n      * replication being used.\n-     * CHAIN: Block on fetch of global log tail from the head log unit in every stripe.\n-     * QUORUM: Block on fetch of global log tail from a majority in every stripe.\n-     *\n+     * CHAIN: Block on fetch of global log tail from the head log unit in every segment.*\n      * @param runtimeLayout current RuntimeLayout\n-     * @return The max global log tail obtained from the log unit servers.\n+     * @return The max global log tail and max global tails across all segments\n      */\n     public static TailsResponse getAllTails(RuntimeLayout runtimeLayout) {\n-        Set<TailsResponse> luResponses = new HashSet<>();\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n \n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the tail of the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getAllTails());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        long[] globalTail = {Address.NON_EXIST};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTI1Mg=="}, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgyNDY2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDozNjozM1rOHBGYyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo1MzowN1rOHBG5gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTI3NQ==", "bodyText": "AtomicLong is cleaner than array.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470915275", "createdAt": "2020-08-15T00:36:33Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +310,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMzY0OQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470923649", "createdAt": "2020-08-15T01:53:07Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +310,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTI3NQ=="}, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg0MDQ1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo1NDo0NVrOHBGhPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo0NDozM1rOHBG2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzQzNw==", "bodyText": "Because of java stream's lazy evaluation property, if CFUtils.get is put in map(), then the futures are actually executed sequentially. We need to parallelize it to get better performance, by gathering all the futures first and then wait on them, similar to this: https://github.com/CorfuDB/CorfuDB/blob/master/runtime/src/main/java/org/corfudb/util/Utils.java#L152-L162", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470917437", "createdAt": "2020-08-15T00:54:45Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());\n+        return segments.stream()\n+                .map(Layout.LayoutSegment::getFirstStripe)\n+                .map(Layout.LayoutStripe::getLogServers)\n+                .map(strip -> strip.get(0))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Compute the max tail across the first node of each segment in the layout\n+     * on the same epoch.\n      *\n      * @param runtimeLayout current RuntimeLayout\n      * @return Log global tail\n      */\n     public static long getLogTail(RuntimeLayout runtimeLayout) {\n-        long globalLogTail = Address.NON_EXIST;\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse response = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogTail());\n-                globalLogTail = Long.max(globalLogTail, response.getLogTail());\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long globalLogTail = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogTail())\n+                .map(CFUtils::getUninterruptibly)\n+                .mapToLong(TailsResponse::getLogTail)\n+                .max().orElseThrow(NoSuchElementException::new);\n \n+        log.debug(\"getLogTail: nodes selected {} global tail {}\",\n+                segmentsHeadNodes,globalLogTail);\n         return globalLogTail;\n     }\n \n     /**\n      * Fetches the max global log tail and all stream tails from the log unit cluster. This depends on the mode of\n      * replication being used.\n-     * CHAIN: Block on fetch of global log tail from the head log unit in every stripe.\n-     * QUORUM: Block on fetch of global log tail from a majority in every stripe.\n-     *\n+     * CHAIN: Block on fetch of global log tail from the head log unit in every segment.*\n      * @param runtimeLayout current RuntimeLayout\n-     * @return The max global log tail obtained from the log unit servers.\n+     * @return The max global log tail and max global tails across all segments\n      */\n     public static TailsResponse getAllTails(RuntimeLayout runtimeLayout) {\n-        Set<TailsResponse> luResponses = new HashSet<>();\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n \n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the tail of the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getAllTails());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, Long> streamTails = new HashMap<>();\n \n-        return aggregateLogUnitTails(luResponses);\n-    }\n-\n-    /**\n-     * Given a set of request tails, we aggregate them and maintain\n-     * the greatest address per stream and the greatest tail over\n-     * all responses.\n-     * @param responses a set of tail responses\n-     * @return An max-aggregation of all tails\n-     */\n-    static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n-        long globalTail = Address.NON_ADDRESS;\n-        Map<UUID, Long> globalStreamTails = new HashMap<>();\n-\n-        for (TailsResponse res : responses) {\n-            globalTail = Math.max(globalTail, res.getLogTail());\n-\n-            for (Map.Entry<UUID, Long> stream : res.getStreamTails().entrySet()) {\n-                long streamTail = globalStreamTails.getOrDefault(stream.getKey(), Address.NON_ADDRESS);\n-                globalStreamTails.put(stream.getKey(), Math.max(streamTail, stream.getValue()));\n-            }\n-        }\n-        // All epochs should be equal as all the tails are queried using a single runtime layout.\n-        return new TailsResponse(globalTail, globalStreamTails);\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getAllTails())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());\n+                    // Find the global max global tail and stream tails across all responses\n+                    globalTail[0] = Long.max(resp.getLogTail(), globalTail[0]);\n+                    resp.getStreamTails().forEach((k, v) -> streamTails.merge(k, v, Long::max));\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjg1Nw==", "bodyText": "Yea, I thought about it, but didnt think it was worth it.\nWill change it anyways.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470922857", "createdAt": "2020-08-15T01:44:33Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -205,99 +229,78 @@ public static void updateCommittedTail(RuntimeLayout runtimeLayout,\n     }\n \n     /**\n-     * Get global log tail.\n+     * Find the chain's head node of each segment\n+     * @param layout layout to search in\n+     * @return returns a set of nodes the represent the first node in all segments\n+     */\n+    private static Set<String> getChainHeadFromAllSegments(Layout layout) {\n+        List<Layout.LayoutSegment> segments = layout.getSegments();\n+        validateSegments(layout.getSegments());\n+        return segments.stream()\n+                .map(Layout.LayoutSegment::getFirstStripe)\n+                .map(Layout.LayoutStripe::getLogServers)\n+                .map(strip -> strip.get(0))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Compute the max tail across the first node of each segment in the layout\n+     * on the same epoch.\n      *\n      * @param runtimeLayout current RuntimeLayout\n      * @return Log global tail\n      */\n     public static long getLogTail(RuntimeLayout runtimeLayout) {\n-        long globalLogTail = Address.NON_EXIST;\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse response = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogTail());\n-                globalLogTail = Long.max(globalLogTail, response.getLogTail());\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long globalLogTail = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogTail())\n+                .map(CFUtils::getUninterruptibly)\n+                .mapToLong(TailsResponse::getLogTail)\n+                .max().orElseThrow(NoSuchElementException::new);\n \n+        log.debug(\"getLogTail: nodes selected {} global tail {}\",\n+                segmentsHeadNodes,globalLogTail);\n         return globalLogTail;\n     }\n \n     /**\n      * Fetches the max global log tail and all stream tails from the log unit cluster. This depends on the mode of\n      * replication being used.\n-     * CHAIN: Block on fetch of global log tail from the head log unit in every stripe.\n-     * QUORUM: Block on fetch of global log tail from a majority in every stripe.\n-     *\n+     * CHAIN: Block on fetch of global log tail from the head log unit in every segment.*\n      * @param runtimeLayout current RuntimeLayout\n-     * @return The max global log tail obtained from the log unit servers.\n+     * @return The max global log tail and max global tails across all segments\n      */\n     public static TailsResponse getAllTails(RuntimeLayout runtimeLayout) {\n-        Set<TailsResponse> luResponses = new HashSet<>();\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n \n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the tail of the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                TailsResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getAllTails());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, Long> streamTails = new HashMap<>();\n \n-        return aggregateLogUnitTails(luResponses);\n-    }\n-\n-    /**\n-     * Given a set of request tails, we aggregate them and maintain\n-     * the greatest address per stream and the greatest tail over\n-     * all responses.\n-     * @param responses a set of tail responses\n-     * @return An max-aggregation of all tails\n-     */\n-    static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n-        long globalTail = Address.NON_ADDRESS;\n-        Map<UUID, Long> globalStreamTails = new HashMap<>();\n-\n-        for (TailsResponse res : responses) {\n-            globalTail = Math.max(globalTail, res.getLogTail());\n-\n-            for (Map.Entry<UUID, Long> stream : res.getStreamTails().entrySet()) {\n-                long streamTail = globalStreamTails.getOrDefault(stream.getKey(), Address.NON_ADDRESS);\n-                globalStreamTails.put(stream.getKey(), Math.max(streamTail, stream.getValue()));\n-            }\n-        }\n-        // All epochs should be equal as all the tails are queried using a single runtime layout.\n-        return new TailsResponse(globalTail, globalStreamTails);\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getAllTails())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());\n+                    // Find the global max global tail and stream tails across all responses\n+                    globalTail[0] = Long.max(resp.getLogTail(), globalTail[0]);\n+                    resp.getStreamTails().forEach((k, v) -> streamTails.merge(k, v, Long::max));\n+                });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzQzNw=="}, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg0MzIyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo1Nzo0OFrOHBGiog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo1MDoyMlrOHBG4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzc5NA==", "bodyText": "Same here.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470917794", "createdAt": "2020-08-15T00:57:48Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +310,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMzM5NQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470923395", "createdAt": "2020-08-15T01:50:22Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +310,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzc5NA=="}, "originalCommit": {"oid": "5338e61051943a191bf15644f437fa5a9145ca8a"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg1Mjc0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTowODoxMlrOHBGnXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTo1MTowM1rOHBG4zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxOTAwNw==", "bodyText": "Why did we comment this check out?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470919007", "createdAt": "2020-08-15T01:08:12Z", "author": {"login": "PavelZaytsev"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +313,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    //checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26238bfd82ddd6f128a9b55bc64a2aa7565999c1"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMzQ3MQ==", "bodyText": "That response doesn't actually has an epoch field. I fixed the API, un-commented and added tests.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470923471", "createdAt": "2020-08-15T01:51:03Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +313,27 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n-\n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        long[] globalTail = {Address.NON_EXIST};\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    //checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxOTAwNw=="}, "originalCommit": {"oid": "26238bfd82ddd6f128a9b55bc64a2aa7565999c1"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg5NTA1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMjowMTozNFrOHBG8ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMjozMToyNFrOHBHGbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNDM5NA==", "bodyText": "This will throw IllegalArgumentException, but should be throw WrongEpochException to be more clear?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470924394", "createdAt": "2020-08-15T02:01:34Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +319,29 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        AtomicLong globalTail = new AtomicLong(Address.NON_EXIST);\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        List<CompletableFuture<StreamsAddressResponse>> cfs = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .collect(Collectors.toList());\n \n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        cfs.stream().map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75cd7e7f9e5a18858cc4c4649a6497eb477f4e4f"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjk1Nw==", "bodyText": "good catch.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2715#discussion_r470926957", "createdAt": "2020-08-15T02:31:24Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/util/Utils.java", "diffHunk": "@@ -307,34 +319,29 @@ static TailsResponse aggregateLogUnitTails(Set<TailsResponse> responses) {\n      * @return response with all streams addresses and global log tail.\n      */\n     public static StreamsAddressResponse getLogAddressSpace(RuntimeLayout runtimeLayout) {\n-        Set<StreamsAddressResponse> luResponses = new HashSet<>();\n-\n-        Layout.LayoutSegment segment = runtimeLayout.getLayout().getLatestSegment();\n-\n-        // Query the head log unit in every stripe.\n-        if (segment.getReplicationMode() == Layout.ReplicationMode.CHAIN_REPLICATION) {\n-            for (Layout.LayoutStripe stripe : segment.getStripes()) {\n-\n-                StreamsAddressResponse res = CFUtils.getUninterruptibly(runtimeLayout\n-                                .getLogUnitClient(stripe.getLogServers().get(DEFAULT_LOGUNIT))\n-                                .getLogAddressSpace());\n-                luResponses.add(res);\n-            }\n-        } else if (segment.getReplicationMode() == Layout.ReplicationMode.QUORUM_REPLICATION) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        return aggregateLogAddressSpace(luResponses);\n-    }\n-\n-    static StreamsAddressResponse aggregateLogAddressSpace(Set<StreamsAddressResponse> responses) {\n-        Map<UUID, StreamAddressSpace> streamAddressSpace = new HashMap<>();\n-        long logTail = Address.NON_ADDRESS;\n+        // Since a node can exist as a head for multiple segments we need to a set to\n+        // coalesce the candidates to unique nodes only\n+        Set<String> segmentsHeadNodes = getChainHeadFromAllSegments(runtimeLayout.getLayout());\n+        AtomicLong globalTail = new AtomicLong(Address.NON_EXIST);\n+        final Map<UUID, StreamAddressSpace> streamsAddressSpace = new HashMap<>();\n+        List<CompletableFuture<StreamsAddressResponse>> cfs = segmentsHeadNodes.stream()\n+                .map(node -> runtimeLayout\n+                        .getLogUnitClient(node)\n+                        .getLogAddressSpace())\n+                .collect(Collectors.toList());\n \n-        for (StreamsAddressResponse res : responses) {\n-            logTail = Math.max(logTail, res.getLogTail());\n-            streamAddressSpace = aggregateStreamAddressMap(res.getAddressMap(), streamAddressSpace);\n-        }\n-        return new StreamsAddressResponse(logTail, streamAddressSpace);\n+        cfs.stream().map(CFUtils::getUninterruptibly)\n+                .forEach(resp -> {\n+                    // All responses should be computed on the same epoch\n+                    checkArgument(resp.getEpoch() == runtimeLayout.getLayout().getEpoch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNDM5NA=="}, "originalCommit": {"oid": "75cd7e7f9e5a18858cc4c4649a6497eb477f4e4f"}, "originalPosition": 301}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1944, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}