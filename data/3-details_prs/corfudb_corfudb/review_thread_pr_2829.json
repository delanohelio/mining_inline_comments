{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1OTY3NDUy", "number": 2829, "reviewThreads": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo0MzoyMlrOFFVZQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo0NDoxNVrOFL6Prw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTM3NzMwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo0MzoyMlrOIFzhJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyNTowMVrOIHkG_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk1Nzg2Mw==", "bodyText": "Can you add the Javadoc for this class and its API methods?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r542957863", "createdAt": "2020-12-15T00:43:22Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.*;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.*;\n+\n+@Slf4j\n+public class CorfuProtocolSequencer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36d95bed7cc403f275ba3aa3ac5393bc144d6e41"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjU1OQ==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802559", "createdAt": "2020-12-17T04:25:01Z", "author": {"login": "chetangudisagar"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.*;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.*;\n+\n+@Slf4j\n+public class CorfuProtocolSequencer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk1Nzg2Mw=="}, "originalCommit": {"oid": "36d95bed7cc403f275ba3aa3ac5393bc144d6e41"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTM3ODU0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMDo0Mzo1NFrOIFzh1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyNTowN1rOIHkHKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk1ODAzOA==", "bodyText": "Can you add the Javadoc for this class and its API methods?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r542958038", "createdAt": "2020-12-15T00:43:54Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.TxResolution.TxResolutionInfoMsg;\n+import org.corfudb.runtime.proto.TxResolution.UuidToListOfBytesPairMsg;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+@Slf4j\n+public class CorfuProtocolTxResolution {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36d95bed7cc403f275ba3aa3ac5393bc144d6e41"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjYwMw==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802603", "createdAt": "2020-12-17T04:25:07Z", "author": {"login": "chetangudisagar"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.TxResolution.TxResolutionInfoMsg;\n+import org.corfudb.runtime.proto.TxResolution.UuidToListOfBytesPairMsg;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+@Slf4j\n+public class CorfuProtocolTxResolution {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk1ODAzOA=="}, "originalCommit": {"oid": "36d95bed7cc403f275ba3aa3ac5393bc144d6e41"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjcxMzk3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo1NjozOFrOIHa43w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyNToxM1rOIHkHSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MTQ4Nw==", "bodyText": "This can be removed as this behaviour is already provided in AbstractServer.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544651487", "createdAt": "2020-12-16T21:56:38Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -174,8 +203,9 @@ public SequencerServer(ServerContext serverContext) {\n     }\n \n     @Override\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjYzMg==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802632", "createdAt": "2020-12-17T04:25:13Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -174,8 +203,9 @@ public SequencerServer(ServerContext serverContext) {\n     }\n \n     @Override\n+    @Deprecated\n     protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MTQ4Nw=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjcxNTUxOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo1NzowM1rOIHa5wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyNTozMFrOIHkHmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MTcxMw==", "bodyText": "This can be removed as this behaviour is already provided in AbstractServer.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544651713", "createdAt": "2020-12-16T21:57:03Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,25 @@ public void shutdown() {\n     }\n \n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n-            return false;\n-        }\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjcxNQ==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802715", "createdAt": "2020-12-17T04:25:30Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,25 @@ public void shutdown() {\n     }\n \n     @Override\n+    @Deprecated\n     public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n-            return false;\n-        }\n+        throw new UnsupportedOperationException(\"This operation is not supported\");\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MTcxMw=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjcxOTQwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMTo1ODowM1rOIHa8DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyNTozNFrOIHkHvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MjMwMA==", "bodyText": "This can be removed once the deprecated methods are removed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544652300", "createdAt": "2020-12-16T21:58:03Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -11,31 +11,32 @@\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n-\n import org.corfudb.common.metrics.micrometer.MeterRegistryProvider;\n-import org.corfudb.runtime.view.stream.StreamAddressSpace;\n-import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n-import org.corfudb.protocols.wireprotocol.StreamsAddressRequest;\n-import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n-import org.roaringbitmap.longlong.Roaring64NavigableMap;\n import org.corfudb.infrastructure.SequencerServerCache.ConflictTxStream;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjc0OA==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802748", "createdAt": "2020-12-17T04:25:34Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -11,31 +11,32 @@\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n-\n import org.corfudb.common.metrics.micrometer.MeterRegistryProvider;\n-import org.corfudb.runtime.view.stream.StreamAddressSpace;\n-import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n-import org.corfudb.protocols.wireprotocol.StreamsAddressRequest;\n-import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n-import org.roaringbitmap.longlong.Roaring64NavigableMap;\n import org.corfudb.infrastructure.SequencerServerCache.ConflictTxStream;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n import org.corfudb.protocols.wireprotocol.CorfuMsg;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1MjMwMA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjc0MDEzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjowMzoyOFrOIHbH4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNTowMzoxMlrOIH51lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTMyOQ==", "bodyText": "Why is this value part of the factory? It seems like getMinAddress is just a constant.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544655329", "createdAt": "2020-12-16T22:03:28Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -147,25 +154,47 @@\n     private long epochRangeLowerBound = Layout.INVALID_EPOCH;\n \n     private final ExecutorService executor;\n+    /**\n+     * - {@link SequencerServer::globalLogTail}:\n+     * global log first available position (initially, 0).\n+     */\n+    @Getter\n+    private long globalLogTail;\n \n     private final Optional<Timer> txResolutionTimer;\n \n     private final Optional<DistributionSummary> streamsPerTx;\n+\n     /**\n      * Returns a new SequencerServer.\n      *\n      * @param serverContext context object providing parameters and objects\n      */\n     public SequencerServer(ServerContext serverContext) {\n+        this(serverContext, new FactoryHelper());\n+    }\n+\n+    /**\n+     * Returns a new SequencerServer.\n+     *\n+     * @param serverContext context object providing parameters and objects\n+     * @param factoryHelper FactoryHelper providing utility methods to get various objects in a factory pattern\n+     */\n+    public SequencerServer(ServerContext serverContext, FactoryHelper factoryHelper) {\n         this.serverContext = serverContext;\n+        this.factoryHelper = factoryHelper;\n         Config config = Config.parse(serverContext.getServerConfig());\n \n         // Sequencer server is single threaded by current design\n-        this.executor = Executors.newSingleThreadExecutor(\n-                new ServerThreadFactory(\"sequencer-\", new ServerThreadFactory.ExceptionHandler()));\n+        this.executor = serverContext.getExecutorService(1, \"sequencer-\");\n+\n+        this.globalLogTail = factoryHelper.getGlobalLogTail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjQ0Nw==", "bodyText": "It was initially present as a parameter initializer along with its declaration and I wanted it to be overridden by the test cases to initialize with a new custom value. So I kept the default behaviour in this part. I understand the FactoryHelper should always return the default objects as we will never be testing it. But I didn't see any other alternative. Can you suggest one if you have one in mind?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544802447", "createdAt": "2020-12-17T04:24:31Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -147,25 +154,47 @@\n     private long epochRangeLowerBound = Layout.INVALID_EPOCH;\n \n     private final ExecutorService executor;\n+    /**\n+     * - {@link SequencerServer::globalLogTail}:\n+     * global log first available position (initially, 0).\n+     */\n+    @Getter\n+    private long globalLogTail;\n \n     private final Optional<Timer> txResolutionTimer;\n \n     private final Optional<DistributionSummary> streamsPerTx;\n+\n     /**\n      * Returns a new SequencerServer.\n      *\n      * @param serverContext context object providing parameters and objects\n      */\n     public SequencerServer(ServerContext serverContext) {\n+        this(serverContext, new FactoryHelper());\n+    }\n+\n+    /**\n+     * Returns a new SequencerServer.\n+     *\n+     * @param serverContext context object providing parameters and objects\n+     * @param factoryHelper FactoryHelper providing utility methods to get various objects in a factory pattern\n+     */\n+    public SequencerServer(ServerContext serverContext, FactoryHelper factoryHelper) {\n         this.serverContext = serverContext;\n+        this.factoryHelper = factoryHelper;\n         Config config = Config.parse(serverContext.getServerConfig());\n \n         // Sequencer server is single threaded by current design\n-        this.executor = Executors.newSingleThreadExecutor(\n-                new ServerThreadFactory(\"sequencer-\", new ServerThreadFactory.ExceptionHandler()));\n+        this.executor = serverContext.getExecutorService(1, \"sequencer-\");\n+\n+        this.globalLogTail = factoryHelper.getGlobalLogTail();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTMyOQ=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1ODU1MA==", "bodyText": "Hmm. Would spying on the SequencerServer work here? There's a getter annotation for the globalLogTail, so you could inject your desired value through this getter method.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r545158550", "createdAt": "2020-12-17T15:03:12Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -147,25 +154,47 @@\n     private long epochRangeLowerBound = Layout.INVALID_EPOCH;\n \n     private final ExecutorService executor;\n+    /**\n+     * - {@link SequencerServer::globalLogTail}:\n+     * global log first available position (initially, 0).\n+     */\n+    @Getter\n+    private long globalLogTail;\n \n     private final Optional<Timer> txResolutionTimer;\n \n     private final Optional<DistributionSummary> streamsPerTx;\n+\n     /**\n      * Returns a new SequencerServer.\n      *\n      * @param serverContext context object providing parameters and objects\n      */\n     public SequencerServer(ServerContext serverContext) {\n+        this(serverContext, new FactoryHelper());\n+    }\n+\n+    /**\n+     * Returns a new SequencerServer.\n+     *\n+     * @param serverContext context object providing parameters and objects\n+     * @param factoryHelper FactoryHelper providing utility methods to get various objects in a factory pattern\n+     */\n+    public SequencerServer(ServerContext serverContext, FactoryHelper factoryHelper) {\n         this.serverContext = serverContext;\n+        this.factoryHelper = factoryHelper;\n         Config config = Config.parse(serverContext.getServerConfig());\n \n         // Sequencer server is single threaded by current design\n-        this.executor = Executors.newSingleThreadExecutor(\n-                new ServerThreadFactory(\"sequencer-\", new ServerThreadFactory.ExceptionHandler()));\n+        this.executor = serverContext.getExecutorService(1, \"sequencer-\");\n+\n+        this.globalLogTail = factoryHelper.getGlobalLogTail();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY1NTMyOQ=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjkwMjc2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo0ODozMlrOIHcldg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDozNToyMFrOIHkTag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY3OTI4Ng==", "bodyText": "Maybe the type can be turned into a boolean: all_streams? This way the else case and the exception can be avoided.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544679286", "createdAt": "2020-12-16T22:48:32Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -617,56 +693,62 @@ private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n         }\n \n         // update the cache of conflict parameters\n-        if (req.getTxnResolution() != null) {\n-            req.getTxnResolution()\n-                    .getWriteConflictParams()\n-                    .forEach((key, value) -> {\n+        if (tokenRequest.hasTxnResolution()) {\n+            tokenRequest.getTxnResolution().getWriteConflictParamsSetList()\n+                    .forEach((item) -> {\n                         // insert an entry with the new timestamp using the\n                         // hash code based on the param and the stream id.\n-                        value.forEach(conflictParam ->\n-                                cache.put(new ConflictTxStream(key, conflictParam, newTail - 1)));\n+                        item.getValueList().forEach(conflictParam ->\n+                                cache.put(new ConflictTxStream(getUUID(item.getKey()),\n+                                        conflictParam.toByteArray(), newTail - 1)));\n                     });\n         }\n \n-        log.trace(\"token {} backpointers {}\", globalLogTail, backPointerMap.build());\n+        log.trace(\"handleAllocation: token={} backpointers={}\", globalLogTail, backPointerMap.build());\n \n         // return the token response with the global tail and the streams backpointers\n-        Token token = new Token(sequencerEpoch, globalLogTail);\n+        Token newToken = new Token(sequencerEpoch, globalLogTail);\n         globalLogTail = newTail;\n-        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(\n-                new TokenResponse(token, backPointerMap.build())));\n+\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(req.getHeader(), getTokenResponseMsg(newToken, backPointerMap.build()));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * This method handles the request of streams addresses.\n-     *\n+     * <p>\n      * The request of address spaces can be of two types:\n-     *      - For specific streams (and specific ranges for each stream).\n-     *      - For all streams (complete range).\n-     *\n+     * - For specific streams (and specific ranges for each stream).\n+     * - For all streams (complete range).\n+     * <p>\n      * The response contains the requested streams address maps and the global log tail.\n      */\n-    @ServerHandler(type = CorfuMsgType.STREAMS_ADDRESS_REQUEST)\n-    private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest> msg,\n-                                             ChannelHandlerContext ctx, IServerRouter r) {\n-        StreamsAddressRequest req = msg.getPayload();\n-        Map<UUID, StreamAddressSpace> streamsAddressMap;\n-\n-        switch (req.getReqType()) {\n-            case StreamsAddressRequest.STREAMS:\n-                streamsAddressMap = getStreamsAddresses(req.getStreamsRanges());\n-                break;\n-\n-            default:\n-                // Retrieve address space for all streams\n-                streamsAddressMap = new HashMap<>(this.streamsAddressMap);\n-                break;\n+    @RequestHandler(type = PayloadCase.STREAMS_ADDRESS_REQUEST)\n+    private void handleStreamsAddressRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        StreamsAddressRequestMsg streamsAddressRequest = req.getPayload().getStreamsAddressRequest();\n+        Map<UUID, StreamAddressSpace> respStreamsAddressMap;\n+\n+        if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.STREAMS) {\n+            respStreamsAddressMap = getStreamsAddressesMap(streamsAddressRequest.getStreamRangeList());\n+        } else if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.ALL_STREAMS) {\n+            // Retrieve address space for all streams\n+            respStreamsAddressMap = new HashMap<>(this.streamsAddressMap);\n+        } else {\n+            throw new IllegalArgumentException(\"handleStreamsAddressRequest: \" +\n+                    \"Received an INVALID type of streamsAddressRequestMsg.\");\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 643}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwNTczOA==", "bodyText": "Can be done but it may not be future proof in this use case, like, what if a new type of stream request comes up other than streams and all_streams? for example, streams meet a certain criteria/behaviour -- active_streams, inactive_streams. The chances are less but there is a possibility. So I didn't bother changing it. I thought that was one reason why it was initially an Enum instead of a boolean value.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544805738", "createdAt": "2020-12-17T04:35:20Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -617,56 +693,62 @@ private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n         }\n \n         // update the cache of conflict parameters\n-        if (req.getTxnResolution() != null) {\n-            req.getTxnResolution()\n-                    .getWriteConflictParams()\n-                    .forEach((key, value) -> {\n+        if (tokenRequest.hasTxnResolution()) {\n+            tokenRequest.getTxnResolution().getWriteConflictParamsSetList()\n+                    .forEach((item) -> {\n                         // insert an entry with the new timestamp using the\n                         // hash code based on the param and the stream id.\n-                        value.forEach(conflictParam ->\n-                                cache.put(new ConflictTxStream(key, conflictParam, newTail - 1)));\n+                        item.getValueList().forEach(conflictParam ->\n+                                cache.put(new ConflictTxStream(getUUID(item.getKey()),\n+                                        conflictParam.toByteArray(), newTail - 1)));\n                     });\n         }\n \n-        log.trace(\"token {} backpointers {}\", globalLogTail, backPointerMap.build());\n+        log.trace(\"handleAllocation: token={} backpointers={}\", globalLogTail, backPointerMap.build());\n \n         // return the token response with the global tail and the streams backpointers\n-        Token token = new Token(sequencerEpoch, globalLogTail);\n+        Token newToken = new Token(sequencerEpoch, globalLogTail);\n         globalLogTail = newTail;\n-        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(\n-                new TokenResponse(token, backPointerMap.build())));\n+\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(req.getHeader(), getTokenResponseMsg(newToken, backPointerMap.build()));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * This method handles the request of streams addresses.\n-     *\n+     * <p>\n      * The request of address spaces can be of two types:\n-     *      - For specific streams (and specific ranges for each stream).\n-     *      - For all streams (complete range).\n-     *\n+     * - For specific streams (and specific ranges for each stream).\n+     * - For all streams (complete range).\n+     * <p>\n      * The response contains the requested streams address maps and the global log tail.\n      */\n-    @ServerHandler(type = CorfuMsgType.STREAMS_ADDRESS_REQUEST)\n-    private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest> msg,\n-                                             ChannelHandlerContext ctx, IServerRouter r) {\n-        StreamsAddressRequest req = msg.getPayload();\n-        Map<UUID, StreamAddressSpace> streamsAddressMap;\n-\n-        switch (req.getReqType()) {\n-            case StreamsAddressRequest.STREAMS:\n-                streamsAddressMap = getStreamsAddresses(req.getStreamsRanges());\n-                break;\n-\n-            default:\n-                // Retrieve address space for all streams\n-                streamsAddressMap = new HashMap<>(this.streamsAddressMap);\n-                break;\n+    @RequestHandler(type = PayloadCase.STREAMS_ADDRESS_REQUEST)\n+    private void handleStreamsAddressRequest(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        StreamsAddressRequestMsg streamsAddressRequest = req.getPayload().getStreamsAddressRequest();\n+        Map<UUID, StreamAddressSpace> respStreamsAddressMap;\n+\n+        if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.STREAMS) {\n+            respStreamsAddressMap = getStreamsAddressesMap(streamsAddressRequest.getStreamRangeList());\n+        } else if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.ALL_STREAMS) {\n+            // Retrieve address space for all streams\n+            respStreamsAddressMap = new HashMap<>(this.streamsAddressMap);\n+        } else {\n+            throw new IllegalArgumentException(\"handleStreamsAddressRequest: \" +\n+                    \"Received an INVALID type of streamsAddressRequestMsg.\");\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY3OTI4Ng=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 643}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjkxMjI5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1MToyM1rOIHcq6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDoyODozN1rOIHkLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4MDY4MA==", "bodyText": "nit: can you consider using a less generic name for this class?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544680680", "createdAt": "2020-12-16T22:51:23Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +790,25 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+    static class FactoryHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 702}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMzcyMw==", "bodyText": "refactored into SequencerFactoryHelper. Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544803723", "createdAt": "2020-12-17T04:28:37Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +790,25 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+    static class FactoryHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4MDY4MA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 702}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjkxODM3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjo1Mjo1NFrOIHcuQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDozODowM1rOIHkWrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4MTUzNw==", "bodyText": "Can remove the public? I think these should only exposed to the package for unit tests.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544681537", "createdAt": "2020-12-16T22:52:54Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +790,25 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+    static class FactoryHelper {\n+        public Map<UUID, StreamAddressSpace> getStreamAddressSpaceMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 703}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwNjU3NQ==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544806575", "createdAt": "2020-12-17T04:38:03Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +790,25 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+    static class FactoryHelper {\n+        public Map<UUID, StreamAddressSpace> getStreamAddressSpaceMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4MTUzNw=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 703}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjk0MzM1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzowMDoxNlrOIHc87g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNToxNjo1NVrOIHlFqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NTI5NA==", "bodyText": "Can these types be removed, along with the wire protocol objects that are no longer needed (like TokenRequest)? For the wire protocol objects that are still needed, we can still remove the implements ICorfuPayload as well as the serialization methods that are no longer needed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544685294", "createdAt": "2020-12-16T23:00:16Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "diffHunk": "@@ -23,49 +23,70 @@\n public enum CorfuMsgType {\n     // Base Messages\n     ACK(4, TypeToken.of(CorfuMsg.class), true, false),\n-    WRONG_EPOCH(5, new TypeToken<CorfuPayloadMsg<Long>>() {},  true, false),\n+    WRONG_EPOCH(5, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }, true, false),\n     NACK(6, TypeToken.of(CorfuMsg.class)),\n     NOT_READY(9, TypeToken.of(CorfuMsg.class), true, false),\n-    WRONG_CLUSTER_ID(28, new TypeToken<CorfuPayloadMsg<WrongClusterMsg>>(){}, true, false),\n+    WRONG_CLUSTER_ID(28, new TypeToken<CorfuPayloadMsg<WrongClusterMsg>>() {\n+    }, true, false),\n \n     // Layout Messages\n-    LAYOUT_REQUEST(10, new TypeToken<CorfuPayloadMsg<Long>>(){}, true, true),\n+    LAYOUT_REQUEST(10, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }, true, true),\n     LAYOUT_RESPONSE(11, TypeToken.of(LayoutMsg.class), true, false),\n-    LAYOUT_PREPARE(12, new TypeToken<CorfuPayloadMsg<LayoutPrepareRequest>>(){}, true, false),\n-    LAYOUT_PREPARE_REJECT(13, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>(){}),\n-    LAYOUT_PROPOSE(14, new TypeToken<CorfuPayloadMsg<LayoutProposeRequest>>(){}, true, false),\n-    LAYOUT_PROPOSE_REJECT(15, new TypeToken<CorfuPayloadMsg<LayoutProposeResponse>>(){}),\n-    LAYOUT_COMMITTED(16, new TypeToken<CorfuPayloadMsg<LayoutCommittedRequest>>(){}, true, false),\n-    LAYOUT_QUERY(17, new TypeToken<CorfuPayloadMsg<Long>>(){}),\n-    LAYOUT_BOOTSTRAP(18, new TypeToken<CorfuPayloadMsg<LayoutBootstrapRequest>>(){}, true, true),\n+    LAYOUT_PREPARE(12, new TypeToken<CorfuPayloadMsg<LayoutPrepareRequest>>() {\n+    }, true, false),\n+    LAYOUT_PREPARE_REJECT(13, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>() {\n+    }),\n+    LAYOUT_PROPOSE(14, new TypeToken<CorfuPayloadMsg<LayoutProposeRequest>>() {\n+    }, true, false),\n+    LAYOUT_PROPOSE_REJECT(15, new TypeToken<CorfuPayloadMsg<LayoutProposeResponse>>() {\n+    }),\n+    LAYOUT_COMMITTED(16, new TypeToken<CorfuPayloadMsg<LayoutCommittedRequest>>() {\n+    }, true, false),\n+    LAYOUT_QUERY(17, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }),\n+    LAYOUT_BOOTSTRAP(18, new TypeToken<CorfuPayloadMsg<LayoutBootstrapRequest>>() {\n+    }, true, true),\n     LAYOUT_NOBOOTSTRAP(19, TypeToken.of(CorfuMsg.class), true, false),\n \n     // Sequencer Messages\n-    TOKEN_REQ(20, new TypeToken<CorfuPayloadMsg<TokenRequest>>(){}),\n-    TOKEN_RES(21, new TypeToken<CorfuPayloadMsg<TokenResponse>>(){}),\n-    BOOTSTRAP_SEQUENCER(22, new TypeToken<CorfuPayloadMsg<SequencerRecoveryMsg>>(){}),\n-    SEQUENCER_TRIM_REQ(23, new TypeToken<CorfuPayloadMsg<Long>>() {}),\n-    SEQUENCER_METRICS_REQUEST(24, TypeToken.of(CorfuMsg.class), true, false),\n-    SEQUENCER_METRICS_RESPONSE(25, new TypeToken<CorfuPayloadMsg<SequencerMetrics>>(){}, true, false),\n-    STREAMS_ADDRESS_REQUEST(26, new TypeToken<CorfuPayloadMsg<StreamsAddressRequest>>(){}),\n-    STREAMS_ADDRESS_RESPONSE(27, new TypeToken<CorfuPayloadMsg<StreamsAddressResponse>>(){}),\n+//    TOKEN_REQ(20, new TypeToken<CorfuPayloadMsg<TokenRequest>>(){}),\n+//    TOKEN_RES(21, new TypeToken<CorfuPayloadMsg<TokenResponse>>(){}),\n+//    BOOTSTRAP_SEQUENCER(22, new TypeToken<CorfuPayloadMsg<SequencerRecoveryMsg>>(){}),\n+//    SEQUENCER_TRIM_REQ(23, new TypeToken<CorfuPayloadMsg<Long>>() {}),\n+//    SEQUENCER_METRICS_REQUEST(24, TypeToken.of(CorfuMsg.class), true, false),\n+//    SEQUENCER_METRICS_RESPONSE(25, new TypeToken<CorfuPayloadMsg<SequencerMetrics>>(){}, true, false),\n+//    STREAMS_ADDRESS_REQUEST(26, new TypeToken<CorfuPayloadMsg<StreamsAddressRequest>>(){}),\n+//    STREAMS_ADDRESS_RESPONSE(27, new TypeToken<CorfuPayloadMsg<StreamsAddressResponse>>(){}),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgxODYwMQ==", "bodyText": "Done, Thank you.\nRemoved the following files.\n- TokenRequest.java\n- SequencerRecoveryMsg.java\n- StreamsAddressRequest.java\n\nRemoved implements ICorfuPayload and serialization and deserialization constructors for the following files. (I couldn't remove them as they were used beyond the RPC layer.)\n- TokenResponse.java\n- SequencerMetrics.java\n- StreamsAddressResponse.java", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544818601", "createdAt": "2020-12-17T05:16:55Z", "author": {"login": "chetangudisagar"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "diffHunk": "@@ -23,49 +23,70 @@\n public enum CorfuMsgType {\n     // Base Messages\n     ACK(4, TypeToken.of(CorfuMsg.class), true, false),\n-    WRONG_EPOCH(5, new TypeToken<CorfuPayloadMsg<Long>>() {},  true, false),\n+    WRONG_EPOCH(5, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }, true, false),\n     NACK(6, TypeToken.of(CorfuMsg.class)),\n     NOT_READY(9, TypeToken.of(CorfuMsg.class), true, false),\n-    WRONG_CLUSTER_ID(28, new TypeToken<CorfuPayloadMsg<WrongClusterMsg>>(){}, true, false),\n+    WRONG_CLUSTER_ID(28, new TypeToken<CorfuPayloadMsg<WrongClusterMsg>>() {\n+    }, true, false),\n \n     // Layout Messages\n-    LAYOUT_REQUEST(10, new TypeToken<CorfuPayloadMsg<Long>>(){}, true, true),\n+    LAYOUT_REQUEST(10, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }, true, true),\n     LAYOUT_RESPONSE(11, TypeToken.of(LayoutMsg.class), true, false),\n-    LAYOUT_PREPARE(12, new TypeToken<CorfuPayloadMsg<LayoutPrepareRequest>>(){}, true, false),\n-    LAYOUT_PREPARE_REJECT(13, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>(){}),\n-    LAYOUT_PROPOSE(14, new TypeToken<CorfuPayloadMsg<LayoutProposeRequest>>(){}, true, false),\n-    LAYOUT_PROPOSE_REJECT(15, new TypeToken<CorfuPayloadMsg<LayoutProposeResponse>>(){}),\n-    LAYOUT_COMMITTED(16, new TypeToken<CorfuPayloadMsg<LayoutCommittedRequest>>(){}, true, false),\n-    LAYOUT_QUERY(17, new TypeToken<CorfuPayloadMsg<Long>>(){}),\n-    LAYOUT_BOOTSTRAP(18, new TypeToken<CorfuPayloadMsg<LayoutBootstrapRequest>>(){}, true, true),\n+    LAYOUT_PREPARE(12, new TypeToken<CorfuPayloadMsg<LayoutPrepareRequest>>() {\n+    }, true, false),\n+    LAYOUT_PREPARE_REJECT(13, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>() {\n+    }),\n+    LAYOUT_PROPOSE(14, new TypeToken<CorfuPayloadMsg<LayoutProposeRequest>>() {\n+    }, true, false),\n+    LAYOUT_PROPOSE_REJECT(15, new TypeToken<CorfuPayloadMsg<LayoutProposeResponse>>() {\n+    }),\n+    LAYOUT_COMMITTED(16, new TypeToken<CorfuPayloadMsg<LayoutCommittedRequest>>() {\n+    }, true, false),\n+    LAYOUT_QUERY(17, new TypeToken<CorfuPayloadMsg<Long>>() {\n+    }),\n+    LAYOUT_BOOTSTRAP(18, new TypeToken<CorfuPayloadMsg<LayoutBootstrapRequest>>() {\n+    }, true, true),\n     LAYOUT_NOBOOTSTRAP(19, TypeToken.of(CorfuMsg.class), true, false),\n \n     // Sequencer Messages\n-    TOKEN_REQ(20, new TypeToken<CorfuPayloadMsg<TokenRequest>>(){}),\n-    TOKEN_RES(21, new TypeToken<CorfuPayloadMsg<TokenResponse>>(){}),\n-    BOOTSTRAP_SEQUENCER(22, new TypeToken<CorfuPayloadMsg<SequencerRecoveryMsg>>(){}),\n-    SEQUENCER_TRIM_REQ(23, new TypeToken<CorfuPayloadMsg<Long>>() {}),\n-    SEQUENCER_METRICS_REQUEST(24, TypeToken.of(CorfuMsg.class), true, false),\n-    SEQUENCER_METRICS_RESPONSE(25, new TypeToken<CorfuPayloadMsg<SequencerMetrics>>(){}, true, false),\n-    STREAMS_ADDRESS_REQUEST(26, new TypeToken<CorfuPayloadMsg<StreamsAddressRequest>>(){}),\n-    STREAMS_ADDRESS_RESPONSE(27, new TypeToken<CorfuPayloadMsg<StreamsAddressResponse>>(){}),\n+//    TOKEN_REQ(20, new TypeToken<CorfuPayloadMsg<TokenRequest>>(){}),\n+//    TOKEN_RES(21, new TypeToken<CorfuPayloadMsg<TokenResponse>>(){}),\n+//    BOOTSTRAP_SEQUENCER(22, new TypeToken<CorfuPayloadMsg<SequencerRecoveryMsg>>(){}),\n+//    SEQUENCER_TRIM_REQ(23, new TypeToken<CorfuPayloadMsg<Long>>() {}),\n+//    SEQUENCER_METRICS_REQUEST(24, TypeToken.of(CorfuMsg.class), true, false),\n+//    SEQUENCER_METRICS_RESPONSE(25, new TypeToken<CorfuPayloadMsg<SequencerMetrics>>(){}, true, false),\n+//    STREAMS_ADDRESS_REQUEST(26, new TypeToken<CorfuPayloadMsg<StreamsAddressRequest>>(){}),\n+//    STREAMS_ADDRESS_RESPONSE(27, new TypeToken<CorfuPayloadMsg<StreamsAddressResponse>>(){}),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NTI5NA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjk2MjIyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzowNjoxOVrOIHdHlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNDo0Njo0MFrOIHkgiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4ODAyMQ==", "bodyText": "Maybe this can become a boolean so that we can just directly return the result? I think this is what's being done in the layout PR.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544688021", "createdAt": "2020-12-16T23:06:19Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +40,95 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg, ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        TokenResponseMsg responseMsg = msg.getPayload().getTokenResponse();\n+\n+        return CorfuProtocolSequencer.getTokenResponse(responseMsg);\n     }\n \n-    @ClientHandler(type = CorfuMsgType.TOKEN_RES)\n-    private static Object handleTokenResponse(CorfuPayloadMsg<TokenResponse> msg,\n-                                              ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a bootstrap sequencer response from the server.\n+     *\n+     * @param msg The bootstrap sequencer response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_SEQUENCER_RESPONSE)\n+    private static Object handleBootstrapSequencerResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                           IClientRouter r) {\n+        BootstrapSequencerResponseMsg responseMsg = msg.getPayload().getBootstrapSequencerResponse();\n+        BootstrapSequencerResponseMsg.Type type = responseMsg.getRespType();\n+\n+        switch (type) {\n+            case ACK:\n+                return true;\n+            case NACK:\n+                return false;\n+            // TODO INVALID\n+            default:\n+                throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwOTA5Nw==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544809097", "createdAt": "2020-12-17T04:46:40Z", "author": {"login": "chetangudisagar"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +40,95 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg, ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        TokenResponseMsg responseMsg = msg.getPayload().getTokenResponse();\n+\n+        return CorfuProtocolSequencer.getTokenResponse(responseMsg);\n     }\n \n-    @ClientHandler(type = CorfuMsgType.TOKEN_RES)\n-    private static Object handleTokenResponse(CorfuPayloadMsg<TokenResponse> msg,\n-                                              ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a bootstrap sequencer response from the server.\n+     *\n+     * @param msg The bootstrap sequencer response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_SEQUENCER_RESPONSE)\n+    private static Object handleBootstrapSequencerResponse(ResponseMsg msg, ChannelHandlerContext ctx,\n+                                                           IClientRouter r) {\n+        BootstrapSequencerResponseMsg responseMsg = msg.getPayload().getBootstrapSequencerResponse();\n+        BootstrapSequencerResponseMsg.Type type = responseMsg.getRespType();\n+\n+        switch (type) {\n+            case ACK:\n+                return true;\n+            case NACK:\n+                return false;\n+            // TODO INVALID\n+            default:\n+                throw new UnsupportedOperationException(\"Response handler not provided\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4ODAyMQ=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjk4MzU0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoxMzoxM1rOIHdToQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoxMzoxM1rOIHdToQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5MTEwNQ==", "bodyText": "The old handler methods can be removed as well.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544691105", "createdAt": "2020-12-16T23:13:13Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -110,12 +122,7 @@\n      * per streams map to last issued global-log position. used for backpointers.\n      */\n     private Map<UUID, Long> streamTailToGlobalTailMap = new HashMap<>();\n-\n-    /**\n-     * Per streams map and their corresponding address space (an address space is defined by the stream's addresses\n-     *  and its latest trim mark)\n-     */\n-    private Map<UUID, StreamAddressSpace> streamsAddressMap = new HashMap<>();\n+    private final FactoryHelper factoryHelper;\n \n     /**\n      * HandlerMethod for this server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjk5NjkyOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoxNzozNlrOIHdbNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNToxNzoyMlrOIHlGVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5MzA0Nw==", "bodyText": "Consider removing the 'Corfu' prefix in order to match the other tests.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544693047", "createdAt": "2020-12-16T23:17:36Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgxODc3Mg==", "bodyText": "Done, thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544818772", "createdAt": "2020-12-17T05:17:22Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5MzA0Nw=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzAxMjA3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoyMjo0MlrOIHdjqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoxMDo1OFrOIHnk1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NTIxMA==", "bodyText": "Is this argument captor necessary? I think calling verify with the expected object should suffice here. In most cases, if you know the result ahead of time, you don't need an argument captor.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544695210", "createdAt": "2020-12-16T23:22:42Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerTrimRequestMsg(trimMark)\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in the previous RPC call.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        // Assert that response has a sequencerTrimResponse object (Note: SequencerTrimResponse will not have any body)\n+        assertTrue(response.getPayload().hasSequencerTrimResponse());\n+        // Verify that sequencerServerCache was invalidated up to the trimMark\n+        ArgumentCaptor<Long> trimMarkCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(cache).invalidateUpTo(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 520}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1OTM1MQ==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544859351", "createdAt": "2020-12-17T07:10:58Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerTrimRequestMsg(trimMark)\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in the previous RPC call.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        // Assert that response has a sequencerTrimResponse object (Note: SequencerTrimResponse will not have any body)\n+        assertTrue(response.getPayload().hasSequencerTrimResponse());\n+        // Verify that sequencerServerCache was invalidated up to the trimMark\n+        ArgumentCaptor<Long> trimMarkCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(cache).invalidateUpTo(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NTIxMA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 520}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzAxNzgyOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoyNDo0MVrOIHdm3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyNTozMFrOIHn9CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NjAzMA==", "bodyText": "Should these be equal to false? That's how the message is sent in the client.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544696030", "createdAt": "2020-12-16T23:24:41Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTU0NA==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544865544", "createdAt": "2020-12-17T07:25:30Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5NjAzMA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 496}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzAzMjY0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzoyOTo0OFrOIHdvBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyNTo0NlrOIHn9iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5ODExOQ==", "bodyText": "Here too. Just verify that trim was called with trimMark.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544698119", "createdAt": "2020-12-16T23:29:48Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerTrimRequestMsg(trimMark)\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in the previous RPC call.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        // Assert that response has a sequencerTrimResponse object (Note: SequencerTrimResponse will not have any body)\n+        assertTrue(response.getPayload().hasSequencerTrimResponse());\n+        // Verify that sequencerServerCache was invalidated up to the trimMark\n+        ArgumentCaptor<Long> trimMarkCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(cache).invalidateUpTo(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);\n+\n+        // Verify that the streamAddressSpace.trim() was called and verify the argument passed\n+        verify(streamAddressSpace).trim(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 524}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTY3Mg==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544865672", "createdAt": "2020-12-17T07:25:46Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);\n+        when(mockFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // The global log tail is set to 0 when sequencer is bootstrapped with the above tailMap\n+        when(mockFactoryHelper.getGlobalLogTail()).thenReturn(globalTail);\n+        when(mockFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\n+        sequencerServer = new SequencerServer(mockServerContext, mockFactoryHelper);\n+\n+        // Send a request with SequencerTrimRequestMsg\n+        long trimMark = 0;\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerTrimRequestMsg(trimMark)\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in the previous RPC call.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        // Assert that response has a sequencerTrimResponse object (Note: SequencerTrimResponse will not have any body)\n+        assertTrue(response.getPayload().hasSequencerTrimResponse());\n+        // Verify that sequencerServerCache was invalidated up to the trimMark\n+        ArgumentCaptor<Long> trimMarkCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(cache).invalidateUpTo(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);\n+\n+        // Verify that the streamAddressSpace.trim() was called and verify the argument passed\n+        verify(streamAddressSpace).trim(trimMarkCaptor.capture());\n+        assertThat(trimMarkCaptor.getValue()).isEqualTo(trimMark);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY5ODExOQ=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 524}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzA1Njg0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMzozODoxMFrOIHd8Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyOToyNFrOIHoD6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMTUxNA==", "bodyText": "I notice that you have some repeated initialization code, such as the initialization of the server, in a handful of tests. Would it be simpler to move such snippets here? This would also help you break the larger tests down into smaller units without having to repeat the initialization work.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544701514", "createdAt": "2020-12-16T23:38:10Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NzMwNw==", "bodyText": "Thanks for pointing it out. I was still in the middle of some changes. I will keep in mind to move the common code here.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544867307", "createdAt": "2020-12-17T07:29:24Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMTUxNA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzEzMTYzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDowNTowN1rOIHelfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNToyODoxNlrOIH7Czw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMjA2MA==", "bodyText": "Why do you have multiple factories? You have already used the spy annotation above.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544712060", "createdAt": "2020-12-17T00:05:07Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 486}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3MTEwNg==", "bodyText": "Good catch.\nwhen(mockSequencerFactoryHelper.getSequencerServerCache(anyInt(), anyLong())).thenReturn(cache);\nThis line was failing with IllegalArgumentException  from SequencerServerCache class (or above levels) with spy one as it was actually invoking the method. Hence, I had to convert it into mock. I didn't want to change any of that code. I even tried some default values(ex - DEFAULT_CACHE_SIZE = 250_000) but to no avail.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544871106", "createdAt": "2020-12-17T07:37:09Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMjA2MA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 486}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE3ODMxOQ==", "bodyText": "I'm not sure I understand where the exception comes from. Something like doReturn(cache).when(mockSequencerFactoryHelper).getSequencerServerCache(anyInt(), anyLong()) should work. Alternatively, maybe we can always use a mock of the factory instead of a spy?\nNote: https://stackoverflow.com/questions/11620103/mockito-trying-to-spy-on-method-is-calling-the-original-method provides a few possible explanations for the issue.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r545178319", "createdAt": "2020-12-17T15:28:16Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getSequencerMetricsRequestMsg()\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a getSequencerMetricsResponseMsg and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasSequencerMetricsResponse());\n+\n+        // Assert that the SequencerMetricsResponseMsg contains SequencerStatus.READY\n+        SequencerMetricsResponseMsg sequencerMetricsResponseMsg = response.getPayload().getSequencerMetricsResponse();\n+        assertTrue(sequencerMetricsResponseMsg.hasSequencerMetrics());\n+        assertThat(sequencerMetricsResponseMsg.getSequencerMetrics().getSequencerStatus())\n+                .isEqualTo(SequencerStatus.READY);\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerTrimRequest() {\n+        // Bootstrap the Sequencer Server with a stream\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tailMaps and create a to BootstrapSequencerRequestMsg\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTail = 1;\n+        // StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+        //         Roaring64NavigableMap.bitmapOf(globalTail));\n+        StreamAddressSpace streamAddressSpace = mock(StreamAddressSpace.class);\n+        tailMap.put(streamA, streamAddressSpace);\n+        long bootstrapMsgEpoch = 1;\n+\n+        SequencerServerCache cache = mock(SequencerServerCache.class);\n+        SequencerServer.FactoryHelper mockFactoryHelper = mock(SequencerServer.FactoryHelper.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMjA2MA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 486}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE1MzI0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxMjozOVrOIHexIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzozNzo0NVrOIHoUVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNTA0Mw==", "bodyText": "Why does these values differ from the ones set when the client sends the message? This seems to be the case in multiple places.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544715043", "createdAt": "2020-12-17T00:12:39Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 446}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3MTUxMA==", "bodyText": "Fixed them. Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544871510", "createdAt": "2020-12-17T07:37:45Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {\n+        // Bootstrap the Sequencer Server with two streams\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n+\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+        long globalTailA = 0;\n+        long globalTailB = 1;\n+        StreamAddressSpace streamAddressSpaceA = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTailA));\n+        StreamAddressSpace streamAddressSpaceB = new StreamAddressSpace(Address.NEVER_READ,\n+                Roaring64NavigableMap.bitmapOf(globalTailB));\n+        tailMap.put(streamA, streamAddressSpaceA);\n+        tailMap.put(streamB, streamAddressSpaceB);\n+        long bootstrapMsgEpoch = 1;\n+\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(tailMap);\n+        // Global log tail is set to 1 when both streams are loaded\n+        when(spyFactoryHelper.getGlobalLogTail()).thenReturn(globalTailB);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+\n+\n+        // Case 1: Send StreamsAddressRequestMsg.STREAMS RPC call\n+        // for streamA with globalTailA as the start point.\n+        // SequencerServer should send streamAddressSpaceA as the response\n+        // Note: StreamAddressRange = (end, start]\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getStreamsAddressRequestMsg(\n+                        Collections.singletonList(new StreamAddressRange(streamA, globalTailA, -1)))\n+        );\n+\n+        // Sequencer epoch was set to bootstrapMsgEpoch in BootstrapSequencerRequestMsg was sent.\n+        when(mockServerContext.getServerEpoch()).thenReturn(bootstrapMsgEpoch);\n+        sequencerServer.setSequencerEpoch(bootstrapMsgEpoch);\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+\n+        ResponseMsg response = responseCaptor.getValue();\n+        List<UuidToStreamAddressSpacePairMsg> streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(1);\n+        StreamAddressSpace responseStreamAddressSpace =\n+                getStreamAddressSpace(streamAddressSpacePairMsgList.get(0).getAddressSpace());\n+\n+        // Verify the values. Note that global tail is of streamB as it was greater than streamA.\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+\n+\n+        // Case 2: Send StreamsAddressRequestMsg.ALL_STREAMS RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getAllStreamsAddressRequestMsg()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter, times(2)).sendResponse(responseCaptor.capture(),\n+                any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        streamAddressSpacePairMsgList =\n+                response.getPayload().getStreamsAddressResponse().getAddressMapList();\n+        Assertions.assertThat(streamAddressSpacePairMsgList.size()).isEqualTo(2);\n+\n+        // We have a list of two items of UUID to StreamAddressSpace\n+        // Assert that each of them has their corresponding values of\n+        // the globalLogTail, trimMark and the streamsAddressMap.\n+        ResponseMsg finalResponse = response;\n+        streamAddressSpacePairMsgList.forEach(uuidToStreamAddressSpacePairMsg ->\n+        {\n+            if (uuidToStreamAddressSpacePairMsg.getStreamUuid().getLsb() == streamA.getLeastSignificantBits() &&\n+                    uuidToStreamAddressSpacePairMsg.getStreamUuid().getMsb() == streamA.getMostSignificantBits()) {\n+                StreamAddressSpace responseStreamAddressSpaceA =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceA.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailA));\n+                assertThat(responseStreamAddressSpaceA.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+            } else {\n+                StreamAddressSpace responseStreamAddressSpaceB =\n+                        getStreamAddressSpace(uuidToStreamAddressSpacePairMsg.getAddressSpace());\n+                assertThat(finalResponse.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTailB);\n+                assertThat(responseStreamAddressSpaceB.getAddressMap())\n+                        .isEqualTo(Roaring64NavigableMap.bitmapOf(globalTailB));\n+                assertThat(responseStreamAddressSpaceB.getTrimMark()).isEqualTo(Address.NEVER_READ);\n+            }\n+        });\n+\n+\n+        // Case 3: Send StreamsAddressRequestMsg.INVALID RPC call.\n+        // SequencerServer should send all streams and their address spaces as the response\n+        request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuMessage.RequestPayloadMsg.newBuilder()\n+                        .setStreamsAddressRequest(Sequencer.StreamsAddressRequestMsg.newBuilder()\n+                                .setReqType(Sequencer.StreamsAddressRequestMsg.Type.INVALID)\n+                                .build())\n+                        .build()\n+        );\n+\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter, times(3)).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        response = responseCaptor.getValue();\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasUnknownError());\n+        // A SerializerException is expected.\n+        ByteString bs = response.getPayload().getServerError().getUnknownError().getThrowable();\n+        try (ObjectInputStream ois = new ObjectInputStream(bs.newInput())) {\n+            Throwable payloadThrowable = (Throwable) ois.readObject();\n+            assertTrue(payloadThrowable instanceof IllegalArgumentException);\n+        } catch (Exception ex) {\n+            fail(\"Missing an IllegalArgumentException from the SequencerServer\");\n+        }\n+    }\n+\n+    /**\n+     * Test that when client sends the SequencerMetricsRequestMsg, the server responds with\n+     * SequencerMetricsResponseMsg with SequencerStatus.READY as its content.\n+     */\n+    @Test\n+    public void sequencerMetricsRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNTA0Mw=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 446}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE2MjcyOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxNjoyNFrOIHe2TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzozODowOVrOIHoVBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjM2NA==", "bodyText": "I don't think this argument captor is needed. See similar comments.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544716364", "createdAt": "2020-12-17T00:16:24Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3MTY4NQ==", "bodyText": "Done, Thank you.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544871685", "createdAt": "2020-12-17T07:38:09Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjM2NA=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE3Mjg2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoxOTo1NlrOIHe7vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzo0NTowMFrOIHoi3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzc1OQ==", "bodyText": "Can we consider breaking up these larger tests into smaller units, instead of testing all the data paths for an RPC in a single unit test?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544717759", "createdAt": "2020-12-17T00:19:56Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NTIyOA==", "bodyText": "They all operate on the same streamsAddressSpaceMap data on the sequencer server. The only difference between each one is the way they fetch the address space data (specific stream vs all stream). The third one is an invalid one. Hence I clubbed them. Splitting would slightly increase the time and space required for tests.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544875228", "createdAt": "2020-12-17T07:45:00Z", "author": {"login": "chetangudisagar"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        false)\n+        );\n+\n+        when(mockServerContext.getServerEpoch()).thenReturn(1L);\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a BootstrapSequencerRequestMsg. If the\n+     * epoch sent by the client is greater than or equal to the current server epoch, and bootstrapWithoutTailsUpdate\n+     * is set as false, a BootstrapSequencerResponseMsg.ACK message should be received.\n+     * <p>\n+     * Further, we request the server with a StreamsAddressRequestMsg and verify that\n+     * the globalLogTail, trimMark and the streamsAddressMap were correctly updated on the server side.\n+     */\n+    @Test\n+    public void testBootStrapSequencer() {\n+        when(spyFactoryHelper.getStreamAddressSpaceMap()).thenReturn(mockStreamAddressSpaceMap);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        UUID streamA = UUID.nameUUIDFromBytes(\"streamA\".getBytes());\n+        // Construct new tails\n+        Map<UUID, StreamAddressSpace> tailMap = new HashMap<>();\n+\n+        long globalTail = 0;\n+        long bootstrapMsgEpoch = 1;\n+        StreamAddressSpace streamAddressSpace = new StreamAddressSpace(Address.NON_ADDRESS,\n+                Roaring64NavigableMap.bitmapOf(globalTail));\n+        tailMap.put(streamA, streamAddressSpace);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        tailMap,\n+                        globalTail,\n+                        bootstrapMsgEpoch,\n+                        false)\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+        // Assert that the payload has a BOOTSTRAP_SEQUENCER_RESPONSE and that the base\n+        // header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.ACK);\n+\n+        // Verify that the mockServerContext.setSequencerEpoch() was called and inspect the argument\n+        ArgumentCaptor<Long> longArgumentCaptor = ArgumentCaptor.forClass(Long.class);\n+        verify(mockServerContext).setSequencerEpoch(longArgumentCaptor.capture());\n+\n+        // Assert that serverContext.setSequencerEpoch() argument is equal to the bootstrapMsgEpoch value\n+        assertThat(longArgumentCaptor.getValue()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that sequencerEpoch value is updated to the bootstrapMsgEpoch value passed in the request\n+        assertThat(sequencerServer.getSequencerEpoch()).isEqualTo(bootstrapMsgEpoch);\n+        // Assert that globalLogTail value is updated to the globalTail value passed in the request\n+        assertThat(sequencerServer.getGlobalLogTail()).isEqualTo(globalTail);\n+        // Assert that epochRangeLowerBound value is updated from its initial value Layout.INVALID_EPOCH\n+        assertThat(sequencerServer.getEpochRangeLowerBound()).isEqualTo(bootstrapMsgEpoch);\n+\n+        ArgumentCaptor<Map<UUID, StreamAddressSpace>> streamAddressSpaceMapCaptor = ArgumentCaptor.forClass(HashMap.class);\n+        verify(mockStreamAddressSpaceMap).clear();\n+        verify(mockStreamAddressSpaceMap).putAll(streamAddressSpaceMapCaptor.capture());\n+        Map<UUID, StreamAddressSpace> capturedStreamAddressSpace = streamAddressSpaceMapCaptor.getValue();\n+        assertThat(capturedStreamAddressSpace.size()).isEqualTo(1);\n+        assertThat(capturedStreamAddressSpace).containsKey(streamA);\n+\n+        StreamAddressSpace responseStreamAddressSpace = capturedStreamAddressSpace.get(streamA);\n+        assertThat(response.getPayload().getStreamsAddressResponse().getLogTail()).isEqualTo(globalTail);\n+        assertThat(responseStreamAddressSpace.getAddressMap()).isEqualTo(Roaring64NavigableMap.bitmapOf(globalTail));\n+        assertThat(responseStreamAddressSpace.getTrimMark()).isEqualTo(Address.NON_ADDRESS);\n+    }\n+\n+    /**\n+     * Test that the SequencerServer correctly handles a StreamsAddressRequestMsg.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.STREAMS then the server should respond with\n+     * the address map of a particular stream requested by the client.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.ALL_STREAMS then the server should respond with\n+     * the address map of all the streams.\n+     * <p>\n+     * If the request type is StreamsAddressRequestMsg.INVALID then the server should throw a new\n+     * {@link IllegalArgumentException}.\n+     */\n+    @Test\n+    public void testStreamAddressRequest() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzc1OQ=="}, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzE4ODkxOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoyNTo0OVrOIHfEcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDoyNTo0OVrOIHfEcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxOTk4Ng==", "bodyText": "Can we also verify that some of the state was not updated? Methods like setSequencerEpoch and others should not have been invoked when the bootstrap request is stale.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544719986", "createdAt": "2020-12-17T00:25:49Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        sequencerServer.setSequencerEpoch(0L);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, true),\n+                CorfuProtocolSequencer.getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg.NACK message\n+        // and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getRespType())\n+                .isEqualTo(Sequencer.BootstrapSequencerResponseMsg.Type.NACK);\n+    }\n+\n+    /**\n+     * Test that stale bootstrap requests are discarded.\n+     * If epoch sent by the client is not greater than the sequencerEpoch then the sequencer should discard the\n+     * BootstrapSequencerRequestMsg, and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testStaleBootstrapRequest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMzIwMzAwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDozMTowMFrOIHfMFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMDozMTowMFrOIHfMFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcyMTk0Mg==", "bodyText": "Same here. Consider also verifying that methods like setSequencerEpoch were not called.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r544721942", "createdAt": "2020-12-17T00:31:00Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/CorfuSequencerServerTest.java", "diffHunk": "@@ -0,0 +1,528 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.service.CorfuProtocolSequencer;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@Slf4j\n+// TODO (Chetan): Remove this after completion\n+@Ignore(\"Still under development.\")\n+public class CorfuSequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+    @Mock\n+    Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+    // Objects that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Spy\n+    private SequencerServer.FactoryHelper spyFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        // When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap messages first.\n+        // ServerContext epoch is set only by the bootstrap request. Make it return the Layout.INVALID_EPOCH.\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+        sequencerServer = new SequencerServer(mockServerContext, spyFactoryHelper);\n+        // Make sequencer\n+        sequencerServer.setSequencerEpoch(0L);\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(true, true),\n+                CorfuProtocolSequencer.getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter).sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate BootstrapSequencerRequestMsg,\n+     * and return a Sequencer.BootstrapSequencerResponseMsg.NACK message.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1750cfb2bd27017b87667099a22fdce54d06dc59"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk1NjI3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNDoxM1rOIIt1YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNDoxM1rOIIt1YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMDQ2NA==", "bodyText": "Are these magic numbers? Will it be better if we replace by local variable?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546010464", "createdAt": "2020-12-18T18:24:13Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -147,35 +147,57 @@\n     private long epochRangeLowerBound = Layout.INVALID_EPOCH;\n \n     private final ExecutorService executor;\n+    /**\n+     * - {@link SequencerServer::globalLogTail}:\n+     * global log first available position (initially, 0).\n+     */\n+    @Getter\n+    private long globalLogTail;\n \n     private final Optional<Timer> txResolutionTimer;\n \n     private final Optional<DistributionSummary> streamsPerTx;\n+\n     /**\n      * Returns a new SequencerServer.\n      *\n      * @param serverContext context object providing parameters and objects\n      */\n     public SequencerServer(ServerContext serverContext) {\n+        this(serverContext, new SequencerFactoryHelper());\n+    }\n+\n+    /**\n+     * Returns a new SequencerServer.\n+     *\n+     * @param serverContext          context object providing parameters and objects\n+     * @param sequencerFactoryHelper FactoryHelper providing utility methods to get various objects\n+     *                               in a factory pattern\n+     */\n+    public SequencerServer(ServerContext serverContext,\n+                           SequencerFactoryHelper sequencerFactoryHelper) {\n         this.serverContext = serverContext;\n+        this.sequencerFactoryHelper = sequencerFactoryHelper;\n         Config config = Config.parse(serverContext.getServerConfig());\n \n         // Sequencer server is single threaded by current design\n-        this.executor = Executors.newSingleThreadExecutor(\n-                new ServerThreadFactory(\"sequencer-\", new ServerThreadFactory.ExceptionHandler()));\n+        this.executor = serverContext.getExecutorService(1, \"sequencer-\");\n+\n+        this.globalLogTail = sequencerFactoryHelper.getGlobalLogTail();\n+        this.cache = sequencerFactoryHelper.getSequencerServerCache(\n+                config.getCacheSize(),\n+                globalLogTail - 1\n+        );\n+        this.streamsAddressMap = sequencerFactoryHelper.getStreamAddressSpaceMap();\n+        this.streamTailToGlobalTailMap = sequencerFactoryHelper.getStreamTailToGlobalTailMap();\n \n-        globalLogTail = Address.getMinAddress();\n-        this.cache = new SequencerServerCache(config.getCacheSize(), globalLogTail - 1);\n         this.txResolutionTimer = MeterRegistryProvider.getInstance().map(registry ->\n                 registry.timer(\"sequencer.tx-resolution.timer\"));\n         this.streamsPerTx = MeterRegistryProvider.getInstance().map(registry ->\n                 DistributionSummary.builder(\"sequencer.tx-resolution.num_streams\")\n-                        .baseUnit(\"stream\").publishPercentiles(0.50, 0.95, 0.99).register(registry));\n-    }\n-\n-    @Override\n-    protected void processRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        executor.submit(() -> getHandler().handle(msg, ctx, r));\n+                        .baseUnit(\"stream\")\n+                        .publishPercentiles(0.50, 0.95, 0.99)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk2NTE4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNjo0NVrOIIt6qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNjo0NVrOIIt6qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTgxNg==", "bodyText": "Can we wrap this with log.isTraceEnabled?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546011816", "createdAt": "2020-12-18T18:26:45Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +476,134 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n-            streamTailToGlobalTailMap = new HashMap<>();\n+            streamTailToGlobalTailMap.clear();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                        streamAddressSpace.getKey(), streamTail);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 455}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTk2NjY1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNzoxMFrOIIt7gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoyNzoxMFrOIIt7gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjAzNQ==", "bodyText": "Can we wrap this with log.isTraceEnabled?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546012035", "createdAt": "2020-12-18T18:27:10Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -617,56 +705,78 @@ private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n         }\n \n         // update the cache of conflict parameters\n-        if (req.getTxnResolution() != null) {\n-            req.getTxnResolution()\n-                    .getWriteConflictParams()\n-                    .forEach((key, value) -> {\n+        if (tokenRequest.hasTxnResolution()) {\n+            tokenRequest.getTxnResolution().getWriteConflictParamsSetList()\n+                    .forEach((item) -> {\n                         // insert an entry with the new timestamp using the\n                         // hash code based on the param and the stream id.\n-                        value.forEach(conflictParam ->\n-                                cache.put(new ConflictTxStream(key, conflictParam, newTail - 1)));\n+                        item.getValueList().forEach(conflictParam ->\n+                                cache.put(new ConflictTxStream(getUUID(item.getKey()),\n+                                        conflictParam.toByteArray(), newTail - 1)));\n                     });\n         }\n \n-        log.trace(\"token {} backpointers {}\", globalLogTail, backPointerMap.build());\n+        log.trace(\"handleAllocation: token={} backpointers={}\",\n+                globalLogTail, backPointerMap.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 728}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjA4NTU1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTowMDoxMVrOIIvDxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTowMTo0MFrOIIvHXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMDUzNA==", "bodyText": "Could we use on-demand import for ResponsePayloadMsg?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546030534", "createdAt": "2020-12-18T19:00:11Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -258,4 +273,50 @@ public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<U\n                         entry -> getStreamAddressSpace(entry.getAddressSpace()))\n                 ));\n     }\n+\n+    /**\n+     * Returns a new {@link CorfuMessage.ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link Sequencer.StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.\n+     *\n+     * @param logTail    the logTail to be set on the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @param epoch    the epoch to be set on the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @param addressMap addressMap of the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @return a new {@link CorfuMessage.ResponsePayloadMsg} Protobuf object\n+     */\n+    public static CorfuMessage.ResponsePayloadMsg getStreamsAddressResponseMsg(\n+            long logTail,\n+            long epoch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ1NQ==", "bodyText": "Same for StreamsAddressResponseMsg", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546031455", "createdAt": "2020-12-18T19:01:40Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -258,4 +273,50 @@ public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<U\n                         entry -> getStreamAddressSpace(entry.getAddressSpace()))\n                 ));\n     }\n+\n+    /**\n+     * Returns a new {@link CorfuMessage.ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link Sequencer.StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.\n+     *\n+     * @param logTail    the logTail to be set on the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @param epoch    the epoch to be set on the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @param addressMap addressMap of the {@link Sequencer.StreamsAddressResponseMsg} object\n+     * @return a new {@link CorfuMessage.ResponsePayloadMsg} Protobuf object\n+     */\n+    public static CorfuMessage.ResponsePayloadMsg getStreamsAddressResponseMsg(\n+            long logTail,\n+            long epoch,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMDUzNA=="}, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjM2MTIzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDoyNDozNVrOIIxraQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDoyNDozNVrOIIxraQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MzQ0OQ==", "bodyText": "nit: Maybe make this a little more formal? like ByteString is Protobuf's immutable ...", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546073449", "createdAt": "2020-12-18T20:24:35Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.TxResolution.TxResolutionInfoMsg;\n+import org.corfudb.runtime.proto.TxResolution.UuidToListOfBytesPairMsg;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in tx_resolution.proto and their Java counterparts. These are used\n+ * by the several RPCs with Sequencer ones being the main one.\n+ */\n+@Slf4j\n+public class CorfuProtocolTxResolution {\n+    /**\n+     * Returns the Protobuf {@link TxResolutionInfoMsg} object from the Java {@link TxResolutionInfo} object.\n+     *\n+     * @param txResolutionInfo the Java {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link TxResolutionInfoMsg} object\n+     */\n+    public static TxResolutionInfoMsg getTxResolutionInfoMsg(TxResolutionInfo txResolutionInfo) {\n+        TxResolutionInfoMsg.Builder txResolutionInfoBuilder = TxResolutionInfoMsg.newBuilder();\n+\n+        txResolutionInfo.getConflictSet().forEach((uuid, bytes) -> {\n+            // Create a List of ByteStrings for each UUID\n+            // ByteString = Protobuf's Immutable sequence of bytes (similar to byte[])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQxNzczOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0NDozM1rOIIyL6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo0NDozM1rOIIyL6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4MTc2OA==", "bodyText": "Maybe place the private helper method at the beginning?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546081768", "createdAt": "2020-12-18T20:44:33Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.TxResolution.TxResolutionInfoMsg;\n+import org.corfudb.runtime.proto.TxResolution.UuidToListOfBytesPairMsg;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in tx_resolution.proto and their Java counterparts. These are used\n+ * by the several RPCs with Sequencer ones being the main one.\n+ */\n+@Slf4j\n+public class CorfuProtocolTxResolution {\n+    /**\n+     * Returns the Protobuf {@link TxResolutionInfoMsg} object from the Java {@link TxResolutionInfo} object.\n+     *\n+     * @param txResolutionInfo the Java {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link TxResolutionInfoMsg} object\n+     */\n+    public static TxResolutionInfoMsg getTxResolutionInfoMsg(TxResolutionInfo txResolutionInfo) {\n+        TxResolutionInfoMsg.Builder txResolutionInfoBuilder = TxResolutionInfoMsg.newBuilder();\n+\n+        txResolutionInfo.getConflictSet().forEach((uuid, bytes) -> {\n+            // Create a List of ByteStrings for each UUID\n+            // ByteString = Protobuf's Immutable sequence of bytes (similar to byte[])\n+            List<ByteString> byteStringList = new ArrayList<>();\n+\n+            // Parse the Set of array of bytes(byte[]) for a UUID and\n+            // create a ByteString for each entry(byte[]) and add to byteStringList\n+            bytes.forEach(b -> byteStringList.add(ByteString.copyFrom(b)));\n+\n+            // Add the newly created entry of UuidToListOfBytesPairMsg\n+            txResolutionInfoBuilder.addConflictSet(\n+                    UuidToListOfBytesPairMsg.newBuilder()\n+                            .setKey(getUuidMsg(uuid))\n+                            .addAllValue(byteStringList)\n+                            .build()\n+            );\n+        });\n+\n+        txResolutionInfo.getWriteConflictParams().forEach((uuid, bytes) -> {\n+            // Create a List of ByteStrings for each UUID\n+            // ByteString = Protobuf's Immutable sequence of bytes (similar to byte[])\n+            List<ByteString> byteStringList = new ArrayList<>();\n+\n+            // Parse the Set of array of bytes(byte[]) for each UUID and\n+            // create a ByteString for each entry(byte[]) and add to byteStringList\n+            bytes.forEach(b -> byteStringList.add(ByteString.copyFrom(b)));\n+\n+            // Add the newly created entry of UuidToListOfBytesPairMsg\n+            txResolutionInfoBuilder.addWriteConflictParamsSet(\n+                    UuidToListOfBytesPairMsg.newBuilder()\n+                            .setKey(getUuidMsg(uuid))\n+                            .addAllValue(byteStringList)\n+                            .build()\n+            );\n+        });\n+\n+        return txResolutionInfoBuilder.setTxId(getUuidMsg(txResolutionInfo.getTXid()))\n+                .setSnapshotTimestamp(getTokenMsg(txResolutionInfo.getSnapshotTimestamp()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Java conflicts Map of UUID to a set of bytes array from the list of Protobuf\n+     * {@link UuidToListOfBytesPairMsg} objects.\n+     *\n+     * @param conflicts the list of Protobuf {@link UuidToListOfBytesPairMsg} objects\n+     * @return the Java conflicts Map of UUID to a set of bytes array\n+     */\n+    private static Map<UUID, Set<byte[]>> getConflictsMap(List<UuidToListOfBytesPairMsg> conflicts) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQ1MjE0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Njo1OVrOIIyf_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Njo1OVrOIIyf_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4NjkwOQ==", "bodyText": "Please complete this java doc :)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546086909", "createdAt": "2020-12-18T20:56:59Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getSequencerMetricsMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpaceMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.getTxResolutionInfoMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined in sequencer.proto.\n+ * These provide the interface for obtaining the Protobuf and the Java representations of the\n+ * following RequestMsg RPCs and their ResponseMsg counterparts -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * These methods are used by both the client and the server.\n+ */\n+@Slf4j\n+public class CorfuProtocolSequencer {\n+    // It stored the EnumBiMap of the Java and Protobuf TokenTypes for efficient conversions.\n+    private static final EnumBiMap<TokenType, TokenResponseMsg.TokenType> tokenResponseTypeMap =\n+            EnumBiMap.create(ImmutableMap.of(\n+                    TokenType.NORMAL, TokenResponseMsg.TokenType.TX_NORMAL,\n+                    TokenType.TX_ABORT_CONFLICT, TokenResponseMsg.TokenType.TX_ABORT_CONFLICT,\n+                    TokenType.TX_ABORT_NEWSEQ, TokenResponseMsg.TokenType.TX_ABORT_NEWSEQ,\n+\n+                    TokenType.TX_ABORT_SEQ_OVERFLOW,\n+                    TokenResponseMsg.TokenType.TX_ABORT_SEQ_OVERFLOW,\n+\n+                    TokenType.TX_ABORT_SEQ_TRIM, TokenResponseMsg.TokenType.TX_ABORT_SEQ_TRIM)\n+            );\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param numTokens    the number of tokens\n+     * @param streams      a list of streams of Java UUID type\n+     * @param conflictInfo a {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams,\n+                                                       TxResolutionInfo conflictInfo) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(TokenRequestMsg.newBuilder()\n+                        .setRequestType(TokenRequestType.TK_TX)\n+                        .setNumTokens(numTokens)\n+                        .setTxnResolution(getTxResolutionInfoMsg(conflictInfo))\n+                        .addAllStreams(streams.stream()\n+                                .map(CorfuProtocolCommon::getUuidMsg)\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     * <p>\n+     * The type of the {@link TokenRequestType} depends on the parameters passed.\n+     * - If numTokens is 0, then the type is TK_QUERY.\n+     * - Else if steams is null or empty, then the type is TK_RAW.\n+     * - Otherwise, the type is TK_MULTI_STREAM.\n+     *\n+     * @param numTokens the number of tokens\n+     * @param streams   a list of streams to be included in the {@link TokenRequestMsg}\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams) {\n+        TokenRequestMsg.Builder tokenRequestBuilder = TokenRequestMsg.newBuilder();\n+        tokenRequestBuilder.setNumTokens(numTokens);\n+\n+        if (numTokens == 0) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_QUERY);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        } else if (streams == null || streams.isEmpty()) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_RAW);\n+        } else {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_MULTI_STREAM);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        }\n+\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(tokenRequestBuilder.build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param type           the {@link TokenType} of the response object.\n+     * @param conflictKey    an array of bytes representing the conflictKey\n+     * @param conflictStream the Java UUID representing the conflictStream\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @param streamTails\n+     * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjQ1NDA5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Nzo0OVrOIIyhMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMDo1Nzo0OVrOIIyhMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA4NzIxOQ==", "bodyText": "Same here", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546087219", "createdAt": "2020-12-18T20:57:49Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getSequencerMetricsMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpaceMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.getTxResolutionInfoMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined in sequencer.proto.\n+ * These provide the interface for obtaining the Protobuf and the Java representations of the\n+ * following RequestMsg RPCs and their ResponseMsg counterparts -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * These methods are used by both the client and the server.\n+ */\n+@Slf4j\n+public class CorfuProtocolSequencer {\n+    // It stored the EnumBiMap of the Java and Protobuf TokenTypes for efficient conversions.\n+    private static final EnumBiMap<TokenType, TokenResponseMsg.TokenType> tokenResponseTypeMap =\n+            EnumBiMap.create(ImmutableMap.of(\n+                    TokenType.NORMAL, TokenResponseMsg.TokenType.TX_NORMAL,\n+                    TokenType.TX_ABORT_CONFLICT, TokenResponseMsg.TokenType.TX_ABORT_CONFLICT,\n+                    TokenType.TX_ABORT_NEWSEQ, TokenResponseMsg.TokenType.TX_ABORT_NEWSEQ,\n+\n+                    TokenType.TX_ABORT_SEQ_OVERFLOW,\n+                    TokenResponseMsg.TokenType.TX_ABORT_SEQ_OVERFLOW,\n+\n+                    TokenType.TX_ABORT_SEQ_TRIM, TokenResponseMsg.TokenType.TX_ABORT_SEQ_TRIM)\n+            );\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param numTokens    the number of tokens\n+     * @param streams      a list of streams of Java UUID type\n+     * @param conflictInfo a {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams,\n+                                                       TxResolutionInfo conflictInfo) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(TokenRequestMsg.newBuilder()\n+                        .setRequestType(TokenRequestType.TK_TX)\n+                        .setNumTokens(numTokens)\n+                        .setTxnResolution(getTxResolutionInfoMsg(conflictInfo))\n+                        .addAllStreams(streams.stream()\n+                                .map(CorfuProtocolCommon::getUuidMsg)\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     * <p>\n+     * The type of the {@link TokenRequestType} depends on the parameters passed.\n+     * - If numTokens is 0, then the type is TK_QUERY.\n+     * - Else if steams is null or empty, then the type is TK_RAW.\n+     * - Otherwise, the type is TK_MULTI_STREAM.\n+     *\n+     * @param numTokens the number of tokens\n+     * @param streams   a list of streams to be included in the {@link TokenRequestMsg}\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams) {\n+        TokenRequestMsg.Builder tokenRequestBuilder = TokenRequestMsg.newBuilder();\n+        tokenRequestBuilder.setNumTokens(numTokens);\n+\n+        if (numTokens == 0) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_QUERY);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        } else if (streams == null || streams.isEmpty()) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_RAW);\n+        } else {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_MULTI_STREAM);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        }\n+\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(tokenRequestBuilder.build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param type           the {@link TokenType} of the response object.\n+     * @param conflictKey    an array of bytes representing the conflictKey\n+     * @param conflictStream the Java UUID representing the conflictStream\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @param streamTails\n+     * @return\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(TokenType type,\n+                                                         byte[] conflictKey,\n+                                                         UUID conflictStream,\n+                                                         Token token,\n+                                                         Map<UUID, Long> backPointerMap,\n+                                                         Map<UUID, Long> streamTails) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setTokenResponse(TokenResponseMsg.newBuilder()\n+                        .setRespType(tokenResponseTypeMap.get(type))\n+                        .setConflictKey(ByteString.copyFrom(conflictKey))\n+                        .setConflictStream(getUuidMsg(conflictStream))\n+                        .setToken(getTokenMsg(token))\n+                        .addAllBackpointerMap(backPointerMap.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .addAllStreamTails(streamTails.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @return\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(Token token,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjUxMjkzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMToyMDoxNVrOIIzD0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMToyMDoxNVrOIIzD0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA5NjA4Mg==", "bodyText": "Add @nonnull annotation for the request handler methods could improve code inspection for inferring nullity\ufeff. Please check this comment\n#2827 (comment)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546096082", "createdAt": "2020-12-18T21:20:15Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -342,72 +367,104 @@ private void handleTokenQuery(CorfuPayloadMsg<TokenRequest> msg,\n             token = new Token(sequencerEpoch, globalLogTail - 1);\n             streamTails = new HashMap<>(streams.size());\n             for (UUID stream : streams) {\n-                streamTails.put(stream, streamTailToGlobalTailMap.getOrDefault(stream, Address.NON_EXIST));\n+                streamTails.put(stream,\n+                        streamTailToGlobalTailMap.getOrDefault(stream, Address.NON_EXIST));\n             }\n         }\n \n-        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(\n-                TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY,\n-                TokenResponse.NO_CONFLICT_STREAM, token, Collections.emptyMap(), streamTails)));\n-\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(\n+                req.getHeader(),\n+                getTokenResponseMsg(TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM,\n+                        token,\n+                        Collections.emptyMap(),\n+                        streamTails)\n+        );\n+\n+        r.sendResponse(response, ctx);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.SEQUENCER_TRIM_REQ)\n-    public void trimCache(CorfuPayloadMsg<Long> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    @RequestHandler(type = PayloadCase.SEQUENCER_TRIM_REQUEST)\n+    public void trimCache(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n         log.info(\"trimCache: Starting cache eviction\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e003000215a23af4ff4d641299e778e7378e1a"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODU0MTI0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMDozMzozOVrOIJlJbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzoyNDoyNVrOIJtCdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxNjcxOQ==", "bodyText": "Please use standard formating here: wrap the return statement with curly brackets in new lines (as it used to be).", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546916719", "createdAt": "2020-12-21T20:33:39Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,21 @@ public void shutdown() {\n     }\n \n     @Override\n-    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n-            return false;\n-        }\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n+        if (getState() != ServerState.READY) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NjAwNg==", "bodyText": "Added, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547046006", "createdAt": "2020-12-22T03:24:25Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,21 @@ public void shutdown() {\n     }\n \n     @Override\n-    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n-            return false;\n-        }\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n+        if (getState() != ServerState.READY) return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxNjcxOQ=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODg1Mzg4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjozNDo1MlrOIJn_JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjo1OToxMlrOIOqoLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MzIzNw==", "bodyText": "Maybe it's better to create a new map as it was and let GC collect it instead of clearing which probably takes more time because clear() needs GC + remove.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546963237", "createdAt": "2020-12-21T22:34:52Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +492,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n-            streamTailToGlobalTailMap = new HashMap<>();\n+            streamTailToGlobalTailMap.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0OTM4OQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552249389", "createdAt": "2021-01-05T22:59:12Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +492,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n-            streamTailToGlobalTailMap = new HashMap<>();\n+            streamTailToGlobalTailMap.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MzIzNw=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODg1NDI1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjozNTowNlrOIJn_Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjo1OToxOVrOIOqoXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MzI5NA==", "bodyText": "Same comment as above", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546963294", "createdAt": "2020-12-21T22:35:06Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +492,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n-            streamTailToGlobalTailMap = new HashMap<>();\n+            streamTailToGlobalTailMap.clear();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n+            this.streamsAddressMap.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 485}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0OTQzNw==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552249437", "createdAt": "2021-01-05T22:59:19Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +492,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n-            streamTailToGlobalTailMap = new HashMap<>();\n+            streamTailToGlobalTailMap.clear();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n+            this.streamsAddressMap.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MzI5NA=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 485}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODg2OTI2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjo0MTo0M1rOIJoH9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzoyNDoxNVrOIJtCUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQ5NQ==", "bodyText": "Could you create a variable UUID streamId = getUUID(id) at the start of the for loop\uff1f Beucase line 715 in this loop is also calling getUUID(id), we can avoid doing extra work by creating a variable first.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546965495", "createdAt": "2020-12-21T22:41:43Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -538,62 +638,69 @@ private void handleRawToken(CorfuPayloadMsg<TokenRequest> msg, ChannelHandlerCon\n      * - if the transaction may commit,\n      * then a normal allocation of log position(s) is pursued.\n      *\n-     * @param msg corfu message containing transaction token\n+     * @param req corfu message containing transaction token\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    private void handleTxToken(CorfuPayloadMsg<TokenRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        final TokenRequest req = msg.getPayload();\n+    private void handleTxToken(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final TokenRequestMsg tokenRequest = req.getPayload().getTokenRequest();\n \n         // in the TK_TX request type, the sequencer is utilized for transaction conflict-resolution.\n         // Token allocation is conditioned on commit.\n         // First, we check if the transaction can commit.\n-        Supplier<TxResolutionResponse> txResponseSupplier = () -> txnCanCommit(req.getTxnResolution());\n-        TxResolutionResponse txResolutionResponse = txResolutionTimer.map(timer -> timer.record(txResponseSupplier))\n-                .orElseGet(() -> txResponseSupplier.get());\n+        Supplier<TxResolutionResponse> txResponseSupplier =\n+                () -> txnCanCommit(getTxResolutionInfo(tokenRequest.getTxnResolution()));\n+        TxResolutionResponse txResolutionResponse =\n+                txResolutionTimer.map(timer -> timer.record(txResponseSupplier))\n+                        .orElseGet(txResponseSupplier);\n+\n         if (txResolutionResponse.getTokenType() != TokenType.NORMAL) {\n             // If the txn aborts, then DO NOT hand out a token.\n             Token newToken = new Token(sequencerEpoch, txResolutionResponse.getAddress());\n-            r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(\n+\n+            // Note: we reuse the request header as the ignore_cluster_id and\n+            // ignore_epoch fields are the same in both cases.\n+            ResponseMsg response = getResponseMsg(req.getHeader(), getTokenResponseMsg(\n                     txResolutionResponse.getTokenType(),\n                     txResolutionResponse.getConflictingKey(),\n                     txResolutionResponse.getConflictingStream(),\n-                    newToken, Collections.emptyMap(), Collections.emptyMap())));\n+                    newToken, Collections.emptyMap(), Collections.emptyMap()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n         // if we get here, this means the transaction can commit.\n         // handleAllocation() does the actual allocation of log position(s)\n         // and returns the response\n-        handleAllocation(msg, ctx, r);\n+        handleAllocation(req, ctx, r);\n     }\n \n     /**\n      * this method does the actual allocation of log addresses,\n      * it also maintains stream-tails, returns a map of stream-tails for backpointers,\n      * and maintains a conflict-parameters map.\n      *\n-     * @param msg corfu message containing allocation\n+     * @param req corfu message containing allocation\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n-                                  ChannelHandlerContext ctx, IServerRouter r) {\n-        final TokenRequest req = msg.getPayload();\n+    private void handleAllocation(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final TokenRequestMsg tokenRequest = req.getPayload().getTokenRequest();\n \n         // extend the tail of the global log by the requested # of tokens\n         // currentTail is the first available position in the global log\n-        long newTail = globalLogTail + req.getNumTokens();\n+        long newTail = globalLogTail + tokenRequest.getNumTokens();\n \n         // for each stream:\n         //   1. obtain the last back-pointer for this stream, if exists; -1L otherwise.\n         //   2. record the new global tail as back-pointer for this stream.\n         //   3. Add the allocated addresses to each stream's address map.\n         ImmutableMap.Builder<UUID, Long> backPointerMap = ImmutableMap.builder();\n-        for (UUID id : req.getStreams()) {\n+        for (UuidMsg id : tokenRequest.getStreamsList()) {\n \n             // step 1. and 2. (comment above)\n-            streamTailToGlobalTailMap.compute(id, (k, v) -> {\n+            streamTailToGlobalTailMap.compute(getUUID(id), (k, v) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 712}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NTk3MA==", "bodyText": "Added, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547045970", "createdAt": "2020-12-22T03:24:15Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -538,62 +638,69 @@ private void handleRawToken(CorfuPayloadMsg<TokenRequest> msg, ChannelHandlerCon\n      * - if the transaction may commit,\n      * then a normal allocation of log position(s) is pursued.\n      *\n-     * @param msg corfu message containing transaction token\n+     * @param req corfu message containing transaction token\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    private void handleTxToken(CorfuPayloadMsg<TokenRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        final TokenRequest req = msg.getPayload();\n+    private void handleTxToken(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final TokenRequestMsg tokenRequest = req.getPayload().getTokenRequest();\n \n         // in the TK_TX request type, the sequencer is utilized for transaction conflict-resolution.\n         // Token allocation is conditioned on commit.\n         // First, we check if the transaction can commit.\n-        Supplier<TxResolutionResponse> txResponseSupplier = () -> txnCanCommit(req.getTxnResolution());\n-        TxResolutionResponse txResolutionResponse = txResolutionTimer.map(timer -> timer.record(txResponseSupplier))\n-                .orElseGet(() -> txResponseSupplier.get());\n+        Supplier<TxResolutionResponse> txResponseSupplier =\n+                () -> txnCanCommit(getTxResolutionInfo(tokenRequest.getTxnResolution()));\n+        TxResolutionResponse txResolutionResponse =\n+                txResolutionTimer.map(timer -> timer.record(txResponseSupplier))\n+                        .orElseGet(txResponseSupplier);\n+\n         if (txResolutionResponse.getTokenType() != TokenType.NORMAL) {\n             // If the txn aborts, then DO NOT hand out a token.\n             Token newToken = new Token(sequencerEpoch, txResolutionResponse.getAddress());\n-            r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(new TokenResponse(\n+\n+            // Note: we reuse the request header as the ignore_cluster_id and\n+            // ignore_epoch fields are the same in both cases.\n+            ResponseMsg response = getResponseMsg(req.getHeader(), getTokenResponseMsg(\n                     txResolutionResponse.getTokenType(),\n                     txResolutionResponse.getConflictingKey(),\n                     txResolutionResponse.getConflictingStream(),\n-                    newToken, Collections.emptyMap(), Collections.emptyMap())));\n+                    newToken, Collections.emptyMap(), Collections.emptyMap()));\n+\n+            r.sendResponse(response, ctx);\n             return;\n         }\n \n         // if we get here, this means the transaction can commit.\n         // handleAllocation() does the actual allocation of log position(s)\n         // and returns the response\n-        handleAllocation(msg, ctx, r);\n+        handleAllocation(req, ctx, r);\n     }\n \n     /**\n      * this method does the actual allocation of log addresses,\n      * it also maintains stream-tails, returns a map of stream-tails for backpointers,\n      * and maintains a conflict-parameters map.\n      *\n-     * @param msg corfu message containing allocation\n+     * @param req corfu message containing allocation\n      * @param ctx netty ChannelHandlerContext\n      * @param r   server router\n      */\n-    private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n-                                  ChannelHandlerContext ctx, IServerRouter r) {\n-        final TokenRequest req = msg.getPayload();\n+    private void handleAllocation(RequestMsg req, ChannelHandlerContext ctx, IServerRouter r) {\n+        final TokenRequestMsg tokenRequest = req.getPayload().getTokenRequest();\n \n         // extend the tail of the global log by the requested # of tokens\n         // currentTail is the first available position in the global log\n-        long newTail = globalLogTail + req.getNumTokens();\n+        long newTail = globalLogTail + tokenRequest.getNumTokens();\n \n         // for each stream:\n         //   1. obtain the last back-pointer for this stream, if exists; -1L otherwise.\n         //   2. record the new global tail as back-pointer for this stream.\n         //   3. Add the allocated addresses to each stream's address map.\n         ImmutableMap.Builder<UUID, Long> backPointerMap = ImmutableMap.builder();\n-        for (UUID id : req.getStreams()) {\n+        for (UuidMsg id : tokenRequest.getStreamsList()) {\n \n             // step 1. and 2. (comment above)\n-            streamTailToGlobalTailMap.compute(id, (k, v) -> {\n+            streamTailToGlobalTailMap.compute(getUUID(id), (k, v) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQ5NQ=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 712}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODg4ODYzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjo0OTo0NlrOIJoS3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzozMzozOVrOIJtK1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2ODI4NA==", "bodyText": "There is already a SequencerServerTest in test package, can you either combine them into one file or rename one of them?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r546968284", "createdAt": "2020-12-21T22:49:46Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,898 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0ODE0OQ==", "bodyText": "Hmm, I thought it was Maithem's suggestion to keep this name (we originally name them like CorfuSequencerServerTest, etc). They might not be able to be combined since these two test sets have quite different setup, and we intended to replace the old ones with the new Mockito unit tests later. Maybe @zfrenette and @Maithem could add more detail on this?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547048149", "createdAt": "2020-12-22T03:33:39Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,898 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2ODI4NA=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTI2NDExOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMTo1NjozMVrOIJrpqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzoyNDowMlrOIJtCHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAyMzI3NA==", "bodyText": "NIT: fix the indent here to align with other @param lines.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547023274", "createdAt": "2020-12-22T01:56:31Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -243,19 +256,48 @@ public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange\n     }\n \n     /**\n-     * Returns a StreamAddressResponse object from its log tail and List\n-     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n-     * represented in Protobuf.\n+     * Returns a new {@link ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.\n      *\n-     * @param tail   the log tail\n-     * @param map    a list of address map entries represented in Protobuf\n-     * @return       an equivalent StreamsAddressResponse object\n+     * @param logTail    the logTail to be set on the {@link StreamsAddressResponseMsg} object\n+     * @param epoch    the epoch to be set on the {@link StreamsAddressResponseMsg} object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NTkxNw==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547045917", "createdAt": "2020-12-22T03:24:02Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -243,19 +256,48 @@ public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange\n     }\n \n     /**\n-     * Returns a StreamAddressResponse object from its log tail and List\n-     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n-     * represented in Protobuf.\n+     * Returns a new {@link ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.\n      *\n-     * @param tail   the log tail\n-     * @param map    a list of address map entries represented in Protobuf\n-     * @return       an equivalent StreamsAddressResponse object\n+     * @param logTail    the logTail to be set on the {@link StreamsAddressResponseMsg} object\n+     * @param epoch    the epoch to be set on the {@link StreamsAddressResponseMsg} object", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAyMzI3NA=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTI4NDYzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjowNzozOFrOIJr1hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzoxNzowN1rOIJs7nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAyNjMwOA==", "bodyText": "Where are these two msg types used? Looks like these are accidently added.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547026308", "createdAt": "2020-12-22T02:07:38Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "diffHunk": "@@ -70,6 +60,8 @@\n     ERROR_VALUE_ADOPTED(59,new TypeToken<CorfuPayloadMsg<ReadResponse>>() {}),\n \n     // EXTRA CODES\n+    LAYOUT_ALREADY_BOOTSTRAP(60, TypeToken.of(CorfuMsg.class), true, false),\n+    LAYOUT_PREPARE_ACK(61, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>(){}, true, false),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NDI1NQ==", "bodyText": "Yeah these two msg types were removed in the PR for Layout PRC, they might be accidentally added when solving the conflicts.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547044255", "createdAt": "2020-12-22T03:17:07Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/CorfuMsgType.java", "diffHunk": "@@ -70,6 +60,8 @@\n     ERROR_VALUE_ADOPTED(59,new TypeToken<CorfuPayloadMsg<ReadResponse>>() {}),\n \n     // EXTRA CODES\n+    LAYOUT_ALREADY_BOOTSTRAP(60, TypeToken.of(CorfuMsg.class), true, false),\n+    LAYOUT_PREPARE_ACK(61, new TypeToken<CorfuPayloadMsg<LayoutPrepareResponse>>(){}, true, false),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAyNjMwOA=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTM3NjIzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjo1ODoxN1rOIJsp9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMzo1MDozMlrOIJtaNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzOTczMw==", "bodyText": "Typo: linktestSequencerChangeDuringAutoCommit -> testSequencerChangeDuringAutoCommit", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547039733", "createdAt": "2020-12-22T02:58:17Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -33,6 +33,9 @@ public StreamsAddressResponse(long logTail, Map<UUID, StreamAddressSpace> stream\n     /**\n      * Deserialization Constructor from Bytebuf to StreamsAddressResponse.\n      *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.linktestSequencerChangeDuringAutoCommit() test case}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MjA4NQ==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547052085", "createdAt": "2020-12-22T03:50:32Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -33,6 +33,9 @@ public StreamsAddressResponse(long logTail, Map<UUID, StreamAddressSpace> stream\n     /**\n      * Deserialization Constructor from Bytebuf to StreamsAddressResponse.\n      *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.linktestSequencerChangeDuringAutoCommit() test case}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzOTczMw=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzOTM3NjYxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjo1ODozNlrOIJsqMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxOToxNzo0M1rOIKw3Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzOTc5Mw==", "bodyText": "This class inherits from ICorfuPayload so it requires this constructor, but I think with your change this class should no longer inherit from ICorfuPayload and this constructor can be removed.But I don't know why currently it's still inheriting from ICorfuPayload?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r547039793", "createdAt": "2020-12-22T02:58:36Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -33,6 +33,9 @@ public StreamsAddressResponse(long logTail, Map<UUID, StreamAddressSpace> stream\n     /**\n      * Deserialization Constructor from Bytebuf to StreamsAddressResponse.\n      *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.linktestSequencerChangeDuringAutoCommit() test case}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1MTc0Mg==", "bodyText": "I tried to remove the inheritance and the testSequencerChangeDuringAutoCommit failed as stated in the javadoc. Could you share what you found about this? @chetangudisagar", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r548151742", "createdAt": "2020-12-23T19:09:50Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -33,6 +33,9 @@ public StreamsAddressResponse(long logTail, Map<UUID, StreamAddressSpace> stream\n     /**\n      * Deserialization Constructor from Bytebuf to StreamsAddressResponse.\n      *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.linktestSequencerChangeDuringAutoCommit() test case}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzOTc5Mw=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE1NzI1OQ==", "bodyText": "This is also used by the LogUnitServer (i.e. LOG_ADDRESS_SPACE), so it cannot be removed until both servers are running on Protobuf.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r548157259", "createdAt": "2020-12-23T19:17:43Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -33,6 +33,9 @@ public StreamsAddressResponse(long logTail, Map<UUID, StreamAddressSpace> stream\n     /**\n      * Deserialization Constructor from Bytebuf to StreamsAddressResponse.\n      *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.linktestSequencerChangeDuringAutoCommit() test case}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzOTc5Mw=="}, "originalCommit": {"oid": "e62d6aea45d9b4da3bf5a586805398c81f516b38"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTA0NDU4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOToxNTowNlrOIOj3YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0OTozM1rOIPUF_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzODU5Mw==", "bodyText": "nit: Can we clarify this note? It seems to suggest that there is something unique about this test case, but the error occurs simply because the LogUnitServer also needs to serialize a StreamsAddressResponse. These methods can be removed once both of the servers are using Protobuf.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552138593", "createdAt": "2021-01-05T19:15:06Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -41,6 +44,14 @@ public StreamsAddressResponse(ByteBuf buf) {\n         this.addressMap = ICorfuPayload.mapFromBuffer(buf, UUID.class, StreamAddressSpace.class);\n     }\n \n+    /**\n+     * Serialize a the object and append to the {@link ByteBuf}  parameter passed.\n+     *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.testSequencerChangeDuringAutoCommit() test case\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODc2NQ==", "bodyText": "Added, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552928765", "createdAt": "2021-01-06T19:49:33Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/StreamsAddressResponse.java", "diffHunk": "@@ -41,6 +44,14 @@ public StreamsAddressResponse(ByteBuf buf) {\n         this.addressMap = ICorfuPayload.mapFromBuffer(buf, UUID.class, StreamAddressSpace.class);\n     }\n \n+    /**\n+     * Serialize a the object and append to the {@link ByteBuf}  parameter passed.\n+     *\n+     * Note: Removing this method fails the\n+     * AutoCommitServiceTest.testSequencerChangeDuringAutoCommit() test case\n+     *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEzODU5Mw=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTExMTgxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOTozNDowN1rOIOkgEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDowM1rOIPRt4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0OTAxMQ==", "bodyText": "CorfuMessage.ResponseMsg can just be replaced by ResponseMsg, and the corresponding import can be removed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552149011", "createdAt": "2021-01-05T19:34:07Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +41,89 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4OTgyNw==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552889827", "createdAt": "2021-01-06T18:30:03Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +41,89 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0OTAxMQ=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTEyNzQzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOTozODo1NVrOIOkptw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDoxOVrOIPRuZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MTQ3OQ==", "bodyText": "nit: This can be simplified a little by removing the local variable.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552151479", "createdAt": "2021-01-05T19:38:55Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +41,89 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg,\n+                                              ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        TokenResponseMsg responseMsg = msg.getPayload().getTokenResponse();\n+\n+        return getTokenResponse(responseMsg);\n+    }\n+\n+    /**\n+     * Handle a bootstrap sequencer response from the server.\n+     *\n+     * @param msg The bootstrap sequencer response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_SEQUENCER_RESPONSE)\n+    private static Object handleBootstrapSequencerResponse(ResponseMsg msg,\n+                                                           ChannelHandlerContext ctx,\n+                                                           IClientRouter r) {\n+        BootstrapSequencerResponseMsg responseMsg =\n+                msg.getPayload().getBootstrapSequencerResponse();\n+        return responseMsg.getIsBootstrapped();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4OTk1Nw==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552889957", "createdAt": "2021-01-06T18:30:19Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerHandler.java", "diffHunk": "@@ -37,33 +41,89 @@ public SequencerClient getClient(long epoch, UUID clusterID) {\n      * The handler and handlers which implement this client.\n      */\n     @Getter\n-    public ClientMsgHandler msgHandler = new ClientMsgHandler(this)\n-            .generateHandlers(MethodHandles.lookup(), this);\n-\n-    /**\n-     * For old CorfuMsg, use {@link #msgHandler}\n-     * The handler and handlers which implement this client.\n-     */\n-    @Getter\n     public ClientResponseHandler responseHandler = new ClientResponseHandler(this)\n             .generateHandlers(MethodHandles.lookup(), this)\n             .generateErrorHandlers(MethodHandles.lookup(), this);\n \n-    @ClientHandler(type = CorfuMsgType.SEQUENCER_METRICS_RESPONSE)\n-    private static Object handleMetricsResponse(CorfuPayloadMsg<SequencerMetrics> msg,\n-                                                ChannelHandlerContext ctx, IClientRouter r) {\n-        return msg.getPayload();\n+    /**\n+     * Handle a token response from the server.\n+     *\n+     * @param msg The token response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return {@link TokenResponseMsg} sent back from server.\n+     */\n+    @ResponseHandler(type = PayloadCase.TOKEN_RESPONSE)\n+    private static Object handleTokenResponse(CorfuMessage.ResponseMsg msg,\n+                                              ChannelHandlerContext ctx,\n+                                              IClientRouter r) {\n+        TokenResponseMsg responseMsg = msg.getPayload().getTokenResponse();\n+\n+        return getTokenResponse(responseMsg);\n+    }\n+\n+    /**\n+     * Handle a bootstrap sequencer response from the server.\n+     *\n+     * @param msg The bootstrap sequencer response message.\n+     * @param ctx The context the message was sent under.\n+     * @param r   A reference to the router.\n+     * @return True if ACK, false if NACK.\n+     */\n+    @ResponseHandler(type = PayloadCase.BOOTSTRAP_SEQUENCER_RESPONSE)\n+    private static Object handleBootstrapSequencerResponse(ResponseMsg msg,\n+                                                           ChannelHandlerContext ctx,\n+                                                           IClientRouter r) {\n+        BootstrapSequencerResponseMsg responseMsg =\n+                msg.getPayload().getBootstrapSequencerResponse();\n+        return responseMsg.getIsBootstrapped();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1MTQ3OQ=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTE2OTA1OnYy", "diffSide": "RIGHT", "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxOTo1MTozOFrOIOlCzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDoyNFrOIPRung==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NzkwMg==", "bodyText": "nit: Replace CorfuMessage.HeaderMsg by just HeaderMsg.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552157902", "createdAt": "2021-01-05T19:51:38Z", "author": {"login": "zfrenette"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDAxNA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890014", "createdAt": "2021-01-06T18:30:24Z", "author": {"login": "xcchang"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE1NzkwMg=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTIyMzYzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDowODoyNVrOIOlkVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjo1Njo1NlrOIP0Miw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2NjQ4Ng==", "bodyText": "I couldn't help but notice that the Protobuf representation for a StreamsAddressSpace uses an uint64 to represent the trim mark. But in some places, the value is initialized with a negative value (see, for example, LogMetadata.java::96). Can this be a problem? I have a similar concern with the representation of the tail in StreamsAddressResponseMsg in sequencer.proto.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552166486", "createdAt": "2021-01-05T20:08:25Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerClient.java", "diffHunk": "@@ -54,9 +57,10 @@ public SequencerClient(IClientRouter router, long epoch, UUID clusterID) {\n      * @param streamsAddressesRange requested streams and ranges.\n      * @return streams address maps in the given range.\n      */\n-    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(List<StreamAddressRange> streamsAddressesRange) {\n-        return sendMessageWithFuture(CorfuMsgType.STREAMS_ADDRESS_REQUEST.payloadMsg(\n-                new StreamsAddressRequest(streamsAddressesRange)));\n+    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(\n+            List<StreamAddressRange> streamsAddressesRange) {\n+        return sendRequestWithFuture(getStreamsAddressRequestMsg(streamsAddressesRange),\n+                false, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI3MTIxOA==", "bodyText": "Actually, from the test cases in SequencerServerTest, they suggest that this is not an issue.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552271218", "createdAt": "2021-01-05T23:59:05Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerClient.java", "diffHunk": "@@ -54,9 +57,10 @@ public SequencerClient(IClientRouter router, long epoch, UUID clusterID) {\n      * @param streamsAddressesRange requested streams and ranges.\n      * @return streams address maps in the given range.\n      */\n-    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(List<StreamAddressRange> streamsAddressesRange) {\n-        return sendMessageWithFuture(CorfuMsgType.STREAMS_ADDRESS_REQUEST.payloadMsg(\n-                new StreamsAddressRequest(streamsAddressesRange)));\n+    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(\n+            List<StreamAddressRange> streamsAddressesRange) {\n+        return sendRequestWithFuture(getStreamsAddressRequestMsg(streamsAddressesRange),\n+                false, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2NjQ4Ng=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk4MDAwNg==", "bodyText": "Java doesn't have unsigned longs. When the system is first bootstrap the trim mark should be less than 0. Otherwise address 0 will be incorrectly considered trimmed. Why not use int64?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552980006", "createdAt": "2021-01-06T21:54:55Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerClient.java", "diffHunk": "@@ -54,9 +57,10 @@ public SequencerClient(IClientRouter router, long epoch, UUID clusterID) {\n      * @param streamsAddressesRange requested streams and ranges.\n      * @return streams address maps in the given range.\n      */\n-    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(List<StreamAddressRange> streamsAddressesRange) {\n-        return sendMessageWithFuture(CorfuMsgType.STREAMS_ADDRESS_REQUEST.payloadMsg(\n-                new StreamsAddressRequest(streamsAddressesRange)));\n+    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(\n+            List<StreamAddressRange> streamsAddressesRange) {\n+        return sendRequestWithFuture(getStreamsAddressRequestMsg(streamsAddressesRange),\n+                false, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2NjQ4Ng=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ1NDczMQ==", "bodyText": "Thanks for confirming. This change has been made.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r553454731", "createdAt": "2021-01-07T16:56:56Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/runtime/clients/SequencerClient.java", "diffHunk": "@@ -54,9 +57,10 @@ public SequencerClient(IClientRouter router, long epoch, UUID clusterID) {\n      * @param streamsAddressesRange requested streams and ranges.\n      * @return streams address maps in the given range.\n      */\n-    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(List<StreamAddressRange> streamsAddressesRange) {\n-        return sendMessageWithFuture(CorfuMsgType.STREAMS_ADDRESS_REQUEST.payloadMsg(\n-                new StreamsAddressRequest(streamsAddressesRange)));\n+    public CompletableFuture<StreamsAddressResponse> getStreamsAddressSpace(\n+            List<StreamAddressRange> streamsAddressesRange) {\n+        return sendRequestWithFuture(getStreamsAddressRequestMsg(streamsAddressesRange),\n+                false, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE2NjQ4Ng=="}, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTI2MDQwOnYy", "diffSide": "RIGHT", "path": "runtime/proto/service/sequencer.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDoyMDoyNlrOIOl6xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDoyMDoyNlrOIOl6xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3MjIzMQ==", "bodyText": "See my other comment about using an uint64.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552172231", "createdAt": "2021-01-05T20:20:26Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/service/sequencer.proto", "diffHunk": "@@ -145,5 +139,6 @@ message StreamsAddressRequestMsg {\n  */\n message StreamsAddressResponseMsg {\n   uint64 log_tail = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2646399591804dc14bd9dfdfddac8029345d4654"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTMwNzM0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDozNjowOVrOIOmXhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDo0M1rOIPRvKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3OTU5MQ==", "bodyText": "nit: the epoch as well.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552179591", "createdAt": "2021-01-05T20:36:09Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -243,19 +256,48 @@ public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange\n     }\n \n     /**\n-     * Returns a StreamAddressResponse object from its log tail and List\n-     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n-     * represented in Protobuf.\n+     * Returns a new {@link ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDE1Mw==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890153", "createdAt": "2021-01-06T18:30:43Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -243,19 +256,48 @@ public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange\n     }\n \n     /**\n-     * Returns a StreamAddressResponse object from its log tail and List\n-     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n-     * represented in Protobuf.\n+     * Returns a new {@link ResponsePayloadMsg} Protobuf object consisting of a\n+     * {@link StreamsAddressResponseMsg} object with the logTail and addressMap set from the\n+     * parameters.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE3OTU5MQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTMxNzY3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMDozOTozM1rOIOmdpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDo1MVrOIPRvcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MTE1OA==", "bodyText": "I think we can remove the implements ICorfuPayload<TxResolutionInfo> for this class, along with its serialization methods.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552181158", "createdAt": "2021-01-05T20:39:33Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDIyNA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890224", "createdAt": "2021-01-06T18:30:51Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolTxResolution.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.corfudb.protocols;\n+\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE4MTE1OA=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTM4OTQ5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTowMjowMFrOIOnIoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMDo1N1rOIPRvnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MjE2MA==", "bodyText": "nit: Protobuf", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552192160", "createdAt": "2021-01-05T21:02:00Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getSequencerMetricsMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpaceMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.getTxResolutionInfoMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined in sequencer.proto.\n+ * These provide the interface for obtaining the Protobuf and the Java representations of the\n+ * following RequestMsg RPCs and their ResponseMsg counterparts -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * These methods are used by both the client and the server.\n+ */\n+@Slf4j\n+public class CorfuProtocolSequencer {\n+    // It stores the EnumBiMap of the Java and Protobuf TokenTypes for efficient conversions.\n+    private static final EnumBiMap<TokenType, TokenResponseMsg.TokenType> tokenResponseTypeMap =\n+            EnumBiMap.create(ImmutableMap.of(\n+                    TokenType.NORMAL, TokenResponseMsg.TokenType.TX_NORMAL,\n+                    TokenType.TX_ABORT_CONFLICT, TokenResponseMsg.TokenType.TX_ABORT_CONFLICT,\n+                    TokenType.TX_ABORT_NEWSEQ, TokenResponseMsg.TokenType.TX_ABORT_NEWSEQ,\n+\n+                    TokenType.TX_ABORT_SEQ_OVERFLOW,\n+                    TokenResponseMsg.TokenType.TX_ABORT_SEQ_OVERFLOW,\n+\n+                    TokenType.TX_ABORT_SEQ_TRIM, TokenResponseMsg.TokenType.TX_ABORT_SEQ_TRIM)\n+            );\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param numTokens    the number of tokens\n+     * @param streams      a list of streams of Java UUID type\n+     * @param conflictInfo a {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams,\n+                                                       TxResolutionInfo conflictInfo) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(TokenRequestMsg.newBuilder()\n+                        .setRequestType(TokenRequestType.TK_TX)\n+                        .setNumTokens(numTokens)\n+                        .setTxnResolution(getTxResolutionInfoMsg(conflictInfo))\n+                        .addAllStreams(streams.stream()\n+                                .map(CorfuProtocolCommon::getUuidMsg)\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     * <p>\n+     * The type of the {@link TokenRequestType} depends on the parameters passed.\n+     * - If numTokens is 0, then the type is TK_QUERY.\n+     * - Else if steams is null or empty, then the type is TK_RAW.\n+     * - Otherwise, the type is TK_MULTI_STREAM.\n+     *\n+     * @param numTokens the number of tokens\n+     * @param streams   a list of streams to be included in the {@link TokenRequestMsg}\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams) {\n+        TokenRequestMsg.Builder tokenRequestBuilder = TokenRequestMsg.newBuilder();\n+        tokenRequestBuilder.setNumTokens(numTokens);\n+\n+        if (numTokens == 0) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_QUERY);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        } else if (streams == null || streams.isEmpty()) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_RAW);\n+        } else {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_MULTI_STREAM);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        }\n+\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(tokenRequestBuilder.build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param type           the {@link TokenType} of the response object.\n+     * @param conflictKey    an array of bytes representing the conflictKey\n+     * @param conflictStream the Java UUID representing the conflictStream\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @param streamTails    the streamsTails of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(TokenType type,\n+                                                         byte[] conflictKey,\n+                                                         UUID conflictStream,\n+                                                         Token token,\n+                                                         Map<UUID, Long> backPointerMap,\n+                                                         Map<UUID, Long> streamTails) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setTokenResponse(TokenResponseMsg.newBuilder()\n+                        .setRespType(tokenResponseTypeMap.get(type))\n+                        .setConflictKey(ByteString.copyFrom(conflictKey))\n+                        .setConflictStream(getUuidMsg(conflictStream))\n+                        .setToken(getTokenMsg(token))\n+                        .addAllBackpointerMap(backPointerMap.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .addAllStreamTails(streamTails.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(Token token,\n+                                                         Map<UUID, Long> backPointerMap) {\n+        return getTokenResponseMsg(TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY,\n+                TokenResponse.NO_CONFLICT_STREAM, token, backPointerMap, Collections.emptyMap());\n+    }\n+\n+    /**\n+     * Returns the Java {@link TokenResponse} object from the given {link TokenResponseMsg}\n+     * Protobuf object.\n+     *\n+     * @param msg the {@link TokenResponseMsg} Protobuff object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDI2OA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890268", "createdAt": "2021-01-06T18:30:57Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getSequencerMetricsMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpaceMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.getTxResolutionInfoMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined in sequencer.proto.\n+ * These provide the interface for obtaining the Protobuf and the Java representations of the\n+ * following RequestMsg RPCs and their ResponseMsg counterparts -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * These methods are used by both the client and the server.\n+ */\n+@Slf4j\n+public class CorfuProtocolSequencer {\n+    // It stores the EnumBiMap of the Java and Protobuf TokenTypes for efficient conversions.\n+    private static final EnumBiMap<TokenType, TokenResponseMsg.TokenType> tokenResponseTypeMap =\n+            EnumBiMap.create(ImmutableMap.of(\n+                    TokenType.NORMAL, TokenResponseMsg.TokenType.TX_NORMAL,\n+                    TokenType.TX_ABORT_CONFLICT, TokenResponseMsg.TokenType.TX_ABORT_CONFLICT,\n+                    TokenType.TX_ABORT_NEWSEQ, TokenResponseMsg.TokenType.TX_ABORT_NEWSEQ,\n+\n+                    TokenType.TX_ABORT_SEQ_OVERFLOW,\n+                    TokenResponseMsg.TokenType.TX_ABORT_SEQ_OVERFLOW,\n+\n+                    TokenType.TX_ABORT_SEQ_TRIM, TokenResponseMsg.TokenType.TX_ABORT_SEQ_TRIM)\n+            );\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param numTokens    the number of tokens\n+     * @param streams      a list of streams of Java UUID type\n+     * @param conflictInfo a {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams,\n+                                                       TxResolutionInfo conflictInfo) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(TokenRequestMsg.newBuilder()\n+                        .setRequestType(TokenRequestType.TK_TX)\n+                        .setNumTokens(numTokens)\n+                        .setTxnResolution(getTxResolutionInfoMsg(conflictInfo))\n+                        .addAllStreams(streams.stream()\n+                                .map(CorfuProtocolCommon::getUuidMsg)\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     * <p>\n+     * The type of the {@link TokenRequestType} depends on the parameters passed.\n+     * - If numTokens is 0, then the type is TK_QUERY.\n+     * - Else if steams is null or empty, then the type is TK_RAW.\n+     * - Otherwise, the type is TK_MULTI_STREAM.\n+     *\n+     * @param numTokens the number of tokens\n+     * @param streams   a list of streams to be included in the {@link TokenRequestMsg}\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams) {\n+        TokenRequestMsg.Builder tokenRequestBuilder = TokenRequestMsg.newBuilder();\n+        tokenRequestBuilder.setNumTokens(numTokens);\n+\n+        if (numTokens == 0) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_QUERY);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        } else if (streams == null || streams.isEmpty()) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_RAW);\n+        } else {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_MULTI_STREAM);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        }\n+\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(tokenRequestBuilder.build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param type           the {@link TokenType} of the response object.\n+     * @param conflictKey    an array of bytes representing the conflictKey\n+     * @param conflictStream the Java UUID representing the conflictStream\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @param streamTails    the streamsTails of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(TokenType type,\n+                                                         byte[] conflictKey,\n+                                                         UUID conflictStream,\n+                                                         Token token,\n+                                                         Map<UUID, Long> backPointerMap,\n+                                                         Map<UUID, Long> streamTails) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setTokenResponse(TokenResponseMsg.newBuilder()\n+                        .setRespType(tokenResponseTypeMap.get(type))\n+                        .setConflictKey(ByteString.copyFrom(conflictKey))\n+                        .setConflictStream(getUuidMsg(conflictStream))\n+                        .setToken(getTokenMsg(token))\n+                        .addAllBackpointerMap(backPointerMap.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .addAllStreamTails(streamTails.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(Token token,\n+                                                         Map<UUID, Long> backPointerMap) {\n+        return getTokenResponseMsg(TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY,\n+                TokenResponse.NO_CONFLICT_STREAM, token, backPointerMap, Collections.emptyMap());\n+    }\n+\n+    /**\n+     * Returns the Java {@link TokenResponse} object from the given {link TokenResponseMsg}\n+     * Protobuf object.\n+     *\n+     * @param msg the {@link TokenResponseMsg} Protobuff object", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5MjE2MA=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTQzMzA3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMToxNTo1NFrOIOnjmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMToxNTo1NFrOIOnjmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE5OTA2NQ==", "bodyText": "Can this be a problem during the rolling upgrade process? We might not need to address this right away, but I can potentially see an issue if a response is received corresponding to a newer token type, if one is ever added. In several other places where a similar approach is employed, getOrDefault is used. I'm not sure if this is appropriate here, but we should keep this in mind when we discuss the capabilities exchange.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552199065", "createdAt": "2021-01-05T21:15:54Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolSequencer.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.common.collect.EnumBiMap;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.CorfuProtocolCommon;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToLongPairMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerTrimResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.StreamsAddressResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg.TokenRequestType;\n+import org.corfudb.runtime.proto.service.Sequencer.TokenResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getSequencerMetricsMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpaceMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getTokenMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.CorfuProtocolTxResolution.getTxResolutionInfoMsg;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined in sequencer.proto.\n+ * These provide the interface for obtaining the Protobuf and the Java representations of the\n+ * following RequestMsg RPCs and their ResponseMsg counterparts -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * These methods are used by both the client and the server.\n+ */\n+@Slf4j\n+public class CorfuProtocolSequencer {\n+    // It stores the EnumBiMap of the Java and Protobuf TokenTypes for efficient conversions.\n+    private static final EnumBiMap<TokenType, TokenResponseMsg.TokenType> tokenResponseTypeMap =\n+            EnumBiMap.create(ImmutableMap.of(\n+                    TokenType.NORMAL, TokenResponseMsg.TokenType.TX_NORMAL,\n+                    TokenType.TX_ABORT_CONFLICT, TokenResponseMsg.TokenType.TX_ABORT_CONFLICT,\n+                    TokenType.TX_ABORT_NEWSEQ, TokenResponseMsg.TokenType.TX_ABORT_NEWSEQ,\n+\n+                    TokenType.TX_ABORT_SEQ_OVERFLOW,\n+                    TokenResponseMsg.TokenType.TX_ABORT_SEQ_OVERFLOW,\n+\n+                    TokenType.TX_ABORT_SEQ_TRIM, TokenResponseMsg.TokenType.TX_ABORT_SEQ_TRIM)\n+            );\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param numTokens    the number of tokens\n+     * @param streams      a list of streams of Java UUID type\n+     * @param conflictInfo a {@link TxResolutionInfo} object\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams,\n+                                                       TxResolutionInfo conflictInfo) {\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(TokenRequestMsg.newBuilder()\n+                        .setRequestType(TokenRequestType.TK_TX)\n+                        .setNumTokens(numTokens)\n+                        .setTxnResolution(getTxResolutionInfoMsg(conflictInfo))\n+                        .addAllStreams(streams.stream()\n+                                .map(CorfuProtocolCommon::getUuidMsg)\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link RequestPayloadMsg} with the {@link TokenRequestMsg} payload\n+     * constructed from the given parameters.\n+     * <p>\n+     * The type of the {@link TokenRequestType} depends on the parameters passed.\n+     * - If numTokens is 0, then the type is TK_QUERY.\n+     * - Else if steams is null or empty, then the type is TK_RAW.\n+     * - Otherwise, the type is TK_MULTI_STREAM.\n+     *\n+     * @param numTokens the number of tokens\n+     * @param streams   a list of streams to be included in the {@link TokenRequestMsg}\n+     * @return the Protobuf {@link RequestPayloadMsg}\n+     */\n+    public static RequestPayloadMsg getTokenRequestMsg(long numTokens, List<UUID> streams) {\n+        TokenRequestMsg.Builder tokenRequestBuilder = TokenRequestMsg.newBuilder();\n+        tokenRequestBuilder.setNumTokens(numTokens);\n+\n+        if (numTokens == 0) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_QUERY);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        } else if (streams == null || streams.isEmpty()) {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_RAW);\n+        } else {\n+            tokenRequestBuilder.setRequestType(TokenRequestType.TK_MULTI_STREAM);\n+            tokenRequestBuilder.addAllStreams(streams.stream()\n+                    .map(CorfuProtocolCommon::getUuidMsg).collect(Collectors.toList()));\n+        }\n+\n+        return RequestPayloadMsg.newBuilder()\n+                .setTokenRequest(tokenRequestBuilder.build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param type           the {@link TokenType} of the response object.\n+     * @param conflictKey    an array of bytes representing the conflictKey\n+     * @param conflictStream the Java UUID representing the conflictStream\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @param streamTails    the streamsTails of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(TokenType type,\n+                                                         byte[] conflictKey,\n+                                                         UUID conflictStream,\n+                                                         Token token,\n+                                                         Map<UUID, Long> backPointerMap,\n+                                                         Map<UUID, Long> streamTails) {\n+        return ResponsePayloadMsg.newBuilder()\n+                .setTokenResponse(TokenResponseMsg.newBuilder()\n+                        .setRespType(tokenResponseTypeMap.get(type))\n+                        .setConflictKey(ByteString.copyFrom(conflictKey))\n+                        .setConflictStream(getUuidMsg(conflictStream))\n+                        .setToken(getTokenMsg(token))\n+                        .addAllBackpointerMap(backPointerMap.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .addAllStreamTails(streamTails.entrySet()\n+                                .stream()\n+                                .map(e -> UuidToLongPairMsg.newBuilder()\n+                                        .setKey(getUuidMsg(e.getKey()))\n+                                        .setValue(e.getValue())\n+                                        .build())\n+                                .collect(Collectors.toList()))\n+                        .build())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf {@link ResponsePayloadMsg} object with the {@link TokenResponseMsg} payload\n+     * constructed from the given parameters.\n+     *\n+     * @param token          the response token\n+     * @param backPointerMap the backPointerMap of UUID to Long type\n+     * @return the Protobuf {@link ResponsePayloadMsg} object\n+     */\n+    public static ResponsePayloadMsg getTokenResponseMsg(Token token,\n+                                                         Map<UUID, Long> backPointerMap) {\n+        return getTokenResponseMsg(TokenType.NORMAL, TokenResponse.NO_CONFLICT_KEY,\n+                TokenResponse.NO_CONFLICT_STREAM, token, backPointerMap, Collections.emptyMap());\n+    }\n+\n+    /**\n+     * Returns the Java {@link TokenResponse} object from the given {link TokenResponseMsg}\n+     * Protobuf object.\n+     *\n+     * @param msg the {@link TokenResponseMsg} Protobuff object\n+     * @return the {@link TokenResponse} object\n+     */\n+    public static TokenResponse getTokenResponse(TokenResponseMsg msg) {\n+        return new TokenResponse(\n+                tokenResponseTypeMap.inverse().get(msg.getRespType()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTUxMDk5OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/view/AbstractViewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTozNDowN1rOIOoZHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMTowNFrOIPRv4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMjc2NQ==", "bodyText": "Should the ignoreEpoch and ignoreClusterId flags be set to false? This is how the client sends this request.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552212765", "createdAt": "2021-01-05T21:34:07Z", "author": {"login": "zfrenette"}, "path": "test/src/test/java/org/corfudb/runtime/view/AbstractViewTest.java", "diffHunk": "@@ -317,9 +313,16 @@ public void bootstrapAllServers(Layout l) {\n                 });\n         TestServer primarySequencerNode = testServerMap.get(l.getSequencers().get(0));\n         primarySequencerNode.sequencerServer\n-                .handleMessage(CorfuMsgType.BOOTSTRAP_SEQUENCER.payloadMsg(new SequencerRecoveryMsg(0L,\n-                        Collections.emptyMap(), l.getEpoch(), false)), null,\n-                        primarySequencerNode.serverRouter);\n+                .handleMessage(\n+                        CorfuProtocolMessage.getRequestMsg(\n+                                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDMzOQ==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890339", "createdAt": "2021-01-06T18:31:04Z", "author": {"login": "xcchang"}, "path": "test/src/test/java/org/corfudb/runtime/view/AbstractViewTest.java", "diffHunk": "@@ -317,9 +313,16 @@ public void bootstrapAllServers(Layout l) {\n                 });\n         TestServer primarySequencerNode = testServerMap.get(l.getSequencers().get(0));\n         primarySequencerNode.sequencerServer\n-                .handleMessage(CorfuMsgType.BOOTSTRAP_SEQUENCER.payloadMsg(new SequencerRecoveryMsg(0L,\n-                        Collections.emptyMap(), l.getEpoch(), false)), null,\n-                        primarySequencerNode.serverRouter);\n+                .handleMessage(\n+                        CorfuProtocolMessage.getRequestMsg(\n+                                getBasicHeader(true, true),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxMjc2NQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTU1MjcxOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMTo0ODowOVrOIOoyhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo1MToyNlrOIPUJPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxOTI2OQ==", "bodyText": "Two token requests were sent here. Can we confirm that removing one does not effect the integrity of the test?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552219269", "createdAt": "2021-01-05T21:48:09Z", "author": {"login": "zfrenette"}, "path": "test/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -199,23 +214,25 @@ public void SequencerWillResetTails() throws Exception {\n         UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n         UUID streamC = UUID.nameUUIDFromBytes(\"streamC\".getBytes());\n \n-        CompletableFuture<TokenResponse> future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamA))));\n+        CompletableFuture<TokenResponse> future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamA)),\n+                false, false);\n         long tailA = future.join().getToken().getSequence();\n \n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamB))));\n+        future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamB)),\n+                false, false);\n         long tailB = future.join().getToken().getSequence();\n \n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamC))));\n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamC))));\n+        future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamC)),\n+                false, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyOTU5Nw==", "bodyText": "Just checked that sending two requests won't change the verification logic later, so I'd prefer to keep one request since  having two identical sendRequest blocks here looks a little weird.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552929597", "createdAt": "2021-01-06T19:51:26Z", "author": {"login": "xcchang"}, "path": "test/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -199,23 +214,25 @@ public void SequencerWillResetTails() throws Exception {\n         UUID streamB = UUID.nameUUIDFromBytes(\"streamB\".getBytes());\n         UUID streamC = UUID.nameUUIDFromBytes(\"streamC\".getBytes());\n \n-        CompletableFuture<TokenResponse> future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamA))));\n+        CompletableFuture<TokenResponse> future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamA)),\n+                false, false);\n         long tailA = future.join().getToken().getSequence();\n \n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamB))));\n+        future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamB)),\n+                false, false);\n         long tailB = future.join().getToken().getSequence();\n \n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamC))));\n-        future = sendRequest(new CorfuPayloadMsg<>(CorfuMsgType.TOKEN_REQ,\n-                new TokenRequest(1L, Collections.singletonList(streamC))));\n+        future = sendRequest(\n+                getTokenRequestMsg(1L, Collections.singletonList(streamC)),\n+                false, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIxOTI2OQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTU5NDc5OnYy", "diffSide": "RIGHT", "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjowMjo1M1rOIOpMBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMTozN1rOIPRw8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyNTc5OQ==", "bodyText": "Are these all supposed to be SequencerMetrics.READY?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552225799", "createdAt": "2021-01-05T22:02:53Z", "author": {"login": "zfrenette"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), CorfuMessage.PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to Long map for the\n+     * arguments of getTokenResponseMsg.\n+     *\n+     * @return a default UUID to Long HashMap.\n+     */\n+    private Map<UUID, Long> getTokenResponseDefaultMap() {\n+        Map<UUID, Long> defaultMap = new HashMap<>();\n+        int numIter = 100;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), (long) i);\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to StreamAddressSpace map for the\n+     * arguments of getStreamsAddressResponseMsg.\n+     *\n+     * @return a default UUID to StreamAddressSpace HashMap.\n+     */\n+    private Map<UUID, StreamAddressSpace> getDefaultAddressMap() {\n+        Map<UUID, StreamAddressSpace> defaultMap = new HashMap<>();\n+        int numIter = 10;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), new StreamAddressSpace());\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        sequencerHandler = new SequencerHandler();\n+        sequencerHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with empty maps.\n+     */\n+    @Test\n+    public void testTokenResponseEmptyMap() {\n+        Token token = new Token(0L, 0L);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        Collections.emptyMap(),\n+                        Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(0, tokenResponse.getStreamTailsCount());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+        assertTrue(tokenResponse.getBackpointerMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with default maps.\n+     */\n+    @Test\n+    public void testTokenResponseDefaultMap() {\n+        Token token = new Token(0L, 0L);\n+        Map<UUID, Long> backPointerMap = getTokenResponseDefaultMap();\n+        Map<UUID, Long> streamTails = getTokenResponseDefaultMap();\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        backPointerMap,\n+                        streamTails)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(streamTails.size(), tokenResponse.getStreamTailsCount());\n+        assertEquals(backPointerMap, tokenResponse.getBackpointerMap());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a BOOTSTRAP_SEQUENCER_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapSequencerResponse() {\n+        ResponseMsg responseAck = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapSequencerResponseMsg(true)\n+        );\n+        ResponseMsg responseNack = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerResponseMsg(false)\n+        );\n+\n+        sequencerHandler.handleMessage(responseAck, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNack, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseAck.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNack.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_TRIM_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerTrimResponse() {\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerTrimResponseMsg()\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(response.getHeader().getRequestId(), true);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_METRICS_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseNormal() {\n+        SequencerMetrics sequencerMetricsReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsNotReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsUnknown = SequencerMetrics.READY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDYwOA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890608", "createdAt": "2021-01-06T18:31:37Z", "author": {"login": "xcchang"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), CorfuMessage.PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to Long map for the\n+     * arguments of getTokenResponseMsg.\n+     *\n+     * @return a default UUID to Long HashMap.\n+     */\n+    private Map<UUID, Long> getTokenResponseDefaultMap() {\n+        Map<UUID, Long> defaultMap = new HashMap<>();\n+        int numIter = 100;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), (long) i);\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to StreamAddressSpace map for the\n+     * arguments of getStreamsAddressResponseMsg.\n+     *\n+     * @return a default UUID to StreamAddressSpace HashMap.\n+     */\n+    private Map<UUID, StreamAddressSpace> getDefaultAddressMap() {\n+        Map<UUID, StreamAddressSpace> defaultMap = new HashMap<>();\n+        int numIter = 10;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), new StreamAddressSpace());\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        sequencerHandler = new SequencerHandler();\n+        sequencerHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with empty maps.\n+     */\n+    @Test\n+    public void testTokenResponseEmptyMap() {\n+        Token token = new Token(0L, 0L);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        Collections.emptyMap(),\n+                        Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(0, tokenResponse.getStreamTailsCount());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+        assertTrue(tokenResponse.getBackpointerMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with default maps.\n+     */\n+    @Test\n+    public void testTokenResponseDefaultMap() {\n+        Token token = new Token(0L, 0L);\n+        Map<UUID, Long> backPointerMap = getTokenResponseDefaultMap();\n+        Map<UUID, Long> streamTails = getTokenResponseDefaultMap();\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        backPointerMap,\n+                        streamTails)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(streamTails.size(), tokenResponse.getStreamTailsCount());\n+        assertEquals(backPointerMap, tokenResponse.getBackpointerMap());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a BOOTSTRAP_SEQUENCER_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapSequencerResponse() {\n+        ResponseMsg responseAck = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapSequencerResponseMsg(true)\n+        );\n+        ResponseMsg responseNack = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerResponseMsg(false)\n+        );\n+\n+        sequencerHandler.handleMessage(responseAck, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNack, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseAck.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNack.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_TRIM_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerTrimResponse() {\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerTrimResponseMsg()\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(response.getHeader().getRequestId(), true);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_METRICS_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseNormal() {\n+        SequencerMetrics sequencerMetricsReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsNotReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsUnknown = SequencerMetrics.READY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIyNTc5OQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTYyNjQ5OnYy", "diffSide": "RIGHT", "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjoxNDowNlrOIOpfJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMTo0NFrOIPRxRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMDY5Mg==", "bodyText": "Maybe also verify that the size of the maps are the same, in case one key-set is a subset of the other.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552230692", "createdAt": "2021-01-05T22:14:06Z", "author": {"login": "zfrenette"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), CorfuMessage.PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to Long map for the\n+     * arguments of getTokenResponseMsg.\n+     *\n+     * @return a default UUID to Long HashMap.\n+     */\n+    private Map<UUID, Long> getTokenResponseDefaultMap() {\n+        Map<UUID, Long> defaultMap = new HashMap<>();\n+        int numIter = 100;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), (long) i);\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to StreamAddressSpace map for the\n+     * arguments of getStreamsAddressResponseMsg.\n+     *\n+     * @return a default UUID to StreamAddressSpace HashMap.\n+     */\n+    private Map<UUID, StreamAddressSpace> getDefaultAddressMap() {\n+        Map<UUID, StreamAddressSpace> defaultMap = new HashMap<>();\n+        int numIter = 10;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), new StreamAddressSpace());\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        sequencerHandler = new SequencerHandler();\n+        sequencerHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with empty maps.\n+     */\n+    @Test\n+    public void testTokenResponseEmptyMap() {\n+        Token token = new Token(0L, 0L);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        Collections.emptyMap(),\n+                        Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(0, tokenResponse.getStreamTailsCount());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+        assertTrue(tokenResponse.getBackpointerMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with default maps.\n+     */\n+    @Test\n+    public void testTokenResponseDefaultMap() {\n+        Token token = new Token(0L, 0L);\n+        Map<UUID, Long> backPointerMap = getTokenResponseDefaultMap();\n+        Map<UUID, Long> streamTails = getTokenResponseDefaultMap();\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        backPointerMap,\n+                        streamTails)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(streamTails.size(), tokenResponse.getStreamTailsCount());\n+        assertEquals(backPointerMap, tokenResponse.getBackpointerMap());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a BOOTSTRAP_SEQUENCER_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapSequencerResponse() {\n+        ResponseMsg responseAck = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapSequencerResponseMsg(true)\n+        );\n+        ResponseMsg responseNack = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerResponseMsg(false)\n+        );\n+\n+        sequencerHandler.handleMessage(responseAck, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNack, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseAck.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNack.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_TRIM_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerTrimResponse() {\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerTrimResponseMsg()\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(response.getHeader().getRequestId(), true);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_METRICS_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseNormal() {\n+        SequencerMetrics sequencerMetricsReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsNotReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsUnknown = SequencerMetrics.READY;\n+        ResponseMsg responseReady = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsReady)\n+        );\n+        ResponseMsg responseNotReady = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsNotReady)\n+        );\n+        ResponseMsg responseUnkown = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsUnknown)\n+        );\n+\n+        sequencerHandler.handleMessage(responseReady, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNotReady, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseUnkown, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsReady);\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsNotReady);\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsUnknown);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler throws an UnsupportedOperationException when the SequencerStatus is invalid.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseUnsupported() {\n+        SequencerMetrics sequencerMetrics = new SequencerMetrics(null);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetrics)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the request was completed exceptionally with the expected exception type.\n+        verify(mockClientRouter).completeExceptionally(eq(response.getHeader().getRequestId()),\n+                any(UnsupportedOperationException.class));\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a STREAMS_ADDRESS_RESPONSE with empty address map.\n+     */\n+    @Test\n+    public void testStreamsAddressResponseEmptyAddressMap() {\n+        long defaultLogTail = 5L;\n+        long defaultEpoch = 10L;\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getStreamsAddressResponseMsg(defaultLogTail, defaultEpoch, Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<StreamsAddressResponse> captor = ArgumentCaptor.forClass(StreamsAddressResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        StreamsAddressResponse streamsAddressResponse = captor.getValue();\n+        assertTrue(streamsAddressResponse.getAddressMap().isEmpty());\n+        assertEquals(defaultLogTail, streamsAddressResponse.getLogTail());\n+        assertEquals(defaultEpoch, streamsAddressResponse.getEpoch());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a STREAMS_ADDRESS_RESPONSE with default address map.\n+     */\n+    @Test\n+    public void testStreamsAddressResponseDefaultAddressMap() {\n+        long defaultLogTail = 5L;\n+        long defaultEpoch = 10L;\n+        Map<UUID, StreamAddressSpace> defaultMap = getDefaultAddressMap();\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getStreamsAddressResponseMsg(defaultLogTail, defaultEpoch, defaultMap)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<StreamsAddressResponse> captor = ArgumentCaptor.forClass(StreamsAddressResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        StreamsAddressResponse streamsAddressResponse = captor.getValue();\n+        assertEquals(defaultLogTail, streamsAddressResponse.getLogTail());\n+        assertEquals(defaultEpoch, streamsAddressResponse.getEpoch());\n+        Map<UUID, StreamAddressSpace> retMap = streamsAddressResponse.getAddressMap();\n+        for (UUID id : defaultMap.keySet()) {\n+            assertEquals(defaultMap.get(id).toString(), retMap.get(id).toString());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDY5Mw==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890693", "createdAt": "2021-01-06T18:31:44Z", "author": {"login": "xcchang"}, "path": "runtime/src/test/java/org/corfudb/runtime/clients/SequencerHandlerTest.java", "diffHunk": "@@ -0,0 +1,322 @@\n+package org.corfudb.runtime.clients;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamsAddressResponseMsg;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerMetricsResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimResponseMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponseMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Slf4j\n+@RunWith(MockitoJUnitRunner.class)\n+public class SequencerHandlerTest {\n+\n+    // The SequencerHandler instance used for testing\n+    private SequencerHandler sequencerHandler;\n+\n+    // Objects that need to be mocked\n+    private IClientRouter mockClientRouter;\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     * @return                  the corresponding HeaderMsg\n+     */\n+    private CorfuMessage.HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), CorfuMessage.PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to Long map for the\n+     * arguments of getTokenResponseMsg.\n+     *\n+     * @return a default UUID to Long HashMap.\n+     */\n+    private Map<UUID, Long> getTokenResponseDefaultMap() {\n+        Map<UUID, Long> defaultMap = new HashMap<>();\n+        int numIter = 100;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), (long) i);\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * A helper method that generates a default UUID to StreamAddressSpace map for the\n+     * arguments of getStreamsAddressResponseMsg.\n+     *\n+     * @return a default UUID to StreamAddressSpace HashMap.\n+     */\n+    private Map<UUID, StreamAddressSpace> getDefaultAddressMap() {\n+        Map<UUID, StreamAddressSpace> defaultMap = new HashMap<>();\n+        int numIter = 10;\n+        for (int i = 0; i < numIter; i++) {\n+            defaultMap.put(UUID.randomUUID(), new StreamAddressSpace());\n+        }\n+        return defaultMap;\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual\n+     * tests by preparing the mocks.\n+     */\n+    @Before\n+    public void setup() {\n+        mockClientRouter = mock(IClientRouter.class);\n+        mockChannelHandlerContext = mock(ChannelHandlerContext.class);\n+        sequencerHandler = new SequencerHandler();\n+        sequencerHandler.setRouter(mockClientRouter);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with empty maps.\n+     */\n+    @Test\n+    public void testTokenResponseEmptyMap() {\n+        Token token = new Token(0L, 0L);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        Collections.emptyMap(),\n+                        Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(0, tokenResponse.getStreamTailsCount());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+        assertTrue(tokenResponse.getBackpointerMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a TOKEN_RESPONSE with default maps.\n+     */\n+    @Test\n+    public void testTokenResponseDefaultMap() {\n+        Token token = new Token(0L, 0L);\n+        Map<UUID, Long> backPointerMap = getTokenResponseDefaultMap();\n+        Map<UUID, Long> streamTails = getTokenResponseDefaultMap();\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getTokenResponseMsg(\n+                        TokenType.NORMAL,\n+                        TokenResponse.NO_CONFLICT_KEY,\n+                        TokenResponse.NO_CONFLICT_STREAM, token,\n+                        backPointerMap,\n+                        streamTails)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<TokenResponse> captor = ArgumentCaptor.forClass(TokenResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        TokenResponse tokenResponse = captor.getValue();\n+        assertEquals(token, tokenResponse.getToken());\n+        assertEquals(TokenType.NORMAL, tokenResponse.getRespType());\n+        assertEquals(TokenResponse.NO_CONFLICT_STREAM, tokenResponse.getConflictStream());\n+        assertEquals(streamTails.size(), tokenResponse.getStreamTailsCount());\n+        assertEquals(backPointerMap, tokenResponse.getBackpointerMap());\n+        assertArrayEquals(tokenResponse.getConflictKey(), TokenResponse.NO_CONFLICT_KEY);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a BOOTSTRAP_SEQUENCER_RESPONSE.\n+     */\n+    @Test\n+    public void testBootstrapSequencerResponse() {\n+        ResponseMsg responseAck = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getBootstrapSequencerResponseMsg(true)\n+        );\n+        ResponseMsg responseNack = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerResponseMsg(false)\n+        );\n+\n+        sequencerHandler.handleMessage(responseAck, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNack, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseAck.getHeader().getRequestId(), true);\n+        verify(mockClientRouter).completeRequest(responseNack.getHeader().getRequestId(), false);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_TRIM_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerTrimResponse() {\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerTrimResponseMsg()\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(response.getHeader().getRequestId(), true);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a SEQUENCER_METRICS_RESPONSE.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseNormal() {\n+        SequencerMetrics sequencerMetricsReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsNotReady = SequencerMetrics.READY;\n+        SequencerMetrics sequencerMetricsUnknown = SequencerMetrics.READY;\n+        ResponseMsg responseReady = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsReady)\n+        );\n+        ResponseMsg responseNotReady = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsNotReady)\n+        );\n+        ResponseMsg responseUnkown = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetricsUnknown)\n+        );\n+\n+        sequencerHandler.handleMessage(responseReady, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseNotReady, mockChannelHandlerContext);\n+        sequencerHandler.handleMessage(responseUnkown, mockChannelHandlerContext);\n+        // Verify that the correct request was completed with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsReady);\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsNotReady);\n+        verify(mockClientRouter).completeRequest(responseReady.getHeader().getRequestId(), sequencerMetricsUnknown);\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler throws an UnsupportedOperationException when the SequencerStatus is invalid.\n+     */\n+    @Test\n+    public void testSequencerMetricsResponseUnsupported() {\n+        SequencerMetrics sequencerMetrics = new SequencerMetrics(null);\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, true),\n+                getSequencerMetricsResponseMsg(sequencerMetrics)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        // Verify that the request was completed exceptionally with the expected exception type.\n+        verify(mockClientRouter).completeExceptionally(eq(response.getHeader().getRequestId()),\n+                any(UnsupportedOperationException.class));\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a STREAMS_ADDRESS_RESPONSE with empty address map.\n+     */\n+    @Test\n+    public void testStreamsAddressResponseEmptyAddressMap() {\n+        long defaultLogTail = 5L;\n+        long defaultEpoch = 10L;\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getStreamsAddressResponseMsg(defaultLogTail, defaultEpoch, Collections.emptyMap())\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<StreamsAddressResponse> captor = ArgumentCaptor.forClass(StreamsAddressResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        StreamsAddressResponse streamsAddressResponse = captor.getValue();\n+        assertTrue(streamsAddressResponse.getAddressMap().isEmpty());\n+        assertEquals(defaultLogTail, streamsAddressResponse.getLogTail());\n+        assertEquals(defaultEpoch, streamsAddressResponse.getEpoch());\n+    }\n+\n+    /**\n+     * Test that the SequencerHandler correctly handles a STREAMS_ADDRESS_RESPONSE with default address map.\n+     */\n+    @Test\n+    public void testStreamsAddressResponseDefaultAddressMap() {\n+        long defaultLogTail = 5L;\n+        long defaultEpoch = 10L;\n+        Map<UUID, StreamAddressSpace> defaultMap = getDefaultAddressMap();\n+\n+        ResponseMsg response = getResponseMsg(\n+                getBasicHeader(false, false),\n+                getStreamsAddressResponseMsg(defaultLogTail, defaultEpoch, defaultMap)\n+        );\n+\n+        sequencerHandler.handleMessage(response, mockChannelHandlerContext);\n+        ArgumentCaptor<StreamsAddressResponse> captor = ArgumentCaptor.forClass(StreamsAddressResponse.class);\n+        // Verify that the correct request was completed (once) with the appropriate value,\n+        // and that we did not complete exceptionally.\n+        verify(mockClientRouter, never()).completeExceptionally(anyLong(), any(Throwable.class));\n+        verify(mockClientRouter).completeRequest(eq(response.getHeader().getRequestId()), captor.capture());\n+\n+        StreamsAddressResponse streamsAddressResponse = captor.getValue();\n+        assertEquals(defaultLogTail, streamsAddressResponse.getLogTail());\n+        assertEquals(defaultEpoch, streamsAddressResponse.getEpoch());\n+        Map<UUID, StreamAddressSpace> retMap = streamsAddressResponse.getAddressMap();\n+        for (UUID id : defaultMap.keySet()) {\n+            assertEquals(defaultMap.get(id).toString(), retMap.get(id).toString());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMDY5Mg=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTY4NTMzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMjozNDoxMlrOIOqBVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozNTo0NVrOIPR5BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzOTQ0NQ==", "bodyText": "Can we rename this, as suggested here #2836 (comment) ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552239445", "createdAt": "2021-01-05T22:34:12Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +846,41 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) :\n+                    DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+\n+    /**\n+     * Used by the unit tests to inject a custom value for the required parameters through the\n+     * constructor\n+     *\n+     * The default implementations are listed here which will be overloaded with\n+     * the custom return values in unit tests.\n+     *\n+     * Note: This class should always return the default/initial objects and should not have\n+     *       any logic as it will never be tested.\n+     */\n+    static class SequencerFactoryHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 910}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MjY3Nw==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552892677", "createdAt": "2021-01-06T18:35:45Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -707,11 +846,41 @@ private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest>\n         private final int cacheSize = DEFAULT_CACHE_SIZE;\n \n         public static Config parse(Map<String, Object> opts) {\n-            int cacheSize = (int)(opts.containsKey(\"--sequencer-cache-size\") ?\n-            Integer.parseInt((String)opts.get(\"--sequencer-cache-size\")) : DEFAULT_CACHE_SIZE);\n+            int cacheSize = opts.containsKey(\"--sequencer-cache-size\") ?\n+                    Integer.parseInt((String) opts.get(\"--sequencer-cache-size\")) :\n+                    DEFAULT_CACHE_SIZE;\n             return Config.builder()\n                     .cacheSize(cacheSize)\n                     .build();\n         }\n     }\n+\n+\n+    /**\n+     * Used by the unit tests to inject a custom value for the required parameters through the\n+     * constructor\n+     *\n+     * The default implementations are listed here which will be overloaded with\n+     * the custom return values in unit tests.\n+     *\n+     * Note: This class should always return the default/initial objects and should not have\n+     *       any logic as it will never be tested.\n+     */\n+    static class SequencerFactoryHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzOTQ0NQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 910}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc1MTk4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowMDowNVrOIOqpYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMTo1MFrOIPRxdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0OTY5Ng==", "bodyText": "Can we use TextFormat.shortDebugString here and in other places where we log a Protobuf message?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552249696", "createdAt": "2021-01-05T23:00:05Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,23 @@ public void shutdown() {\n     }\n \n     @Override\n-    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n+        if (getState() != ServerState.READY) {\n             return false;\n         }\n \n-        if ((sequencerEpoch != serverContext.getServerEpoch())\n-                && (!msg.getMsgType().equals(CorfuMsgType.BOOTSTRAP_SEQUENCER))) {\n+        if ((sequencerEpoch != serverContext.getServerEpoch()) &&\n+                (!request.getPayload().getPayloadCase()\n+                        .equals(PayloadCase.BOOTSTRAP_SEQUENCER_REQUEST))) {\n+\n             log.warn(\"Rejecting msg at sequencer : sequencerStateEpoch:{}, serverEpoch:{}, \"\n-                    + \"msg:{}\", sequencerEpoch, serverContext.getServerEpoch(), msg);\n+                            + \"header:{}\", sequencerEpoch, serverContext.getServerEpoch(),\n+                    request.getHeader());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDc0MA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890740", "createdAt": "2021-01-06T18:31:50Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -190,26 +220,23 @@ public void shutdown() {\n     }\n \n     @Override\n-    public boolean isServerReadyToHandleMsg(CorfuMsg msg) {\n-        if (getState() != ServerState.READY){\n+    public boolean isServerReadyToHandleMsg(RequestMsg request) {\n+        if (getState() != ServerState.READY) {\n             return false;\n         }\n \n-        if ((sequencerEpoch != serverContext.getServerEpoch())\n-                && (!msg.getMsgType().equals(CorfuMsgType.BOOTSTRAP_SEQUENCER))) {\n+        if ((sequencerEpoch != serverContext.getServerEpoch()) &&\n+                (!request.getPayload().getPayloadCase()\n+                        .equals(PayloadCase.BOOTSTRAP_SEQUENCER_REQUEST))) {\n+\n             log.warn(\"Rejecting msg at sequencer : sequencerStateEpoch:{}, serverEpoch:{}, \"\n-                    + \"msg:{}\", sequencerEpoch, serverContext.getServerEpoch(), msg);\n+                            + \"header:{}\", sequencerEpoch, serverContext.getServerEpoch(),\n+                    request.getHeader());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0OTY5Ng=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTc3MzM5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzowOTo0MFrOIOq2ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMTo1OVrOIPRx0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MzAyOQ==", "bodyText": "Use TextFormat.shortDebugString?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552253029", "createdAt": "2021-01-05T23:09:40Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +494,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n             streamTailToGlobalTailMap = new HashMap<>();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n-            this.streamsAddressMap.putAll(addressSpaceMap);\n+            streamsAddressMap = new HashMap<>();\n+            streamsAddressMap.putAll(addressSpaceMap);\n \n-            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : this.streamsAddressMap.entrySet()) {\n-                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range [{}-{}], \" +\n-                                \"on sequencer reset.\",\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    streamsAddressMap.entrySet()) {\n+                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range\" +\n+                                \" [{}-{}], on sequencer reset.\",\n                         Utils.toReadableId(streamAddressSpace.getKey()),\n                         streamAddressSpace.getValue().getTrimMark(),\n                         streamAddressSpace.getValue().getAddressMap().getLongCardinality(),\n                         streamAddressSpace.getValue().getLowestAddress(),\n                         streamAddressSpace.getValue().getHighestAddress());\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Stream[{}] address map on sequencer reset: {}\",\n-                            Utils.toReadableId(streamAddressSpace.getKey()), streamAddressSpace.getValue().getAddressMap());\n+                            Utils.toReadableId(streamAddressSpace.getKey()),\n+                            streamAddressSpace.getValue().getAddressMap());\n                 }\n             }\n         }\n \n         // Update epochRangeLowerBound if the bootstrap epoch is not consecutive.\n-        if (epochRangeLowerBound == Layout.INVALID_EPOCH || bootstrapMsgEpoch != sequencerEpoch + 1) {\n+        if (epochRangeLowerBound == Layout.INVALID_EPOCH\n+                || bootstrapMsgEpoch != sequencerEpoch + 1) {\n             epochRangeLowerBound = bootstrapMsgEpoch;\n         }\n \n         // Mark the sequencer as ready after the tails have been populated.\n-        sequencerEpoch = bootstrapMsgEpoch;\n+        setSequencerEpoch(bootstrapMsgEpoch);\n         serverContext.setSequencerEpoch(bootstrapMsgEpoch);\n \n-        log.info(\"Sequencer reset with token = {}, size {} streamTailToGlobalTailMap = {}, sequencerEpoch = {}\",\n-                globalLogTail, streamTailToGlobalTailMap.size(), streamTailToGlobalTailMap, sequencerEpoch);\n+        log.info(\"Sequencer reset with token = {}, size {} streamTailToGlobalTailMap = {},\" +\n+                        \" sequencerEpoch = {}\", globalLogTail, streamTailToGlobalTailMap.size(),\n+                streamTailToGlobalTailMap, sequencerEpoch);\n \n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(),\n+                false, true);\n+        r.sendResponse(getResponseMsg(responseHeader,\n+                getBootstrapSequencerResponseMsg(true)), ctx);\n     }\n \n     /**\n      * Service an incoming metrics request with the metrics response.\n      */\n-    @ServerHandler(type = CorfuMsgType.SEQUENCER_METRICS_REQUEST)\n-    public void handleMetricsRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    @RequestHandler(type = PayloadCase.SEQUENCER_METRICS_REQUEST)\n+    public void handleMetricsRequest(@Nonnull RequestMsg req,\n+                                     @Nonnull ChannelHandlerContext ctx,\n+                                     @Nonnull IServerRouter r) {\n         // Sequencer Ready flag is set to true as this message will be responded to only if the\n         // sequencer is in a ready state.\n-        SequencerMetrics sequencerMetrics = new SequencerMetrics(SequencerStatus.READY);\n-        r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.SEQUENCER_METRICS_RESPONSE, sequencerMetrics));\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(req.getHeader(),\n+                getSequencerMetricsResponseMsg(new SequencerMetrics(SequencerStatus.READY)));\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Service an incoming token request.\n      */\n-    @ServerHandler(type = CorfuMsgType.TOKEN_REQ)\n-    public void tokenRequest(CorfuPayloadMsg<TokenRequest> msg,\n-                                          ChannelHandlerContext ctx, IServerRouter r) {\n-        log.trace(\"Token request. Msg: {}\", msg);\n+    @RequestHandler(type = PayloadCase.TOKEN_REQUEST)\n+    public void tokenRequest(@Nonnull RequestMsg req,\n+                             @Nonnull ChannelHandlerContext ctx,\n+                             @Nonnull IServerRouter r) {\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"tokenRequest: Token request msg: {}\", req);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 569}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MDgzMg==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552890832", "createdAt": "2021-01-06T18:31:59Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +494,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n             streamTailToGlobalTailMap = new HashMap<>();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n-            this.streamsAddressMap.putAll(addressSpaceMap);\n+            streamsAddressMap = new HashMap<>();\n+            streamsAddressMap.putAll(addressSpaceMap);\n \n-            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : this.streamsAddressMap.entrySet()) {\n-                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range [{}-{}], \" +\n-                                \"on sequencer reset.\",\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    streamsAddressMap.entrySet()) {\n+                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range\" +\n+                                \" [{}-{}], on sequencer reset.\",\n                         Utils.toReadableId(streamAddressSpace.getKey()),\n                         streamAddressSpace.getValue().getTrimMark(),\n                         streamAddressSpace.getValue().getAddressMap().getLongCardinality(),\n                         streamAddressSpace.getValue().getLowestAddress(),\n                         streamAddressSpace.getValue().getHighestAddress());\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Stream[{}] address map on sequencer reset: {}\",\n-                            Utils.toReadableId(streamAddressSpace.getKey()), streamAddressSpace.getValue().getAddressMap());\n+                            Utils.toReadableId(streamAddressSpace.getKey()),\n+                            streamAddressSpace.getValue().getAddressMap());\n                 }\n             }\n         }\n \n         // Update epochRangeLowerBound if the bootstrap epoch is not consecutive.\n-        if (epochRangeLowerBound == Layout.INVALID_EPOCH || bootstrapMsgEpoch != sequencerEpoch + 1) {\n+        if (epochRangeLowerBound == Layout.INVALID_EPOCH\n+                || bootstrapMsgEpoch != sequencerEpoch + 1) {\n             epochRangeLowerBound = bootstrapMsgEpoch;\n         }\n \n         // Mark the sequencer as ready after the tails have been populated.\n-        sequencerEpoch = bootstrapMsgEpoch;\n+        setSequencerEpoch(bootstrapMsgEpoch);\n         serverContext.setSequencerEpoch(bootstrapMsgEpoch);\n \n-        log.info(\"Sequencer reset with token = {}, size {} streamTailToGlobalTailMap = {}, sequencerEpoch = {}\",\n-                globalLogTail, streamTailToGlobalTailMap.size(), streamTailToGlobalTailMap, sequencerEpoch);\n+        log.info(\"Sequencer reset with token = {}, size {} streamTailToGlobalTailMap = {},\" +\n+                        \" sequencerEpoch = {}\", globalLogTail, streamTailToGlobalTailMap.size(),\n+                streamTailToGlobalTailMap, sequencerEpoch);\n \n-        r.sendResponse(ctx, msg, CorfuMsgType.ACK.msg());\n+        HeaderMsg responseHeader = getHeaderMsg(req.getHeader(),\n+                false, true);\n+        r.sendResponse(getResponseMsg(responseHeader,\n+                getBootstrapSequencerResponseMsg(true)), ctx);\n     }\n \n     /**\n      * Service an incoming metrics request with the metrics response.\n      */\n-    @ServerHandler(type = CorfuMsgType.SEQUENCER_METRICS_REQUEST)\n-    public void handleMetricsRequest(CorfuMsg msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    @RequestHandler(type = PayloadCase.SEQUENCER_METRICS_REQUEST)\n+    public void handleMetricsRequest(@Nonnull RequestMsg req,\n+                                     @Nonnull ChannelHandlerContext ctx,\n+                                     @Nonnull IServerRouter r) {\n         // Sequencer Ready flag is set to true as this message will be responded to only if the\n         // sequencer is in a ready state.\n-        SequencerMetrics sequencerMetrics = new SequencerMetrics(SequencerStatus.READY);\n-        r.sendResponse(ctx, msg, new CorfuPayloadMsg<>(CorfuMsgType.SEQUENCER_METRICS_RESPONSE, sequencerMetrics));\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(req.getHeader(),\n+                getSequencerMetricsResponseMsg(new SequencerMetrics(SequencerStatus.READY)));\n+\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * Service an incoming token request.\n      */\n-    @ServerHandler(type = CorfuMsgType.TOKEN_REQ)\n-    public void tokenRequest(CorfuPayloadMsg<TokenRequest> msg,\n-                                          ChannelHandlerContext ctx, IServerRouter r) {\n-        log.trace(\"Token request. Msg: {}\", msg);\n+    @RequestHandler(type = PayloadCase.TOKEN_REQUEST)\n+    public void tokenRequest(@Nonnull RequestMsg req,\n+                             @Nonnull ChannelHandlerContext ctx,\n+                             @Nonnull IServerRouter r) {\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"tokenRequest: Token request msg: {}\", req);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI1MzAyOQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 569}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTgyOTgwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzozMzo1NVrOIOrXFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0OTowNlrOIPUFYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MTM5OQ==", "bodyText": "Maybe include the type received as part of the exception message?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552261399", "createdAt": "2021-01-05T23:33:55Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -617,56 +731,78 @@ private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n         }\n \n         // update the cache of conflict parameters\n-        if (req.getTxnResolution() != null) {\n-            req.getTxnResolution()\n-                    .getWriteConflictParams()\n-                    .forEach((key, value) -> {\n+        if (tokenRequest.hasTxnResolution()) {\n+            tokenRequest.getTxnResolution().getWriteConflictParamsSetList()\n+                    .forEach((item) -> {\n                         // insert an entry with the new timestamp using the\n                         // hash code based on the param and the stream id.\n-                        value.forEach(conflictParam ->\n-                                cache.put(new ConflictTxStream(key, conflictParam, newTail - 1)));\n+                        item.getValueList().forEach(conflictParam ->\n+                                cache.put(new ConflictTxStream(getUUID(item.getKey()),\n+                                        conflictParam.toByteArray(), newTail - 1)));\n                     });\n         }\n-\n-        log.trace(\"token {} backpointers {}\", globalLogTail, backPointerMap.build());\n-\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"handleAllocation: token={} backpointers={}\",\n+                    globalLogTail, backPointerMap.build());\n+        }\n         // return the token response with the global tail and the streams backpointers\n-        Token token = new Token(sequencerEpoch, globalLogTail);\n+        Token newToken = new Token(sequencerEpoch, globalLogTail);\n         globalLogTail = newTail;\n-        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(\n-                new TokenResponse(token, backPointerMap.build())));\n+\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(\n+                req.getHeader(), getTokenResponseMsg(newToken, backPointerMap.build()));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * This method handles the request of streams addresses.\n-     *\n+     * <p>\n      * The request of address spaces can be of two types:\n-     *      - For specific streams (and specific ranges for each stream).\n-     *      - For all streams (complete range).\n-     *\n+     * - For specific streams (and specific ranges for each stream).\n+     * - For all streams (complete range).\n+     * <p>\n      * The response contains the requested streams address maps and the global log tail.\n      */\n-    @ServerHandler(type = CorfuMsgType.STREAMS_ADDRESS_REQUEST)\n-    private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest> msg,\n-                                             ChannelHandlerContext ctx, IServerRouter r) {\n-        StreamsAddressRequest req = msg.getPayload();\n-        Map<UUID, StreamAddressSpace> streamsAddressMap;\n-\n-        switch (req.getReqType()) {\n-            case StreamsAddressRequest.STREAMS:\n-                streamsAddressMap = getStreamsAddresses(req.getStreamsRanges());\n-                break;\n-\n-            default:\n-                // Retrieve address space for all streams\n-                streamsAddressMap = new HashMap<>(this.streamsAddressMap);\n-                break;\n+    @RequestHandler(type = PayloadCase.STREAMS_ADDRESS_REQUEST)\n+    private void handleStreamsAddressRequest(@Nonnull RequestMsg req,\n+                                             @Nonnull ChannelHandlerContext ctx,\n+                                             @Nonnull IServerRouter r) {\n+        StreamsAddressRequestMsg streamsAddressRequest =\n+                req.getPayload().getStreamsAddressRequest();\n+        Map<UUID, StreamAddressSpace> respStreamsAddressMap;\n+\n+        if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.STREAMS) {\n+            respStreamsAddressMap =\n+                    getStreamsAddressesMap(streamsAddressRequest.getStreamRangeList());\n+        } else if (streamsAddressRequest.getReqType() ==\n+                StreamsAddressRequestMsg.Type.ALL_STREAMS) {\n+            // Retrieve address space for all streams\n+            respStreamsAddressMap = new HashMap<>(streamsAddressMap);\n+        } else {\n+            throw new IllegalArgumentException(\"handleStreamsAddressRequest: \" +\n+                    \"Received an INVALID type of streamsAddressRequestMsg.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 823}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODYxMQ==", "bodyText": "Added, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552928611", "createdAt": "2021-01-06T19:49:06Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -617,56 +731,78 @@ private void handleAllocation(CorfuPayloadMsg<TokenRequest> msg,\n         }\n \n         // update the cache of conflict parameters\n-        if (req.getTxnResolution() != null) {\n-            req.getTxnResolution()\n-                    .getWriteConflictParams()\n-                    .forEach((key, value) -> {\n+        if (tokenRequest.hasTxnResolution()) {\n+            tokenRequest.getTxnResolution().getWriteConflictParamsSetList()\n+                    .forEach((item) -> {\n                         // insert an entry with the new timestamp using the\n                         // hash code based on the param and the stream id.\n-                        value.forEach(conflictParam ->\n-                                cache.put(new ConflictTxStream(key, conflictParam, newTail - 1)));\n+                        item.getValueList().forEach(conflictParam ->\n+                                cache.put(new ConflictTxStream(getUUID(item.getKey()),\n+                                        conflictParam.toByteArray(), newTail - 1)));\n                     });\n         }\n-\n-        log.trace(\"token {} backpointers {}\", globalLogTail, backPointerMap.build());\n-\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"handleAllocation: token={} backpointers={}\",\n+                    globalLogTail, backPointerMap.build());\n+        }\n         // return the token response with the global tail and the streams backpointers\n-        Token token = new Token(sequencerEpoch, globalLogTail);\n+        Token newToken = new Token(sequencerEpoch, globalLogTail);\n         globalLogTail = newTail;\n-        r.sendResponse(ctx, msg, CorfuMsgType.TOKEN_RES.payloadMsg(\n-                new TokenResponse(token, backPointerMap.build())));\n+\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(\n+                req.getHeader(), getTokenResponseMsg(newToken, backPointerMap.build()));\n+        r.sendResponse(response, ctx);\n     }\n \n     /**\n      * This method handles the request of streams addresses.\n-     *\n+     * <p>\n      * The request of address spaces can be of two types:\n-     *      - For specific streams (and specific ranges for each stream).\n-     *      - For all streams (complete range).\n-     *\n+     * - For specific streams (and specific ranges for each stream).\n+     * - For all streams (complete range).\n+     * <p>\n      * The response contains the requested streams address maps and the global log tail.\n      */\n-    @ServerHandler(type = CorfuMsgType.STREAMS_ADDRESS_REQUEST)\n-    private void handleStreamsAddressRequest(CorfuPayloadMsg<StreamsAddressRequest> msg,\n-                                             ChannelHandlerContext ctx, IServerRouter r) {\n-        StreamsAddressRequest req = msg.getPayload();\n-        Map<UUID, StreamAddressSpace> streamsAddressMap;\n-\n-        switch (req.getReqType()) {\n-            case StreamsAddressRequest.STREAMS:\n-                streamsAddressMap = getStreamsAddresses(req.getStreamsRanges());\n-                break;\n-\n-            default:\n-                // Retrieve address space for all streams\n-                streamsAddressMap = new HashMap<>(this.streamsAddressMap);\n-                break;\n+    @RequestHandler(type = PayloadCase.STREAMS_ADDRESS_REQUEST)\n+    private void handleStreamsAddressRequest(@Nonnull RequestMsg req,\n+                                             @Nonnull ChannelHandlerContext ctx,\n+                                             @Nonnull IServerRouter r) {\n+        StreamsAddressRequestMsg streamsAddressRequest =\n+                req.getPayload().getStreamsAddressRequest();\n+        Map<UUID, StreamAddressSpace> respStreamsAddressMap;\n+\n+        if (streamsAddressRequest.getReqType() == StreamsAddressRequestMsg.Type.STREAMS) {\n+            respStreamsAddressMap =\n+                    getStreamsAddressesMap(streamsAddressRequest.getStreamRangeList());\n+        } else if (streamsAddressRequest.getReqType() ==\n+                StreamsAddressRequestMsg.Type.ALL_STREAMS) {\n+            // Retrieve address space for all streams\n+            respStreamsAddressMap = new HashMap<>(streamsAddressMap);\n+        } else {\n+            throw new IllegalArgumentException(\"handleStreamsAddressRequest: \" +\n+                    \"Received an INVALID type of streamsAddressRequestMsg.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2MTM5OQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 823}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTg1NTU4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzo0NToxN1rOIOrmKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMjoyOFrOIPRyvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NTI1OA==", "bodyText": "Maybe consider factoring some of the common preparation code here? If nothing can be cleanly factored, consider updating the comment.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552265258", "createdAt": "2021-01-05T23:45:17Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;\n+\n+    // Using spy as we use the default behaviour most of the times and\n+    // override only a few times.\n+    @Spy\n+    private SequencerServer.SequencerFactoryHelper spySequencerFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MTA2OQ==", "bodyText": "Updated the comment, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552891069", "createdAt": "2021-01-06T18:32:28Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;\n+\n+    // Using spy as we use the default behaviour most of the times and\n+    // override only a few times.\n+    @Spy\n+    private SequencerServer.SequencerFactoryHelper spySequencerFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NTI1OA=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTg2NDM5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzo0Nzo1OFrOIOrrow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozMjozNlrOIPRy-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NjY1OQ==", "bodyText": "CASE 2:", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552266659", "createdAt": "2021-01-05T23:47:58Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;\n+\n+    // Using spy as we use the default behaviour most of the times and\n+    // override only a few times.\n+    @Spy\n+    private SequencerServer.SequencerFactoryHelper spySequencerFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap\n+     * message first.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        sequencerServer = new SequencerServer(mockServerContext, spySequencerFactoryHelper);\n+        // Make sequencer server's epoch 0L\n+        sequencerServer.setSequencerEpoch(0L);\n+        // ServerContext epoch is set only by the bootstrap request.\n+        // Make it return the Layout.INVALID_EPOCH (-1).\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, false),\n+                getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup i.e -1) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate\n+     * BootstrapSequencerRequestMsg, and return\n+     * {@link BootstrapSequencerResponseMsg}\n+     * with isBootstrapped set to False.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spySequencerFactoryHelper);\n+\n+        // CASE 1: the sequencer server's epoch = Layout.INVALID_EPOCH\n+        // and the epoch sent by the client is the consecutive epoch of the sequencerEpoch\n+        sequencerServer.setSequencerEpoch(Layout.INVALID_EPOCH);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg message with\n+        // isBootstrapped set to False and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getIsBootstrapped())\n+                .isFalse();\n+\n+        // Assert that the sequencerServer's and serverContext's Epoch has not changed\n+        assertEquals(Layout.INVALID_EPOCH, sequencerServer.getSequencerEpoch());\n+        verify(mockServerContext, never()).setSequencerEpoch(anyLong());\n+\n+        // CASE 1: the sequencer server's epoch != Layout.INVALID_EPOCH", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MTEyOA==", "bodyText": "Done, thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552891128", "createdAt": "2021-01-06T18:32:36Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;\n+\n+    // Using spy as we use the default behaviour most of the times and\n+    // override only a few times.\n+    @Spy\n+    private SequencerServer.SequencerFactoryHelper spySequencerFactoryHelper;\n+\n+    /**\n+     * A helper method that creates a basic message header populated\n+     * with default values.\n+     *\n+     * @param ignoreClusterId indicates if the message is clusterId aware\n+     * @param ignoreEpoch     indicates if the message is epoch aware\n+     * @return the corresponding HeaderMsg\n+     */\n+    private HeaderMsg getBasicHeader(boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestCounter.incrementAndGet(), PriorityLevel.NORMAL, 0L,\n+                getUuidMsg(DEFAULT_UUID), getUuidMsg(DEFAULT_UUID), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * A helper method that compares the base fields of two message headers.\n+     * These include the request ID, the epoch, the client ID, and the cluster ID.\n+     *\n+     * @param requestHeader  the header from the request message\n+     * @param responseHeader the header from the response message\n+     * @return true if the two headers have the same base field values\n+     */\n+    private boolean compareBaseHeaderFields(HeaderMsg requestHeader, HeaderMsg responseHeader) {\n+        return requestHeader.getRequestId() == responseHeader.getRequestId() &&\n+                requestHeader.getEpoch() == responseHeader.getEpoch() &&\n+                requestHeader.getClientId().equals(responseHeader.getClientId()) &&\n+                requestHeader.getClusterId().equals(responseHeader.getClusterId());\n+    }\n+\n+    /**\n+     * Perform the required preparation before running individual tests.\n+     * This includes preparing the mocks and initializing the DirectExecutorService.\n+     */\n+    @Before\n+    public void setup() {\n+        // Initialize with newDirectExecutorService to execute the server RPC\n+        // handler methods on the calling thread\n+        when(mockServerContext.getExecutorService(anyInt(), anyString()))\n+                .thenReturn(MoreExecutors.newDirectExecutorService());\n+    }\n+\n+    /**\n+     * Test that the SequencerServer sends NotReadyErrorMsg when client sends a TokenRequestMsg\n+     * without bootstrapping it before.\n+     * When ServerContext epoch and sequencer epoch are not equal, it expects the bootstrap\n+     * message first.\n+     * Essentially tests the {@link SequencerServer#isServerReadyToHandleMsg(RequestMsg)} method.\n+     */\n+    @Test\n+    public void testSequencerServerNotReady() {\n+        sequencerServer = new SequencerServer(mockServerContext, spySequencerFactoryHelper);\n+        // Make sequencer server's epoch 0L\n+        sequencerServer.setSequencerEpoch(0L);\n+        // ServerContext epoch is set only by the bootstrap request.\n+        // Make it return the Layout.INVALID_EPOCH (-1).\n+        when(mockServerContext.getServerEpoch()).thenReturn(Layout.INVALID_EPOCH);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, false),\n+                getTokenRequestMsg(0, Collections.emptyList())\n+        );\n+\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a SERVER_ERROR and that the base\n+        // header fields have remained the same\n+        assertTrue(compareBaseHeaderFields(request.getHeader(), response.getHeader()));\n+        assertTrue(response.getPayload().hasServerError());\n+        assertTrue(response.getPayload().getServerError().hasNotReadyError());\n+    }\n+\n+\n+    /**\n+     * Test that if sequencer server's epoch is Layout.INVALID_EPOCH (startup i.e -1) OR\n+     * if epoch sent by the client is not the consecutive epoch of the sequencerEpoch\n+     * then the sequencer should not accept bootstrapWithoutTailsUpdate\n+     * BootstrapSequencerRequestMsg, and return\n+     * {@link BootstrapSequencerResponseMsg}\n+     * with isBootstrapped set to False.\n+     */\n+    @Test\n+    public void testRequireFullBootstrap() {\n+        sequencerServer = new SequencerServer(mockServerContext, spySequencerFactoryHelper);\n+\n+        // CASE 1: the sequencer server's epoch = Layout.INVALID_EPOCH\n+        // and the epoch sent by the client is the consecutive epoch of the sequencerEpoch\n+        sequencerServer.setSequencerEpoch(Layout.INVALID_EPOCH);\n+\n+        RequestMsg request = getRequestMsg(\n+                getBasicHeader(false, false),\n+                getBootstrapSequencerRequestMsg(\n+                        Collections.emptyMap(),\n+                        0,\n+                        0,\n+                        true)\n+        );\n+\n+        // Invoke the handler method\n+        sequencerServer.handleMessage(request, mockChannelHandlerContext, mockServerRouter);\n+\n+        // Verify that sendResponse() was called and capture the response object\n+        ArgumentCaptor<ResponseMsg> responseCaptor = ArgumentCaptor.forClass(ResponseMsg.class);\n+        verify(mockServerRouter)\n+                .sendResponse(responseCaptor.capture(), any(ChannelHandlerContext.class));\n+        ResponseMsg response = responseCaptor.getValue();\n+\n+        // Assert that the payload has a BootstrapSequencerResponseMsg message with\n+        // isBootstrapped set to False and that the base header fields have remained the same\n+        assertThat(compareBaseHeaderFields(request.getHeader(), response.getHeader())).isTrue();\n+        assertThat(response.getPayload().hasBootstrapSequencerResponse()).isTrue();\n+        assertThat(response.getPayload().getBootstrapSequencerResponse().getIsBootstrapped())\n+                .isFalse();\n+\n+        // Assert that the sequencerServer's and serverContext's Epoch has not changed\n+        assertEquals(Layout.INVALID_EPOCH, sequencerServer.getSequencerEpoch());\n+        verify(mockServerContext, never()).setSequencerEpoch(anyLong());\n+\n+        // CASE 1: the sequencer server's epoch != Layout.INVALID_EPOCH", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2NjY1OQ=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NTg3NzY3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQyMzo1MToyNlrOIOr0Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODozNTozNFrOIPR4pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2ODgyMg==", "bodyText": "Out of curiosity, why does this need to be mocked?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552268822", "createdAt": "2021-01-05T23:51:26Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg5MjU4MA==", "bodyText": "These two maps were exposed to have some verifications in the test cases, but we now use new HashMap<>() pattern in the SequencerServer and don't want to go into such details in tests, so they are deleted.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552892580", "createdAt": "2021-01-06T18:35:34Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/test/java/org/corfudb/infrastructure/SequencerServerTest.java", "diffHunk": "@@ -0,0 +1,986 @@\n+package org.corfudb.infrastructure;\n+\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.ByteString;\n+import io.netty.channel.ChannelHandlerContext;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.protocols.wireprotocol.TokenResponse;\n+import org.corfudb.protocols.wireprotocol.TokenType;\n+import org.corfudb.protocols.wireprotocol.TxResolutionInfo;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.Sequencer.SequencerMetricsResponseMsg;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.ObjectInputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.corfudb.protocols.CorfuProtocolCommon.DEFAULT_UUID;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getStreamAddressSpace;\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getHeaderMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolMessage.getRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getAllStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getBootstrapSequencerRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getDefaultSequencerMetricsRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getSequencerTrimRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getStreamsAddressRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenRequestMsg;\n+import static org.corfudb.protocols.service.CorfuProtocolSequencer.getTokenResponse;\n+import static org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.BootstrapSequencerResponseMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.StreamsAddressRequestMsg;\n+import static org.corfudb.runtime.proto.service.Sequencer.TokenRequestMsg;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * This class has test methods that test the RPC calls present in {@link SequencerServer}.\n+ * The RequestMsg type messages that are tested are as follows -\n+ * - TokenRequestMsg\n+ * - BootstrapSequencerRequestMsg\n+ * - SequencerTrimRequestMsg\n+ * - SequencerMetricsRequestMsg\n+ * - StreamsAddressRequestMsg\n+ * See test methods for their functionality descriptions.\n+ */\n+@Slf4j\n+public class SequencerServerTest {\n+\n+    private final AtomicInteger requestCounter = new AtomicInteger();\n+\n+    @Rule\n+    public MockitoRule mockito = MockitoJUnit.rule();\n+\n+    // The SequencerServer instance used for testing\n+    private SequencerServer sequencerServer;\n+\n+    // Parameters that need to be mocked\n+    @Mock\n+    private ServerContext mockServerContext;\n+    @Mock\n+    private IServerRouter mockServerRouter;\n+    @Mock\n+    private ChannelHandlerContext mockChannelHandlerContext;\n+    @Mock\n+    private Map<UUID, StreamAddressSpace> mockStreamAddressSpaceMap;\n+    @Mock\n+    private Map<UUID, Long> mockStreamTailToGlobalTailMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI2ODgyMg=="}, "originalCommit": {"oid": "da9a463f1f7f612b02d6f7589292f64fb94a143b"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDI5MzE5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMToyOTo1NlrOIPWoIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo1NjowNVrOIPXQHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3MDI3Mw==", "bodyText": "These changes to the LayoutServer are addressing comments from the LayoutServer PR ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552970273", "createdAt": "2021-01-06T21:29:56Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -431,8 +435,9 @@ private void forceLayout(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext\n     // TODO as this message is not set to ignore EPOCH.\n     // TODO How do we handle holes in history if we let in layout commit message. Maybe we have a\n     // TODO hole filling process\n+    @VisibleForTesting\n     @RequestHandler(type = RequestPayloadMsg.PayloadCase.COMMIT_LAYOUT_REQUEST)\n-    public void handleCommitLayoutRequest(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext ctx,\n+    void handleCommitLayoutRequest(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext ctx,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e8d0b89fa8c016b7f697b486dc1ddd5e3a3d6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk4MDUwOQ==", "bodyText": "Yes they are", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552980509", "createdAt": "2021-01-06T21:56:05Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LayoutServer.java", "diffHunk": "@@ -431,8 +435,9 @@ private void forceLayout(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext\n     // TODO as this message is not set to ignore EPOCH.\n     // TODO How do we handle holes in history if we let in layout commit message. Maybe we have a\n     // TODO hole filling process\n+    @VisibleForTesting\n     @RequestHandler(type = RequestPayloadMsg.PayloadCase.COMMIT_LAYOUT_REQUEST)\n-    public void handleCommitLayoutRequest(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext ctx,\n+    void handleCommitLayoutRequest(@Nonnull RequestMsg req, @Nonnull ChannelHandlerContext ctx,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3MDI3Mw=="}, "originalCommit": {"oid": "0d0e8d0b89fa8c016b7f697b486dc1ddd5e3a3d6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDMyOTQzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMTo0NDoxNVrOIPW99A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMzowNDo0MFrOIPY-qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NTg2MA==", "bodyText": "sequencerEpoch should probably be a private volatile.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r552975860", "createdAt": "2021-01-06T21:44:15Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +495,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n             streamTailToGlobalTailMap = new HashMap<>();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n-            this.streamsAddressMap.putAll(addressSpaceMap);\n+            streamsAddressMap = new HashMap<>();\n+            streamsAddressMap.putAll(addressSpaceMap);\n \n-            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : this.streamsAddressMap.entrySet()) {\n-                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range [{}-{}], \" +\n-                                \"on sequencer reset.\",\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    streamsAddressMap.entrySet()) {\n+                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range\" +\n+                                \" [{}-{}], on sequencer reset.\",\n                         Utils.toReadableId(streamAddressSpace.getKey()),\n                         streamAddressSpace.getValue().getTrimMark(),\n                         streamAddressSpace.getValue().getAddressMap().getLongCardinality(),\n                         streamAddressSpace.getValue().getLowestAddress(),\n                         streamAddressSpace.getValue().getHighestAddress());\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Stream[{}] address map on sequencer reset: {}\",\n-                            Utils.toReadableId(streamAddressSpace.getKey()), streamAddressSpace.getValue().getAddressMap());\n+                            Utils.toReadableId(streamAddressSpace.getKey()),\n+                            streamAddressSpace.getValue().getAddressMap());\n                 }\n             }\n         }\n \n         // Update epochRangeLowerBound if the bootstrap epoch is not consecutive.\n-        if (epochRangeLowerBound == Layout.INVALID_EPOCH || bootstrapMsgEpoch != sequencerEpoch + 1) {\n+        if (epochRangeLowerBound == Layout.INVALID_EPOCH\n+                || bootstrapMsgEpoch != sequencerEpoch + 1) {\n             epochRangeLowerBound = bootstrapMsgEpoch;\n         }\n \n         // Mark the sequencer as ready after the tails have been populated.\n-        sequencerEpoch = bootstrapMsgEpoch;\n+        setSequencerEpoch(bootstrapMsgEpoch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e8d0b89fa8c016b7f697b486dc1ddd5e3a3d6"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwODgwOA==", "bodyText": "Done,  thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2829#discussion_r553008808", "createdAt": "2021-01-06T23:04:40Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/SequencerServer.java", "diffHunk": "@@ -419,114 +495,141 @@ public void resetServer(CorfuPayloadMsg<SequencerRecoveryMsg> msg,\n         // Note, this is correct, but conservative (may lead to false abort).\n         // It is necessary because we reset the sequencer.\n         if (!bootstrapWithoutTailsUpdate) {\n-            globalLogTail = msg.getPayload().getGlobalTail();\n+            globalLogTail = req.getPayload().getBootstrapSequencerRequest().getGlobalTail();\n             // Deregister gauges\n             MeterRegistryProvider.deregisterServerMeter(cache.getConflictKeysCounterName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n             MeterRegistryProvider.deregisterServerMeter(cache.getWindowSizeName(),\n                     Tags.empty(), Meter.Type.GAUGE);\n-            cache = new SequencerServerCache(cache.getCacheSize(), globalLogTail - 1);\n+            cache = sequencerFactoryHelper.getSequencerServerCache(\n+                    cache.getCacheSize(),\n+                    globalLogTail - 1\n+            );\n+\n             // Clear the existing map as it could have been populated by an earlier reset.\n             streamTailToGlobalTailMap = new HashMap<>();\n \n             // Set tail for every stream\n-            for(Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : addressSpaceMap.entrySet()) {\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    addressSpaceMap.entrySet()) {\n                 Long streamTail = streamAddressSpace.getValue().getTail();\n-                log.trace(\"On Sequencer reset, tail for stream {} set to {}\", streamAddressSpace.getKey(), streamTail);\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"On Sequencer reset, tail for stream {} set to {}\",\n+                            streamAddressSpace.getKey(), streamTail);\n+                }\n                 streamTailToGlobalTailMap.put(streamAddressSpace.getKey(), streamTail);\n             }\n \n             // Reset streams address map\n-            this.streamsAddressMap = new HashMap<>();\n-            this.streamsAddressMap.putAll(addressSpaceMap);\n+            streamsAddressMap = new HashMap<>();\n+            streamsAddressMap.putAll(addressSpaceMap);\n \n-            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace : this.streamsAddressMap.entrySet()) {\n-                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range [{}-{}], \" +\n-                                \"on sequencer reset.\",\n+            for (Map.Entry<UUID, StreamAddressSpace> streamAddressSpace :\n+                    streamsAddressMap.entrySet()) {\n+                log.info(\"Stream[{}] set to last trimmed address {} and {} addresses in the range\" +\n+                                \" [{}-{}], on sequencer reset.\",\n                         Utils.toReadableId(streamAddressSpace.getKey()),\n                         streamAddressSpace.getValue().getTrimMark(),\n                         streamAddressSpace.getValue().getAddressMap().getLongCardinality(),\n                         streamAddressSpace.getValue().getLowestAddress(),\n                         streamAddressSpace.getValue().getHighestAddress());\n                 if (log.isTraceEnabled()) {\n                     log.trace(\"Stream[{}] address map on sequencer reset: {}\",\n-                            Utils.toReadableId(streamAddressSpace.getKey()), streamAddressSpace.getValue().getAddressMap());\n+                            Utils.toReadableId(streamAddressSpace.getKey()),\n+                            streamAddressSpace.getValue().getAddressMap());\n                 }\n             }\n         }\n \n         // Update epochRangeLowerBound if the bootstrap epoch is not consecutive.\n-        if (epochRangeLowerBound == Layout.INVALID_EPOCH || bootstrapMsgEpoch != sequencerEpoch + 1) {\n+        if (epochRangeLowerBound == Layout.INVALID_EPOCH\n+                || bootstrapMsgEpoch != sequencerEpoch + 1) {\n             epochRangeLowerBound = bootstrapMsgEpoch;\n         }\n \n         // Mark the sequencer as ready after the tails have been populated.\n-        sequencerEpoch = bootstrapMsgEpoch;\n+        setSequencerEpoch(bootstrapMsgEpoch);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NTg2MA=="}, "originalCommit": {"oid": "0d0e8d0b89fa8c016b7f697b486dc1ddd5e3a3d6"}, "originalPosition": 528}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1796, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}