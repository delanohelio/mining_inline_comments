{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2Mzg0MTk3", "number": 2699, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzoxNzo0OFrOEXaf-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTo1NTowM1rOEYmY1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTg2ODcyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzoxNzo0OFrOG_MaLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMzozNjo0OVrOG_MxlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjc4MQ==", "bodyText": "Make private and remove Secondary indexes.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r468916781", "createdAt": "2020-08-11T23:17:48Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -36,31 +37,30 @@\n  *\n  * Created by hisundar on 5/8/19.\n  *\n- * @param <E>   Type of the entry to be enqueued into the persisted queue\n  */\n @Slf4j\n-public class CorfuQueue<E> {\n+public class CorfuQueue {\n     /**\n      * The main CorfuTable which contains the primary key-value mappings.\n      */\n-    private final CorfuTable<CorfuRecordId, E> corfuTable;\n+    private final CorfuTable<CorfuRecordId, ByteString> corfuTable;\n     private final CorfuGuidGenerator guidGenerator;\n \n-    public CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer,\n-                      Index.Registry<CorfuRecordId, E> indices) {\n-        final Supplier<StreamingMap<CorfuRecordId, E>> mapSupplier =\n-                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, E>());\n+    public CorfuQueue(CorfuRuntime runtime, String streamName,\n+                      Index.Registry<CorfuRecordId, ByteString> indices) {\n+        final Supplier<StreamingMap<CorfuRecordId, ByteString>> mapSupplier =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52b9e734a7eef97485c0a9f7a174ce2c60f9eee"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyMjc3Mw==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r468922773", "createdAt": "2020-08-11T23:36:49Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -36,31 +37,30 @@\n  *\n  * Created by hisundar on 5/8/19.\n  *\n- * @param <E>   Type of the entry to be enqueued into the persisted queue\n  */\n @Slf4j\n-public class CorfuQueue<E> {\n+public class CorfuQueue {\n     /**\n      * The main CorfuTable which contains the primary key-value mappings.\n      */\n-    private final CorfuTable<CorfuRecordId, E> corfuTable;\n+    private final CorfuTable<CorfuRecordId, ByteString> corfuTable;\n     private final CorfuGuidGenerator guidGenerator;\n \n-    public CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer,\n-                      Index.Registry<CorfuRecordId, E> indices) {\n-        final Supplier<StreamingMap<CorfuRecordId, E>> mapSupplier =\n-                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, E>());\n+    public CorfuQueue(CorfuRuntime runtime, String streamName,\n+                      Index.Registry<CorfuRecordId, ByteString> indices) {\n+        final Supplier<StreamingMap<CorfuRecordId, ByteString>> mapSupplier =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkxNjc4MQ=="}, "originalCommit": {"oid": "d52b9e734a7eef97485c0a9f7a174ce2c60f9eee"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDc4NTcwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzoxNjoyNlrOG_UxDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMDoyNDo0MFrOG_xI-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzcwOQ==", "bodyText": "Add support to add CorfuQueue to the MultiCheckpointWriter", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r469053709", "createdAt": "2020-08-12T07:16:26Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -36,32 +39,30 @@\n  *\n  * Created by hisundar on 5/8/19.\n  *\n- * @param <E>   Type of the entry to be enqueued into the persisted queue\n  */\n @Slf4j\n-public class CorfuQueue<E> {\n+public class CorfuQueue {\n     /**\n      * The main CorfuTable which contains the primary key-value mappings.\n      */\n-    private final CorfuTable<CorfuRecordId, E> corfuTable;\n+    private final CorfuTable<CorfuRecordId, ByteString> corfuTable;\n     private final CorfuGuidGenerator guidGenerator;\n \n-    public CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer,\n-                      Index.Registry<CorfuRecordId, E> indices) {\n-        final Supplier<StreamingMap<CorfuRecordId, E>> mapSupplier =\n-                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, E>());\n+    @VisibleForTesting\n+    CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer) {\n+        final Supplier<StreamingMap<CorfuRecordId, ByteString>> mapSupplier =\n+                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, ByteString>());\n         corfuTable = runtime.getObjectsView().build()\n-                .setTypeToken(new TypeToken<CorfuTable<CorfuRecordId, E>>() {})\n+                .setTypeToken(new TypeToken<CorfuTable<CorfuRecordId, ByteString>>() {})\n                 .setStreamName(streamName)\n-                .setArguments(indices, mapSupplier)\n+                .setArguments(Index.Registry.empty(), mapSupplier)\n                 .setSerializer(serializer)\n                 .open();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a1fd2b715245403b412bee1063dd232307a770c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUxODU4NA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r469518584", "createdAt": "2020-08-12T20:24:40Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -36,32 +39,30 @@\n  *\n  * Created by hisundar on 5/8/19.\n  *\n- * @param <E>   Type of the entry to be enqueued into the persisted queue\n  */\n @Slf4j\n-public class CorfuQueue<E> {\n+public class CorfuQueue {\n     /**\n      * The main CorfuTable which contains the primary key-value mappings.\n      */\n-    private final CorfuTable<CorfuRecordId, E> corfuTable;\n+    private final CorfuTable<CorfuRecordId, ByteString> corfuTable;\n     private final CorfuGuidGenerator guidGenerator;\n \n-    public CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer,\n-                      Index.Registry<CorfuRecordId, E> indices) {\n-        final Supplier<StreamingMap<CorfuRecordId, E>> mapSupplier =\n-                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, E>());\n+    @VisibleForTesting\n+    CorfuQueue(CorfuRuntime runtime, String streamName, ISerializer serializer) {\n+        final Supplier<StreamingMap<CorfuRecordId, ByteString>> mapSupplier =\n+                () -> new StreamingMapDecorator<>(new LinkedHashMap<CorfuRecordId, ByteString>());\n         corfuTable = runtime.getObjectsView().build()\n-                .setTypeToken(new TypeToken<CorfuTable<CorfuRecordId, E>>() {})\n+                .setTypeToken(new TypeToken<CorfuTable<CorfuRecordId, ByteString>>() {})\n                 .setStreamName(streamName)\n-                .setArguments(indices, mapSupplier)\n+                .setArguments(Index.Registry.empty(), mapSupplier)\n                 .setSerializer(serializer)\n                 .open();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzcwOQ=="}, "originalCommit": {"oid": "8a1fd2b715245403b412bee1063dd232307a770c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAwMDgwOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTozNjo1MVrOG_zvEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMToyODo1OVrOHAeXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA==", "bodyText": "just wondering for code coverage of the sequence and id part can this test case wrap the enqueue in a transaction?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r469561104", "createdAt": "2020-08-12T21:36:51Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTIyMA==", "bodyText": "I think there's a bug. When I wrap oldQueueInstance1 with a transaction, but not oldQueueInstance2, then the read order is flipped. If there is no transaction, then how is addPreCommitListener called?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470041220", "createdAt": "2020-08-13T15:33:43Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE0NTkwOA==", "bodyText": "it won't be called - we can't support a mixed case like that anyway", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470145908", "createdAt": "2020-08-13T18:01:45Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE0ODAzMA==", "bodyText": "Why not?\nIf it's not allowed then the operation should be failed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470148030", "createdAt": "2020-08-13T18:05:37Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE0ODcyMw==", "bodyText": "Also, most of the tests don't use transactions to produce to the queue, so I'm not sure why this isnt allowed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470148723", "createdAt": "2020-08-13T18:06:49Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE1NzI5NA==", "bodyText": "Even if we don't mix transactional and non-transaction. Just having non-transactional enqueues will produce an incorrect order.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470157294", "createdAt": "2020-08-13T18:22:09Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE5ODIwNQ==", "bodyText": "so you suggest we just throw error if queue is used outside a transaction?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470198205", "createdAt": "2020-08-13T19:31:27Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1OTU2Ng==", "bodyText": "Yea, it won't make sense to allow it if its incorrect. #2712", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470259566", "createdAt": "2020-08-13T21:28:59Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,133 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MTEwNA=="}, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNDAwOTkzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MDowM1rOG_z0dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQyMTo0MDowM1rOG_z0dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjQ4NQ==", "bodyText": "No you are right - the sequence should not be included here. perhaps you can remove the TODO?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r469562485", "createdAt": "2020-08-12T21:40:03Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -135,6 +147,24 @@ public boolean equals(Object o) {\n             return getEntryId() == that.getEntryId();\n         }\n \n+        @Override\n+        public byte[] generateCorfuHash() {\n+            // Note that this hash is used for transaction conflict resolution and shouldn't\n+            // generate collisions for different entries\n+            // TODO(Maithem) this probably needs the sequence number to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8962d75d58b3cafbf4bb26d28969ce23a289bb0"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY2NTIxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/util/serializer/CorfuQueueSerializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNzowMFrOHAfVrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNzowMFrOHAfVrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTUwMw==", "bodyText": "maybe rename to tag? It has the same name as the serializer type.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470275503", "createdAt": "2020-08-13T22:07:00Z", "author": {"login": "zhangn49"}, "path": "runtime/src/main/java/org/corfudb/util/serializer/CorfuQueueSerializer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package org.corfudb.util.serializer;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+\n+import com.google.protobuf.ByteString;\n+import io.netty.buffer.ByteBuf;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.collections.CorfuQueue;\n+\n+public class CorfuQueueSerializer implements ISerializer {\n+\n+    // Serialization tag for a queue's metadata entry\n+    private final byte entryRecordIdMarker = 1;\n+\n+    // Serialization tag for the queue's payload\n+    private final byte entryPayloadMarker = 2;\n+\n+    private final byte type;\n+\n+    public CorfuQueueSerializer(byte type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public byte getType() {\n+        return type;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Object deserialize(ByteBuf b, CorfuRuntime rt) {\n+        byte type = b.readByte();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d956b59037e7a13efb45e66a27a0ae870d5e13b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY4MDY5OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoxMzoxMVrOHAffDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoxMzoxMVrOHAffDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NzkwMg==", "bodyText": "Will this test fail after #2712 ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470277902", "createdAt": "2020-08-13T22:13:11Z", "author": {"login": "zhangn49"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -105,9 +117,136 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            System.out.println(b);\n+            log.debug(\"Entry {}\", b);\n         }\n+    }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                getDefaultRuntime().getObjectsView().TXBegin();\n+                oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));\n+                getDefaultRuntime().getObjectsView().TXEnd();\n+            } else {\n+                oldQueueInstance2.enqueue(getByteString(String.valueOf(itemIdx)));\n+            }\n+        });\n \n+        // Verify that a new client is able to see all items produced from the different\n+        // clients\n+        CorfuRuntime rt3 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue newQueueInstance= new CorfuQueue(rt3, \"test\");\n \n+        assertThat(newQueueInstance.size()).isEqualTo(numItemsToProduce);\n+\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            System.out.println(newQueueInstance.entryList().get(itemIdx).getEntry().toStringUtf8());\n+            //assertThat(newQueueInstance.entryList().get(itemIdx).getEntry().toStringUtf8())\n+              ///      .isEqualTo(String.valueOf(itemIdx));\n+        });\n+    }\n+\n+    @Test\n+    public void queueMapCompatibility() {\n+\n+        // Produce some items to the corfu queue\n+        CorfuQueue queue = new CorfuQueue(getDefaultRuntime(), \"test\");\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            queue.enqueue(getByteString(String.valueOf(itemIdx)));\n+        });\n+\n+        // Verify that the queue can be opened as a map object\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuTable<CorfuQueue.CorfuRecordId, ByteString> map = rt2.getObjectsView()\n+                .build()\n+                .setStreamName(\"test\")\n+                .setTypeToken(new TypeToken<CorfuTable<CorfuQueue.CorfuRecordId, ByteString>>() {})\n+                .setSerializer(Serializers.QUEUE_SERIALIZER)\n+                .open();\n+\n+        assertThat(map.size()).isEqualTo(numItemsToProduce);\n+\n+        Set<String> entryPayloads = map.entryStream()\n+                .map(Map.Entry::getValue)\n+                .map(ByteString::toStringUtf8)\n+                .collect(Collectors.toSet());\n+\n+        assertThat(entryPayloads.size()).isEqualTo(numItemsToProduce);\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            assertThat(entryPayloads).contains(String.valueOf(itemIdx));\n+        });\n+    }\n+\n+    @Test\n+    public void queueCheckpointTest() {\n+\n+        // Produce to two different queues using the old and new serializer\n+        CorfuQueue queueInstance1 = new CorfuQueue(getDefaultRuntime(), \"stream1\",\n+                Serializers.JSON);\n+\n+        CorfuQueue queueInstance2 = new CorfuQueue(getDefaultRuntime(), \"stream2\");\n+\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            queueInstance1.enqueue(getByteString(String.valueOf(itemIdx)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d956b59037e7a13efb45e66a27a0ae870d5e13b"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjMwMjMwOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTo1NTowM1rOHBBoZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxOTo1NTowM1rOHBBoZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNzM0OQ==", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "url": "https://github.com/CorfuDB/CorfuDB/pull/2699#discussion_r470837349", "createdAt": "2020-08-14T19:55:03Z", "author": {"login": "corfudb-bot"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -124,7 +131,138 @@ public String toString() {\n         bmap.put(new ByteArray(\"fg\".getBytes()), \"fg\");\n         bmap.put(new ByteArray(\"abcd\".getBytes()), \"abcd\");\n         for (Map.Entry<ByteArray, String> b : bmap.entrySet()) {\n-            log.debug(\"{}\", b);\n+            log.debug(\"Entry {}\", b);\n         }\n     }\n+\n+    @Test\n+    public void queueBackwardsCompatibility() {\n+        CorfuQueue oldQueueInstance1 = new CorfuQueue(getDefaultRuntime(), \"test\",\n+                Serializers.JSON);\n+\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue oldQueueInstance2 = new CorfuQueue(rt2, \"test\",\n+                Serializers.QUEUE_SERIALIZER);\n+\n+        // produce items to the queue with two different serializers from two different clients\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            if (itemIdx % 2 == 0) {\n+                executeTxn(getDefaultRuntime(),\n+                        () -> oldQueueInstance1.enqueue(getByteString(String.valueOf(itemIdx))));\n+            } else {\n+                executeTxn(rt2,\n+                        () -> oldQueueInstance2.enqueue(getByteString(String.valueOf(itemIdx))));\n+            }\n+        });\n+\n+        // Verify that a new client is able to see all items produced from the different\n+        // clients\n+        CorfuRuntime rt3 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuQueue newQueueInstance= new CorfuQueue(rt3, \"test\");\n+\n+        assertThat(newQueueInstance.size()).isEqualTo(numItemsToProduce);\n+\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            assertThat(newQueueInstance.entryList().get(itemIdx).getEntry().toStringUtf8())\n+                    .isEqualTo(String.valueOf(itemIdx));\n+        });\n+    }\n+\n+    @Test\n+    public void queueMapCompatibility() {\n+\n+        // Produce some items to the corfu queue\n+        CorfuQueue queue = new CorfuQueue(getDefaultRuntime(), \"test\");\n+        final int numItemsToProduce = 10;\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            executeTxn(getDefaultRuntime(),\n+                    () -> queue.enqueue(getByteString(String.valueOf(itemIdx))));\n+        });\n+\n+        // Verify that the queue can be opened as a map object\n+        CorfuRuntime rt2 = getNewRuntime(getDefaultNode()).connect();\n+        CorfuTable<CorfuQueue.CorfuRecordId, ByteString> map = rt2.getObjectsView()\n+                .build()\n+                .setStreamName(\"test\")\n+                .setTypeToken(new TypeToken<CorfuTable<CorfuQueue.CorfuRecordId, ByteString>>() {})\n+                .setSerializer(Serializers.QUEUE_SERIALIZER)\n+                .open();\n+\n+        assertThat(map.size()).isEqualTo(numItemsToProduce);\n+\n+        Set<String> entryPayloads = map.entryStream()\n+                .map(Map.Entry::getValue)\n+                .map(ByteString::toStringUtf8)\n+                .collect(Collectors.toSet());\n+\n+        assertThat(entryPayloads.size()).isEqualTo(numItemsToProduce);\n+        IntStream.range(0, numItemsToProduce).forEach(itemIdx -> {\n+            assertThat(entryPayloads).contains(String.valueOf(itemIdx));\n+        });\n+    }\n+\n+    @Test\n+    public void queueCheckpointTest() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "650d2e403a6bf5d234a8712146f365ce1925ef56"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1912, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}