{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MDE4MTk3", "number": 2495, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0Mjo1NlrODtN8gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTozMjowMlrODtWD2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQwOTk0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0Mjo1NlrOF-hCcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMzozNzowN1rOF-r53Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5NzMzMA==", "bodyText": "is it possible to get rid of setters?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401097330", "createdAt": "2020-03-31T17:42:56Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,23 +77,21 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEzMjA1Ng==", "bodyText": "no, it breaks SMR if we create a new object - we must modify the exact value that was added to the table's hash map.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401132056", "createdAt": "2020-03-31T18:40:05Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,23 +77,21 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5NzMzMA=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3NTM1Nw==", "bodyText": "not sure about SMR, but if you are going to change these fields and use them to calculate hashCode then it is very dangerous operation you can break HashMap by that.\nI mean if you change those fields after you add it to any java data structure like HashMap, Queue and so on, you will not be able to find that entry in the data structure", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401275357", "createdAt": "2020-03-31T23:37:07Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,23 +77,21 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5NzMzMA=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQzMTMzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0ODoyOVrOF-hP1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODo1NDowM1rOF-jrkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDc1OQ==", "bodyText": "When you implement equals method you have to implement a hashCode method, if not then functionality will be broken.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401100759", "createdAt": "2020-03-31T17:48:29Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -123,11 +114,11 @@ public int compareTo(CorfuRecordId o) {\n          * @return\n          */\n         public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+            return (epoch == o.getEpoch()) && (sequence == o.getSequence()) && entryId == o.getEntryId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE0MDYyNw==", "bodyText": "done. thanks!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401140627", "createdAt": "2020-03-31T18:54:03Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -123,11 +114,11 @@ public int compareTo(CorfuRecordId o) {\n          * @return\n          */\n         public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+            return (epoch == o.getEpoch()) && (sequence == o.getSequence()) && entryId == o.getEntryId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDc1OQ=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQzOTE0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1MDozMlrOF-hUvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODozOToxNFrOF-jIIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMjAxMw==", "bodyText": "Also, please add @Owerride", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401102013", "createdAt": "2020-03-31T17:50:32Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -123,11 +114,11 @@ public int compareTo(CorfuRecordId o) {\n          * @return\n          */\n         public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+            return (epoch == o.getEpoch()) && (sequence == o.getSequence()) && entryId == o.getEntryId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEzMTU1NQ==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401131555", "createdAt": "2020-03-31T18:39:14Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -123,11 +114,11 @@ public int compareTo(CorfuRecordId o) {\n          * @return\n          */\n         public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+            return (epoch == o.getEpoch()) && (sequence == o.getSequence()) && entryId == o.getEntryId();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMjAxMw=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQ1MzAzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1NDowMlrOF-hdaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxMTo1NFrOF-kU0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDIzMw==", "bodyText": "You must be very careful with setters. They always bring much more complexity to the code, make it fragile, more complicated to analyze and there are always problems with concurrency.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401104233", "createdAt": "2020-03-31T17:54:02Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -172,6 +180,7 @@ public CorfuRecordId enqueue(E e) {\n          * because if this method is wrapped in a transaction, the order is established only later.\n          */\n         @Getter\n+        @Setter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEzMTQ0MQ==", "bodyText": "yes unfortunately we do not have access to the commit sequence and epoch until the transaction actually commits, so we cannot go with immutable construct. It has to be set later, creating a new copy would break it away from the SMR version.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401131441", "createdAt": "2020-03-31T18:39:04Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -172,6 +180,7 @@ public CorfuRecordId enqueue(E e) {\n          * because if this method is wrapped in a transaction, the order is established only later.\n          */\n         @Getter\n+        @Setter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDIzMw=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MTE4Ng==", "bodyText": "sad to hear that we can't afford immutability, so, ok", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401151186", "createdAt": "2020-03-31T19:11:54Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -172,6 +180,7 @@ public CorfuRecordId enqueue(E e) {\n          * because if this method is wrapped in a transaction, the order is established only later.\n          */\n         @Getter\n+        @Setter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDIzMw=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQ1NTcwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1NDo0MlrOF-hfDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxMDo0M1rOF-kRvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDY1NQ==", "bodyText": "why not to pass CorfuRecordId as a parameter?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401104655", "createdAt": "2020-03-31T17:54:42Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -181,8 +190,8 @@ public String toString() {\n             return String.format(\"%s=>%s\", recordId, entry);\n         }\n \n-        CorfuQueueRecord(long ordering, long entryId, E entry) {\n-            this.recordId = new CorfuRecordId(ordering, entryId);\n+        CorfuQueueRecord(long epoch, long ordering, long entryId, E entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEzMDUzMA==", "bodyText": "because these fields need to be accessed and set individually at different times I thought it would be cleaner to separate those two.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401130530", "createdAt": "2020-03-31T18:37:33Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -181,8 +190,8 @@ public String toString() {\n             return String.format(\"%s=>%s\", recordId, entry);\n         }\n \n-        CorfuQueueRecord(long ordering, long entryId, E entry) {\n-            this.recordId = new CorfuRecordId(ordering, entryId);\n+        CorfuQueueRecord(long epoch, long ordering, long entryId, E entry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDY1NQ=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MDM5Nw==", "bodyText": "ok", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401150397", "createdAt": "2020-03-31T19:10:43Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -181,8 +190,8 @@ public String toString() {\n             return String.format(\"%s=>%s\", recordId, entry);\n         }\n \n-        CorfuQueueRecord(long ordering, long entryId, E entry) {\n-            this.recordId = new CorfuRecordId(ordering, entryId);\n+        CorfuQueueRecord(long epoch, long ordering, long entryId, E entry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNDY1NQ=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQ2NDQ4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1NzowMVrOF-hkqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODozNjowNlrOF-jAlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjA5MQ==", "bodyText": "Please don't use TransactionalContext as a prefix. Please add TransactionalContext to imports", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401106091", "createdAt": "2020-03-31T17:57:01Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +250,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener);\n+\n+    @Getter\n+    private List<TransactionalContext.PreCommitListener> preCommitListeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyOTYyMg==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401129622", "createdAt": "2020-03-31T18:36:06Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +250,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener);\n+\n+    @Getter\n+    private List<TransactionalContext.PreCommitListener> preCommitListeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjA5MQ=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzQ2NjA0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1NzoyN1rOF-hlpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODozNTo1OFrOF-jAQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjM0Mw==", "bodyText": "please add TransactionalContext to imports", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401106343", "createdAt": "2020-03-31T17:57:27Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "diffHunk": "@@ -85,4 +85,9 @@ public SnapshotTransactionalContext(Transaction transaction) {\n     public void addTransaction(AbstractTransactionalContext tc) {\n         throw new UnsupportedOperationException(\"Can't merge into a readonly txn (yet)\");\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyOTUzOA==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401129538", "createdAt": "2020-03-31T18:35:58Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "diffHunk": "@@ -85,4 +85,9 @@ public SnapshotTransactionalContext(Transaction transaction) {\n     public void addTransaction(AbstractTransactionalContext tc) {\n         throw new UnsupportedOperationException(\"Can't merge into a readonly txn (yet)\");\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjM0Mw=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzUwMzcwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowNzozMVrOF-h9Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowNzozMVrOF-h9Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjM5MA==", "bodyText": "update method java doc, no returned value.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401112390", "createdAt": "2020-03-31T18:07:31Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzUxMTQyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowOTozM1rOF-iCDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowNDozMFrOF-oMAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMzYxNQ==", "bodyText": "Can we have these two values '0', as statics with suggestive names that ease readability? Also, why do we enforce epoch to be 0? would it be better to have negative which means non-initialized?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401113615", "createdAt": "2020-03-31T18:09:33Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNDQ2Ng==", "bodyText": "fixed. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401214466", "createdAt": "2020-03-31T21:04:30Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMzYxNQ=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzU2MjcyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODoyMzo0NVrOF-iimg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowNDozNVrOF-oMJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMTk0Ng==", "bodyText": "Add class description?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401121946", "createdAt": "2020-03-31T18:23:45Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNDUwMQ==", "bodyText": "fixed. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401214501", "createdAt": "2020-03-31T21:04:35Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMTk0Ng=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzU2ODkyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODoyNToyNlrOF-imkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMToyNDoxOFrOF-oyGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMjk2Mw==", "bodyText": "perhaps add a trace level logging line here?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401122963", "createdAt": "2020-03-31T18:25:26Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {\n+                this.queueRecord = queueRecord;\n+            }\n+            @Override\n+            public void preCommitCallback(TokenResponse tokenResponse) {\n+                queueRecord.getRecordId().setEpoch(tokenResponse.getEpoch());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNDIxNg==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401224216", "createdAt": "2020-03-31T21:24:18Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {\n+                this.queueRecord = queueRecord;\n+            }\n+            @Override\n+            public void preCommitCallback(TokenResponse tokenResponse) {\n+                queueRecord.getRecordId().setEpoch(tokenResponse.getEpoch());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMjk2Mw=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzU4MTQxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODoyODozOVrOF-iudg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMToyNDo0NFrOF-oy3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyNDk4Mg==", "bodyText": "Can we add a comment making clear that enqueue's occurring outside the transactional scope will not be guaranteed ordering.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401124982", "createdAt": "2020-03-31T18:28:39Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {\n+                this.queueRecord = queueRecord;\n+            }\n+            @Override\n+            public void preCommitCallback(TokenResponse tokenResponse) {\n+                queueRecord.getRecordId().setEpoch(tokenResponse.getEpoch());\n+                queueRecord.getRecordId().setSequence(tokenResponse.getSequence());\n+            }\n+        }\n+        // If we are in a transaction, then we need the commit address of this transaction", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNDQxNA==", "bodyText": "not just that, I am enforcing it via an explicit check.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401224414", "createdAt": "2020-03-31T21:24:44Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +140,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<E>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements TransactionalContext.PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {\n+                this.queueRecord = queueRecord;\n+            }\n+            @Override\n+            public void preCommitCallback(TokenResponse tokenResponse) {\n+                queueRecord.getRecordId().setEpoch(tokenResponse.getEpoch());\n+                queueRecord.getRecordId().setSequence(tokenResponse.getSequence());\n+            }\n+        }\n+        // If we are in a transaction, then we need the commit address of this transaction", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyNDk4Mg=="}, "originalCommit": {"oid": "2f4e336eb5cdf4bbd5c4adba3962548f205f7454"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc1MjYwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxMzo1N1rOF-kZgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozNzoyM1rOF-nRmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MjM4Nw==", "bodyText": "Actually instead of bolierplate code you should use @EqualsAndHashCode annotation from lombok. Can you make that change?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401152387", "createdAt": "2020-03-31T19:13:57Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,58 +78,56 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n-        }\n+        @Setter\n+        @Getter\n+        private long sequence;\n \n-        /**\n-         * @return Return only the ordering part of the entry without the id.\n-         */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n-            }\n-            return id.compareTo(o.id);\n+            return Comparator.comparing(CorfuRecordId::getEpoch)\n+                    .thenComparing(CorfuRecordId::getSequence)\n+                    .thenComparing(CorfuRecordId::getEntryId)\n+                    .compare(this, o);\n         }\n \n         /**\n-         * It is ok to check equality of a CorfuRecordId with ordering data against one without.\n-         * @param o object to compare against.\n+         * It is NOT ok to check equality of a CorfuRecordId with ordering data against one without.\n+         * @param otherObj object to compare against.\n          * @return\n          */\n-        public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+        @Override\n+        public boolean equals(Object otherObj) {\n+            if (this == otherObj) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NTI1Mg==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401195252", "createdAt": "2020-03-31T20:29:39Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,58 +78,56 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n-        }\n+        @Setter\n+        @Getter\n+        private long sequence;\n \n-        /**\n-         * @return Return only the ordering part of the entry without the id.\n-         */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n-            }\n-            return id.compareTo(o.id);\n+            return Comparator.comparing(CorfuRecordId::getEpoch)\n+                    .thenComparing(CorfuRecordId::getSequence)\n+                    .thenComparing(CorfuRecordId::getEntryId)\n+                    .compare(this, o);\n         }\n \n         /**\n-         * It is ok to check equality of a CorfuRecordId with ordering data against one without.\n-         * @param o object to compare against.\n+         * It is NOT ok to check equality of a CorfuRecordId with ordering data against one without.\n+         * @param otherObj object to compare against.\n          * @return\n          */\n-        public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+        @Override\n+        public boolean equals(Object otherObj) {\n+            if (this == otherObj) return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MjM4Nw=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5OTUxNA==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401199514", "createdAt": "2020-03-31T20:37:23Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -76,58 +78,56 @@ public int size() {\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n-        }\n+        @Setter\n+        @Getter\n+        private long sequence;\n \n-        /**\n-         * @return Return only the ordering part of the entry without the id.\n-         */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n-            }\n-            return id.compareTo(o.id);\n+            return Comparator.comparing(CorfuRecordId::getEpoch)\n+                    .thenComparing(CorfuRecordId::getSequence)\n+                    .thenComparing(CorfuRecordId::getEntryId)\n+                    .compare(this, o);\n         }\n \n         /**\n-         * It is ok to check equality of a CorfuRecordId with ordering data against one without.\n-         * @param o object to compare against.\n+         * It is NOT ok to check equality of a CorfuRecordId with ordering data against one without.\n+         * @param otherObj object to compare against.\n          * @return\n          */\n-        public boolean equals(CorfuRecordId o) {\n-            return id.getLeastSignificantBits() == o.id.getLeastSignificantBits();\n+        @Override\n+        public boolean equals(Object otherObj) {\n+            if (this == otherObj) return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1MjM4Nw=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc2MTk2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxNjozMFrOF-kfRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMDowOVrOF-oDBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Mzg2Mg==", "bodyText": "Is it better to use invalid epoch and sequence instead of 0 ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401153862", "createdAt": "2020-03-31T19:16:30Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwMDQzOA==", "bodyText": "would it matter? keeping it as zero allows these non-transactional entries to go to the first of the queue - might make it easier for testing", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401200438", "createdAt": "2020-03-31T20:39:00Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Mzg2Mg=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNzMyMw==", "bodyText": "But then if you compare the a non-tranactional entry with a tranactional entry who was committed at epoch 0, sequence 0,  it would be confusing right?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401207323", "createdAt": "2020-03-31T20:51:29Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Mzg2Mg=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMjE2NQ==", "bodyText": "yes, that isn't supported. ok let me catch that case and assert.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401212165", "createdAt": "2020-03-31T21:00:09Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Mzg2Mg=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc2ODc4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxODoyOVrOF-kjmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozNjo0MVrOF-nQLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NDk3MQ==", "bodyText": "Private", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401154971", "createdAt": "2020-03-31T19:18:29Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5OTE0OA==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401199148", "createdAt": "2020-03-31T20:36:41Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NDk3MQ=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc3MDk3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToxOTowM1rOF-kk5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozNjozNFrOF-nP1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTMwMg==", "bodyText": "Private", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401155302", "createdAt": "2020-03-31T19:19:03Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5OTA2MQ==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401199061", "createdAt": "2020-03-31T20:36:34Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -149,10 +149,27 @@ public String toString() {\n      *          known until the transaction commits.\n      *          The ID returned here is only really useful for remove() operations.\n      */\n-    public CorfuRecordId enqueue(E e) {\n+    public void enqueue(E e) {\n         final Long id = guidGenerator.nextLong();\n-        corfuTable.put(id, e);\n-        return new CorfuRecordId(0, id);\n+        CorfuQueueRecord<E> queueEntry = new CorfuQueueRecord<>(0, 0, id, e);\n+        class QueueEntryAddressGetter implements PreCommitListener {\n+            CorfuQueueRecord<E> queueRecord;\n+            QueueEntryAddressGetter(CorfuQueueRecord<E> queueRecord) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1NTMwMg=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc4NzMzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToyMzozNlrOF-ku4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozMzo0OVrOF-nKBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Nzg1OQ==", "bodyText": "ordering -> sequence ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401157859", "createdAt": "2020-03-31T19:23:36Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -181,15 +199,28 @@ public String toString() {\n             return String.format(\"%s=>%s\", recordId, entry);\n         }\n \n-        CorfuQueueRecord(long ordering, long entryId, E entry) {\n-            this.recordId = new CorfuRecordId(ordering, entryId);\n+        CorfuQueueRecord(long epoch, long ordering, long entryId, E entry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5NzU3Mg==", "bodyText": "fixed. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401197572", "createdAt": "2020-03-31T20:33:49Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -181,15 +199,28 @@ public String toString() {\n             return String.format(\"%s=>%s\", recordId, entry);\n         }\n \n-        CorfuQueueRecord(long ordering, long entryId, E entry) {\n-            this.recordId = new CorfuRecordId(ordering, entryId);\n+        CorfuQueueRecord(long epoch, long ordering, long entryId, E entry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1Nzg1OQ=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzc5ODI5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToyNjoyNVrOF-k1iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOToyNjoyNVrOF-k1iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE1OTU2MA==", "bodyText": "Fix Indent", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401159560", "createdAt": "2020-03-31T19:26:25Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -242,41 +253,20 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n             );\n         }\n \n-        // Bind the iteration order to a snapshot of the Queue using a transaction.\n-        long snapshotVersion;\n-        boolean startedNewTransaction = false;\n-        if (TransactionalContext.isInTransaction()) {\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-        } else {\n-            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)\n-                    .build()\n-                    .begin();\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-            startedNewTransaction = true;\n-        }\n         List<CorfuQueueRecord<E>> copy = new ArrayList<>(\n                 Math.min(corfuTable.size(), maxEntries)\n         );\n \n+    Comparator<Map.Entry<Long, CorfuQueueRecord<E>>> recordIdComparator = (r1, r2) ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzgzNjc3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTozNzowN1rOF-lNDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMjoyMVrOF-oHdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTU4Mg==", "bodyText": "You can put a .limit(maxEntries) after .filter() to avoid collecting and sorting all entries and ++index. This should be more efficient.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401165582", "createdAt": "2020-03-31T19:37:07Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -242,41 +253,20 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n             );\n         }\n \n-        // Bind the iteration order to a snapshot of the Queue using a transaction.\n-        long snapshotVersion;\n-        boolean startedNewTransaction = false;\n-        if (TransactionalContext.isInTransaction()) {\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-        } else {\n-            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)\n-                    .build()\n-                    .begin();\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-            startedNewTransaction = true;\n-        }\n         List<CorfuQueueRecord<E>> copy = new ArrayList<>(\n                 Math.min(corfuTable.size(), maxEntries)\n         );\n \n+    Comparator<Map.Entry<Long, CorfuQueueRecord<E>>> recordIdComparator = (r1, r2) ->\n+                r1.getValue().getRecordId().compareTo(r2.getValue().recordId);\n         int index = 0;\n-        for (Long entryId : corfuTable.keySet().stream()\n-                .filter(e -> e > entriesAfter)\n-                .sorted().collect(Collectors.toList())) {\n+        for (Map.Entry<Long, CorfuQueueRecord<E>> entry : corfuTable.entryStream()\n+                .filter(e -> e.getValue().getRecordId().compareTo(entriesAfter) > 0)\n+                .sorted(recordIdComparator).collect(Collectors.toList())) {\n             if (++index >= maxEntries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMzMwMw==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401213303", "createdAt": "2020-03-31T21:02:21Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -242,41 +253,20 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n             );\n         }\n \n-        // Bind the iteration order to a snapshot of the Queue using a transaction.\n-        long snapshotVersion;\n-        boolean startedNewTransaction = false;\n-        if (TransactionalContext.isInTransaction()) {\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-        } else {\n-            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)\n-                    .build()\n-                    .begin();\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-            startedNewTransaction = true;\n-        }\n         List<CorfuQueueRecord<E>> copy = new ArrayList<>(\n                 Math.min(corfuTable.size(), maxEntries)\n         );\n \n+    Comparator<Map.Entry<Long, CorfuQueueRecord<E>>> recordIdComparator = (r1, r2) ->\n+                r1.getValue().getRecordId().compareTo(r2.getValue().recordId);\n         int index = 0;\n-        for (Long entryId : corfuTable.keySet().stream()\n-                .filter(e -> e > entriesAfter)\n-                .sorted().collect(Collectors.toList())) {\n+        for (Map.Entry<Long, CorfuQueueRecord<E>> entry : corfuTable.entryStream()\n+                .filter(e -> e.getValue().getRecordId().compareTo(entriesAfter) > 0)\n+                .sorted(recordIdComparator).collect(Collectors.toList())) {\n             if (++index >= maxEntries) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NTU4Mg=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzg0NTUzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTozOTo0N1rOF-lSvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMjozMFrOF-oHvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzAzOQ==", "bodyText": "Is it better to use invalid epoch and sequence instead of 0 ? Same for the rests", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401167039", "createdAt": "2020-03-31T19:39:47Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -285,23 +275,23 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n      * @return all the entries in the Queue\n      */\n     public List<CorfuQueueRecord<E>> entryList() {\n-        return this.entryList(0L, MAX_INDEX_ENTRIES);\n+        return this.entryList(new CorfuRecordId(0,0,0), MAX_INDEX_ENTRIES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMzM3NQ==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401213375", "createdAt": "2020-03-31T21:02:30Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -285,23 +275,23 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n      * @return all the entries in the Queue\n      */\n     public List<CorfuQueueRecord<E>> entryList() {\n-        return this.entryList(0L, MAX_INDEX_ENTRIES);\n+        return this.entryList(new CorfuRecordId(0,0,0), MAX_INDEX_ENTRIES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzAzOQ=="}, "originalCommit": {"oid": "d0180e37c00bab9fe63b72f528b4fe96ddb0f6b0"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzg5NTEzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1Mzo0MlrOF-lwzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowNDowNVrOF-oLKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDczMw==", "bodyText": "I'm wondering if this is correct in case of nested transactions. In that case we would merge the read/write set in the child transaction's context into parent's context, however the preCommitListeners seems not doing this.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401174733", "createdAt": "2020-03-31T19:53:42Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +251,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(PreCommitListener preCommitListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNDI0OQ==", "bodyText": "I thought about this - that is the reason I always pick the RootContext to store these preCommitListeners. As you said nesting transactions will keep merging their writeSets() anyway which is is unnecessary because only the address of the parent transaction matters anyway.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401214249", "createdAt": "2020-03-31T21:04:05Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +251,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(PreCommitListener preCommitListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NDczMw=="}, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzkwMTg4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1NTozNFrOF-l07A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo0NTowM1rOF-pYDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTc4OA==", "bodyText": "If the copy is after the comparison, wouldn't it skip one. For instance maxEntries =1, on the first entry it would immediately break and not add the single entry. Or change to index++", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401175788", "createdAt": "2020-03-31T19:55:34Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -242,41 +253,20 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n             );\n         }\n \n-        // Bind the iteration order to a snapshot of the Queue using a transaction.\n-        long snapshotVersion;\n-        boolean startedNewTransaction = false;\n-        if (TransactionalContext.isInTransaction()) {\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-        } else {\n-            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)\n-                    .build()\n-                    .begin();\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-            startedNewTransaction = true;\n-        }\n         List<CorfuQueueRecord<E>> copy = new ArrayList<>(\n                 Math.min(corfuTable.size(), maxEntries)\n         );\n \n+    Comparator<Map.Entry<Long, CorfuQueueRecord<E>>> recordIdComparator = (r1, r2) ->\n+                r1.getValue().getRecordId().compareTo(r2.getValue().recordId);\n         int index = 0;\n-        for (Long entryId : corfuTable.keySet().stream()\n-                .filter(e -> e > entriesAfter)\n-                .sorted().collect(Collectors.toList())) {\n+        for (Map.Entry<Long, CorfuQueueRecord<E>> entry : corfuTable.entryStream()\n+                .filter(e -> e.getValue().getRecordId().compareTo(entriesAfter) > 0)\n+                .sorted(recordIdComparator).collect(Collectors.toList())) {\n             if (++index >= maxEntries) {\n                 break;\n             }\n-            // Note that index is already limited to fit within MAX_BITS_FOR_INDEX\n-            long ordering = (snapshotVersion << MAX_BITS_FOR_INDEX) | index;\n-            CorfuQueueRecord<E> record = new CorfuQueueRecord<>(\n-                    ordering, entryId, corfuTable.get(entryId)\n-            );\n-            copy.add(record);\n-        }\n-        // Given that we are using a WRITE_AFTER_WRITE on a read-only txn, we expect no aborts.\n-        if (startedNewTransaction) {\n-            runtime.getObjectsView().TXEnd();\n+            copy.add(entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzMzkzMw==", "bodyText": "I think your comment is on old version of the code - the whole loop is fixed up based on a previous comment, so I guess it can't happen anymore?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401233933", "createdAt": "2020-03-31T21:45:03Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -242,41 +253,20 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n             );\n         }\n \n-        // Bind the iteration order to a snapshot of the Queue using a transaction.\n-        long snapshotVersion;\n-        boolean startedNewTransaction = false;\n-        if (TransactionalContext.isInTransaction()) {\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-        } else {\n-            runtime.getObjectsView().TXBuild().type(TransactionType.WRITE_AFTER_WRITE)\n-                    .build()\n-                    .begin();\n-            snapshotVersion = TransactionalContext.getCurrentContext()\n-                    .getSnapshotTimestamp().getSequence();\n-            startedNewTransaction = true;\n-        }\n         List<CorfuQueueRecord<E>> copy = new ArrayList<>(\n                 Math.min(corfuTable.size(), maxEntries)\n         );\n \n+    Comparator<Map.Entry<Long, CorfuQueueRecord<E>>> recordIdComparator = (r1, r2) ->\n+                r1.getValue().getRecordId().compareTo(r2.getValue().recordId);\n         int index = 0;\n-        for (Long entryId : corfuTable.keySet().stream()\n-                .filter(e -> e > entriesAfter)\n-                .sorted().collect(Collectors.toList())) {\n+        for (Map.Entry<Long, CorfuQueueRecord<E>> entry : corfuTable.entryStream()\n+                .filter(e -> e.getValue().getRecordId().compareTo(entriesAfter) > 0)\n+                .sorted(recordIdComparator).collect(Collectors.toList())) {\n             if (++index >= maxEntries) {\n                 break;\n             }\n-            // Note that index is already limited to fit within MAX_BITS_FOR_INDEX\n-            long ordering = (snapshotVersion << MAX_BITS_FOR_INDEX) | index;\n-            CorfuQueueRecord<E> record = new CorfuQueueRecord<>(\n-                    ordering, entryId, corfuTable.get(entryId)\n-            );\n-            copy.add(record);\n-        }\n-        // Given that we are using a WRITE_AFTER_WRITE on a read-only txn, we expect no aborts.\n-        if (startedNewTransaction) {\n-            runtime.getObjectsView().TXEnd();\n+            copy.add(entry.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NTc4OA=="}, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NzkwNjY0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1Njo1OFrOF-l34A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo1MDoxN1rOF-piEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjU0NA==", "bodyText": "can we do the same, declare statics so it is easy to follow this init..", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401176544", "createdAt": "2020-03-31T19:56:58Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -285,23 +275,23 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n      * @return all the entries in the Queue\n      */\n     public List<CorfuQueueRecord<E>> entryList() {\n-        return this.entryList(0L, MAX_INDEX_ENTRIES);\n+        return this.entryList(new CorfuRecordId(0,0,0), MAX_INDEX_ENTRIES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjQ5OQ==", "bodyText": "added trace, thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401236499", "createdAt": "2020-03-31T21:50:17Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -285,23 +275,23 @@ public int compareTo(CorfuQueueRecord<? extends E> o) {\n      * @return all the entries in the Queue\n      */\n     public List<CorfuQueueRecord<E>> entryList() {\n-        return this.entryList(0L, MAX_INDEX_ENTRIES);\n+        return this.entryList(new CorfuRecordId(0,0,0), MAX_INDEX_ENTRIES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NjU0NA=="}, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk2OTgzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/OptimisticTransactionalContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxNDozMFrOF-meRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo1MDowNVrOF-phtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NjM3Mw==", "bodyText": "add trace or debug logging?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401186373", "createdAt": "2020-03-31T20:14:30Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/OptimisticTransactionalContext.java", "diffHunk": "@@ -286,4 +286,9 @@ public long getConflictSetAndCommit(ConflictSetInfo conflictSet) {\n         log.trace(\"Commit[{}] Written to {}\", this, address);\n         return address;\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {\n+        this.getPreCommitListeners().add(preCommitListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjQwNw==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401236407", "createdAt": "2020-03-31T21:50:05Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/OptimisticTransactionalContext.java", "diffHunk": "@@ -286,4 +286,9 @@ public long getConflictSetAndCommit(ConflictSetInfo conflictSet) {\n         log.trace(\"Commit[{}] Written to {}\", this, address);\n         return address;\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {\n+        this.getPreCommitListeners().add(preCommitListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NjM3Mw=="}, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODAwMTczOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/view/StreamsView.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyMjo1NlrOF-mxpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo1MToxMVrOF-pjrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MTMzNA==", "bodyText": "add some logging?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401191334", "createdAt": "2020-03-31T20:22:56Z", "author": {"login": "annym"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/StreamsView.java", "diffHunk": "@@ -168,6 +168,17 @@ public long append(@Nonnull Object object, @Nullable TxResolutionInfo conflictIn\n             }\n \n             try {\n+                if (TransactionalContext.isInTransaction()) {\n+                    // If this transaction has entries that wish to capture the committed address\n+                    // invoke its preCommitCallbacks with the tokenResponse from the sequencer.\n+                    // Note that we might invoke the same method multiple times on retries,\n+                    // which means the preCommitCallback must be idempotent.\n+                    TokenResponse finalTokenResponse = tokenResponse;\n+                    TransactionalContext.getRootContext()\n+                            .getPreCommitListeners()\n+                            .forEach(e -> e.preCommitCallback(finalTokenResponse));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjkxMA==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401236910", "createdAt": "2020-03-31T21:51:11Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/StreamsView.java", "diffHunk": "@@ -168,6 +168,17 @@ public long append(@Nonnull Object object, @Nullable TxResolutionInfo conflictIn\n             }\n \n             try {\n+                if (TransactionalContext.isInTransaction()) {\n+                    // If this transaction has entries that wish to capture the committed address\n+                    // invoke its preCommitCallbacks with the tokenResponse from the sequencer.\n+                    // Note that we might invoke the same method multiple times on retries,\n+                    // which means the preCommitCallback must be idempotent.\n+                    TokenResponse finalTokenResponse = tokenResponse;\n+                    TransactionalContext.getRootContext()\n+                            .getPreCommitListeners()\n+                            .forEach(e -> e.preCommitCallback(finalTokenResponse));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MTMzNA=="}, "originalCommit": {"oid": "45b6120022507bd7ee1a2133c65de06d4286d7d8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODQyMzg1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMjo0NToxMlrOF-q44A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNzowOTozMlrOF-zdiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA==", "bodyText": "Looks like you are still using 0, 0 for non-transactional entries (the else branch in enqueue) ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401258720", "createdAt": "2020-03-31T22:45:12Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1OTg0NA==", "bodyText": "exactly, Queue is still usable if all enqueue() are non-transactional (unit tests only at this point)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401259844", "createdAt": "2020-03-31T22:48:28Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MTIyMw==", "bodyText": "I mean if we still use 0, 0 for non-transactional entries, we won't have entries with Address.NON_ADDRESS, so why do we need this check?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401261223", "createdAt": "2020-03-31T22:52:22Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2Nzk1Ng==", "bodyText": "Sorry good catch", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401267956", "createdAt": "2020-03-31T23:13:01Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM0NTU3Mw==", "bodyText": "@hisundar Is this fixed?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401345573", "createdAt": "2020-04-01T04:11:34Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM5OTE3OQ==", "bodyText": "yes I removed the check as you suggested.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401399179", "createdAt": "2020-04-01T07:09:32Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -75,59 +80,55 @@ public int size() {\n      * with their snapshot+index id (also a long) which represents a global comparable ordering.\n      * This class encapsulates these two longs into one Id and add rules on comparability.\n      */\n+    @EqualsAndHashCode\n     public static class CorfuRecordId implements Comparable<CorfuRecordId> {\n-        private final UUID id;\n-        public CorfuRecordId(long ordering, long uniqueId) {\n-            this.id = new UUID(ordering, uniqueId);\n-        }\n+        @Setter\n+        @Getter\n+        private long epoch;\n \n-        /**\n-         * @return Return only the unique part of the id without the ordering\n-         */\n-        public long getEntryId() {\n-            return id.getLeastSignificantBits();\n+        @Setter\n+        @Getter\n+        private long sequence;\n+\n+        @Getter\n+        private long entryId;\n+\n+        public CorfuRecordId(long epoch, long sequence, long entryId) {\n+            this.epoch = epoch;\n+            this.sequence = sequence;\n+            this.entryId = entryId;\n         }\n \n         /**\n-         * @return Return only the ordering part of the entry without the id.\n+         * @return Pack CorfuRecordId into a 16 byte UUID\n+         * Q: Is it safe?\n+         * At the rate of 2ms per transaction, sequence will take  69 years to rollover.\n+         * At the rate of 1 cluster reconfig per minute, epoch will take 31 years to rollover.\n          */\n-        public long getOrdering() {\n-            return id.getMostSignificantBits();\n+        public UUID asUUID() {\n+            final int BITS_FOR_SEQUENCE = 40;\n+            return new UUID(epoch<<BITS_FOR_SEQUENCE | sequence, entryId);\n         }\n \n         /**\n          * It's NOT ok to compare two objects if their ordering metadata is dissimilar.\n          * @param o object to compare against.\n-         * @throws IllegalArgumentException if the two Ids are not comparable.\n          * @return results of comparison.\n          */\n         @Override\n         public int compareTo(CorfuRecordId o) {\n-            if (this.id.getMostSignificantBits() == 0 && o.id.getMostSignificantBits() != 0) {\n-                throw new IllegalArgumentException(\n-                        \"Incompatible CorfuRecordId comparison: ordering unavailable\");\n-            }\n-            if (this.id.getMostSignificantBits() !=0 && o.id.getMostSignificantBits() == 0) {\n-               throw new IllegalArgumentException(\n-                       \"Incompatible CorfuRecordId comparison: order of compared object unknown\");\n-            }\n-            if (this.id.getLeastSignificantBits() == o.id.getLeastSignificantBits()) {\n-                return 0;\n+            if ((this.sequence != Address.NON_ADDRESS && o.sequence == Address.NON_ADDRESS) ||\n+                    (this.sequence == Address.NON_ADDRESS && o.sequence != Address.NON_ADDRESS)) {\n+                throw new IllegalStateException(\"CorfuQueue cannot mix transactional and non-transactional types\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI1ODcyMA=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODUyMzU4OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMzozMzowNFrOF-r1TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMDozMjo1N1rOF-s4ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3NDE4OQ==", "bodyText": "Please fix\nlog.debug(\"ENQ: {} => {} at {}\", i, queueData, streamOffset);", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401274189", "createdAt": "2020-03-31T23:33:04Z", "author": {"login": "xnull"}, "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "diffHunk": "@@ -88,11 +93,13 @@ public Record(CorfuRecordId id, String data) {\n                     TXBegin(txnType);\n                     Long coinToss = new Random().nextLong() % numConflictKeys;\n                     conflictMap.put(coinToss, coinToss);\n+                    corfuQueue.enqueue(queueData);\n+                    // Each transaction may or may not sleep to simulate out of order between enQ & commit\n+                    TimeUnit.MILLISECONDS.sleep(coinToss);\n                     lock.lock();\n-                    CorfuRecordId id = corfuQueue.enqueue(queueData);\n                     final long streamOffset = TXEnd();\n-                    validator.add(new Record(id, queueData));\n-                    log.debug(\"ENQ:\" + id + \"=>\" + queueData + \" at \" + streamOffset);\n+                    validator.add(new Record(new CorfuRecordId(0,0,i), queueData));\n+                    log.debug(\"ENQ:\" + i + \"=>\" + queueData + \" at \" + streamOffset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5MTM3MA==", "bodyText": "done. thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401291370", "createdAt": "2020-04-01T00:32:57Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "diffHunk": "@@ -88,11 +93,13 @@ public Record(CorfuRecordId id, String data) {\n                     TXBegin(txnType);\n                     Long coinToss = new Random().nextLong() % numConflictKeys;\n                     conflictMap.put(coinToss, coinToss);\n+                    corfuQueue.enqueue(queueData);\n+                    // Each transaction may or may not sleep to simulate out of order between enQ & commit\n+                    TimeUnit.MILLISECONDS.sleep(coinToss);\n                     lock.lock();\n-                    CorfuRecordId id = corfuQueue.enqueue(queueData);\n                     final long streamOffset = TXEnd();\n-                    validator.add(new Record(id, queueData));\n-                    log.debug(\"ENQ:\" + id + \"=>\" + queueData + \" at \" + streamOffset);\n+                    validator.add(new Record(new CorfuRecordId(0,0,i), queueData));\n+                    log.debug(\"ENQ:\" + i + \"=>\" + queueData + \" at \" + streamOffset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3NDE4OQ=="}, "originalCommit": {"oid": "e3990910593367ba839bb9968c170516443a1ff5"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODY4NDYyOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMDo1OTo0MVrOF-tUtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDowNToxMFrOF-wGYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5ODYxNA==", "bodyText": "We should remove the lock and generated some tx abort scenarios. You can define validator as a hashtable instead of an array. I am not clear if tx aborted, if the record will be removed from the queue or not?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401298614", "createdAt": "2020-04-01T00:59:41Z", "author": {"login": "xiaoqin2012"}, "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "diffHunk": "@@ -88,11 +93,13 @@ public Record(CorfuRecordId id, String data) {\n                     TXBegin(txnType);\n                     Long coinToss = new Random().nextLong() % numConflictKeys;\n                     conflictMap.put(coinToss, coinToss);\n+                    corfuQueue.enqueue(queueData);\n+                    // Each transaction may or may not sleep to simulate out of order between enQ & commit\n+                    TimeUnit.MILLISECONDS.sleep(coinToss);\n                     lock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzOTk2Ng==", "bodyText": "Aborts are definitely happening because we conflict on one of two values, for example in a test with 2000 transactions only about 1500 succeed. But I will add an assert to verify this too.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401339966", "createdAt": "2020-04-01T03:47:24Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "diffHunk": "@@ -88,11 +93,13 @@ public Record(CorfuRecordId id, String data) {\n                     TXBegin(txnType);\n                     Long coinToss = new Random().nextLong() % numConflictKeys;\n                     conflictMap.put(coinToss, coinToss);\n+                    corfuQueue.enqueue(queueData);\n+                    // Each transaction may or may not sleep to simulate out of order between enQ & commit\n+                    TimeUnit.MILLISECONDS.sleep(coinToss);\n                     lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5ODYxNA=="}, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM0NDA5Ng==", "bodyText": "Actually it turns out travis sometimes serializes the runs which means there might not be any aborts due to concurrency. So I can't add an assert or test will become very non-deterministic :(", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401344096", "createdAt": "2020-04-01T04:05:10Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/runtime/concurrent/CorfuQueueTxTest.java", "diffHunk": "@@ -88,11 +93,13 @@ public Record(CorfuRecordId id, String data) {\n                     TXBegin(txnType);\n                     Long coinToss = new Random().nextLong() % numConflictKeys;\n                     conflictMap.put(coinToss, coinToss);\n+                    corfuQueue.enqueue(queueData);\n+                    // Each transaction may or may not sleep to simulate out of order between enQ & commit\n+                    TimeUnit.MILLISECONDS.sleep(coinToss);\n                     lock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5ODYxNA=="}, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODczNjM0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTozMDowN1rOF-ty3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMzo0NToyM1rOF-v0eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNjMzNA==", "bodyText": "are snapshot transactions considered read-only?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401306334", "createdAt": "2020-04-01T01:30:07Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "diffHunk": "@@ -85,4 +85,9 @@ public SnapshotTransactionalContext(Transaction transaction) {\n     public void addTransaction(AbstractTransactionalContext tc) {\n         throw new UnsupportedOperationException(\"Can't merge into a readonly txn (yet)\");\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {\n+        throw new UnsupportedOperationException(\"Can't register precommit hooks in readonly txn\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzOTUxNA==", "bodyText": "yes, there are similar exceptions for attempting to write in a snapshot transaction", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401339514", "createdAt": "2020-04-01T03:45:23Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/SnapshotTransactionalContext.java", "diffHunk": "@@ -85,4 +85,9 @@ public SnapshotTransactionalContext(Transaction transaction) {\n     public void addTransaction(AbstractTransactionalContext tc) {\n         throw new UnsupportedOperationException(\"Can't merge into a readonly txn (yet)\");\n     }\n+\n+    @Override\n+    public void addPreCommitListener(TransactionalContext.PreCommitListener preCommitListener) {\n+        throw new UnsupportedOperationException(\"Can't register precommit hooks in readonly txn\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNjMzNA=="}, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODczOTQ3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMTozMjowMlrOF-t0sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMzo0NTowMVrOF-v0KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNjgwMQ==", "bodyText": "Shouldnt it be overridden in WriteAfterWriteTransactionalContext as well?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401306801", "createdAt": "2020-04-01T01:32:02Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +251,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(PreCommitListener preCommitListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzOTQzMw==", "bodyText": "WriteAfterWrite inherits from OptimisticTransaction and will end up inheriting this method too.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2495#discussion_r401339433", "createdAt": "2020-04-01T03:45:01Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/object/transactions/AbstractTransactionalContext.java", "diffHunk": "@@ -248,6 +251,17 @@ public void syncWithRetryUnsafe(VersionLockedObject vlo,\n      */\n     public abstract void addTransaction(AbstractTransactionalContext tc);\n \n+    /**\n+     * Add an object that needs extra processing right before commit happens\n+     *\n+     * @param preCommitListener The context of the object that needs extra processing\n+     *                         along with its lambda.\n+     */\n+    public abstract void addPreCommitListener(PreCommitListener preCommitListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNjgwMQ=="}, "originalCommit": {"oid": "752605354b0c690f74b4f167c8b56dad195f8075"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1961, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}