{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMzg1NTEx", "number": 2307, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoxOToxMVrODYte3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMzo0OFrODYthLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM3NTk3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoxOToxMVrOFeueIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxOToyOTo0N1rOFhKDXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2Mjk3OQ==", "bodyText": "Could they be final? Looks we don't change their references.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2307#discussion_r367762979", "createdAt": "2020-01-17T04:19:11Z", "author": {"login": "zhangn49"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -911,6 +913,8 @@ synchronized void seek(long globalAddress) {\n      */\n     @Data\n     static class StreamCheckpoint {\n+        public static StreamCheckpoint UNINITIALIZED = new StreamCheckpoint();\n+        public static StreamCheckpoint INITIALIZED = new StreamCheckpoint();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "334162d1ea179324f15b3622ffdfb1e905cf2810"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMjAzMA==", "bodyText": "Yep.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2307#discussion_r370312030", "createdAt": "2020-01-23T19:29:47Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -911,6 +913,8 @@ synchronized void seek(long globalAddress) {\n      */\n     @Data\n     static class StreamCheckpoint {\n+        public static StreamCheckpoint UNINITIALIZED = new StreamCheckpoint();\n+        public static StreamCheckpoint INITIALIZED = new StreamCheckpoint();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2Mjk3OQ=="}, "originalCommit": {"oid": "334162d1ea179324f15b3622ffdfb1e905cf2810"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjM4MTg4OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNDoyMzo0OFrOFeuhZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxOTozMDozMFrOFhKEpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzgxNA==", "bodyText": "I see testCheckpointTrim and testSuccessiveCheckpointTrim use these four lines to trim.\nCan we replace them with trim()?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2307#discussion_r367763814", "createdAt": "2020-01-17T04:23:48Z", "author": {"login": "zhangn49"}, "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -174,6 +182,68 @@ public void testSuccessiveCheckpointTrim() throws Exception {\n                 .isEqualTo(\"a\" + (nCheckpoints - 1));\n     }\n \n+    /**\n+     * Verify that the streaming interface can be consumed directly and that\n+     * {@link TrimmedException} is being thrown when linearizable history is lost.\n+     */\n+    @Test\n+    public void rawStreamConsumer() {\n+        final int BATCH_SIZE = 10;\n+        final int CHECKPOINT_SIZE = 3;\n+        final String CHECKPOINT_AUTHOR = \"Author\";\n+        final String tableName = \"test\";\n+        final CorfuTable<Integer, Integer> map = getDefaultRuntime().getObjectsView().build()\n+                .setTypeToken(new TypeToken<CorfuTable<Integer, Integer>>() {})\n+                .setStreamName(tableName)\n+                .open();\n+\n+        final MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter();\n+        mcw.addMap(map);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        // Insert a checkpoint\n+        Token checkpointAddress = mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        // Trim the log in between the checkpoints\n+        trim(checkpointAddress);\n+\n+        CorfuRuntime newRuntime = getNewRuntime(getDefaultNode()).connect();\n+        Map<Integer, Integer> newMap = newRuntime.getObjectsView().build()\n+                .setTypeToken(new TypeToken<SMRMap<Integer, Integer>>() {\n+                })\n+                .setStreamName(tableName)\n+                .open();\n+\n+        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+        // Seek beyond the last trimmed address.\n+        // The first call to remainingUpTo() will load the checkpoint, and the\n+        // second one will fetch the actual data.\n+        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+                .map(List::size).mapToInt(Integer::intValue).sum())\n+                .isEqualTo(BATCH_SIZE);\n+\n+        trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> newMap.put(idx, idx));\n+        Assertions.assertThatThrownBy(() -> s.remainingUpTo(Long.MAX_VALUE))\n+                .isInstanceOf(TrimmedException.class);\n+    }\n+\n+    /**\n+     * Given the token, trim the address-space at {@link Token#getSequence()}.\n+     *\n+     * @param token point at which to trim the address space.\n+     */\n+    private void trim(Token token) {\n+        getRuntime().getAddressSpaceView().prefixTrim(token);\n+        getRuntime().getAddressSpaceView().gc();\n+        getRuntime().getAddressSpaceView().invalidateServerCaches();\n+        getRuntime().getAddressSpaceView().invalidateClientCache();\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "334162d1ea179324f15b3622ffdfb1e905cf2810"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMjM1OA==", "bodyText": "Sounds good.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2307#discussion_r370312358", "createdAt": "2020-01-23T19:30:30Z", "author": {"login": "vjeko"}, "path": "test/src/test/java/org/corfudb/runtime/checkpoint/CheckpointTrimTest.java", "diffHunk": "@@ -174,6 +182,68 @@ public void testSuccessiveCheckpointTrim() throws Exception {\n                 .isEqualTo(\"a\" + (nCheckpoints - 1));\n     }\n \n+    /**\n+     * Verify that the streaming interface can be consumed directly and that\n+     * {@link TrimmedException} is being thrown when linearizable history is lost.\n+     */\n+    @Test\n+    public void rawStreamConsumer() {\n+        final int BATCH_SIZE = 10;\n+        final int CHECKPOINT_SIZE = 3;\n+        final String CHECKPOINT_AUTHOR = \"Author\";\n+        final String tableName = \"test\";\n+        final CorfuTable<Integer, Integer> map = getDefaultRuntime().getObjectsView().build()\n+                .setTypeToken(new TypeToken<CorfuTable<Integer, Integer>>() {})\n+                .setStreamName(tableName)\n+                .open();\n+\n+        final MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter();\n+        mcw.addMap(map);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        // Insert a checkpoint\n+        Token checkpointAddress = mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR);\n+\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> map.put(idx, idx));\n+\n+        // Trim the log in between the checkpoints\n+        trim(checkpointAddress);\n+\n+        CorfuRuntime newRuntime = getNewRuntime(getDefaultNode()).connect();\n+        Map<Integer, Integer> newMap = newRuntime.getObjectsView().build()\n+                .setTypeToken(new TypeToken<SMRMap<Integer, Integer>>() {\n+                })\n+                .setStreamName(tableName)\n+                .open();\n+\n+        IStreamView s = newRuntime.getStreamsView().get(CorfuRuntime.getStreamID(tableName));\n+        s.seek(BATCH_SIZE + CHECKPOINT_SIZE);\n+        // Seek beyond the last trimmed address.\n+        // The first call to remainingUpTo() will load the checkpoint, and the\n+        // second one will fetch the actual data.\n+        Assertions.assertThat(Stream.of(s.remainingUpTo(Long.MAX_VALUE), s.remainingUpTo(Long.MAX_VALUE))\n+                .map(List::size).mapToInt(Integer::intValue).sum())\n+                .isEqualTo(BATCH_SIZE);\n+\n+        trim(mcw.appendCheckpoints(getRuntime(), CHECKPOINT_AUTHOR));\n+        IntStream.range(0, BATCH_SIZE).forEach(idx -> newMap.put(idx, idx));\n+        Assertions.assertThatThrownBy(() -> s.remainingUpTo(Long.MAX_VALUE))\n+                .isInstanceOf(TrimmedException.class);\n+    }\n+\n+    /**\n+     * Given the token, trim the address-space at {@link Token#getSequence()}.\n+     *\n+     * @param token point at which to trim the address space.\n+     */\n+    private void trim(Token token) {\n+        getRuntime().getAddressSpaceView().prefixTrim(token);\n+        getRuntime().getAddressSpaceView().gc();\n+        getRuntime().getAddressSpaceView().invalidateServerCaches();\n+        getRuntime().getAddressSpaceView().invalidateClientCache();\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzgxNA=="}, "originalCommit": {"oid": "334162d1ea179324f15b3622ffdfb1e905cf2810"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2041, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}