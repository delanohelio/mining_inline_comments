{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwODk1OTI2", "number": 2826, "title": "CorfuStore streaming redesign part 3 - implementation and integration.", "bodyText": "Overview\nDescription:\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore.\nRelated issue(s) (if applicable): #\nChecklist (Definition of Done):\n\n There are no TODOs left in the code\n Coding conventions (e.g. for logging, unit tests) have been followed\n Change is covered by automated tests\n Public API has Javadoc", "createdAt": "2020-11-13T23:13:49Z", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826", "merged": true, "mergeCommit": {"oid": "01908fb93fac013ce025e2ce2256279f1b54ff4d"}, "closed": true, "closedAt": "2021-01-20T23:06:19Z", "author": {"login": "WenbinZhu"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdcUVh-AFqTUzMDU1MzA4Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyFEOFgBqjQyMjk1ODQ4ODY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwNTUzMDg3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-530553087", "createdAt": "2020-11-14T04:19:19Z", "commit": {"oid": "c907b207e87dfc799e3a605b81f2889b30566f1c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNDoxOToxOVrOHzILRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNDo0MzozN1rOHzITGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM3MzM4MQ==", "bodyText": "Consolidating the functions is ok, but would be good to retain these comments.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r523373381", "createdAt": "2020-11-14T04:19:19Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStreamEntry.java", "diffHunk": "@@ -121,36 +112,10 @@ private static OperationType getOperationType(@Nonnull SMREntry entry) {\n                 operationType = OperationType.DELETE;\n                 break;\n             default:\n-                throw new RuntimeException(\"SMRMethod \"+entry.getSMRMethod()\n+                throw new RuntimeException(\"SMRMethod \" + entry.getSMRMethod()\n                         + \" cannot be translated to any known operation type\");\n         }\n-        return operationType;\n-    }\n-\n-    /**\n-     *  Convert an SMREntry into a CorfuStreamEntry when the SMR arguments have clear types\n-     *  (like if called from a commit callback)\n-     * @param entry - the entry to convert from.\n-     * @param epoch - the epoch this entry was written to/will be written to.\n-     */\n-    public static\n-    CorfuStreamEntry fromSMREntry(@Nonnull SMREntry entry, final long epoch) {\n-\n-        long address = entry.getGlobalAddress();\n-\n-        OperationType operationType = getOperationType(entry);\n-        Object[] args = entry.getSMRArguments();\n-        if (args.length > 0) {\n-            if (args.length > 1) {\n-                CorfuRecord record = (CorfuRecord) args[1];\n-                return new CorfuStreamEntry((Message)args[0],\n-                        record.getPayload(), record.getMetadata(), 0, address, operationType);\n-            }\n-            // this would likely be the case with \"remove\" SMR method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c907b207e87dfc799e3a605b81f2889b30566f1c"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM3NTE3Ng==", "bodyText": "use of remaining() is exactly what got us into the OOM scenario. Even with more selectivity, this will result in OOM if there is a lot of distance between the lastAddress and the tail.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r523375176", "createdAt": "2020-11-14T04:40:47Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remaining();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c907b207e87dfc799e3a605b81f2889b30566f1c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM3NTM4Ng==", "bodyText": "If the goal of using fixed size queue and retry was to avoid starvation of other streams when the number of subscribers exceeds the number of threads. Then won't this still bring back the starvation if the number of updates are large?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r523375386", "createdAt": "2020-11-14T04:43:37Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remaining();\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());\n+            pollingExecutor.submit(this);\n+            return;\n+        }\n+\n+        // Insert polled updates to the subscription buffer, with a shared\n+        // fixed amount of time waiting for buffer being not full.\n+        long remainingBlockTime = QUEUE_FULL_BLOCK_TIME_MS.toNanos();\n+        for (ILogData update : updates) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c907b207e87dfc799e3a605b81f2889b30566f1c"}, "originalPosition": 90}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c907b207e87dfc799e3a605b81f2889b30566f1c", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c907b207e87dfc799e3a605b81f2889b30566f1c", "committedDate": "2020-11-13T22:32:27Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "8f6ead90c884497af69486f3b9f231b9e5df9364", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8f6ead90c884497af69486f3b9f231b9e5df9364", "committedDate": "2020-11-17T08:48:33Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f6ead90c884497af69486f3b9f231b9e5df9364", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8f6ead90c884497af69486f3b9f231b9e5df9364", "committedDate": "2020-11-17T08:48:33Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "01fbb3a6e6ddb1fad7f343c78a310868d68e7caa", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/01fbb3a6e6ddb1fad7f343c78a310868d68e7caa", "committedDate": "2020-11-17T09:52:57Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "01fbb3a6e6ddb1fad7f343c78a310868d68e7caa", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/01fbb3a6e6ddb1fad7f343c78a310868d68e7caa", "committedDate": "2020-11-17T09:52:57Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "8f607b55ac4f40b20cf188e2111ef6fe661623d3", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8f607b55ac4f40b20cf188e2111ef6fe661623d3", "committedDate": "2020-11-17T22:23:39Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f607b55ac4f40b20cf188e2111ef6fe661623d3", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8f607b55ac4f40b20cf188e2111ef6fe661623d3", "committedDate": "2020-11-17T22:23:39Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "6e7cfeb8113e50ec23e5cd483f8a47cb98321131", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/6e7cfeb8113e50ec23e5cd483f8a47cb98321131", "committedDate": "2020-11-19T05:31:21Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e7cfeb8113e50ec23e5cd483f8a47cb98321131", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/6e7cfeb8113e50ec23e5cd483f8a47cb98321131", "committedDate": "2020-11-19T05:31:21Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "94f755169fe742fb2c8c26c78664f948fb2ff4f8", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/94f755169fe742fb2c8c26c78664f948fb2ff4f8", "committedDate": "2020-11-19T05:33:46Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94f755169fe742fb2c8c26c78664f948fb2ff4f8", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/94f755169fe742fb2c8c26c78664f948fb2ff4f8", "committedDate": "2020-11-19T05:33:46Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/594b78e9daff228d9d2be330ecd56056669dcc52", "committedDate": "2020-11-19T05:53:50Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjgyNjcx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-535682671", "createdAt": "2020-11-20T18:33:40Z", "commit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1ODY4OTY5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-535868969", "createdAt": "2020-11-21T01:39:12Z", "commit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMTozOToxMlrOH3lnmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMjoyNjozOVrOH3l_xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1MDA3Mw==", "bodyText": "where is this used ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r528050073", "createdAt": "2020-11-21T01:39:12Z", "author": {"login": "medhavidhawan"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());\n+            pollingExecutor.submit(this);\n+            return;\n+        }\n+\n+        // Insert polled updates to the subscription buffer, with a shared\n+        // fixed amount of time waiting for buffer being not full.\n+        long remainingBlockTime = QUEUE_FULL_BLOCK_TIME_MS.toNanos();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1MjgxNQ==", "bodyText": "Nit: why are you holding up the thread here ? Why not submit with some delay and let the thread be used for other tasks. You will need to either use some scheduledExecutor for that or have some common data structure to keep the submissions that need to be delayed and feed the executor from there.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r528052815", "createdAt": "2020-11-21T01:58:16Z", "author": {"login": "medhavidhawan"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1NjA4MQ==", "bodyText": "How did we arrive at this number ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r528056081", "createdAt": "2020-11-21T02:25:19Z", "author": {"login": "medhavidhawan"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA1NjI2Mg==", "bodyText": "do we need parameterize some of these numbers in case we need to tweak them to find the right values.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r528056262", "createdAt": "2020-11-21T02:26:39Z", "author": {"login": "medhavidhawan"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "594b78e9daff228d9d2be330ecd56056669dcc52", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/594b78e9daff228d9d2be330ecd56056669dcc52", "committedDate": "2020-11-19T05:53:50Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/1d1ddfdb6eeb05fa3c3c6831821f2830e897224a", "committedDate": "2020-11-24T00:46:44Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwOTA5NDkz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-550909493", "createdAt": "2020-12-13T11:13:35Z", "commit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMToxMzozNVrOIEzH9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMjowNjoyOFrOIEzrdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwMjgzOQ==", "bodyText": "above -> below", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541902839", "createdAt": "2020-12-13T11:13:35Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStreamEntry.java", "diffHunk": "@@ -1,26 +1,25 @@\n package org.corfudb.runtime.collections;\n \n import com.google.protobuf.Message;\n+import lombok.EqualsAndHashCode;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.SMREntry;\n \n import javax.annotation.Nonnull;\n-import javax.annotation.Nullable;\n-\n-import org.corfudb.protocols.logprotocol.SMREntry;\n \n /**\n- * Entry returned by CorfuStore's StreamListener interface\n+ * Entry returned by CorfuStore's StreamListener interface.\n+ * NOTE: Ensure that the above protobuf generated classes are accessible to your JVM!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwMzUwNw==", "bodyText": "for alphabetic order of imports, shouldnt the 'java' imports be before 'org.corfudb..'?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541903507", "createdAt": "2020-12-13T11:17:36Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -1,12 +1,21 @@\n package org.corfudb.runtime.collections;\n \n import com.google.protobuf.Message;\n-\n import lombok.AllArgsConstructor;\n import lombok.Getter;\n import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n \n+import javax.annotation.Nonnull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwNDI3OQ==", "bodyText": "order of lombok and java imports", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541904279", "createdAt": "2020-12-13T11:22:26Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwNTQ1NA==", "bodyText": "do we need a log statement here?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541905454", "createdAt": "2020-12-13T11:29:23Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * A runnable task for a subscription to retrieve the previously\n+ * polled transaction updates from the buffer and send notifications\n+ * to client via the registered call backs. This task is executed\n+ * by the thread pool continuously until an error occurs which would\n+ * stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamNotificationTask implements Runnable {\n+\n+    // Number of transaction updates to send notification in each run.\n+    private static final int NOTIFICATION_BATCH_SIZE = 10;\n+\n+    // Total amount of time to wait for retrieving the data changes from buffer if it is empty.\n+    private static final Duration QUEUE_EMPTY_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // A warning will be raised if client call back takes longer than this time threshold.\n+    private static final Duration SLOW_NOTIFICATION_TIME_MS = Duration.ofMillis(1_500);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing client notification tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    StreamNotificationTask(StreamingManager streamingManager,\n+                           StreamSubscription subscription,\n+                           ExecutorService notificationExecutor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.notificationExecutor = notificationExecutor;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            sendNotifications();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during client notification callback, \" +\n+                    \"listener: {}, namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the first data change from the buffer and send notification\n+     * to the client via the pre-registered call back.\n+     */\n+    private void sendNotifications() throws Exception {\n+        // Total amount of time for the batch waiting for buffer being not empty.\n+        long remainingBlockTime = QUEUE_EMPTY_BLOCK_TIME_MS.toNanos();\n+        StreamListener listener = subscription.getListener();\n+\n+        for (int iter = 0; iter < NOTIFICATION_BATCH_SIZE; iter++) {\n+            // If listener already unsubscribed, do not process or schedule again.\n+            if (subscription.isStopped()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMDkzMQ==", "bodyText": "log a message?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541910931", "createdAt": "2020-12-13T12:00:37Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMTkyNQ==", "bodyText": "already checked this on L72", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r541911925", "createdAt": "2020-12-13T12:06:28Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());\n+            pollingExecutor.submit(this);\n+            return;\n+        }\n+\n+        // Insert polled updates to the subscription buffer, with a shared\n+        // fixed amount of time waiting for buffer being not full.\n+        long remainingBlockTime = QUEUE_FULL_BLOCK_TIME_MS.toNanos();\n+        for (ILogData update : updates) {\n+            if (subscription.isStopped()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMDk5NDgx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-552099481", "createdAt": "2020-12-15T04:36:09Z", "commit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNDozNjoxMFrOIF4hZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNToyNzoxN1rOIF5j3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzOTg0NA==", "bodyText": "nit - order of imports javax vs java", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543039844", "createdAt": "2020-12-15T04:36:10Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1MTA0NA==", "bodyText": "One thing I think can improve debuggability is to we have a 'name' field in the StreamListener.  It will help identify if a particular listener has subscribed or not.  Logging the listener instance reference will not help much.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543051044", "createdAt": "2020-12-15T05:10:30Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;\n+\n+    // Corfu runtime to interact with corfu streams.\n+    private final CorfuRuntime runtime;\n+\n+    // A map of all stream listeners and their subscription contexts.\n+    private final Map<StreamListener, StreamSubscription> subscriptions;\n+\n+    // Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Thread pool for executing client call back tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    /**\n+     * Create the stream manager, initialize the tasks pools.\n+     *\n+     * @param runtime Corfu runtime to use for streaming\n+     */\n+    public StreamingManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+\n+        this.pollingExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-poller-%d\").build());\n+        this.notificationExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-notifier-%d\").build());\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                long lastAddress) {\n+        subscribe(streamListener, namespace, streamTag, tablesOfInterest, lastAddress, DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     * @param bufferSize       maximum size of buffered transaction entries\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                long lastAddress, int bufferSize) {\n+        if (bufferSize < 1) {\n+            throw new IllegalArgumentException(\"subscribe: Buffer size cannot be less than 1.\");\n+        }\n+\n+        if (subscriptions.containsKey(streamListener)) {\n+            // Multiple subscribers subscribing to same namespace and table is allowed\n+            // as long as the hashcode() and equals() method of the listeners are different.\n+            throw new StreamSubscriptionException(\n+                    \"StreamingManager::subscribe: listener already registered \" + streamListener);\n+        }\n+\n+        StreamingMetrics metrics = new StreamingMetrics(\n+                streamListener, namespace, streamTag, runtime.getParameters().getMetricRegistry());\n+        StreamSubscription subscription = new StreamSubscription(\n+                runtime, streamListener, namespace, streamTag, tablesOfInterest, bufferSize, metrics);\n+        subscriptions.put(streamListener, subscription);\n+\n+        pollingExecutor.submit(new StreamPollingTask(this, lastAddress, subscription, pollingExecutor));\n+        notificationExecutor.submit(new StreamNotificationTask(this, subscription, notificationExecutor));\n+\n+        log.info(\"Subscribed stream listener {}, numSubscribers: {}, streamTag: {}, lastAddress: {}, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1MTIwNQ==", "bodyText": "can this be made private?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543051205", "createdAt": "2020-12-15T05:11:00Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;\n+\n+    // Corfu runtime to interact with corfu streams.\n+    private final CorfuRuntime runtime;\n+\n+    // A map of all stream listeners and their subscription contexts.\n+    private final Map<StreamListener, StreamSubscription> subscriptions;\n+\n+    // Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Thread pool for executing client call back tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    /**\n+     * Create the stream manager, initialize the tasks pools.\n+     *\n+     * @param runtime Corfu runtime to use for streaming\n+     */\n+    public StreamingManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+\n+        this.pollingExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-poller-%d\").build());\n+        this.notificationExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-notifier-%d\").build());\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                long lastAddress) {\n+        subscribe(streamListener, namespace, streamTag, tablesOfInterest, lastAddress, DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     * @param bufferSize       maximum size of buffered transaction entries\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                long lastAddress, int bufferSize) {\n+        if (bufferSize < 1) {\n+            throw new IllegalArgumentException(\"subscribe: Buffer size cannot be less than 1.\");\n+        }\n+\n+        if (subscriptions.containsKey(streamListener)) {\n+            // Multiple subscribers subscribing to same namespace and table is allowed\n+            // as long as the hashcode() and equals() method of the listeners are different.\n+            throw new StreamSubscriptionException(\n+                    \"StreamingManager::subscribe: listener already registered \" + streamListener);\n+        }\n+\n+        StreamingMetrics metrics = new StreamingMetrics(\n+                streamListener, namespace, streamTag, runtime.getParameters().getMetricRegistry());\n+        StreamSubscription subscription = new StreamSubscription(\n+                runtime, streamListener, namespace, streamTag, tablesOfInterest, bufferSize, metrics);\n+        subscriptions.put(streamListener, subscription);\n+\n+        pollingExecutor.submit(new StreamPollingTask(this, lastAddress, subscription, pollingExecutor));\n+        notificationExecutor.submit(new StreamNotificationTask(this, subscription, notificationExecutor));\n+\n+        log.info(\"Subscribed stream listener {}, numSubscribers: {}, streamTag: {}, lastAddress: {}, \" +\n+                \"namespace {}, tables {}\", streamListener, subscriptions.size(), streamTag, lastAddress,\n+                namespace, tablesOfInterest);\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener client listener to unsubscribe\n+     */\n+    synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        unsubscribe(streamListener, true);\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener            client listener to unsubscribe\n+     * @param warnIfNotSubscribedBefore whether to log warning if listener is not\n+     *                                  subscribed or already unsubscribed\n+     */\n+    synchronized void unsubscribe(@Nonnull StreamListener streamListener,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1MTI4MQ==", "bodyText": "can it be made private?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543051281", "createdAt": "2020-12-15T05:11:16Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;\n+\n+    // Corfu runtime to interact with corfu streams.\n+    private final CorfuRuntime runtime;\n+\n+    // A map of all stream listeners and their subscription contexts.\n+    private final Map<StreamListener, StreamSubscription> subscriptions;\n+\n+    // Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Thread pool for executing client call back tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    /**\n+     * Create the stream manager, initialize the tasks pools.\n+     *\n+     * @param runtime Corfu runtime to use for streaming\n+     */\n+    public StreamingManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+\n+        this.pollingExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-poller-%d\").build());\n+        this.notificationExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,\n+                new ThreadFactoryBuilder().setNameFormat(\"streaming-notifier-%d\").build());\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                long lastAddress) {\n+        subscribe(streamListener, namespace, streamTag, tablesOfInterest, lastAddress, DEFAULT_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Subscribe to transaction updates.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        namespace of interested tables\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables will be returned\n+     * @param lastAddress      last processed address, new notifications start from lastAddress + 1\n+     * @param bufferSize       maximum size of buffered transaction entries\n+     */\n+    synchronized void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1Mjg5MQ==", "bodyText": "where will these executors be shut down?  They should always be running while Corfu server is up but do we need a method which hooks with the server shutdown and stops these executors?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543052891", "createdAt": "2020-12-15T05:16:04Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;\n+\n+    // Corfu runtime to interact with corfu streams.\n+    private final CorfuRuntime runtime;\n+\n+    // A map of all stream listeners and their subscription contexts.\n+    private final Map<StreamListener, StreamSubscription> subscriptions;\n+\n+    // Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Thread pool for executing client call back tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    /**\n+     * Create the stream manager, initialize the tasks pools.\n+     *\n+     * @param runtime Corfu runtime to use for streaming\n+     */\n+    public StreamingManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+\n+        this.pollingExecutor = Executors.newFixedThreadPool(NUM_THREAD_PER_POOL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1NDk0Mw==", "bodyText": "javax imports after java?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543054943", "createdAt": "2020-12-15T05:21:50Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -42,6 +32,19 @@\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n+import java.lang.reflect.InvocationTargetException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1Njg2MA==", "bodyText": "can we create it in the constructor instead?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r543056860", "createdAt": "2020-12-15T05:27:17Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -461,6 +486,21 @@ public synchronized StreamManager getStreamManager() {\n         return this.streamManager;\n     }\n \n+    /**\n+     * Register a streaming subscription manager as a singleton.\n+     */\n+    public StreamingManager getStreamingManager() {\n+        if (streamingManager == null) {\n+            synchronized (StreamingManager.class) {\n+                if (streamingManager == null) {\n+                    streamingManager = new StreamingManager(runtime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a"}, "originalPosition": 185}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d1ddfdb6eeb05fa3c3c6831821f2830e897224a", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/1d1ddfdb6eeb05fa3c3c6831821f2830e897224a", "committedDate": "2020-11-24T00:46:44Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "366d3349fb16da68c937e930bf3b8ae5c065e59e", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/366d3349fb16da68c937e930bf3b8ae5c065e59e", "committedDate": "2020-12-18T00:32:46Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NzIwMzM0", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-555720334", "createdAt": "2020-12-18T18:32:45Z", "commit": {"oid": "366d3349fb16da68c937e930bf3b8ae5c065e59e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "366d3349fb16da68c937e930bf3b8ae5c065e59e", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/366d3349fb16da68c937e930bf3b8ae5c065e59e", "committedDate": "2020-12-18T00:32:46Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "6526ed062898c697f0c1c8fc695f51d7cb4bbaea", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/6526ed062898c697f0c1c8fc695f51d7cb4bbaea", "committedDate": "2021-01-04T22:46:29Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6526ed062898c697f0c1c8fc695f51d7cb4bbaea", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/6526ed062898c697f0c1c8fc695f51d7cb4bbaea", "committedDate": "2021-01-04T22:46:29Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/0d585a7f61fc34181d505ebe4d19c7ddf070ef7d", "committedDate": "2021-01-06T22:29:13Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjQwMDI1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564640025", "createdAt": "2021-01-08T23:07:29Z", "commit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMzowNzoyOVrOIQkH-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMzowNzoyOVrOIQkH-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIzOTk5NQ==", "bodyText": "Deprecate the subscribe method that uses the old stream manager too ?\nhttps://github.com/CorfuDB/CorfuDB/pull/2826/files#diff-f44ea07bfcd37e9243f12f8e2e3666056f2a25d4943965e359e61a43d4e64135R257", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554239995", "createdAt": "2021-01-08T23:07:29Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -274,21 +274,40 @@ void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace\n      *                         if null, only future updates will be returned\n      */\n     public void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n-                   @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n-                   @Nullable Timestamp timestamp) {\n-        runtime.getTableRegistry().getStreamManager()\n+                          @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjQ1Njg3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564645687", "createdAt": "2021-01-08T23:26:19Z", "commit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMzoyNjoxOVrOIQkbxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMzoyNjoxOVrOIQkbxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI0NTA2MA==", "bodyText": "This looks like a leak. You are allowing subscribe to be called from StreamManager and StreamingManager but unsubscribe only invokes StreamingManager::unsubscribe", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554245060", "createdAt": "2021-01-08T23:26:19Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -274,21 +274,40 @@ void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace\n      *                         if null, only future updates will be returned\n      */\n     public void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n-                   @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n-                   @Nullable Timestamp timestamp) {\n-        runtime.getTableRegistry().getStreamManager()\n+                          @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                          @Nullable Timestamp timestamp) {\n+        runtime.getTableRegistry().getStreamingManager()\n                 .subscribe(streamListener, namespace, streamTag, tablesOfInterest,\n                         (timestamp == null) ? getTimestamp().getSequence() : timestamp.getSequence());\n     }\n \n+    /**\n+     * Subscribe to transaction updates on specific tables with the streamTag in the namespace.\n+     * Objects returned will honor transactional boundaries.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        the CorfuStore namespace to subscribe to\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables of interest will be sent to listener\n+     * @param timestamp        if specified, all stream updates after this timestamp will be returned\n+     *                         if null, only future updates will be returned\n+     * @param bufferSize       maximum size of buffered transaction entries\n+     */\n+    public void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                          @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                          @Nullable Timestamp timestamp, int bufferSize) {\n+        runtime.getTableRegistry().getStreamingManager()\n+                .subscribe(streamListener, namespace, streamTag, tablesOfInterest,\n+                        (timestamp == null) ? getTimestamp().getSequence() : timestamp.getSequence(), bufferSize);\n+    }\n+\n     /**\n      * Gracefully shutdown a streamer.\n      * Once this call returns no further stream updates will be returned.\n      *\n      * @param streamListener - callback context.\n      */\n     public void unsubscribe(@Nonnull StreamListener streamListener) {\n-        runtime.getTableRegistry().getStreamManager()\n-                .unsubscribe(streamListener);\n+        runtime.getTableRegistry().getStreamingManager().unsubscribe(streamListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d585a7f61fc34181d505ebe4d19c7ddf070ef7d", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/0d585a7f61fc34181d505ebe4d19c7ddf070ef7d", "committedDate": "2021-01-06T22:29:13Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "f3fa07b2916b80a3a06d234e5e593689ed4850ba", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f3fa07b2916b80a3a06d234e5e593689ed4850ba", "committedDate": "2021-01-09T00:52:55Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3fa07b2916b80a3a06d234e5e593689ed4850ba", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f3fa07b2916b80a3a06d234e5e593689ed4850ba", "committedDate": "2021-01-09T00:52:55Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa", "committedDate": "2021-01-09T00:55:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjY4ODQ1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564668845", "createdAt": "2021-01-09T01:15:44Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMToxNTo0NFrOIQl3HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMToxNTo0NFrOIQl3HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI2ODQ0NA==", "bodyText": "Do you need to expose this to the shim CorfuStoreShim ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554268444", "createdAt": "2021-01-09T01:15:44Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -273,22 +277,52 @@ void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace\n      * @param timestamp        if specified, all stream updates from this timestamp will be returned\n      *                         if null, only future updates will be returned\n      */\n-    public void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n-                   @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n-                   @Nullable Timestamp timestamp) {\n-        runtime.getTableRegistry().getStreamManager()\n+    public void subscribeListener(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                                  @Nonnull String streamTag, @Nonnull List<String> tablesOfInterest,\n+                                  @Nullable Timestamp timestamp) {\n+        runtime.getTableRegistry().getStreamingManager()\n                 .subscribe(streamListener, namespace, streamTag, tablesOfInterest,\n                         (timestamp == null) ? getTimestamp().getSequence() : timestamp.getSequence());\n     }\n \n+    /**\n+     * Subscribe to transaction updates on specific tables with the streamTag in the namespace.\n+     * Objects returned will honor transactional boundaries.\n+     *\n+     * @param streamListener   client listener for callback\n+     * @param namespace        the CorfuStore namespace to subscribe to\n+     * @param streamTag        only updates of tables with the stream tag will be polled\n+     * @param tablesOfInterest only updates from these tables of interest will be sent to listener\n+     * @param timestamp        if specified, all stream updates after this timestamp will be returned\n+     *                         if null, only future updates will be returned\n+     * @param bufferSize       maximum size of buffered transaction entries\n+     */\n+    public void subscribeListener(@Nonnull StreamListener streamListener, @Nonnull String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjcxMTA3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564671107", "createdAt": "2021-01-09T01:33:28Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMTozMzoyOVrOIQmBKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMTozMzoyOVrOIQmBKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MTAxOA==", "bodyText": "How do you stop the StreamingManager ?\nThis class is creating non-daemon threads and ignoring interrupts. A shutdown/close method should be added an invoked from CorfuStore.\nAlso, why is StreamManager::shutdown invoked from TableRegistry, it seems very strange.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554271018", "createdAt": "2021-01-09T01:33:29Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjcxNTUx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564671551", "createdAt": "2021-01-09T01:37:22Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMTozNzoyM1rOIQmDaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMTozNzoyM1rOIQmDaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3MTU5NQ==", "bodyText": "These have to be configurable and exposed. We have already seen bugs where we need to be able to tune a bunch of parameters. Unfortunately, most of our configurations are not configurable and require source code changes.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554271595", "createdAt": "2021-01-09T01:37:23Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0Njc3MjAy", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564677202", "createdAt": "2021-01-09T02:40:48Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMjo0MDo0OVrOIQmglw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMjo0MDo0OVrOIQmglw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI3OTA2Mw==", "bodyText": "You can improve the read performance by introducing a local variable. For example,\npublic StreamingManager getStreamingManager() {\n        StreamingManager localRef = streamingManager;\n        if (localRef == null) {\n            synchronized (this) {\n                localRef = streamingManager;\n                if (localRef == null) {\n                    localRef = streamingManager = new StreamingManager(runtime);\n                }\n            }\n        }\n        return localRef;\n    }", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554279063", "createdAt": "2021-01-09T02:40:49Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -480,6 +505,21 @@ public synchronized StreamManager getStreamManager() {\n         return this.streamManager;\n     }\n \n+    /**\n+     * Register a streaming subscription manager as a singleton.\n+     */\n+    public StreamingManager getStreamingManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0Njc4MzU4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564678358", "createdAt": "2021-01-09T02:58:21Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMjo1ODoyMlrOIQmnvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwMjo1ODoyMlrOIQmnvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4MDg5Mw==", "bodyText": "Not related to this PR per-se but should these types be validated when registryTable is populated ? So TableRegistry should try to load the types with the class loader and should fail with ClassNotFoundException if the type is not there, which is more appropriate than NoSuchElementException", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554280893", "createdAt": "2021-01-09T02:58:22Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -393,19 +419,18 @@ public static String getFullyQualifiedTableName(TableName tableName) {\n             // To do so, consult the TableRegistry for an entry which indicates the table exists.\n             if (registryTable.containsKey(\n                     TableName.newBuilder()\n-                    .setNamespace(namespace)\n-                    .setTableName(tableName)\n-                    .build())\n+                            .setNamespace(namespace)\n+                            .setTableName(tableName)\n+                            .build())\n             ) {\n                 // If table does exist then the caller must use the long form of the openTable()\n                 // since there are too few arguments to open a table not seen by this runtime.\n                 throw new IllegalArgumentException(\"Please provide Key, Value & Metadata schemas to re-open\"\n-                + \" this existing table \" + tableName + \" in namespace \" + namespace);\n+                        + \" this existing table \" + tableName + \" in namespace \" + namespace);\n             } else {\n-                // If the table is completely unheard of return NoSuchElementException\n-                throw new NoSuchElementException(\n-                        String.format(\"No such table found: namespace: %s, tableName: %s\",\n-                        namespace, tableName));\n+                // If the table is completely unheard of return NoSuchElementException.\n+                throw new NoSuchElementException(String.format(\n+                        \"No such table found: namespace: %s, tableName: %s\", namespace, tableName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgyNDU3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564682457", "createdAt": "2021-01-09T04:09:43Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDowOTo0NFrOIQnCJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDowOTo0NFrOIQnCJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4NzY1Mw==", "bodyText": "You can simplyf this logic to\n        long lastAddress = 0;\n        while (iterator.hasNext() && --maxEntries > 0) {\n            lastAddress = iterator.next();\n        }\n\n        return lastAddress;", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554287653", "createdAt": "2021-01-09T04:09:44Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AddressMapStreamView.java", "diffHunk": "@@ -383,7 +382,34 @@ private boolean isTrimCoveredByCheckpoint(long trimMark) {\n      * @return whether this stream is capable of being checkpointed\n      */\n     private boolean isCheckpointCapable() {\n-        return !getId().equals(ObjectsView.TRANSACTION_STREAM_ID);\n+        return !getId().equals(ObjectsView.TRANSACTION_STREAM_ID)\n+                && getStreamOptions().isCheckpointCapable();\n+    }\n+\n+    @Override\n+    protected long getMaxGlobalFromMaxEntries(int maxEntries) {\n+        if (maxEntries == Integer.MAX_VALUE) {\n+            return Address.MAX;\n+        }\n+\n+        StreamAddressSpace streamAddressSpace = runtime.getSequencerView()\n+                .getStreamAddressSpace(new StreamAddressRange(getId(), Address.MAX, getCurrentGlobalPosition()));\n+\n+        long size = streamAddressSpace.getAddressMap().getLongCardinality();\n+        if (size == 0L) {\n+            return Address.NON_ADDRESS;\n+        }\n+\n+        if (size <= maxEntries) {\n+            return streamAddressSpace.getHighestAddress();\n+        }\n+\n+        LongIterator it = streamAddressSpace.getAddressMap().getLongIterator();\n+        while (--maxEntries > 0) {\n+            it.next();\n+        }\n+\n+        return it.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgyNjYx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564682661", "createdAt": "2021-01-09T04:13:52Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoxMzo1MlrOIQnDhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoxMzo1MlrOIQnDhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4ODAwNw==", "bodyText": "This will emit all of of unnecessary sequencer queries. A sequencer query should only be called if maxEntries + current pointer address is larger than maxResolution ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554288007", "createdAt": "2021-01-09T04:13:52Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/AbstractQueuedStreamView.java", "diffHunk": "@@ -397,6 +401,34 @@ private void processTrimmedException(TrimmedException te) {\n                 .collect(Collectors.toList());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<ILogData> remainingAtMost(int maxEntries) {\n+        // TODO: instrument remainingUpTo directly to limit the number of\n+        // of entries returned instead of calling it.\n+        if (maxEntries < 1) {\n+            throw new IllegalArgumentException(\n+                    \"remainingAtMost(): maxEntries cannot be less than 1.\");\n+        }\n+\n+        long maxGlobal = getMaxGlobalFromMaxEntries(maxEntries);\n+        if (Address.nonAddress(maxGlobal)) {\n+            return Collections.emptyList();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgyODcx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564682871", "createdAt": "2021-01-09T04:18:48Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoxODo0OVrOIQnFdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoxODo0OVrOIQnFdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4ODUwMg==", "bodyText": "Shouldn't this be scoped to a namespace (i.e., STREAM_TAG_PREFIX + nameSpace + streamTag) ?\nThere could be an issue were subscribers can read data from a different namespace.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554288502", "createdAt": "2021-01-09T04:18:49Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/TableRegistry.java", "diffHunk": "@@ -293,6 +302,16 @@ public static String getFullyQualifiedTableName(TableName tableName) {\n         return getFullyQualifiedTableName(tableName.getNamespace(), tableName.getTableName());\n     }\n \n+    /**\n+     * Return the stream Id for the provided stream tag.\n+     *\n+     * @param streamTag stream tag in string\n+     * @return stream Id in UUID\n+     */\n+    public static UUID getStreamIdForStreamTag(String streamTag) {\n+        return CorfuRuntime.getStreamID(STREAM_TAG_PREFIX + streamTag);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgzMzc4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564683378", "createdAt": "2021-01-09T04:29:43Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoyOTo0M1rOIQnI2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDoyOTo0M1rOIQnI2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4OTM3MQ==", "bodyText": "Instead of returning an incorrect value here and relying on remainingAtMost to throw an exception I think its cleaner to just move UnsupportedOperationException to a default implementation in the IStreamView interface.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554289371", "createdAt": "2021-01-09T04:29:43Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/stream/BackpointerStreamView.java", "diffHunk": "@@ -178,5 +185,10 @@ protected boolean discoverAddressSpace(final UUID streamId,\n \n         return !queue.isEmpty();\n     }\n+\n+    @Override\n+    protected long getMaxGlobalFromMaxEntries(int maxEntries) {\n+        return Address.MAX;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgzNjgx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564683681", "createdAt": "2021-01-09T04:37:03Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDozNzowM1rOIQnLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDozNzowM1rOIQnLbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MDAzMA==", "bodyText": "Is this class only required for logging purposes? If the these stats can't be accessed externally and only used for logging, then I would suggest converting it to a proper Metric so that we can collect it and log it as within our metrics performance library.\nThis metric can be kept registered and kept in the StreamSubscription instance.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554290030", "createdAt": "2021-01-09T04:37:03Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingMetrics.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * List of metrics captured for a stream listener.\n+ * <p>\n+ * Created by WenbinZhu on 11/23/20.\n+ */\n+public class StreamingMetrics {\n+\n+    private final String listenerId;\n+\n+    private final TimingHistogram deliveryDuration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjgzNzc5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564683779", "createdAt": "2021-01-09T04:39:14Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDozOToxNVrOIQnMAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDozOToxNVrOIQnMAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MDE3OQ==", "bodyText": "You can just nuke this and use a histogram from Micrometer. I also think that record is a better verb than set here.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554290179", "createdAt": "2021-01-09T04:39:15Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingMetrics.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * List of metrics captured for a stream listener.\n+ * <p>\n+ * Created by WenbinZhu on 11/23/20.\n+ */\n+public class StreamingMetrics {\n+\n+    private final String listenerId;\n+\n+    private final TimingHistogram deliveryDuration;\n+\n+    StreamingMetrics(StreamListener listener, String namespace, String streamTag, MetricRegistry registry) {\n+        this.listenerId = String.format(\"StreamListener_%s_%s_%s\", listener, namespace, streamTag);\n+        this.deliveryDuration = new TimingHistogram(registry.histogram(listenerId + \"_deliveryDuration\"));\n+    }\n+\n+    public void setDeliveryDuration(long elapsedTime) {\n+        deliveryDuration.update(elapsedTime);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NjkwNzUx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564690751", "createdAt": "2021-01-09T07:17:02Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNzoxNzowMlrOIQoArg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNzoxNzowMlrOIQoArg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMwMzY2Mg==", "bodyText": "This won't produce any metrics. We moved away from using dropwizard to micrometer, make sure the correct registry is passed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554303662", "createdAt": "2021-01-09T07:17:02Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingMetrics.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.codahale.metrics.MetricRegistry;\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * List of metrics captured for a stream listener.\n+ * <p>\n+ * Created by WenbinZhu on 11/23/20.\n+ */\n+public class StreamingMetrics {\n+\n+    private final String listenerId;\n+\n+    private final TimingHistogram deliveryDuration;\n+\n+    StreamingMetrics(StreamListener listener, String namespace, String streamTag, MetricRegistry registry) {\n+        this.listenerId = String.format(\"StreamListener_%s_%s_%s\", listener, namespace, streamTag);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NzA2Njgx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564706681", "createdAt": "2021-01-09T08:34:03Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozNDowNFrOIQoa9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozNDowNFrOIQoa9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDM5MA==", "bodyText": "This is not the only way to prevent busy polling and can cause high latencies.\nIf you have 1 thread running the notification tasks and 8 subscriptions and only one that is producing data then, the listener of that active stream will take 7 * 50 milliseconds to deliver the notification. You can try to hide this by increasing the number of threads in the notification task, but then the pathological case can be really bad and it doesn't seem like its unlikely, or rather, its not clear that at most a 50ms penalty will be inured.\nDepending on the producer rate it seems really hard to reason about the worst case. It's better to just use a scheduled executor and push that sleep to the executor scheduling instead of doing it before the submit.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554310390", "createdAt": "2021-01-09T08:34:04Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NzEyMDk4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564712098", "createdAt": "2021-01-09T08:37:38Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozNzozOFrOIQocbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwODozNzozOFrOIQocbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMDc2NQ==", "bodyText": "Can you just put a sanity check here that the lastReadAddress is not regressing ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554310765", "createdAt": "2021-01-09T08:37:38Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+\n+        // No new updates, take a short break and poll again.\n+        if (updates.isEmpty()) {\n+            TimeUnit.MILLISECONDS.sleep(IDLE_WAIT_TIME_MS.toMillis());\n+            pollingExecutor.submit(this);\n+            return;\n+        }\n+\n+        // Insert polled updates to the subscription buffer, with a shared\n+        // fixed amount of time waiting for buffer being not full.\n+        long remainingBlockTime = QUEUE_FULL_BLOCK_TIME_MS.toNanos();\n+        for (ILogData update : updates) {\n+            if (subscription.isStopped()) {\n+                return;\n+            }\n+\n+            // Buffer is full after max waiting time elapses, break and re-schedule.\n+            long startTime = System.nanoTime();\n+            if (!subscription.enqueueStreamEntry(update, remainingBlockTime)) {\n+                break;\n+            }\n+\n+            remainingBlockTime -= System.nanoTime() - startTime;\n+            lastReadAddress = update.getGlobalAddress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NzYxNDI1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564761425", "createdAt": "2021-01-09T09:11:34Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOToxMTozNFrOIQonLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOToxMTozNFrOIQonLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxMzUxOQ==", "bodyText": "The logic can be simplified while also improving graceful degradation by actually trying to check if StreamSubscription::streamBuffer has enough space before issuing the read to the server. Otherwise if the system is in a degraded state and the buffers are not being consumed fast enough, then you will be issuing reads and computing all the logic in StreamSubscription::enqueueStreamEntry  and then returning false on streamBuffer.offer.\nWhen throttling is actually required its probably better assume the pessimistic case vs the optimistic case (i.e., current logic): where you hope the the queue clears up while you're doing your processing.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554313519", "createdAt": "2021-01-09T09:11:34Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamPollingTask.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A runnable task for a subscription to poll data change from the\n+ * transaction stream and put into the subscription's buffer. This\n+ * task is executed by the thread pool continuously until an error\n+ * occurs which would stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamPollingTask implements Runnable {\n+\n+    // A period of time in ms to sleep before next cycle when poller gets no new data changes.\n+    private static final Duration IDLE_WAIT_TIME_MS = Duration.ofMillis(50);\n+\n+    // Total amount of time to wait for putting the polled data changes into buffer if it is full.\n+    private static final Duration QUEUE_FULL_BLOCK_TIME_MS = Duration.ofMillis(2_000);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The corfu transaction stream to poll data changes from.\n+    private final IStreamView txnStream;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Last address of the data successfully processed by the buffer.\n+    private long lastReadAddress;\n+\n+    StreamPollingTask(StreamingManager streamingManager, long lastAddress,\n+                      StreamSubscription subscription, ExecutorService executor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.pollingExecutor = executor;\n+        this.lastReadAddress = lastAddress;\n+        this.txnStream = subscription.getTxnStream();\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            pollTxnStream();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during txn stream polling, listener: {}, \" +\n+                    \"namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Poll new data changes from the transaction stream and put into\n+     * the subscription's buffer one by one.\n+     */\n+    private void pollTxnStream() throws Exception {\n+        // If listener already unsubscribed, do not process or schedule again.\n+        if (subscription.isStopped()) {\n+            return;\n+        }\n+\n+        // Seek to next address and poll transaction updates.\n+        txnStream.seek(lastReadAddress + 1L);\n+        List<ILogData> updates = txnStream.remainingAtMost(subscription.getStreamBufferSize());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0NzcwNzM0", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-564770734", "createdAt": "2021-01-09T09:26:03Z", "commit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOToyNjowM1rOIQo9dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwOToyNjowM1rOIQo9dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDMxOTIyMQ==", "bodyText": "There are so many use cases where the client would want to control their own threading. I think we should just allow them to pass in an executor when calling subscribe. For example, they might need to prioritize some subscriptions over other subscriptions.\nFurthermore, it makes it harder to test. For example, the application can't write a deterministic unit test if they can't control the executors in StreamingManager. If the application is able to passs their own exeuctors, then they can deterministcly test call backs using something like  MoreExecutors.newDirectExecutorService.\nFinally, if they own their threading then they have to manage the exeuctors lifecycle, which means we don't need to make a decision on their behalf on whether threads should be daemon or not, and its less code for us.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r554319221", "createdAt": "2021-01-09T09:26:03Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamingManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+\n+import javax.annotation.Nonnull;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A streaming subscription manager that allows clients to listen on\n+ * the transaction updates of interested tables. The updates will be\n+ * streamlined and clients can get notifications via the registered\n+ * call backs.\n+ * <p>\n+ * Created by WenbinZhu on 11/5/20.\n+ */\n+@Slf4j\n+public class StreamingManager {\n+\n+    // Number of thread in polling and notification pool.\n+    private static final int NUM_THREAD_PER_POOL = 4;\n+\n+    // Default buffer size for each subscription.\n+    private static final int DEFAULT_BUFFER_SIZE = 50;\n+\n+    // Corfu runtime to interact with corfu streams.\n+    private final CorfuRuntime runtime;\n+\n+    // A map of all stream listeners and their subscription contexts.\n+    private final Map<StreamListener, StreamSubscription> subscriptions;\n+\n+    // Thread pool for executing stream polling tasks.\n+    private final ExecutorService pollingExecutor;\n+\n+    // Thread pool for executing client call back tasks.\n+    private final ExecutorService notificationExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/5e25ca91a6cbd59de644dbc60ca7c66eaeb6adaa", "committedDate": "2021-01-09T00:55:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "c65f0e24e7d42cc1df437e4ce5adea62647140c0", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c65f0e24e7d42cc1df437e4ce5adea62647140c0", "committedDate": "2021-01-11T20:43:14Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c65f0e24e7d42cc1df437e4ce5adea62647140c0", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c65f0e24e7d42cc1df437e4ce5adea62647140c0", "committedDate": "2021-01-11T20:43:14Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "d94c5119ebe39a2b8dd66ce25bfb9391a0f9e020", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/d94c5119ebe39a2b8dd66ce25bfb9391a0f9e020", "committedDate": "2021-01-12T02:00:25Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d94c5119ebe39a2b8dd66ce25bfb9391a0f9e020", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/d94c5119ebe39a2b8dd66ce25bfb9391a0f9e020", "committedDate": "2021-01-12T02:00:25Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "8ee51d4b19303bc8d0357677577d2979d0c9814d", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8ee51d4b19303bc8d0357677577d2979d0c9814d", "committedDate": "2021-01-12T02:15:01Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ee51d4b19303bc8d0357677577d2979d0c9814d", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/8ee51d4b19303bc8d0357677577d2979d0c9814d", "committedDate": "2021-01-12T02:15:01Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "ee314c580d475d35445cd01f4df23bb070192fd2", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ee314c580d475d35445cd01f4df23bb070192fd2", "committedDate": "2021-01-12T03:47:21Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee314c580d475d35445cd01f4df23bb070192fd2", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ee314c580d475d35445cd01f4df23bb070192fd2", "committedDate": "2021-01-12T03:47:21Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "211bd1f813836bfb2068ad57bfa334f87ad052a6", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/211bd1f813836bfb2068ad57bfa334f87ad052a6", "committedDate": "2021-01-12T21:34:53Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "211bd1f813836bfb2068ad57bfa334f87ad052a6", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/211bd1f813836bfb2068ad57bfa334f87ad052a6", "committedDate": "2021-01-12T21:34:53Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "1f9cc57f4944b39980512fbcb3b8f03c0c19698e", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/1f9cc57f4944b39980512fbcb3b8f03c0c19698e", "committedDate": "2021-01-12T21:35:59Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f9cc57f4944b39980512fbcb3b8f03c0c19698e", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/1f9cc57f4944b39980512fbcb3b8f03c0c19698e", "committedDate": "2021-01-12T21:35:59Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "a80c7038cb1ae01ce89ea650437b72477072d3ff", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/a80c7038cb1ae01ce89ea650437b72477072d3ff", "committedDate": "2021-01-13T19:56:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a80c7038cb1ae01ce89ea650437b72477072d3ff", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/a80c7038cb1ae01ce89ea650437b72477072d3ff", "committedDate": "2021-01-13T19:56:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/3b658e373336d683693c685bd0bf77774b00b7a8", "committedDate": "2021-01-14T01:08:22Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MDE1MjQ5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-568015249", "createdAt": "2021-01-14T08:40:13Z", "commit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODo0MDoxM1rOITZRPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODo0MDoxM1rOITZRPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzIwNzg3MQ==", "bodyText": "Can you also add metrics on the consumer side. The kvstore already has issues where the consumer callbacks consume too much time, so I'm expecting we will need to track this as well.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r557207871", "createdAt": "2021-01-14T08:40:13Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamSubscriptionMetrics.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.corfudb.runtime.collections;\n+\n+import io.micrometer.core.instrument.Timer;\n+import org.corfudb.runtime.CorfuRuntime;\n+\n+import java.util.Optional;\n+\n+/**\n+ * List of metrics captured for a stream listener.\n+ * <p>\n+ * Created by WenbinZhu on 11/23/20.\n+ */\n+public class StreamSubscriptionMetrics {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MDIwNTgw", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-568020580", "createdAt": "2021-01-14T08:47:41Z", "commit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODo0Nzo0MlrOITaCdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQwODo0Nzo0MlrOITaCdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzIyMDQ2OQ==", "bodyText": "Can you also add\nif (iter == 0 && nextUpdate == null) {\n\n notificationExecutor.schedule(this, IDLE_WAIT_TIME_MS, TimeUnit.MILLISECONDS);\nreturn;\n     }\nThis will prevent unnecessary waits on the consumer side when the stream is always empty. This improves the CPU usage for empty streams, but the ideal solution is to only submit the task if the producer enqueued entries. Going from 50ms polling to seconds should be ok for our scale, I think.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#discussion_r557220469", "createdAt": "2021-01-14T08:47:42Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamNotificationTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.corfudb.runtime.collections;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.time.Duration;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * A runnable task for a subscription to retrieve the previously\n+ * polled transaction updates from the buffer and send notifications\n+ * to client via the registered call backs. This task is executed\n+ * by the thread pool continuously until an error occurs which would\n+ * stop the subscription.\n+ * <p>\n+ * Created by WenbinZhu on 11/9/20.\n+ */\n+@Slf4j\n+class StreamNotificationTask implements Runnable {\n+\n+    // Number of transaction updates to send notification in each run.\n+    private static final int NOTIFICATION_BATCH_SIZE = 10;\n+\n+    // Total amount of time to wait for retrieving the data changes from buffer if it is empty.\n+    private static final Duration QUEUE_EMPTY_BLOCK_TIME_MS = Duration.ofMillis(1_000);\n+\n+    // A warning will be raised if client call back takes longer than this time threshold.\n+    private static final Duration SLOW_NOTIFICATION_TIME_MS = Duration.ofMillis(1_500);\n+\n+    // The streaming manager that is in charge of listener subscriptions.\n+    private final StreamingManager streamingManager;\n+\n+    // The subscription context associated with this task.\n+    private final StreamSubscription subscription;\n+\n+    // The Thread pool for executing client notification tasks.\n+    private final ExecutorService notificationExecutor;\n+\n+    StreamNotificationTask(StreamingManager streamingManager,\n+                           StreamSubscription subscription,\n+                           ExecutorService notificationExecutor) {\n+        this.streamingManager = streamingManager;\n+        this.subscription = subscription;\n+        this.notificationExecutor = notificationExecutor;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            sendNotifications();\n+        } catch (Throwable throwable) {\n+            StreamListener listener = subscription.getListener();\n+            log.error(\"Encountered exception {} during client notification callback, \" +\n+                    \"listener: {}, namespace: {}\", throwable, listener, subscription.getNamespace());\n+            streamingManager.unsubscribe(listener, false);\n+            listener.onError(throwable);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the first data change from the buffer and send notification\n+     * to the client via the pre-registered call back.\n+     */\n+    private void sendNotifications() throws Exception {\n+        // Total amount of time for the batch waiting for buffer being not empty.\n+        long remainingBlockTime = QUEUE_EMPTY_BLOCK_TIME_MS.toNanos();\n+        StreamListener listener = subscription.getListener();\n+\n+        for (int iter = 0; iter < NOTIFICATION_BATCH_SIZE; iter++) {\n+            // If listener already unsubscribed, do not process or schedule again.\n+            if (subscription.isStopped()) {\n+                return;\n+            }\n+\n+            long startTime = System.nanoTime();\n+            CorfuStreamEntries nextUpdate = subscription.dequeueStreamEntry(remainingBlockTime);\n+\n+            // No new updates after max waiting time elapses, break and re-schedule.\n+            if (nextUpdate == null) {\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MDI1MDQz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2826#pullrequestreview-568025043", "createdAt": "2021-01-14T08:53:48Z", "commit": {"oid": "3b658e373336d683693c685bd0bf77774b00b7a8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6bf8e4b3d0c6c8733bc38cc9e8ff7d9f016208b8", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/6bf8e4b3d0c6c8733bc38cc9e8ff7d9f016208b8", "committedDate": "2021-01-14T09:15:17Z", "message": "Merge branch 'master' into ufo_stream_redesign_impl_2"}, "afterCommit": {"oid": "87013c882f049532686fde452c9b159d3902dcca", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/87013c882f049532686fde452c9b159d3902dcca", "committedDate": "2021-01-15T01:08:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4653d95650906dc470df7278b96911bf00491aad", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4653d95650906dc470df7278b96911bf00491aad", "committedDate": "2021-01-20T19:27:24Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87013c882f049532686fde452c9b159d3902dcca", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/87013c882f049532686fde452c9b159d3902dcca", "committedDate": "2021-01-15T01:08:37Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}, "afterCommit": {"oid": "4653d95650906dc470df7278b96911bf00491aad", "author": {"user": {"login": "WenbinZhu", "name": "Wenbin Zhu"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4653d95650906dc470df7278b96911bf00491aad", "committedDate": "2021-01-20T19:27:24Z", "message": "CorfuStore streaming redesign part 3 - implementation and integration.\n\nImplements the new subscription API and new threading model for\nstreaming and integrate into CorfuStore."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4153, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}