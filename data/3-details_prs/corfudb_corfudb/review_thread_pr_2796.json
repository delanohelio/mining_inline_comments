{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MTUyNTY1", "number": 2796, "reviewThreads": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyMTowOVrOEwd0Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjozMToxOFrOE0ozlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjU1NTk4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyMTowOVrOHmDUUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyMTowOVrOHmDUUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2MjI4OQ==", "bodyText": "You don't need this check. It's already done above.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509662289", "createdAt": "2020-10-21T20:21:09Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjU2Nzk5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyMzo0OFrOHmDcFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyMzo0OFrOHmDcFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NDI3OQ==", "bodyText": "Also, can we change state to handshake? It clearer this way and more consistent.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509664279", "createdAt": "2020-10-21T20:23:48Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjU4ODIyOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyNzoxNFrOHmDpHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyNzoxNFrOHmDpHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2NzYxNA==", "bodyText": "Is the first RequestMsg always going to be a handshake request? It might be a good idea to check anyways.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509667614", "createdAt": "2020-10-21T20:27:14Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjU5Mjc3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyODoyNFrOHmDr6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDoyODoyNFrOHmDr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY2ODMzMA==", "bodyText": "You should really try to avoid unassigned variables. Take a look at my comment about the return statement below.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509668330", "createdAt": "2020-10-21T20:28:24Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjYwNzM5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDozMjoxMlrOHmD07Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDozMjoxMlrOHmD07Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY3MDYzNw==", "bodyText": "You should make this a precondition check as well. Currently you have:\n\nif (A) {\n  X...\n} else {\n  Y...\n}\n\nZ...\n\nYou can re-organize this:\nif (!A) {\n  Y...\n}\n\nX...\nZ...\n\nThis way you avoid unassigned variables.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509670637", "createdAt": "2020-10-21T20:32:12Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -73,37 +77,36 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n             super.channelRead(ctx, m);\n             return;\n         }\n+        UUID clientId = null;\n+        UUID serverId = null;\n \n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n+        if (m instanceof RequestMsg) {\n+            RequestMsg request = ((RequestMsg) m);\n+            HandshakeRequestMsg handshakeRequest = request.getPayload().getHandshakeRequest();\n \n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n             log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n                     READ_TIMEOUT_HANDLER);\n+\n             // Remove the handler from the pipeline. Also remove the reference of the context from\n             // the handler so that it does not disconnect the channel.\n             ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n+\n+            clientId = getUUID(handshakeRequest.getClientId());\n+            serverId = getUUID(handshakeRequest.getServerId());\n+        } else {\n+            log.warn(\"channelRead: Invalid message received by handshake handler. Message - {}\", m);\n             if (this.state.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                // The message was unregistered, we are dropping it.\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);\n             }\n+\n             return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjY4MDU1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo0Nzo1N1rOHmEmJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMDo0Nzo1N1rOHmEmJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY4MzIzOA==", "bodyText": "You should make this a precondition check and return. This will reduce the amount of if-else nesting.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509683238", "createdAt": "2020-10-21T20:47:57Z", "author": {"login": "vjeko"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -231,7 +244,14 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             log.debug(\"write: Handshake already completed, not appending corfu message to queue\");\n             super.write(ctx, msg, promise);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mjc2NTM1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTowNzoyNVrOHmFdqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTowNzoyNVrOHmFdqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzQ1MQ==", "bodyText": "Style: space after if.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697451", "createdAt": "2020-10-21T21:07:25Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mjc2NjA2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTowNzozNFrOHmFeNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMTowNzozNFrOHmFeNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY5NzU4OA==", "bodyText": "Style.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509697588", "createdAt": "2020-10-21T21:07:34Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mjc4MTA3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxMDo0N1rOHmFn4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjowMjoyMFrOHmpC_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw==", "bodyText": "Check not needed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509700067", "createdAt": "2020-10-21T21:10:47Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4MDQ0Ng==", "bodyText": "@vjeko Is there a reason why this is checked multiple times in the original code? I was under the impression that the handshake state could change between the first check and the second, so this was needed to avoid message loss.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510280446", "createdAt": "2020-10-22T16:02:20Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwMDA2Nw=="}, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjgxNDQ4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxNzo1NlrOHmF-0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxNzo1NlrOHmF-0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNTkzNg==", "bodyText": "Avoid unassigned variables.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509705936", "createdAt": "2020-10-21T21:17:56Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjgxOTk0OnYy", "diffSide": "LEFT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxODo1OVrOHmGCUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToxODo1OVrOHmGCUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwNjgzNQ==", "bodyText": "Is there a reason why return is omitted here? In this case, you still go on and do your handshake computation.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509706835", "createdAt": "2020-10-21T21:18:59Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {\n+            try {\n+                CorfuMsg msg = (CorfuMsg) m;\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, msg);\n+                } else {\n                     log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received is not a valid CorfuMsg type.\");\n                 }\n+            } catch (Exception ex) {\n+                log.error(\"channelRead: Message received is not a valid CorfuMsg or ResponseMsg type.\");\n             }\n-            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MjgzNTc1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyMjoxNVrOHmGM_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMToyMjoxNVrOHmGM_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcwOTU2NA==", "bodyText": "I would make this your base-case. It should simplify your logic.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509709564", "createdAt": "2020-10-21T21:22:15Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -84,36 +95,44 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n             return;\n         }\n \n-        CorfuPayloadMsg<HandshakeResponse> handshakeResponse;\n+        UUID serverId = null;\n+        String corfuVersion = null;\n+\n+        if(m instanceof ResponseMsg) {\n+            ResponseMsg response = ((ResponseMsg) m);\n+\n+            if(response.getPayload().hasHandshakeResponse()) {\n+                log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n+                        READ_TIMEOUT_HANDLER);\n+\n+                HandshakeResponseMsg handshakeResponse = response.getPayload().getHandshakeResponse();\n+                corfuVersion = handshakeResponse.getCorfuVersion();\n+                serverId = getUUID(handshakeResponse.getServerId());\n \n-        try {\n-            handshakeResponse = (CorfuPayloadMsg<HandshakeResponse>) m;\n-            log.info(\"channelRead: Handshake Response received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler. \" +\n-                    \"Send upstream only if handshake succeeded.\", e);\n-            if (this.handshakeState.completed()) {\n-                // Only send upstream if handshake is complete.\n-                super.channelRead(ctx, m);\n+                // Remove the handler from the pipeline. Also remove the reference of the context from\n+                // the handler so that it does not disconnect the channel.\n+                ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    CorfuMsg msg = (CorfuMsg) m;\n+                log.warn(\"channelRead: Non-Handshake Response received {}\", response);\n+                if (this.handshakeState.completed()) {\n+                    // Only send upstream if handshake is complete.\n+                    super.channelRead(ctx, m);\n+                }\n+            }\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI1ODQ1OnYy", "diffSide": "RIGHT", "path": "runtime/proto/common.proto", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1NzozM1rOHmKo3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODoyNDoxNFrOHmucgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjIzOQ==", "bodyText": "Is this really a metric?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509782239", "createdAt": "2020-10-21T22:57:33Z", "author": {"login": "vjeko"}, "path": "runtime/proto/common.proto", "diffHunk": "@@ -0,0 +1,83 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+/**\n+ * Common Protobuf definitions used by several RPCs.\n+ */\n+\n+message UuidMsg {\n+  int64 lsb = 1;\n+  int64 msb = 2;\n+}\n+\n+// Token returned by the sequencer is a combination of the\n+// sequence number and the epoch at which it was acquired.\n+message TokenMsg {\n+  int64 epoch = 1;\n+  int64 sequence = 2;\n+}\n+\n+/**\n+ * Sequencer metrics for a node.\n+ */\n+message SequencerMetricsMsg {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM2ODg5OQ==", "bodyText": "I agree that it isn't much, but I wanted to keep it consistent with the current name.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510368899", "createdAt": "2020-10-22T18:24:14Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/common.proto", "diffHunk": "@@ -0,0 +1,83 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+/**\n+ * Common Protobuf definitions used by several RPCs.\n+ */\n+\n+message UuidMsg {\n+  int64 lsb = 1;\n+  int64 msb = 2;\n+}\n+\n+// Token returned by the sequencer is a combination of the\n+// sequence number and the epoch at which it was acquired.\n+message TokenMsg {\n+  int64 epoch = 1;\n+  int64 sequence = 2;\n+}\n+\n+/**\n+ * Sequencer metrics for a node.\n+ */\n+message SequencerMetricsMsg {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MjIzOQ=="}, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI2NjA0OnYy", "diffSide": "RIGHT", "path": "runtime/proto/common.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowMDo1NVrOHmKtpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowMDo1NVrOHmKtpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MzQ2Mw==", "bodyText": "Make these variables more descriptive, such as streamUuid and addressSpace.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509783463", "createdAt": "2020-10-21T23:00:55Z", "author": {"login": "vjeko"}, "path": "runtime/proto/common.proto", "diffHunk": "@@ -0,0 +1,83 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+/**\n+ * Common Protobuf definitions used by several RPCs.\n+ */\n+\n+message UuidMsg {\n+  int64 lsb = 1;\n+  int64 msb = 2;\n+}\n+\n+// Token returned by the sequencer is a combination of the\n+// sequence number and the epoch at which it was acquired.\n+message TokenMsg {\n+  int64 epoch = 1;\n+  int64 sequence = 2;\n+}\n+\n+/**\n+ * Sequencer metrics for a node.\n+ */\n+message SequencerMetricsMsg {\n+  enum SequencerStatus {\n+    INVALID = 0;\n+    // Sequencer is in READY state, and can dispatch tokens.\n+    READY = 1;\n+    // Sequencer is in a NOT_READY state.\n+    NOT_READY = 2;\n+    // Unknown state.\n+    UNKNOWN = 3;\n+  }\n+\n+  // Ready state of a sequencer to determine its READY/NOT_READY state.\n+  SequencerStatus sequencer_status = 1;\n+}\n+\n+// Representation of a Layout as a JSON string.\n+message LayoutMsg {\n+  string layout_json = 1;\n+}\n+\n+/**\n+ * A stream's address space is defined by:\n+ *       1. The collection of all addresses that belong to this stream.\n+ *       2. The trim mark (last trimmed address, i.e., an address that is\n+ *       no longer present and that was subsumed by a checkpoint).\n+ */\n+message StreamAddressSpaceMsg {\n+  // Holds the last trimmed address for this stream.\n+  // Note: keeping the last trimmed address is required in order to properly set the stream tail on sequencer resets\n+  // when a stream has been checkpointed and trimmed and there are no further updates to this stream.\n+  uint64 trim_mark = 1;\n+\n+  // Holds the complete map of addresses for this stream.\n+  // Note: currently of type Roaring64NavigableMap.\n+  bytes address_map = 2;\n+}\n+\n+/**\n+ * This message represents a range of addresses for a stream.\n+ * This is used to request the address map of a stream in\n+ * a given boundary-- limits given by (end, start].\n+ */\n+message StreamAddressRangeMsg {\n+  UuidMsg stream_id = 1;\n+  // Start is inclusive\n+  int64 start = 2;\n+  // End is exclusive\n+  int64 end = 3;\n+}\n+\n+message UuidToLongPairMsg {\n+  UuidMsg key = 1;\n+  int64 value = 2;\n+}\n+\n+message UuidToStreamAddressSpacePairMsg {\n+  UuidMsg key = 1;\n+  StreamAddressSpaceMsg value = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI5MjEyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMjo1MlrOHmK9NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxMjo1MlrOHmK9NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NzQ0NQ==", "bodyText": "You might want to throw an InvalidStateException insated in the default block.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509787445", "createdAt": "2020-10-21T23:12:52Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzMyMzQyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyNzoxMFrOHmLPpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyNzoxMFrOHmLPpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MjE2NQ==", "bodyText": "Style: missing space.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792165", "createdAt": "2020-10-21T23:27:10Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzMyNzE4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyOTowMVrOHmLR-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyOTowMVrOHmLR-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjc2MA==", "bodyText": "It might make sense to fail early and fail loudly here. An exception?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792760", "createdAt": "2020-10-21T23:29:01Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzMyODA2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyOToyNlrOHmLScA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoyOToyNlrOHmLScA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5Mjg4MA==", "bodyText": "Style: missing space.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509792880", "createdAt": "2020-10-21T23:29:26Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolCommon {\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.get(metrics.getSequencerStatus()))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch(msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+        }\n+\n+        //TODO: Revisit for rolling-upgrades?\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try(ByteString.Output bso = ByteString.newOutput()) {\n+            try(DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (Exception ex) {\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +\n+                    \"while serializing roaring64NavigableMap\", ex, ex.getCause());\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try(DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzMzMjE5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozMToxOVrOHmLU1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozMToxOVrOHmLU1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5MzQ5NA==", "bodyText": "No need for an empty line.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509793494", "createdAt": "2020-10-21T23:31:19Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM0MjAwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozNjozNVrOHmLa0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozNjozNVrOHmLa0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTAyNg==", "bodyText": "Can't you do HeaderMsg.newBuilder().mergeFrom(header).setPriority(PriorityLevel.HIGH);?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795026", "createdAt": "2020-10-21T23:36:35Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+\n+@Slf4j\n+public class CorfuProtocolMessage {\n+    public static final ProtocolVersion CURRENT_VERSION = ProtocolVersion.V0;\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UuidMsg clusterId,\n+                                         UuidMsg clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return HeaderMsg.newBuilder()\n+                .setVersion(CURRENT_VERSION)\n+                .setRequestId(requestId)\n+                .setPriority(priority)\n+                .setEpoch(epoch)\n+                .setClusterId(clusterId)\n+                .setClientId(clientId)\n+                .setIgnoreClusterId(ignoreClusterId)\n+                .setIgnoreEpoch(ignoreEpoch)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     *\n+     * @param requestId         the request id, generated by the client\n+     * @param priority          the priority of the message\n+     * @param epoch             the epoch of the message\n+     * @param clusterId         the cluster id\n+     * @param clientId          the clients own id\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(long requestId, PriorityLevel priority, long epoch, UUID clusterId,\n+                                         UUID clientId, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(requestId, priority, epoch, getUuidMsg(clusterId),\n+                getUuidMsg(clientId), ignoreClusterId, ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Used by the server as a convenient way to copy reusable field values.\n+     *\n+     * @param header            the original request header\n+     * @param ignoreClusterId   indicates if the message is clusterId aware\n+     * @param ignoreEpoch       indicates if the message is epoch aware\n+     */\n+    public static HeaderMsg getHeaderMsg(HeaderMsg header, boolean ignoreClusterId, boolean ignoreEpoch) {\n+        return getHeaderMsg(header.getRequestId(),\n+                header.getPriority(),\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                ignoreClusterId,\n+                ignoreEpoch);\n+    }\n+\n+    /**\n+     * Returns a header containing information common to all service RPCs.\n+     * Use by the server to increase the priority of certain requests.\n+     *\n+     * @param header   the original request header\n+     */\n+    public static HeaderMsg getHighPriorityHeaderMsg(HeaderMsg header) {\n+        return getHeaderMsg(header.getRequestId(),\n+                PriorityLevel.HIGH,\n+                header.getEpoch(),\n+                header.getClusterId(),\n+                header.getClientId(),\n+                header.getIgnoreClusterId(),\n+                header.getIgnoreEpoch());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM0Njk0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozOTowNlrOHmLdrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozOTowNlrOHmLdrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTc1OQ==", "bodyText": "Try-with-resource might be a better approach:\ntry (ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf)) {", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795759", "createdAt": "2020-10-21T23:39:06Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM0ODEwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozOTo0MVrOHmLeaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzozOTo0MVrOHmLeaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NTk0Nw==", "bodyText": "Same here -- try-with-resource.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509795947", "createdAt": "2020-10-21T23:39:41Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {\n+                RequestMsg request = RequestMsg.parseFrom(msgInputStream);\n+                list.add(request);\n+            } catch (Exception e) {\n+                log.error(\"decode: An exception occurred during parsing request from ByteBufInputStream of byteBuf.\", e);\n+            } finally {\n+                msgInputStream.close();\n+            }\n+        } else if (msgMark == PROTO_CORFU_RESPONSE_MSG_MARK){\n+            ByteBufInputStream msgInputStream = new ByteBufInputStream(byteBuf);\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1MDIyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MDozMFrOHmLflA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MDozMFrOHmLflA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjI0NA==", "bodyText": "Style: missing space.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796244", "createdAt": "2020-10-21T23:40:30Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,34 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {\n+            list.add(CorfuMsg.deserialize(byteBuf));\n+        } else if (msgMark == PROTO_CORFU_REQUEST_MSG_MARK){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1Mjc5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MTo1MVrOHmLhGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0MTo1MVrOHmLhGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NjYzMw==", "bodyText": "throws does not seem to be necessary.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509796633", "createdAt": "2020-10-21T23:41:51Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1Nzc4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NDozNlrOHmLkIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NDozNlrOHmLkIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQxMA==", "bodyText": "try-with-resource?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797410", "createdAt": "2020-10-21T23:44:36Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM1NzkxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NDo0MVrOHmLkNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzoyNzoyMFrOHmsZNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA==", "bodyText": "try-with-resource?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509797428", "createdAt": "2020-10-21T23:44:41Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {\n+                    log.warn(\"encode[{}]: Exception occurred when encoding request {}, caused by {}\",\n+                            request.getHeader().getRequestId(), request.getHeader(), e.getCause(), e);\n+                } finally {\n+                    IOUtils.closeQuietly(requestOutputStream);\n+                }\n+            } else if (object instanceof ResponseMsg) {\n+                ResponseMsg response = (ResponseMsg) object;\n+                ByteBufOutputStream responseOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMzNTI4Ng==", "bodyText": "Good idea. Will do.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r510335286", "createdAt": "2020-10-22T17:27:20Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {\n+                    log.warn(\"encode[{}]: Exception occurred when encoding request {}, caused by {}\",\n+                            request.getHeader().getRequestId(), request.getHeader(), e.getCause(), e);\n+                } finally {\n+                    IOUtils.closeQuietly(requestOutputStream);\n+                }\n+            } else if (object instanceof ResponseMsg) {\n+                ResponseMsg response = (ResponseMsg) object;\n+                ByteBufOutputStream responseOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5NzQyOA=="}, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzM2NDE2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NzozMlrOHmLnsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzo0NzozMlrOHmLnsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc5ODMyMw==", "bodyText": "Style: missing space.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r509798323", "createdAt": "2020-10-21T23:47:32Z", "author": {"login": "vjeko"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,67 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.IOUtils;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n     protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n+                          Object object,\n                           ByteBuf byteBuf) throws Exception {\n         try {\n-            corfuMsg.serialize(byteBuf);\n-            if(log.isDebugEnabled()) {\n+            if (object instanceof CorfuMsg) {\n+                CorfuMsg corfuMsg = (CorfuMsg) object;\n+                byteBuf.writeByte(LEGACY_CORFU_MSG_MARK); // Temporary -- Marks the Corfu msg as legacy.\n+                corfuMsg.serialize(byteBuf);\n+            } else if (object instanceof RequestMsg) {\n+                RequestMsg request = (RequestMsg) object;\n+                ByteBufOutputStream requestOutputStream = new ByteBufOutputStream(byteBuf);\n+                try {\n+                    requestOutputStream.writeByte(PROTO_CORFU_REQUEST_MSG_MARK); // Temporary - Marks the Corfu msg as protobuf.\n+                    request.writeTo(requestOutputStream);\n+                } catch(IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c9ea35a22f65130ea5ca81bb2a38e86547fad0"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjgzNjY0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxM1rOHpBItA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxM1rOHpBItA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI3Ng==", "bodyText": "Codacy found an issue: The method 'channelRead(ChannelHandlerContext, Object)' has an NPath complexity of 288, current threshold is 200", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772276", "createdAt": "2020-10-27T15:06:13Z", "author": {"login": "corfudb-bot"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,50 +80,44 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjgzNjcxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxNFrOHpBIvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxNFrOHpBIvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjI4Ng==", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolMessage' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772286", "createdAt": "2020-10-27T15:06:14Z", "author": {"login": "corfudb-bot"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in corfu_message.proto. These provide the interface for obtaining headers,\n+ * as well as the main request and response (Protobuf) messages sent by the\n+ * client and server.\n+ */\n+@Slf4j\n+public class CorfuProtocolMessage {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjgzNjg0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxNlrOHpBIzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxNlrOHpBIzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMwMg==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.corfudb.protocols.CorfuProtocolCommon'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772302", "createdAt": "2020-10-27T15:06:16Z", "author": {"login": "corfudb-bot"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjgzNjkxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxN1rOHpBI4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxN1rOHpBI4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjMyMQ==", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolCommon' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772321", "createdAt": "2020-10-27T15:06:17Z", "author": {"login": "corfudb-bot"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,211 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.Common.LayoutMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.Common.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.Common.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.Common.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.Common.TokenMsg;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.Common.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjgzNzE0OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxOVrOHpBJAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNTowNjoxOVrOHpBJAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MjM1NQ==", "bodyText": "Codacy found an issue: The utility class name 'CorfuProtocolBase' doesn't match '[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r512772355", "createdAt": "2020-10-27T15:06:19Z", "author": {"login": "corfudb-bot"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolBase.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package org.corfudb.protocols.service;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.VersionInfo;\n+import org.corfudb.runtime.proto.service.Base.HandshakeRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.HandshakeResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.PingRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.PingResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.ResetResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.RestartResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.SealRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.SealResponseMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionRequestMsg;\n+import org.corfudb.runtime.proto.service.Base.VersionResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.getUuidMsg;\n+\n+import java.util.UUID;\n+\n+/**\n+ * This class provides methods for creating the Protobuf objects defined\n+ * in base.proto. These provide the interface for performing the RPCs\n+ * handled by the Base server, as well as the handshake.\n+ */\n+@Slf4j\n+public class CorfuProtocolBase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzgyMDUwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNTo0MjoxOVrOHpwmDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MzozMFrOHq2JIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg==", "bodyText": "I noticed that some other 1-line if clause below are inside curly braces, maybe we should add to make style consistent?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513549836", "createdAt": "2020-10-28T15:42:19Z", "author": {"login": "xcchang"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNDUwNQ==", "bodyText": "+1 we seem to expand all the if statements with curly braces. If ever a check is enforced on this it might help to keep things consistent.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513804505", "createdAt": "2020-10-28T22:41:26Z", "author": {"login": "hisundar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4OTMxNA==", "bodyText": "Done", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514689314", "createdAt": "2020-10-30T01:53:30Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTgzNg=="}, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzg2NjMyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNTo1MTozNVrOHpxDZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MzowM1rOHq2Hfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ==", "bodyText": "should we expand this? I think only the getUuidMsg is used", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513557349", "createdAt": "2020-10-28T15:51:35Z", "author": {"login": "xcchang"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4ODg5NQ==", "bodyText": "Done", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514688895", "createdAt": "2020-10-30T01:53:03Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/service/CorfuProtocolMessage.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package org.corfudb.protocols.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.Common.UuidMsg;\n+import org.corfudb.runtime.proto.ServerErrors.ServerErrorMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.PriorityLevel;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ProtocolVersion;\n+import org.corfudb.runtime.proto.service.CorfuMessage.HeaderMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestPayloadMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponsePayloadMsg;\n+\n+import java.util.UUID;\n+\n+import static org.corfudb.protocols.CorfuProtocolCommon.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzM0OQ=="}, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTQzMzI2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjo0MzozM1rOHqAL-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODoyMzo0OFrOHqpDXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg==", "bodyText": "should this be m.toString() won't just printing m display just the address of the object and not its contents?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805306", "createdAt": "2020-10-28T22:43:33Z", "author": {"login": "hisundar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NDg0NA==", "bodyText": "I believe that .toString() is automatically invoked in the case of complex objects: See the section \"How can I log the string contents of a single (possibly complex) object?\" in http://www.slf4j.org/faq.html", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514474844", "createdAt": "2020-10-29T18:23:48Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTMwNg=="}, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxOTQzMzY5OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjo0Mzo0M1rOHqAMMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODoyODo1MVrOHqpPXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ==", "bodyText": "do you want this to be m.toString()?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r513805361", "createdAt": "2020-10-28T22:43:43Z", "author": {"login": "hisundar"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NzkxNw==", "bodyText": "See my comment above", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514477917", "createdAt": "2020-10-29T18:28:51Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,31 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n+        if (this.handshakeState.failed()) return;\n \n-        if (this.state.failed()) {\n-            return;\n-        }\n+        if (!(m instanceof RequestMsg) || !((RequestMsg) m).getPayload().hasHandshakeRequest()) {\n+            log.warn(\"channelRead: Non-handshake message received by handshake handler. Message - {}\", m);\n \n-        if (this.state.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n-            return;\n-        }\n-\n-        CorfuPayloadMsg<HandshakeMsg> handshake;\n-\n-        try {\n-            handshake = (CorfuPayloadMsg<HandshakeMsg>) m;\n-            log.debug(\"channelRead: Handshake Message received. Removing {} from pipeline.\",\n-                    READ_TIMEOUT_HANDLER);\n-            // Remove the handler from the pipeline. Also remove the reference of the context from\n-            // the handler so that it does not disconnect the channel.\n-            ctx.pipeline().remove(READ_TIMEOUT_HANDLER).handlerRemoved(ctx);\n-        } catch (ClassCastException e) {\n-            log.warn(\"channelRead: Non-handshake message received by handshake handler.\" +\n-                    \" Send upstream only if handshake succeeded.\");\n-            if (this.state.completed()) {\n+            if (this.handshakeState.completed()) {\n                 // Only send upstream if handshake is complete.\n+                log.warn(\"channelRead: Sending the message to upstream as the handshake was completed. Message - {}\", m);\n                 super.channelRead(ctx, m);\n             } else {\n-                // Otherwise, drop message.\n-                try {\n-                    log.debug(\"channelRead: Dropping message: {}\", ((CorfuMsg) m).getMsgType().name());\n-                } catch (Exception ex) {\n-                    log.error(\"channelRead: Message received by Server is not a valid \" +\n-                            \"CorfuMsg type.\");\n-                }\n+                log.warn(\"channelRead: Dropping the message as the handshake was not completed. Message - {}\", m);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwNTM2MQ=="}, "originalCommit": {"oid": "6825f6572b1059a89600514235cdb1607a52f58b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDM2MzI1OnYy", "diffSide": "RIGHT", "path": "runtime/proto/common.proto", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjowNDo1OFrOHqwXGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MjoxMFrOHq2ETQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NDU4NA==", "bodyText": "can we name this file as rpc_common.proto or similar instead of just common.proto?\nhttps://dave.cheney.net/2019/01/08/avoid-package-names-like-base-util-or-common", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514594584", "createdAt": "2020-10-29T22:04:58Z", "author": {"login": "hisundar"}, "path": "runtime/proto/common.proto", "diffHunk": "@@ -0,0 +1,83 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4ODA3Nw==", "bodyText": "Done", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514688077", "createdAt": "2020-10-30T01:52:10Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/common.proto", "diffHunk": "@@ -0,0 +1,83 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NDU4NA=="}, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDM3NzgxOnYy", "diffSide": "RIGHT", "path": "runtime/proto/service/corfu_message.proto", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoxMDoyOVrOHqwgMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MTo1NlrOHq2DeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NjkxMw==", "bodyText": "Instead of an enum can this be a regular protobuf that includes a fixed64?\nVersion of V0 by itself does not have much use, but if this field can be expanded, we can potentially consider this to be our version capability exchange. since this is included into all the headers.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514596913", "createdAt": "2020-10-29T22:10:29Z", "author": {"login": "hisundar"}, "path": "runtime/proto/service/corfu_message.proto", "diffHunk": "@@ -0,0 +1,159 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto.service\";\n+\n+import \"common.proto\";\n+import \"service/base.proto\";\n+import \"service/layout.proto\";\n+import \"service/log_unit.proto\";\n+import \"service/sequencer.proto\";\n+import \"service/management.proto\";\n+import \"server_errors.proto\";\n+\n+//TODO: Reasonable way to determine version?\n+enum ProtocolVersion {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4Nzg2NQ==", "bodyText": "Done. It remains unused for the time being, but this could be a good approach.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687865", "createdAt": "2020-10-30T01:51:56Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/service/corfu_message.proto", "diffHunk": "@@ -0,0 +1,159 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto.service\";\n+\n+import \"common.proto\";\n+import \"service/base.proto\";\n+import \"service/layout.proto\";\n+import \"service/log_unit.proto\";\n+import \"service/sequencer.proto\";\n+import \"service/management.proto\";\n+import \"server_errors.proto\";\n+\n+//TODO: Reasonable way to determine version?\n+enum ProtocolVersion {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5NjkxMw=="}, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDQyMjkyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoyODo0OVrOHqw7Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MToyM1rOHq2BWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg==", "bodyText": "can we add the missing java doc for this method?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514603842", "createdAt": "2020-10-29T22:28:49Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,33 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzMyMQ==", "bodyText": "Done", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687321", "createdAt": "2020-10-30T01:51:23Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -19,7 +23,33 @@\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzg0Mg=="}, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDQyNzg3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjozMDo0NVrOHqw-Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMTo1MToxM1rOHq2A_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng==", "bodyText": "can we consider adding the missing java doc for this method?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514604586", "createdAt": "2020-10-29T22:30:45Z", "author": {"login": "hisundar"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n-    protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n-                          ByteBuf byteBuf) throws Exception {\n+    protected void encode(ChannelHandlerContext channelHandlerContext, Object object, ByteBuf byteBuf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY4NzIyOQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r514687229", "createdAt": "2020-10-30T01:51:13Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {\n \n \n     final LongAccumulator maxValue = new LongAccumulator(Math::max, Long.MIN_VALUE);\n \n     @Override\n-    protected void encode(ChannelHandlerContext channelHandlerContext,\n-                          CorfuMsg corfuMsg,\n-                          ByteBuf byteBuf) throws Exception {\n+    protected void encode(ChannelHandlerContext channelHandlerContext, Object object, ByteBuf byteBuf) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNDU4Ng=="}, "originalCommit": {"oid": "2673f515f96423392e648ae7999ce732741ecc3c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODI5MTE1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo0Njo0NVrOHrXZCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToxNDozNFrOHrcwfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw==", "bodyText": "let's add a log line here, otherwise, it'd be pretty hard to know if a handshake failed", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515234057", "createdAt": "2020-10-30T16:46:45Z", "author": {"login": "xnull"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,33 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-\n-        if (this.state.failed()) {\n+        if (this.handshakeState.failed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTk4Mw==", "bodyText": "Done. Added a log line in both the server and client handshake handlers.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515321983", "createdAt": "2020-10-30T19:14:34Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -62,47 +66,33 @@ public ServerHandshakeHandler(UUID nodeId, String corfuVersion, String timeoutIn\n      */\n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n-\n-        if (this.state.failed()) {\n+        if (this.handshakeState.failed()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNDA1Nw=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODMwNzI4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1MDoyOVrOHrXimg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToxNDo0N1rOHrcw5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg==", "bodyText": "Please don't add more logs here, ServerHandshakeHandler already a huge problem in terms of log generation.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515236506", "createdAt": "2020-10-30T16:50:29Z", "author": {"login": "xnull"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -121,16 +111,26 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         log.debug(\"channelRead: Sending handshake response: Node Id: {} Corfu Version: {}\",\n                 this.nodeId, this.corfuVersion);\n \n-        CorfuMsg handshakeResponse = CorfuMsgType.HANDSHAKE_RESPONSE\n-                .payloadMsg(new HandshakeResponse(this.nodeId, this.corfuVersion));\n-        ctx.writeAndFlush(handshakeResponse);\n \n-        // Flush messages in queue\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(((RequestMsg) m).getHeader(),\n+                getHandshakeResponseMsg(this.nodeId, this.corfuVersion));\n+\n+        ctx.writeAndFlush(response);\n+\n+        // Flush messages in queues\n         log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n+        log.debug(\"channelRead: There are [{}] responseMessages in queue to be flushed.\", this.responseMessages.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjA4NQ==", "bodyText": "Done. These have been removed.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322085", "createdAt": "2020-10-30T19:14:47Z", "author": {"login": "zfrenette"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/ServerHandshakeHandler.java", "diffHunk": "@@ -121,16 +111,26 @@ public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         log.debug(\"channelRead: Sending handshake response: Node Id: {} Corfu Version: {}\",\n                 this.nodeId, this.corfuVersion);\n \n-        CorfuMsg handshakeResponse = CorfuMsgType.HANDSHAKE_RESPONSE\n-                .payloadMsg(new HandshakeResponse(this.nodeId, this.corfuVersion));\n-        ctx.writeAndFlush(handshakeResponse);\n \n-        // Flush messages in queue\n+        // Note: we reuse the request header as the ignore_cluster_id and\n+        // ignore_epoch fields are the same in both cases.\n+        ResponseMsg response = getResponseMsg(((RequestMsg) m).getHeader(),\n+                getHandshakeResponseMsg(this.nodeId, this.corfuVersion));\n+\n+        ctx.writeAndFlush(response);\n+\n+        // Flush messages in queues\n         log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n+        log.debug(\"channelRead: There are [{}] responseMessages in queue to be flushed.\", this.responseMessages.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNjUwNg=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODMyOTU1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1NTo1M1rOHrXvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzo0ODo0MlrOHraAkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA==", "bodyText": "this looks weird, why not reuse SequencerStatus and get rid of SequencerMetrics? or vise versa", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515239880", "createdAt": "2020-10-30T16:55:53Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3Njk0Ng==", "bodyText": "Here we mimicked how the SequencerMetrics Java object is currently represented. Our goal was to allow for the possibility of (easily) extending the message should the RPC ever evolve. If more information about the Sequencer is ever needed, fields in the message wrapper can be added without significant changes.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515276946", "createdAt": "2020-10-30T17:48:42Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzOTg4MA=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM0Mjc2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo1OToxNFrOHrX3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToxNTowNlrOHrcxbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng==", "bodyText": "There is a rule: never write an error in the log if you throw an exception. They are mutually exclusive.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515241976", "createdAt": "2020-10-30T16:59:14Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            // Log the error and rethrow the exception\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTQxOA==", "bodyText": "Sounds good. I'll stick to logging the error for the time being. Will update shortly.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515319418", "createdAt": "2020-10-30T19:08:42Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            // Log the error and rethrow the exception\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjIyMg==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322222", "createdAt": "2020-10-30T19:15:06Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                addressSpace.getAddressMap().serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            // Log the error and rethrow the exception\n+            log.error(\"getStreamAddressSpaceMsg: error=[{}, {}] \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0MTk3Ng=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODM4NDI2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoxMDowMVrOHrYSXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToyMDowOVrOHrc5lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw==", "bodyText": "I'm concerned about the enclosed try blocks. Also, as I know we never used DataOutputStream, so not sure if we need it here.\nQuestions:\n\nwhy treamAddressSpaceMsg#addressMap is a string when it should be a map?\nIOException is a very hard exception to deal with, it would be great not to have it (but of course we shouldn't just silently ignore it)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515248733", "createdAt": "2020-10-30T17:10:01Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2OTY5Nw==", "bodyText": "The map stored in a StreamAddressSpaceMsg is a RoaringBitmap, which we represent in Protobuf as a sequence of bytes. I am not sure how we would otherwise represent it. Currently, DataOutputStream is used in ICorfuPayload to serialize the RoaringBitmap into a ByteBuf.  I tried emulating the approach by using DataOutputStream as an intermediate step since I wasn't able to serialize the map directly into a ByteString, which is how Protobuf represents a sequence of bytes.\nAs for the IO exception, the only things that seem appropriate in response to the serialization error is 1) logging an error and continuing silently, or 2), throwing an exception. Is there a more appropriate response that we haven't considered?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515269697", "createdAt": "2020-10-30T17:37:18Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMjI4MQ==", "bodyText": "For the sake of consistency, I'd say the best approach that I know, could be:\npublic static Optional<StreamAddressSpaceMsg> getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n        \n        Optional<ByteString> maybeAddressMap = Optional.empty();\n        try (ByteString.Output bso = ByteString.newOutput()) {\n            try (DataOutputStream dos = new DataOutputStream(bso)) {\n                addressSpace.getAddressMap().serialize(dos);\n                maybeAddressMap = Optional.of(bso.toByteString());\n            }\n        } catch (IOException ex) {\n            String msg = \"getStreamAddressSpaceMsg: error=[{}] while serializing roaring64NavigableMap\";\n            log.error(msg, ex.getCause(), ex);\n        }\n        \n        return maybeAddressMap.map(addressMap ->{\n            StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n            addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n            addressSpaceMsgBuilder.setAddressMap(addressMap);\n            return addressSpaceMsgBuilder.build();\n        });\n    }\n\nBTW, who's using getStreamAddressSpaceMsg? I didn't find anything in Corfu which uses it", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515322281", "createdAt": "2020-10-30T19:15:12Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNDMxMQ==", "bodyText": "This method in the API isn't used yet. It will be used by the SequencerClient/Server and LogUnitServer when the PRs replacing the implementation of these RPCs are ready to go. For example, the SequencerClient will invoke this method when performing a bootstrap to convert the streamAddressSpaceMap into a Protobuf representation before sending it over the wire.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515324311", "createdAt": "2020-10-30T19:20:09Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) throws IOException {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI0ODczMw=="}, "originalCommit": {"oid": "8b2e1495801fd780d8a9ae682c49477941fe9b35"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjg2NzYxOnYy", "diffSide": "RIGHT", "path": "runtime/proto/log_data.proto", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDowNzoyMFrOHr9yTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjo1MTozOFrOHsetDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2MzExOQ==", "bodyText": "Could you explain why we need to use the Int64Value wrapper instead of int64 here?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515863119", "createdAt": "2020-11-02T10:07:20Z", "author": {"login": "WenbinZhu"}, "path": "runtime/proto/log_data.proto", "diffHunk": "@@ -0,0 +1,70 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+import \"rpc_common.proto\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+/**\n+ * LogData and related Protobuf definitions.\n+ * Used by the LogUnit RPCs and ValueAdoptedErrorMsg.\n+ */\n+\n+message DataRankMsg {\n+  int64 rank = 1;\n+  UuidMsg id = 2;\n+}\n+\n+// Types of metadata defined in IMetadata.java (LogUnitMetadataType).\n+\n+message LogUnitMetadataMsg {\n+  DataRankMsg data_rank = 1;\n+  repeated UuidToLongPairMsg backpointer_map = 2;\n+  google.protobuf.Int64Value global_address = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwMjQ0NA==", "bodyText": "The issue occurs when converting the LogUnitMetadataMsg into a Java object (i.e. the EnumMap<LogUnitMetadataType, Object> metadataMap). With a primitive type, there was no way to differentiate between the cases when a value was unset and when a value was explicitly set to its default value for that type. Using Int64Value provides a hasGlobalAddress() method, for example, which can differentiate between these two cases. Note: The API methods for LogUnit (and others) will be included in later PRs.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516402444", "createdAt": "2020-11-03T02:51:38Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/log_data.proto", "diffHunk": "@@ -0,0 +1,70 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+import \"rpc_common.proto\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+/**\n+ * LogData and related Protobuf definitions.\n+ * Used by the LogUnit RPCs and ValueAdoptedErrorMsg.\n+ */\n+\n+message DataRankMsg {\n+  int64 rank = 1;\n+  UuidMsg id = 2;\n+}\n+\n+// Types of metadata defined in IMetadata.java (LogUnitMetadataType).\n+\n+message LogUnitMetadataMsg {\n+  DataRankMsg data_rank = 1;\n+  repeated UuidToLongPairMsg backpointer_map = 2;\n+  google.protobuf.Int64Value global_address = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2MzExOQ=="}, "originalCommit": {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjkwMTMxOnYy", "diffSide": "RIGHT", "path": "runtime/proto/log_data.proto", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDoxNToyNlrOHr-GPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjo1NToyN1rOHsewsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2ODIyMA==", "bodyText": "I think this be defined in log_unit.proto", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r515868220", "createdAt": "2020-11-02T10:15:26Z", "author": {"login": "WenbinZhu"}, "path": "runtime/proto/log_data.proto", "diffHunk": "@@ -0,0 +1,70 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+import \"rpc_common.proto\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+/**\n+ * LogData and related Protobuf definitions.\n+ * Used by the LogUnit RPCs and ValueAdoptedErrorMsg.\n+ */\n+\n+message DataRankMsg {\n+  int64 rank = 1;\n+  UuidMsg id = 2;\n+}\n+\n+// Types of metadata defined in IMetadata.java (LogUnitMetadataType).\n+\n+message LogUnitMetadataMsg {\n+  DataRankMsg data_rank = 1;\n+  repeated UuidToLongPairMsg backpointer_map = 2;\n+  google.protobuf.Int64Value global_address = 3;\n+  google.protobuf.Int32Value checkpoint_type = 4;\n+  UuidMsg checkpoint_id = 5;\n+  UuidMsg checkpointed_stream_id = 6;\n+  google.protobuf.Int64Value checkpointed_stream_start_log_address = 7;\n+  UuidMsg client_id = 8;\n+  google.protobuf.Int64Value thread_id = 9;\n+  google.protobuf.Int64Value epoch = 10;\n+  google.protobuf.Int32Value codec_type_id = 11;\n+}\n+\n+// Types of LogData defined in DataType.java\n+// Note: All metadata aware.\n+// Note: Currently, only DATA carries a payload.\n+\n+message LogDataEntryMsg {\n+  bytes data = 1;\n+}\n+\n+message LogDataEmptyMsg {\n+}\n+\n+message LogDataHoleMsg {\n+}\n+\n+message LogDataTrimmedMsg {\n+}\n+\n+message LogDataRankOnlyMsg {\n+}\n+\n+message LogDataMsg {\n+  LogUnitMetadataMsg metadata = 1;\n+\n+  oneof payload {\n+    LogDataEntryMsg log_data_entry = 11;\n+    LogDataEmptyMsg log_data_empty = 12;\n+    LogDataHoleMsg log_data_hole = 13;\n+    LogDataTrimmedMsg log_data_trimmed = 14;\n+    LogDataRankOnlyMsg log_data_rank_only = 15;\n+  }\n+}\n+\n+message ReadResponseMsg {\n+  int64 address = 1;\n+  LogDataMsg log_data = 2;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQwMzM3OQ==", "bodyText": "It's also used in server_errors.proto. We aimed to divide the Protobuf definitions into service and non-service definitions.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516403379", "createdAt": "2020-11-03T02:55:27Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/log_data.proto", "diffHunk": "@@ -0,0 +1,70 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto\";\n+\n+import \"rpc_common.proto\";\n+import \"google/protobuf/wrappers.proto\";\n+\n+/**\n+ * LogData and related Protobuf definitions.\n+ * Used by the LogUnit RPCs and ValueAdoptedErrorMsg.\n+ */\n+\n+message DataRankMsg {\n+  int64 rank = 1;\n+  UuidMsg id = 2;\n+}\n+\n+// Types of metadata defined in IMetadata.java (LogUnitMetadataType).\n+\n+message LogUnitMetadataMsg {\n+  DataRankMsg data_rank = 1;\n+  repeated UuidToLongPairMsg backpointer_map = 2;\n+  google.protobuf.Int64Value global_address = 3;\n+  google.protobuf.Int32Value checkpoint_type = 4;\n+  UuidMsg checkpoint_id = 5;\n+  UuidMsg checkpointed_stream_id = 6;\n+  google.protobuf.Int64Value checkpointed_stream_start_log_address = 7;\n+  UuidMsg client_id = 8;\n+  google.protobuf.Int64Value thread_id = 9;\n+  google.protobuf.Int64Value epoch = 10;\n+  google.protobuf.Int32Value codec_type_id = 11;\n+}\n+\n+// Types of LogData defined in DataType.java\n+// Note: All metadata aware.\n+// Note: Currently, only DATA carries a payload.\n+\n+message LogDataEntryMsg {\n+  bytes data = 1;\n+}\n+\n+message LogDataEmptyMsg {\n+}\n+\n+message LogDataHoleMsg {\n+}\n+\n+message LogDataTrimmedMsg {\n+}\n+\n+message LogDataRankOnlyMsg {\n+}\n+\n+message LogDataMsg {\n+  LogUnitMetadataMsg metadata = 1;\n+\n+  oneof payload {\n+    LogDataEntryMsg log_data_entry = 11;\n+    LogDataEmptyMsg log_data_empty = 12;\n+    LogDataHoleMsg log_data_hole = 13;\n+    LogDataTrimmedMsg log_data_trimmed = 14;\n+    LogDataRankOnlyMsg log_data_rank_only = 15;\n+  }\n+}\n+\n+message ReadResponseMsg {\n+  int64 address = 1;\n+  LogDataMsg log_data = 2;\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2ODIyMA=="}, "originalCommit": {"oid": "61a057f8b427b71c07ff630292a1c10d0333cf59"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTYzNzQ3OnYy", "diffSide": "RIGHT", "path": "runtime/proto/service/corfu_message.proto", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjoyODoxOFrOHsYCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxMjoxOFrOHsbpSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MzI4Ng==", "bodyText": "Please get rid of TODO messages", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516293286", "createdAt": "2020-11-02T22:28:18Z", "author": {"login": "xnull"}, "path": "runtime/proto/service/corfu_message.proto", "diffHunk": "@@ -0,0 +1,158 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto.service\";\n+\n+import \"rpc_common.proto\";\n+import \"service/base.proto\";\n+import \"service/layout.proto\";\n+import \"service/log_unit.proto\";\n+import \"service/sequencer.proto\";\n+import \"service/management.proto\";\n+import \"server_errors.proto\";\n+\n+/**\n+ * Enum indicating the priority of a request or response.\n+ */\n+enum PriorityLevel {\n+  PRIORITY_LEVEL_INVALID = 0;\n+  NORMAL = 1;\n+  HIGH = 2;\n+}\n+\n+//TODO: Reasonable way to perform a capability exchange?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjMyOA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352328", "createdAt": "2020-11-03T00:12:18Z", "author": {"login": "zfrenette"}, "path": "runtime/proto/service/corfu_message.proto", "diffHunk": "@@ -0,0 +1,158 @@\n+syntax = \"proto3\";\n+\n+package org.corfudb.runtime;\n+option java_package = \"org.corfudb.runtime.proto.service\";\n+\n+import \"rpc_common.proto\";\n+import \"service/base.proto\";\n+import \"service/layout.proto\";\n+import \"service/log_unit.proto\";\n+import \"service/sequencer.proto\";\n+import \"service/management.proto\";\n+import \"server_errors.proto\";\n+\n+/**\n+ * Enum indicating the priority of a request or response.\n+ */\n+enum PriorityLevel {\n+  PRIORITY_LEVEL_INVALID = 0;\n+  NORMAL = 1;\n+  HIGH = 2;\n+}\n+\n+//TODO: Reasonable way to perform a capability exchange?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MzI4Ng=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTY1MDc5OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjozMzoxNlrOHsYK2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxMjozMlrOHsbpsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ==", "bodyText": "Would be great to use enum instead of static variables, like:\nenum MessageMarker {\n  LEGACY_CORFU_MSG_MARK(0x1), PROTO_CORFU_REQUEST_MSG_MARK(0x2), PROTO_CORFU_RESPONSE_MSG_MARK(0x3)\n\n  private final byte value;\n}", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295385", "createdAt": "2020-11-02T22:33:16Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTgyOQ==", "bodyText": "Also you don't need \"CORFU\" prefix in their names (it reduces length a bit)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516295829", "createdAt": "2020-11-02T22:34:17Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjQzMg==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352432", "createdAt": "2020-11-03T00:12:32Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5NTM4NQ=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTY4OTYwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0Mjo1MlrOHsYjbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxNDoxMlrOHsbstQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng==", "bodyText": "please rename e to something meaningful", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516301676", "createdAt": "2020-11-02T22:42:52Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                Roaring64NavigableMap rm = addressSpace.getAddressMap();\n+                // Improve compression\n+                rm.runOptimize();\n+                rm.serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while serializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try (DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {\n+            roaring64NavigableMap.deserialize(dis);\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while deserializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return new StreamAddressSpace(msg.getTrimMark(), roaring64NavigableMap);\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressRange object.\n+     *\n+     * @param streamAddressRange   the desired (Java) StreamAddressRange\n+     */\n+    public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange streamAddressRange) {\n+        return StreamAddressRangeMsg.newBuilder()\n+                .setStreamId(getUuidMsg(streamAddressRange.getStreamID()))\n+                .setStart(streamAddressRange.getStart())\n+                .setEnd(streamAddressRange.getEnd())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressResponse object from its log tail and List\n+     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n+     * represented in Protobuf.\n+     *\n+     * @param tail   the log tail\n+     * @param map    a list of address map entries represented in Protobuf\n+     */\n+    public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<UuidToStreamAddressSpacePairMsg> map) {\n+        return new StreamsAddressResponse(tail, map.stream()\n+                .collect(Collectors.<UuidToStreamAddressSpacePairMsg, UUID, StreamAddressSpace>toMap(\n+                        e -> getUUID(e.getStreamUuid()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzIwNQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353205", "createdAt": "2020-11-03T00:14:12Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    public static final byte LEGACY_CORFU_MSG_MARK = 0x1;\n+    public static final byte PROTO_CORFU_REQUEST_MSG_MARK = 0x2;\n+    public static final byte PROTO_CORFU_RESPONSE_MSG_MARK = 0x3;\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;\n+            default:\n+                throw new UnsupportedOperationException(\"SequencerMetrics message unrecognized: \"\n+                        + \"Status=\" + msg.getSequencerStatus());\n+        }\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressSpace object.\n+     *\n+     * @param addressSpace   the desired (Java) StreamAddressSpace\n+     */\n+    public static StreamAddressSpaceMsg getStreamAddressSpaceMsg(StreamAddressSpace addressSpace) {\n+        StreamAddressSpaceMsg.Builder addressSpaceMsgBuilder = StreamAddressSpaceMsg.newBuilder();\n+        addressSpaceMsgBuilder.setTrimMark(addressSpace.getTrimMark());\n+\n+        try (ByteString.Output bso = ByteString.newOutput()) {\n+            try (DataOutputStream dos = new DataOutputStream(bso)) {\n+                Roaring64NavigableMap rm = addressSpace.getAddressMap();\n+                // Improve compression\n+                rm.runOptimize();\n+                rm.serialize(dos);\n+                addressSpaceMsgBuilder.setAddressMap(bso.toByteString());\n+            }\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while serializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return addressSpaceMsgBuilder.build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressSpace object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf StreamAddressSpace message\n+     */\n+    public static StreamAddressSpace getStreamAddressSpace(StreamAddressSpaceMsg msg) {\n+        Roaring64NavigableMap roaring64NavigableMap = new Roaring64NavigableMap();\n+\n+        try (DataInputStream dis = new DataInputStream(msg.getAddressMap().newInput())) {\n+            roaring64NavigableMap.deserialize(dis);\n+        } catch (IOException ex) {\n+            throw new SerializerException(\"Unexpected error while deserializing roaring64NavigableMap\", ex);\n+        }\n+\n+        return new StreamAddressSpace(msg.getTrimMark(), roaring64NavigableMap);\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a StreamAddressRange object.\n+     *\n+     * @param streamAddressRange   the desired (Java) StreamAddressRange\n+     */\n+    public static StreamAddressRangeMsg getStreamAddressRangeMsg(StreamAddressRange streamAddressRange) {\n+        return StreamAddressRangeMsg.newBuilder()\n+                .setStreamId(getUuidMsg(streamAddressRange.getStreamID()))\n+                .setStart(streamAddressRange.getStart())\n+                .setEnd(streamAddressRange.getEnd())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a StreamAddressResponse object from its log tail and List\n+     * of address map entries, each consisting of a UUID and a StreamAddressSpace,\n+     * represented in Protobuf.\n+     *\n+     * @param tail   the log tail\n+     * @param map    a list of address map entries represented in Protobuf\n+     */\n+    public static StreamsAddressResponse getStreamsAddressResponse(long tail, List<UuidToStreamAddressSpacePairMsg> map) {\n+        return new StreamsAddressResponse(tail, map.stream()\n+                .collect(Collectors.<UuidToStreamAddressSpacePairMsg, UUID, StreamAddressSpace>toMap(\n+                        e -> getUUID(e.getStreamUuid()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMTY3Ng=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTczMDUxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo1NDoyNlrOHsY9hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxMjo1N1rOHsbqeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA==", "bodyText": "we'd have a race condition here, in a multithreaded environment having a LinkedList. causing race conditions.\n\n\nCould you please replace it with a BlockingQueue?\n\n\nNext step - I don't see the motivation for having a queue here, can we replace it with ConcurrentHashMap? or concurrent set (ConcurrentHashMap.newKeySet())?\n\n\nSince you touched it, could you please also replace messages with a concurrent version or a concurrenthashmap? In this class and in serverhandler?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308358", "createdAt": "2020-11-02T22:54:26Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,12 +137,16 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n+\n+        // Flush messages in queues\n         while (!messages.isEmpty()) {\n             ctx.writeAndFlush(messages.poll());\n         }\n \n+        while (!requestMessages.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjYzMg==", "bodyText": "Done! Used a ConcurrentHashMap as suggested.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352632", "createdAt": "2020-11-03T00:12:57Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,12 +137,16 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n+\n+        // Flush messages in queues\n         while (!messages.isEmpty()) {\n             ctx.writeAndFlush(messages.poll());\n         }\n \n+        while (!requestMessages.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODM1OA=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTczNDIwOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo1NToyM1rOHsY_vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxNDoyNVrOHsbtRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg==", "bodyText": "Let's make \"00000000-0000-0000-0000-000000000000\" a constant, put it in to a utility class and use the constant instead of a string", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516308926", "createdAt": "2020-11-02T22:55:23Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -145,19 +157,19 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n      * Channel event that is triggered when a new connected channel is created.\n      *\n      * @param ctx channel handler context\n-     * @throws Exception\n      */\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx)\n-        throws Exception {\n-        log.info(\"channelActive: Outgoing connection established to: {} from id={}\", ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        log.info(\"channelActive: Outgoing connection established to: {} from id={}\",\n+                ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+\n+        // Note: Some fields in the header are unused during the handshake process.\n+        HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n+                UUID.fromString(\"00000000-0000-0000-0000-000000000000\"), this.clientId, false, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MzM1MA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516353350", "createdAt": "2020-11-03T00:14:25Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -145,19 +157,19 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n      * Channel event that is triggered when a new connected channel is created.\n      *\n      * @param ctx channel handler context\n-     * @throws Exception\n      */\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx)\n-        throws Exception {\n-        log.info(\"channelActive: Outgoing connection established to: {} from id={}\", ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+    public void channelActive(ChannelHandlerContext ctx) {\n+        log.info(\"channelActive: Outgoing connection established to: {} from id={}\",\n+                ctx.channel().remoteAddress(), ctx.channel().localAddress());\n+\n+        // Note: Some fields in the header are unused during the handshake process.\n+        HeaderMsg header = getHeaderMsg(0, CorfuMessage.PriorityLevel.NORMAL, 0,\n+                UUID.fromString(\"00000000-0000-0000-0000-000000000000\"), this.clientId, false, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwODkyNg=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTc0Mzk2OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo1ODoxOVrOHsZGOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDoxMzowN1rOHsbqwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw==", "bodyText": "Would be great to have an enum here (I mentioned above) and replace if conditions with switch statement", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516310587", "createdAt": "2020-11-02T22:58:19Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -1,25 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n+import java.io.IOException;\n import java.util.List;\n-\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Decodes an inbound corfu message from a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param byteBuf                 the underlying ByteBuf\n+     * @param list                    a list of decoded objects given to the\n+     *                                next pipeline handler\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjcwNA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516352704", "createdAt": "2020-11-03T00:13:07Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageDecoder.java", "diffHunk": "@@ -1,25 +1,66 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufInputStream;\n import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.ByteToMessageDecoder;\n \n+import java.io.IOException;\n import java.util.List;\n-\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n public class NettyCorfuMessageDecoder extends ByteToMessageDecoder {\n \n+    /**\n+     * Decodes an inbound corfu message from a ByteBuf. The corfu message is either\n+     * legacy (of type CorfuMsg) or Protobuf (of type RequestMsg/ResponseMsg).\n+     *\n+     * @param channelHandlerContext   the Netty channel handler context\n+     * @param byteBuf                 the underlying ByteBuf\n+     * @param list                    a list of decoded objects given to the\n+     *                                next pipeline handler\n+     */\n     @Override\n     protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf,\n                           List<Object> list) throws Exception {\n-        list.add(CorfuMsg.deserialize(byteBuf));\n+        // Check the type of message based on first byte\n+        byte msgMark = byteBuf.readByte();\n+\n+        if (msgMark == LEGACY_CORFU_MSG_MARK) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMDU4Nw=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTc0OTIyOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo1OTo0M1rOHsZJqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowMjowOFrOHsZO7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA==", "bodyText": "why object? Can it be a proto message?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516311464", "createdAt": "2020-11-02T22:59:43Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,74 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjgxMw==", "bodyText": "This is because it has to work for multiple Protobuf types: RequestMsg and ResponseMsg. And for the time being, it also has to work with legacy CorfuMsg types.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516312813", "createdAt": "2020-11-02T23:02:08Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/NettyCorfuMessageEncoder.java", "diffHunk": "@@ -1,29 +1,74 @@\n package org.corfudb.protocols.wireprotocol;\n \n import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.MessageToByteEncoder;\n-\n+import java.io.IOException;\n+import java.util.concurrent.atomic.LongAccumulator;\n import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.runtime.proto.service.CorfuMessage.RequestMsg;\n+import org.corfudb.runtime.proto.service.CorfuMessage.ResponseMsg;\n \n-import java.util.concurrent.atomic.LongAccumulator;\n+import static org.corfudb.protocols.CorfuProtocolCommon.LEGACY_CORFU_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_REQUEST_MSG_MARK;\n+import static org.corfudb.protocols.CorfuProtocolCommon.PROTO_CORFU_RESPONSE_MSG_MARK;\n \n /**\n  * Created by mwei on 10/1/15.\n  */\n @Slf4j\n-public class NettyCorfuMessageEncoder extends MessageToByteEncoder<CorfuMsg> {\n+public class NettyCorfuMessageEncoder extends MessageToByteEncoder<Object> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMTQ2NA=="}, "originalCommit": {"oid": "64c340b533b7c60139dd7cb0efeb33b297ccccda"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjA3Mjg4OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDozODoxOVrOHscYKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyNDowNlrOHseU4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ==", "bodyText": "This is a tricky part: imagine another thread is adding messages at the same time when you clean the set, as a result, you would delete messages (with clear method) from the set without executing \"writeAndFlush\".\nthe code should be:\nSet< CorfuMsg> messagesToFlush = new HashSet<>(messages);\nmessagesToFlush.forEach(msg ->{\n  messages.remove(msg);\n  ctx.writeAndFlush(msg);\n});", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364331", "createdAt": "2020-11-03T00:38:19Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjI1OQ==", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396259", "createdAt": "2020-11-03T02:24:06Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDMzMQ=="}, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjA3Mzk3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDozODozOVrOHscYyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyNDo1MVrOHseVpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ==", "bodyText": "same here", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516364491", "createdAt": "2020-11-03T00:38:39Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);\n+        messages.clear();\n+        requestMessages.forEach(ctx::writeAndFlush);\n+        requestMessages.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NjQ1NQ==", "bodyText": "Note: after internal discussion, this will be addressed in a separate PR.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516396455", "createdAt": "2020-11-03T02:24:51Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -129,11 +138,12 @@ public void channelRead(ChannelHandlerContext ctx, Object m)\n         }\n \n         log.info(\"channelRead: Handshake succeeded. Server Corfu Version: [{}]\", corfuVersion);\n-        log.debug(\"channelRead: There are [{}] messages in queue to be flushed.\", this.messages.size());\n-        // Flush messages in queue\n-        while (!messages.isEmpty()) {\n-            ctx.writeAndFlush(messages.poll());\n-        }\n+\n+        // Flush messages in backlog\n+        messages.forEach(ctx::writeAndFlush);\n+        messages.clear();\n+        requestMessages.forEach(ctx::writeAndFlush);\n+        requestMessages.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM2NDQ5MQ=="}, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjE5MTI1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMToyNToyM1rOHsdfhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzoyNzoyMFrOHsfLAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA==", "bodyText": "Can you put return on a new line?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516382598", "createdAt": "2020-11-03T01:25:23Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    @AllArgsConstructor\n+    public enum MessageMarker {\n+        LEGACY_MSG_MARK(0x1),\n+        PROTO_REQUEST_MSG_MARK(0x2),\n+        PROTO_RESPONSE_MSG_MARK(0x3);\n+\n+        private final int value;\n+\n+        public byte asByte() {\n+            return (byte) value;\n+        }\n+\n+        public static Map<Byte, MessageMarker> typeMap =\n+                Arrays.<MessageMarker>stream(MessageMarker.values())\n+                    .collect(Collectors.toMap(MessageMarker::asByte, Function.identity()));\n+    }\n+\n+    public static final UUID DEFAULT_UUID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDExMw==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410113", "createdAt": "2020-11-03T03:27:20Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/CorfuProtocolCommon.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package org.corfudb.protocols;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.ByteString;\n+import lombok.AllArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.corfudb.protocols.wireprotocol.SequencerMetrics;\n+import org.corfudb.protocols.wireprotocol.StreamAddressRange;\n+import org.corfudb.protocols.wireprotocol.StreamsAddressResponse;\n+import org.corfudb.protocols.wireprotocol.Token;\n+import org.corfudb.runtime.exceptions.SerializerException;\n+import org.corfudb.runtime.proto.RpcCommon.LayoutMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg;\n+import org.corfudb.runtime.proto.RpcCommon.SequencerMetricsMsg.SequencerStatus;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressRangeMsg;\n+import org.corfudb.runtime.proto.RpcCommon.StreamAddressSpaceMsg;\n+import org.corfudb.runtime.proto.RpcCommon.TokenMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidMsg;\n+import org.corfudb.runtime.proto.RpcCommon.UuidToStreamAddressSpacePairMsg;\n+import org.corfudb.runtime.view.Layout;\n+import org.corfudb.runtime.view.stream.StreamAddressSpace;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class provides methods for creating and converting between the Protobuf\n+ * objects defined in rpc_common.proto and their Java counterparts. These are used\n+ * by the majority of the service RPCs.\n+ */\n+@Slf4j\n+public class CorfuProtocolCommon {\n+    // Prevent class from being instantiated\n+    private CorfuProtocolCommon() {}\n+\n+    private static final EnumMap<SequencerMetrics.SequencerStatus, SequencerStatus> sequencerStatusTypeMap =\n+            new EnumMap<>(ImmutableMap.of(\n+                    SequencerMetrics.SequencerStatus.READY, SequencerStatus.READY,\n+                    SequencerMetrics.SequencerStatus.NOT_READY, SequencerStatus.NOT_READY,\n+                    SequencerMetrics.SequencerStatus.UNKNOWN, SequencerStatus.UNKNOWN));\n+\n+    // Temporary message header markers indicating message type.\n+    @AllArgsConstructor\n+    public enum MessageMarker {\n+        LEGACY_MSG_MARK(0x1),\n+        PROTO_REQUEST_MSG_MARK(0x2),\n+        PROTO_RESPONSE_MSG_MARK(0x3);\n+\n+        private final int value;\n+\n+        public byte asByte() {\n+            return (byte) value;\n+        }\n+\n+        public static Map<Byte, MessageMarker> typeMap =\n+                Arrays.<MessageMarker>stream(MessageMarker.values())\n+                    .collect(Collectors.toMap(MessageMarker::asByte, Function.identity()));\n+    }\n+\n+    public static final UUID DEFAULT_UUID = UUID.fromString(\"00000000-0000-0000-0000-000000000000\");\n+\n+    /**\n+     * Returns the Protobuf representation of a UUID.\n+     *\n+     * @param uuid   the desired (Java) UUID\n+     */\n+    public static UuidMsg getUuidMsg(UUID uuid) {\n+        return UuidMsg.newBuilder()\n+                .setLsb(uuid.getLeastSignificantBits())\n+                .setMsb(uuid.getMostSignificantBits())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a UUID object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf UUID message\n+     */\n+    public static UUID getUUID(UuidMsg msg) {\n+        return new UUID(msg.getMsb(), msg.getLsb());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Layout.\n+     *\n+     * @param layout   the desired (Java) Layout\n+     */\n+    public static LayoutMsg getLayoutMsg(Layout layout) {\n+        return LayoutMsg.newBuilder()\n+                .setLayoutJson(layout.asJSONString())\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a Layout object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf Layout message\n+     */\n+    public static Layout getLayout(LayoutMsg msg) {\n+        return Layout.fromJSONString(msg.getLayoutJson());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token, given\n+     * its epoch and sequence.\n+     *\n+     * @param epoch      the epoch of the token\n+     * @param sequence   the sequencer number of the token\n+     */\n+    public static TokenMsg getTokenMsg(long epoch, long sequence) {\n+        return TokenMsg.newBuilder()\n+                .setEpoch(epoch)\n+                .setSequence(sequence)\n+                .build();\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a Token.\n+     *\n+     * @param token   the desired (Java) Token\n+     */\n+    public static TokenMsg getTokenMsg(Token token) {\n+        return getTokenMsg(token.getEpoch(), token.getSequence());\n+    }\n+\n+    /**\n+     * Returns the Protobuf representation of a SequencerMetrics object.\n+     *\n+     * @param metrics   the desired (Java) SequencerMetrics\n+     */\n+    public static SequencerMetricsMsg getSequencerMetricsMsg(SequencerMetrics metrics) {\n+        return SequencerMetricsMsg.newBuilder()\n+                .setSequencerStatus(sequencerStatusTypeMap.getOrDefault(\n+                        metrics.getSequencerStatus(), SequencerStatus.INVALID))\n+                .build();\n+    }\n+\n+    /**\n+     * Returns a SequencerMetrics object from its Protobuf representation.\n+     *\n+     * @param msg   the Protobuf SequencerMetrics message\n+     */\n+    public static SequencerMetrics getSequencerMetrics(SequencerMetricsMsg msg) {\n+        switch (msg.getSequencerStatus()) {\n+            case READY: return SequencerMetrics.READY;\n+            case NOT_READY: return SequencerMetrics.NOT_READY;\n+            case UNKNOWN: return SequencerMetrics.UNKNOWN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjU5OA=="}, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjI3Mzg1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoxNDo0MVrOHseM7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzoyNzoyOFrOHsfLEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw==", "bodyText": "Add the reason for dropping message?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516394223", "createdAt": "2020-11-03T02:14:41Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDEyOA==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410128", "createdAt": "2020-11-03T03:27:28Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.\n+                super.channelRead(ctx, msg);\n+            } else {\n+                log.debug(\"channelRead: Dropping message: {}\", msg.getMsgType().name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDIyMw=="}, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjI5OTc1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjozMToxOFrOHsebew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMzoyNzozN1rOHsfLJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw==", "bodyText": "I think the original comment is more clear, can you restore that?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516397947", "createdAt": "2020-11-03T02:31:18Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQxMDE1MQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2796#discussion_r516410151", "createdAt": "2020-11-03T03:27:37Z", "author": {"login": "zfrenette"}, "path": "runtime/src/main/java/org/corfudb/protocols/wireprotocol/ClientHandshakeHandler.java", "diffHunk": "@@ -69,54 +81,51 @@ public ClientHandshakeHandler(@NonNull UUID clientId, UUID serverId, int handsha\n      * @throws Exception\n      */\n     @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object m)\n-        throws Exception {\n-\n+    public void channelRead(ChannelHandlerContext ctx, Object m) throws Exception {\n         if (this.handshakeState.failed()) {\n-            // if handshake has already failed, return\n+            log.warn(\"channelRead: Handshake has failed. Dropping message - {}\", m);\n             return;\n         }\n \n-        if (this.handshakeState.completed()) {\n-            // If handshake completed successfully, but still a message came through this handler,\n-            // send on to the next handler in order to avoid message loss.\n-            super.channelRead(ctx, m);\n+        if (m instanceof CorfuMsg) {\n+            CorfuMsg msg = (CorfuMsg) m;\n+            if (this.handshakeState.completed()) {\n+                // Only send upstream if handshake is complete.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5Nzk0Nw=="}, "originalCommit": {"oid": "2b32e68f880358f0ab0566e491a9f81e56a590ee"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1736, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}