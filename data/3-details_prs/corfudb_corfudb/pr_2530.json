{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNzg2MDI2", "number": 2530, "title": "CorfuStore: Lightweight Streaming Layer", "bodyText": "Streaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread whose fate is just bound to its calls.\nA sanity limit of 8 subscribers means for advanced use cases of several table subscriptions\nit would be up to the callers to work together to prevent system hog.\nThe stream layer will not assume upper layer needs.\nOverview\nDescription:\nWhy should this be merged:\nRelated issue(s) (if applicable): #\nChecklist (Definition of Done):\n\n There are no TODOs left in the code\n Coding conventions (e.g. for logging, unit tests) have been followed\n Change is covered by automated tests\n Public API has Javadoc", "createdAt": "2020-05-04T07:39:23Z", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530", "merged": true, "mergeCommit": {"oid": "8c5af13f39c8b20803cad3c6488d649f251e9e1d"}, "closed": true, "closedAt": "2020-09-18T06:14:43Z", "author": {"login": "hisundar"}, "timelineItems": {"totalCount": 51, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceE7xXgFqTQwNTI5NTgyNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJ1HNmABqjM3NzkyOTkwMjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Mjk1ODI2", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-405295826", "createdAt": "2020-05-04T19:48:43Z", "commit": {"oid": "0c1433d81838dfaa810d9355654ce2d305a3e2ce"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c1433d81838dfaa810d9355654ce2d305a3e2ce", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/0c1433d81838dfaa810d9355654ce2d305a3e2ce", "committedDate": "2020-05-04T07:35:32Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread."}, "afterCommit": {"oid": "4f035c6214110a2fff37ec4046e83420ff9e6d2f", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4f035c6214110a2fff37ec4046e83420ff9e6d2f", "committedDate": "2020-05-05T22:14:12Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f035c6214110a2fff37ec4046e83420ff9e6d2f", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4f035c6214110a2fff37ec4046e83420ff9e6d2f", "committedDate": "2020-05-05T22:14:12Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "ec70e58c4f78279c1df4af1ee70b06e5678d3565", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ec70e58c4f78279c1df4af1ee70b06e5678d3565", "committedDate": "2020-05-06T18:17:26Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec70e58c4f78279c1df4af1ee70b06e5678d3565", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ec70e58c4f78279c1df4af1ee70b06e5678d3565", "committedDate": "2020-05-06T18:17:26Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/59476c21f4a0e204c15446fdd71f8429cfb3a770", "committedDate": "2020-05-20T18:51:50Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzgzOTU2", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416383956", "createdAt": "2020-05-21T18:21:04Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyMTowNFrOGY9wWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyMTowNFrOGY9wWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDgxMA==", "bodyText": "Since you implement pub-sub, it would be great if you could use https://www.reactive-streams.org/ instead of self-written protocols.\nreactive-streams is a part of Java 9, so when we migrate to newer versions of java it can be used natively", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428830810", "createdAt": "2020-05-21T18:21:04Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2Mzg3MjU2", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416387256", "createdAt": "2020-05-21T18:26:02Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyNjowMlrOGY961Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyNjowMlrOGY961Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMzQ5Mw==", "bodyText": "Creating a new thread could be an expensive operation, probably reactive-streams already solved this problem internally in an efficient way", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428833493", "createdAt": "2020-05-21T18:26:02Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2Mzg3OTk5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416387999", "createdAt": "2020-05-21T18:27:06Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyNzowNlrOGY99FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyNzowNlrOGY99FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDA2OQ==", "bodyText": "it should be static in the other case make it non-caps", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428834069", "createdAt": "2020-05-21T18:27:06Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2Mzg5MDg4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416389088", "createdAt": "2020-05-21T18:28:40Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyODo0MVrOGY-AfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoyODo0MVrOGY-AfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNDk0MA==", "bodyText": "could be race condition here, please use ConcurrentHashMap", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428834940", "createdAt": "2020-05-21T18:28:41Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkwNDIy", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416390422", "createdAt": "2020-05-21T18:30:40Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMDo0MFrOGY-Etw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMDo0MFrOGY-Etw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjAyMw==", "bodyText": "log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener);", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428836023", "createdAt": "2020-05-21T18:30:40Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkxNjY2", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416391666", "createdAt": "2020-05-21T18:32:32Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMjozM1rOGY-IXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMjozM1rOGY-IXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjk1Nw==", "bodyText": "I'm concerned, probably we gonna create too many threads", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428836957", "createdAt": "2020-05-21T18:32:33Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkyMjk5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416392299", "createdAt": "2020-05-21T18:33:31Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMzozMVrOGY-KOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozMzozMVrOGY-KOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzQzMw==", "bodyText": "Should be AtomicBoolean", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428837433", "createdAt": "2020-05-21T18:33:31Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkyNjQ0", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416392644", "createdAt": "2020-05-21T18:34:01Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozNDowMVrOGY-LOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODozNDowMVrOGY-LOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzY4OQ==", "bodyText": "NIT: When concating the strings I think its better to have spaces around +", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428837689", "createdAt": "2020-05-21T18:34:01Z", "author": {"login": "PavelZaytsev"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDExMjU1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416411255", "createdAt": "2020-05-21T19:01:33Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowMTozM1rOGY_ECw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowOTowN1rOGY_S8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ==", "bodyText": "The exception name makes sense for the second case, but seems confusing for the first case.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428852235", "createdAt": "2020-05-21T19:01:33Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTA2NA==", "bodyText": "I think it's cleaner to put the try catch block outside the while loop, because once it hits exception, it is stopped. And preferrably also combine the the first try catch block for txnStream.seek(), they seem to be the same.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428855064", "createdAt": "2020-05-21T19:07:05Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjA0OQ==", "bodyText": "This should be trace right?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428856049", "createdAt": "2020-05-21T19:09:07Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {\n+                    while (!txnStream.hasNext()) {\n+                        log.debug(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDIwMzA3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416420307", "createdAt": "2020-05-21T19:15:33Z", "commit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToxNTozNFrOGY_ewg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMDozN1rOGY_88Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTA3NA==", "bodyText": "nit - space after + signs", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428859074", "createdAt": "2020-05-21T19:15:34Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1OTUxMw==", "bodyText": "also, typo in 'subscriber'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428859513", "createdAt": "2020-05-21T19:16:17Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjIzNQ=="}, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzkwNQ==", "bodyText": "nit: spaces around '+'", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428863905", "createdAt": "2020-05-21T19:24:58Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {\n+                    while (!txnStream.hasNext()) {\n+                        log.debug(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                            // Only extract the list of updates per stream as a list\n+                            multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                    CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                    epoch,\n+                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                            ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        log.debug(\"{}::onNext took {} ms\", listener.toString(),\n+                                TimeUnit.NANOSECONDS.toMillis(onNextEnd - onNextStart));\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(\"CorfuSubscriber: \"+namespace+\":\"+listener.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDYzOA==", "bodyText": "also isnt it more clear this way? \"corfusubscriber: listener.toString() + namesapace\"?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428864638", "createdAt": "2020-05-21T19:26:22Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \"+MAX_SUBSCRIBERS+\" hit! Consider consolidating \"+streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscrbie already registered \"+streamListener+\". Maybe call unregister\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\", streamListener,\n+                startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for \"+streamListener.toString());\n+            return;\n+        }\n+        st.setShutdown(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        @Getter\n+        @Setter\n+        private volatile boolean shutdown = false;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            while (!isShutdown()) {\n+                try {\n+                    while (!txnStream.hasNext()) {\n+                        log.debug(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                            // Only extract the list of updates per stream as a list\n+                            multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                    CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                    epoch,\n+                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                            ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        log.debug(\"{}::onNext took {} ms\", listener.toString(),\n+                                TimeUnit.NANOSECONDS.toMillis(onNextEnd - onNextStart));\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(\"CorfuSubscriber: \"+namespace+\":\"+listener.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzkwNQ=="}, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjgwMQ==", "bodyText": "is the client expected to know the start address of the stream of interest?  Is it possible for the client to have this info in a clean way?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428866801", "createdAt": "2020-05-21T19:30:37Z", "author": {"login": "pankti-m"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuStore.java", "diffHunk": "@@ -173,7 +170,7 @@ public Query query(@Nonnull final String namespace) {\n     void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n                    @Nonnull List<TableSchema> tablesOfInterest,\n                    @Nullable Timestamp timestamp) {\n-        txnStreamingManager.subscribe(streamListener, namespace, tablesOfInterest,\n+        streamManager.subscribe(streamListener, namespace, tablesOfInterest,\n                 (timestamp == null) ? getTimestamp().getSequence() : timestamp.getSequence());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "59476c21f4a0e204c15446fdd71f8429cfb3a770", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/59476c21f4a0e204c15446fdd71f8429cfb3a770", "committedDate": "2020-05-20T18:51:50Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/152eeb47f631be762a96d16b94601cf8b4cff2a6", "committedDate": "2020-05-21T20:02:52Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDgyNjg3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416482687", "createdAt": "2020-05-21T20:51:15Z", "commit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1MToxNVrOGZCbUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1MToxNVrOGZCbUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNzM0Nw==", "bodyText": "please rename the variable, it is not a constant", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428907347", "createdAt": "2020-05-21T20:51:15Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDg3MDYx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416487061", "createdAt": "2020-05-21T20:57:58Z", "commit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1Nzo1OFrOGZCoSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1Nzo1OFrOGZCoSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMDY2NQ==", "bodyText": "looks like there is a problem here, you do not handle InterruptedException it means there could be problems when other threads will try to stop this thread. Intellij IDEA should makes this line yellow with the warning/explanation.\nP.S. I know you execute interrupt() in unsubscribe method. I can't require you or claim but the way how this while cycle is written seems fragile to me", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428910665", "createdAt": "2020-05-21T20:57:58Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDg3NDg1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416487485", "createdAt": "2020-05-21T20:58:33Z", "commit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1ODozM1rOGZCpow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1ODozM1rOGZCpow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTAxMQ==", "bodyText": "no need for return", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428911011", "createdAt": "2020-05-21T20:58:33Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "originalPosition": 194}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDg3Nzg3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416487787", "createdAt": "2020-05-21T20:59:01Z", "commit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1OTowMVrOGZCqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo1OTowMVrOGZCqdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMTIyMQ==", "bodyText": "please use String.format", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428911221", "createdAt": "2020-05-21T20:59:01Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.sql.Time;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.SubscriberAlreadyExistsException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new SubscriberAlreadyExistsException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        int DEFAULT_TIMEOUT_IN_MILLI = 50;\n+                        TimeUnit.MILLISECONDS.sleep(DEFAULT_TIMEOUT_IN_MILLI);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(\"CorfuSubscriber: \" + listener.toString() + \":\" + namespace);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6"}, "originalPosition": 203}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "152eeb47f631be762a96d16b94601cf8b4cff2a6", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/152eeb47f631be762a96d16b94601cf8b4cff2a6", "committedDate": "2020-05-21T20:02:52Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/0199b7b79e73c28e6916bde8835567a3a916da14", "committedDate": "2020-05-21T21:22:30Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTA4OTk5", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416508999", "createdAt": "2020-05-21T21:33:12Z", "commit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozMzoxMlrOGZDscA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozMzoxMlrOGZDscA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODExMg==", "bodyText": "It would be great if you fix all yellows in the code, some of them could indicate about fragility in the code some bout bugs, thanks", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428928112", "createdAt": "2020-05-21T21:33:12Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTE1MDkw", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416515090", "createdAt": "2020-05-21T21:44:31Z", "commit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTo0NDozMVrOGZEAng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTo0NDozMVrOGZEAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMzI3OA==", "bodyText": "Sorry my bad, the format has to be\nsuper(String.format(\"CorfuSubscriber: %s:%s\", listener, namespace));", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428933278", "createdAt": "2020-05-21T21:44:31Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+            }\n+        }\n+\n+        public SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema> tableSchemas,\n+                                  long startAddress) {\n+            super(String.format(\"CorfuSubscriber: {}:{}\", listener.toString(), namespace));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTMwOTM2", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-416530936", "createdAt": "2020-05-21T22:17:42Z", "commit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjoxNzo0MlrOGZEyPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjoxNzo0MlrOGZEyPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NTk4Mw==", "bodyText": "If I understand it properly what you are trying to do is to have scheduler which will run your task periodically.\nYou can use java scheduler and it simplifies code. You will not need to check shutdown variable, no need for thread.sleep, catching exceptions to stop the thread, and so on.\nPlease take a look simplifyStreaming...simplifyStreaming-scheduler", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r428945983", "createdAt": "2020-05-21T22:17:42Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14"}, "originalPosition": 155}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0199b7b79e73c28e6916bde8835567a3a916da14", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/0199b7b79e73c28e6916bde8835567a3a916da14", "committedDate": "2020-05-21T21:22:30Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "committedDate": "2020-05-21T22:20:27Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDYwNzg1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-417060785", "createdAt": "2020-05-22T17:02:31Z", "commit": {"oid": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNzowMjozMVrOGZd-rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNzowMjozMVrOGZd-rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM1ODc2Nw==", "bodyText": "Here we call remaining(). that could cause the high memory usage. Instead of call remaining(), we can call remainUpto(offset + 40).\nWe can do something like this:\npollTxStream() {\nn = 0;\nwhile {\nn = polltxstream(upto);\n} do (n > 0)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r429358767", "createdAt": "2020-05-22T17:02:31Z", "author": {"login": "xiaoqin2012"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/TransactionPoller.java", "diffHunk": "@@ -1,111 +0,0 @@\n-package org.corfudb.runtime.collections;\n-\n-import lombok.Getter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.List;\n-import java.util.LinkedList;\n-import java.util.Comparator;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nonnull;\n-\n-import org.corfudb.protocols.wireprotocol.ILogData;\n-import org.corfudb.runtime.CorfuRuntime;\n-import org.corfudb.runtime.view.ObjectsView;\n-import org.corfudb.runtime.view.StreamOptions;\n-import org.corfudb.runtime.view.stream.IStreamView;\n-\n-/**\n- *\n- * Created by sneginhal on 10/22/2019.\n- */\n-@Slf4j\n-public class TransactionPoller implements Runnable {\n-\n-    /**\n-     * Corfu Runtime.\n-     */\n-    private final CorfuRuntime runtime;\n-\n-    /**\n-     * List of StreamingSubscriptionContexts to process.\n-     *\n-     * This is the list of StreamingSubscriptionContexts sorted by the last read addresses.\n-     */\n-    private final List<StreamingSubscriptionContext> streamContexts;\n-\n-    /**\n-     * A reference to the transaction stream\n-     */\n-    @Getter\n-    private final IStreamView txnStream;\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param streams The list of StreamingSubscriptionContexts to process.\n-     */\n-    public TransactionPoller(@Nonnull CorfuRuntime runtime,\n-                             @Nonnull List<StreamingSubscriptionContext> streams) {\n-        this.runtime = runtime;\n-        this.streamContexts = streams.stream()\n-                .sorted(Comparator.comparingLong(sc -> sc.getLastReadAddress()))\n-                .collect(Collectors.toList());\n-\n-        StreamOptions options = StreamOptions.builder()\n-                .cacheEntries(false)\n-                .build();\n-\n-        txnStream = runtime.getStreamsView()\n-                .getUnsafe(ObjectsView.TRANSACTION_STREAM_ID, options);\n-    }\n-\n-    /**\n-     *\n-     */\n-    @Override\n-    public void run() {\n-        try {\n-            pollTxStream();\n-        } catch (Throwable t) {\n-            // We don't want the thread running the poller to be terminated due to\n-            // some unexpected exception, so catch all here.\n-            log.error(\"Encountered an exception while polling the txn stream: {}\", t);\n-\n-            streamContexts.forEach(sc -> sc.setPollerException(t));\n-        } finally {\n-            streamContexts.forEach(sc -> sc.release());\n-        }\n-    }\n-\n-    private void pollTxStream() {\n- \n-        long lastReadAddress = streamContexts.get(0).getLastReadAddress();\n-\n-        log.trace(\"Seeking txStream to {}\", lastReadAddress + 1);\n-        txnStream.seek(lastReadAddress + 1);\n-        log.trace(\"txStream current global position after seeking {}, hasNext {}\",\n-                txnStream.getCurrentGlobalPosition(), txnStream.hasNext());\n-\n-        List<ILogData> updates = txnStream.remaining();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/cf2547f5b43ec345d4e1bf74d51787e7eea570d0", "committedDate": "2020-05-21T22:20:27Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "660f74198726a97e9e83d729cad1dfff687877fd", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/660f74198726a97e9e83d729cad1dfff687877fd", "committedDate": "2020-06-17T17:54:13Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTY5MjY1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-445969265", "createdAt": "2020-07-09T21:06:36Z", "commit": {"oid": "660f74198726a97e9e83d729cad1dfff687877fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTAzOTUx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446103951", "createdAt": "2020-07-10T03:46:17Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0NjoxN1rOGvo74Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0NjoxN1rOGvo74Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjk0NQ==", "bodyText": "I think its cleaner to pass a config type that has this as a default.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452606945", "createdAt": "2020-07-10T03:46:17Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTA0NTQy", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446104542", "createdAt": "2020-07-10T03:48:35Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0ODozNVrOGvo95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0ODozNVrOGvo95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzQ2Mg==", "bodyText": "These are not deamon threads, they can hang the JVM on exit.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452607462", "createdAt": "2020-07-10T03:48:35Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTA0Nzkw", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446104790", "createdAt": "2020-07-10T03:49:39Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0OTozOVrOGvo-vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo0OTozOVrOGvo-vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzY3OA==", "bodyText": "Please name these threads accordingly. Otherwise, its can be hard to profile/debug.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452607678", "createdAt": "2020-07-10T03:49:39Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTA2Mzkx", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446106391", "createdAt": "2020-07-10T03:55:58Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1NTo1OFrOGvpETw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1NTo1OFrOGvpETw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTEwMw==", "bodyText": "On unsubscribe the stream is not removed from the StreamsView. A series of subscribe/unsubscribe can create a stream leak.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452609103", "createdAt": "2020-07-10T03:55:58Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+            }\n+        }\n+\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriptionThread(@Nonnull StreamManager streamManager,\n+                                  @Nonnull StreamListener listener,\n+                                  @Nonnull String namespace,\n+                                  @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                                  long startAddress) {\n+            super(String.format(\"CorfuSubscriber: %s:%s\", listener.toString(), namespace));\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(false)\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTA3MTg4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446107188", "createdAt": "2020-07-10T03:59:09Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1OToxMFrOGvpG-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwMzo1OToxMFrOGvpG-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwOTc4Ng==", "bodyText": "I wouldn't use this API. It's not used and might be buggy. I recommend that you just try to sync anyways. If there are no deltas, the callbacks won't trigger.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452609786", "createdAt": "2020-07-10T03:59:10Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 156}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTEwMDkz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446110093", "createdAt": "2020-07-10T04:10:56Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxMDo1NlrOGvpQNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxMDo1NlrOGvpQNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMjE0OA==", "bodyText": "This will eventually call interrupt on its own self. After the interrupt there is a log line. Once a thread is interrupted it's possible that the subsequent io call fails with ClosedByInterruptException or similar interrupted exceptions.\nAnyways, it seems like the unsubscribe was designed to be called from a different thread, not the thread itself.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452612148", "createdAt": "2020-07-10T04:10:56Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+\n+        public void run() {\n+            try {\n+                log.info(\"{}:Seeking txStream to {}\", listener.toString(), startAddress + 1);\n+                txnStream.seek(startAddress + 1);\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}:onError at seek to {}\", listener.toString(), startAddress + 1);\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);\n+                return;\n+            }\n+\n+            try {\n+                while (!shutdown.get()) {\n+                    while (!txnStream.hasNext()) {\n+                        log.trace(\"{}::run() all caught up. Taking a 50ms nap\", listener.toString());\n+                        final int defaultTimeoutInMilli = 50;\n+                        TimeUnit.MILLISECONDS.sleep(defaultTimeoutInMilli);\n+                    }\n+                    ILogData logData = txnStream.nextUpTo(Address.MAX);\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                }\n+            } catch (Throwable throwable) {\n+                log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                listener.onError(throwable);\n+                streamManager.unsubscribe(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTExNDgw", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446111480", "createdAt": "2020-07-10T04:16:36Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxNjozNlrOGvpU4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxNjozNlrOGvpU4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzM0Nw==", "bodyText": "Spawning a thread per subscriber seems to be too expensive for what's being achieved.\nI think its better to multiplex these over an executor. The polling logic and life-cycle management is also cleaner with a scheduler executor. You can submit a periodic job that syncs the subscription streams, that will give you a task future that can be canceled. I think that's cleaner than managing the life cycle of the thread yourself.\nI think the code already has some bugs related to the thread life cycle management, so maybe consider just using a scheduled executor.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452613347", "createdAt": "2020-07-10T04:16:36Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int MAX_SUBSCRIBERS = 12; // Arbitrary sanity check value.\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, SubscriptionThread> subscriptions = new HashMap<>();\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this.runtime = runtime;\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.size() >= MAX_SUBSCRIBERS) {\n+            throw new StreamSubscriptionException(\n+                    \"subscribe: Max \" + MAX_SUBSCRIBERS + \" hit! Consider consolidating \"\n+                            + streamListener);\n+        }\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriptionThread st = new SubscriptionThread(this, streamListener,\n+                namespace, tablesOfInterest, startAddress);\n+        subscriptions.put(streamListener, st);\n+        st.start();\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        SubscriptionThread st = subscriptions.remove(streamListener);\n+        if (st == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        st.shutdown.set(true);\n+        st.interrupt();\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+    }\n+\n+    class SubscriptionThread extends Thread {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTExNzMz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446111733", "createdAt": "2020-07-10T04:17:43Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxNzo0M1rOGvpV6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDoxNzo0M1rOGvpV6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYxMzYxMQ==", "bodyText": "Instead of extending from RuntimeException I think we should introduce CorfuClientExceptions and extend from that. Right now our API with the application is not well-defined and that would be the right step forward.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452613611", "createdAt": "2020-07-10T04:17:43Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/exceptions/StreamSubscriptionException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.corfudb.runtime.exceptions;\n+\n+/**\n+ * CorfuStore only allows one subscriber for a given namespace.\n+ * If an attempt is made to register another subscriber without terminating or unsubscribing\n+ * the existing subscriber on that namespace this exception will be thrown.\n+ */\n+public class StreamSubscriptionException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTExOTY3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446111967", "createdAt": "2020-07-10T04:18:41Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTMzMjY1", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-446133265", "createdAt": "2020-07-10T05:40:06Z", "commit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNTo0MDowNlrOGvqfLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNTo0MDowNlrOGvqfLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzMjM2Ng==", "bodyText": "Can you also implement a close that runtime calls on shutdown ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r452632366", "createdAt": "2020-07-10T05:40:06Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package org.corfudb.runtime.collections;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/601d6e0fd613dcae9c9fec94cdd9aa7a134583d2", "committedDate": "2020-07-09T22:39:57Z", "message": "Merge branch 'master' into simplifyStreaming"}, "afterCommit": {"oid": "f1bb1c2d38991ae9a494b27e44741672392a097b", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f1bb1c2d38991ae9a494b27e44741672392a097b", "committedDate": "2020-09-15T00:02:59Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1bb1c2d38991ae9a494b27e44741672392a097b", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f1bb1c2d38991ae9a494b27e44741672392a097b", "committedDate": "2020-09-15T00:02:59Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/93d834e7710f02680219ef8c93b449c223faa825", "committedDate": "2020-09-15T00:07:08Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/93d834e7710f02680219ef8c93b449c223faa825", "committedDate": "2020-09-15T00:07:08Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "committedDate": "2020-09-15T04:56:26Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/d0e84d507f8d72f22d529b1b9e2c4e67bddd547f", "committedDate": "2020-09-15T04:56:26Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "committedDate": "2020-09-15T05:51:15Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjYyMTk3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-488262197", "createdAt": "2020-09-15T01:34:06Z", "commit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMTozNDowNlrOHRtQag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNTozNjozNVrOHRxYVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyOTMyMg==", "bodyText": "getTableRegistry() is lazily evaluated, so if the runtime never uses CorfuStore, then taleRegistry will never be created, but when shutting down, calling this will create a new tableRegistry which is not trival (tableRegistry constructor will do io to register itself). I think this needs to be taken care of.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488329322", "createdAt": "2020-09-15T01:34:06Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/CorfuRuntime.java", "diffHunk": "@@ -837,6 +837,7 @@ private void handleUncaughtThread(@Nonnull Thread thread, @Nonnull Throwable thr\n     public void shutdown() {\n         // Stopping async task from fetching layout.\n         isShutdown = true;\n+        getTableRegistry().shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Mzg1MA==", "bodyText": "Can convert to local variable.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488353850", "createdAt": "2020-09-15T03:01:44Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1NTg4NQ==", "bodyText": "The comment in the StreamSubscriptionException.java says this is thrown when subscribing to the same namespace, but how does the code here preventing that? subscriptions.containsKey(streamListener) checks the streamListener's hashcode() and equals(), but does not check for namespace, which means if client uses a new streamListener but subscribing to same namespace, it's still allowed, right?  Also the original implentation allows subscribing to the same namespace and even same table, is there a reason to change that behavior?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488355885", "createdAt": "2020-09-15T03:09:51Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1Njc3Nw==", "bodyText": "I think there should be a limit on maxSubscribers, especially now we have a poller per subscription which increases IO. Besides the tasks scheduled to be run are in an infinite loop (if new data can be fetched), which means if you have more than maxSubscribers subscriptions, it's possible that the new subscriptions will never be scheduled, right?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488356777", "createdAt": "2020-09-15T03:13:03Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1ODEyNw==", "bodyText": "Maybe we need to make openedStreams a HashSet instead of a List", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488358127", "createdAt": "2020-09-15T03:17:50Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/view/StreamsView.java", "diffHunk": "@@ -104,6 +104,13 @@ public void clear() {\n         openedStreams.clear();\n     }\n \n+    /**\n+     * Remove a specific stream from openedStreams\n+     */\n+    public void removeStream(IStreamView stream) {\n+        openedStreams.remove(stream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM1OTgwOQ==", "bodyText": "I suggest not pass true to cancel(). This will raise UnrecoverableCorfuInterruptedError. We saw a lot of such bugs, and nowadays we are confident to punt these bugs to verticals because corfu never do thread.interupt() or future.cancel(true).", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488359809", "createdAt": "2020-09-15T03:24:12Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2MTUxMA==", "bodyText": "I think we should disable cache for the poller. If you look at privous corfustore stream or our DCN, they both disabled cache to avoid polluting addressSpaceView cache, which could cause a lot of NoRollbackException.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488361510", "createdAt": "2020-09-15T03:31:12Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3NDg4MA==", "bodyText": "Maybe these two debug messages should be trace level since they are for every update, which will be noisy.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488374880", "createdAt": "2020-09-15T04:24:49Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM3ODEwNA==", "bodyText": "This check is not need, if logData is null, you will break out of the loop in line 201.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488378104", "createdAt": "2020-09-15T04:37:17Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);\n+                    break;\n+                }\n+            } while (logData != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM4MjU1Mg==", "bodyText": "I think unsubscribe should be before onError. If there is an error, verticals need to resubscribe, which should be unsubscribe beforehand. By the way I check current vertical's code, they are actully doing nothing but logging in onError(), which I think is not correct.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488382552", "createdAt": "2020-09-15T04:47:00Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;\n+\n+        public AtomicBoolean shutdown;\n+\n+        /**\n+         * A reference to the underlying stream\n+         */\n+        @Getter\n+        private final IStreamView txnStream;\n+        public <K extends Message, V extends Message, M extends Message>\n+        SubscriberTask(@Nonnull StreamManager streamManager,\n+                       @Nonnull StreamListener listener,\n+                       @Nonnull String namespace,\n+                       @Nonnull List<TableSchema<K, V, M>> tableSchemas,\n+                       long startAddress) {\n+            this.streamManager = streamManager;\n+            this.listener = listener;\n+            this.namespace = namespace;\n+            this.tablesOfInterest = new HashMap<>();\n+            this.shutdown = new AtomicBoolean();\n+            tableSchemas.forEach(tableSchema -> tablesOfInterest.put(\n+                    CorfuRuntime.getStreamID(\n+                            TableRegistry.getFullyQualifiedTableName(namespace,\n+                                    tableSchema.getTableName())\n+                    ), tableSchema\n+            ));\n+\n+            this.startAddress = startAddress;\n+            StreamOptions options = StreamOptions.builder()\n+                    .cacheEntries(!runtime.getParameters().isCacheDisabled())\n+                    .build();\n+\n+            this.txnStream = runtime.getStreamsView()\n+                    .get(ObjectsView.TRANSACTION_STREAM_ID, options);\n+            this.txnStream.seek(startAddress + 1);\n+        }\n+\n+        public void run() {\n+            ILogData logData = null;\n+            do {\n+                try {\n+                    Thread.currentThread().setName(namespace + listener.toString());\n+                    logData = txnStream.nextUpTo(Address.MAX);\n+                    if (logData == null) {\n+                        break; // Stream is all caught up, sleep for a bit.\n+                    }\n+                    MultiObjectSMREntry multiObjSMREntry = (MultiObjectSMREntry) logData.getPayload(runtime);\n+                    long epoch = logData.getEpoch();\n+                    Map<TableSchema, List<CorfuStreamEntry>> entries = new HashMap<>();\n+                    // first only filter by the stream IDs of interest that are present in this logData\n+                    logData.getStreams().stream().filter(tablesOfInterest::containsKey)\n+                            .forEach(streamId -> entries.put(tablesOfInterest.get(streamId),\n+                                    // Only extract the list of updates per stream as a list\n+                                    multiObjSMREntry.getSMRUpdates(streamId).stream().map(smrEntry ->\n+                                            CorfuStreamEntry.fromSMREntry(smrEntry,\n+                                                    epoch,\n+                                                    tablesOfInterest.get(streamId).getKeyClass(),\n+                                                    tablesOfInterest.get(streamId).getPayloadClass(),\n+                                                    tablesOfInterest.get(streamId).getMetadataClass())\n+                                    ).collect(Collectors.toList())));\n+\n+                    if (!entries.isEmpty()) {\n+                        CorfuStreamEntries callbackResult = new CorfuStreamEntries(entries);\n+                        log.debug(\"{}::onNext with {} updates\", listener.toString(), entries.size());\n+                        long onNextStart = System.nanoTime();\n+                        listener.onNext(callbackResult);\n+                        long onNextEnd = System.nanoTime();\n+                        if (TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart) > 0) {\n+                            log.debug(\"{}::onNext took {}s\", listener.toString(),\n+                                    TimeUnit.NANOSECONDS.toSeconds(onNextEnd - onNextStart));\n+                        }\n+                    }\n+                } catch (Throwable throwable) {\n+                    log.warn(\"{}::onError: {}\", listener.toString(), throwable.toString());\n+                    listener.onError(throwable);\n+                    streamManager.unsubscribe(listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93d834e7710f02680219ef8c93b449c223faa825"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Njg4NQ==", "bodyText": "Unused variable.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r488396885", "createdAt": "2020-09-15T05:36:35Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    private final int maxSubscribers;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+\n+    @Getter\n+    ScheduledExecutorService scheduledExecutorService;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    class StreamSubscriber {\n+        SubscriberTask subscriberTask;\n+        ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.maxSubscribers = maxSubscribers;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public synchronized void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return;\n+        }\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        subscriber.getScheduledFuture().cancel(true);\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+        /**\n+         * Starting address.\n+         */\n+        private final long startAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0e84d507f8d72f22d529b1b9e2c4e67bddd547f"}, "originalPosition": 157}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/ee2154f36b37b0df6aeb32a84a8d03a75183a7e5", "committedDate": "2020-09-15T05:51:15Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "c262dda6554b74bf5d373d97498720259ade1ace", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c262dda6554b74bf5d373d97498720259ade1ace", "committedDate": "2020-09-15T18:00:58Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c262dda6554b74bf5d373d97498720259ade1ace", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c262dda6554b74bf5d373d97498720259ade1ace", "committedDate": "2020-09-15T18:00:58Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "f3c8a616c69705d5d94123748510b2d232daa3b7", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f3c8a616c69705d5d94123748510b2d232daa3b7", "committedDate": "2020-09-15T23:26:17Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3c8a616c69705d5d94123748510b2d232daa3b7", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/f3c8a616c69705d5d94123748510b2d232daa3b7", "committedDate": "2020-09-15T23:26:17Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "c9605990620387b7d185d3dead5eae2d1a627f99", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c9605990620387b7d185d3dead5eae2d1a627f99", "committedDate": "2020-09-16T00:59:13Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9605990620387b7d185d3dead5eae2d1a627f99", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/c9605990620387b7d185d3dead5eae2d1a627f99", "committedDate": "2020-09-16T00:59:13Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "3ed6772a807ddbe2831412404f1e6d83a2522521", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/3ed6772a807ddbe2831412404f1e6d83a2522521", "committedDate": "2020-09-16T03:17:29Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ed6772a807ddbe2831412404f1e6d83a2522521", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/3ed6772a807ddbe2831412404f1e6d83a2522521", "committedDate": "2020-09-16T03:17:29Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "committedDate": "2020-09-16T16:45:01Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTQyNzA4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#pullrequestreview-490142708", "createdAt": "2020-09-17T00:32:16Z", "commit": {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMDozMjoxNlrOHTIoew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMDozMjo0OVrOHTIpJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjQyNw==", "bodyText": "@hisundar I think at least we need to log a warning message if the number of subscribers exceeds limit, otherwise it will be hard to debug when such issues happen. Also is 6 a bit large for default maxSubscribers considering each subscriber will now have a thread?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489826427", "createdAt": "2020-09-17T00:32:16Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    public static final int DEFAULT_LONG_RUNNING_TIME_SECS = 1; // When to log long running onNext()\n+    /**\n+     * The actual executor thread pool where the subscribers will run.\n+     */\n+    private ScheduledExecutorService scheduledExecutorService;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    private class StreamSubscriber {\n+        private final SubscriberTask subscriberTask;\n+        private final ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgyNjU5OA==", "bodyText": "There is already a isShutdown variable on line 168 right?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2530#discussion_r489826598", "createdAt": "2020-09-17T00:32:49Z", "author": {"login": "WenbinZhu"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/StreamManager.java", "diffHunk": "@@ -0,0 +1,261 @@\n+package org.corfudb.runtime.collections;\n+\n+import com.google.protobuf.Message;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.corfudb.protocols.logprotocol.MultiObjectSMREntry;\n+import org.corfudb.protocols.wireprotocol.ILogData;\n+import org.corfudb.runtime.CorfuRuntime;\n+import org.corfudb.runtime.exceptions.StreamSubscriptionException;\n+import org.corfudb.runtime.view.Address;\n+import org.corfudb.runtime.view.ObjectsView;\n+import org.corfudb.runtime.view.StreamOptions;\n+import org.corfudb.runtime.view.TableRegistry;\n+import org.corfudb.runtime.view.stream.IStreamView;\n+\n+/**\n+ * A simple thread based subscription engine where each subscriber or listener gets\n+ * a thread which will listen on the tables of interest to it and moves at a rate\n+ * which is the same as the consumption.\n+ *\n+ * Created by hisundar on 04/28/2020.\n+ */\n+@Slf4j\n+public class StreamManager {\n+\n+    private static final int DEFAULT_NUM_SUBSCRIBERS = 6; // Arbitrary sanity check value.\n+    private static final int DEFAULT_SLEEP_MILLIS = 50; // Default time to sleep\n+    public static final int DEFAULT_LONG_RUNNING_TIME_SECS = 1; // When to log long running onNext()\n+    /**\n+     * The actual executor thread pool where the subscribers will run.\n+     */\n+    private ScheduledExecutorService scheduledExecutorService;\n+\n+    /**\n+     * Map of StreamingSubscriptionThreads.\n+     * <p>\n+     * This is the map of all streaming subscriptions.\n+     */\n+    @Getter\n+    private final Map<StreamListener, StreamSubscriber> subscriptions;\n+\n+    /**\n+     * Corfu Runtime.\n+     */\n+    @Getter\n+    private final CorfuRuntime runtime;\n+\n+    @AllArgsConstructor\n+    @Getter\n+    private class StreamSubscriber {\n+        private final SubscriberTask subscriberTask;\n+        private final ScheduledFuture<?> scheduledFuture;\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime, int maxSubscribers) {\n+        this.runtime = runtime;\n+        this.subscriptions = new HashMap<>();\n+        this.scheduledExecutorService = Executors.newScheduledThreadPool(maxSubscribers);\n+    }\n+\n+    public StreamManager(@Nonnull CorfuRuntime runtime) {\n+        this(runtime, DEFAULT_NUM_SUBSCRIBERS);\n+    }\n+\n+    public void shutdown() {\n+        log.info(\"Shutting down StreamManager executor pool\");\n+        scheduledExecutorService.shutdown();\n+    }\n+\n+    /**\n+     * Subscribe to updates.\n+     *\n+     * @param streamListener   Client listener.\n+     * @param namespace        Namespace of interest.\n+     * @param tablesOfInterest Only updates from these tables will be returned.\n+     * @param startAddress     Address to start the notifications from.\n+     */\n+    public synchronized <K extends Message, V extends Message, M extends Message>\n+    void subscribe(@Nonnull StreamListener streamListener, @Nonnull String namespace,\n+                   @Nonnull List<TableSchema<K, V, M>> tablesOfInterest, long startAddress) {\n+        if (subscriptions.containsKey(streamListener)) {\n+            // Multiple subscribers subscribing to same namespace and table is allowed.\n+            // Which is why we use the caller's hashcode() and equals() are used to validate re-subscription.\n+            // If the caller does not want to start another subscriber on the same namespace & table,\n+            // then the hashcode should be constructed from listener name.\n+            // If caller wants to allow 2 subscriptions on the same namespace+table,\n+            // then hashcode and equals can just reflect the subscriber's name or other distinguishing fields.\n+            // Basically we are saying, \"hey you decide if this is a re-subscription or a new subscription\"\n+            throw new StreamSubscriptionException(\n+                    \"StreamManager:subscriber already registered \"\n+                            + streamListener + \". Maybe call unregister first?\");\n+        }\n+        log.info(\"StreamManager::subscribe {}, startAddress {}, namespace {}, tables {}\",\n+                streamListener, startAddress, namespace, tablesOfInterest.toString());\n+        SubscriberTask task = new SubscriberTask(this,\n+                streamListener, namespace, tablesOfInterest, startAddress);\n+        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(\n+                task, 0, DEFAULT_SLEEP_MILLIS, TimeUnit.MILLISECONDS);\n+        subscriptions.put(streamListener, new StreamSubscriber(task, scheduledFuture));\n+    }\n+\n+    /**\n+     * Unsubscribe a prior subscription.\n+     *\n+     * @param streamListener Client listener.\n+     */\n+    public void unsubscribe(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber streamSubscriber = unsubscribeInternal(streamListener);\n+        if (streamSubscriber != null) {\n+            streamSubscriber.getScheduledFuture().cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * Internal method that can be safely invoked from the same thread executing the task.\n+     * @param streamListener client's listener object.\n+     * @return - returns the stream subscriber context for lifecycle management.\n+     */\n+    private synchronized StreamSubscriber unsubscribeInternal(@Nonnull StreamListener streamListener) {\n+        StreamSubscriber subscriber = subscriptions.remove(streamListener);\n+        if (subscriber == null) {\n+            log.warn(\"StreamManager::unsubscribe has no context for {}\", streamListener.toString());\n+            return null;\n+        }\n+        // Since we are not force interrupting the thread, set a flag for it to shutdown\n+        subscriber.getSubscriberTask().isShutdown.set(true);\n+        log.info(\"Unsubscribed StreamListener {}\", streamListener.toString());\n+        runtime.getStreamsView().removeStream(subscriber.getSubscriberTask().txnStream);\n+        return subscriber;\n+    }\n+\n+    class SubscriberTask implements Runnable {\n+        /**\n+         * The callback context\n+         */\n+        private final StreamListener listener;\n+\n+        /**\n+         * Parent class to manage errors.\n+         */\n+        @Getter\n+        private final StreamManager streamManager;\n+\n+        /**\n+         * Namespace of interest.\n+         */\n+        @Getter\n+        private final String namespace;\n+\n+        @Setter\n+        private final AtomicBoolean isShutdown = new AtomicBoolean(false);\n+\n+        /**\n+         * Tables of interest.\n+         *\n+         * Map of (Stream Id - TableSchema)\n+         */\n+        @Getter\n+        private final Map<UUID,\n+                TableSchema<? extends Message, ? extends Message, ? extends Message>> tablesOfInterest;\n+\n+        public AtomicBoolean shutdown;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6"}, "originalPosition": 179}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/785083a226b2cf3f47e061f2a9bdf2a7296e40d6", "committedDate": "2020-09-16T16:45:01Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "committedDate": "2020-09-17T17:59:07Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4213606f8db70988138fd1b838218527315138fb", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4213606f8db70988138fd1b838218527315138fb", "committedDate": "2020-09-17T18:15:05Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/48215b7151d04f40e291cbf262a2c7b0d3dedcf9", "committedDate": "2020-09-17T17:59:07Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}, "afterCommit": {"oid": "4213606f8db70988138fd1b838218527315138fb", "author": {"user": {"login": "hisundar", "name": "Sundar Sridharan"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/4213606f8db70988138fd1b838218527315138fb", "committedDate": "2020-09-17T18:15:05Z", "message": "CorfuStore: Lightweight Streaming Layer\n\nStreaming needs to work in JVMs that have very little heap space.\nIn such processes use of a separate txPoller with buffering of\nupdates creates an overhead that causes the JVM to go OOM.\nThis change simplifies streaming layer avoids & avoids buffering.\nEach subscriber gets a separate tx stream and task on a thread.\nAdd logging for debugging capability."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3242, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}