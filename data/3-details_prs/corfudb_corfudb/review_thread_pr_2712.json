{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NjA0OTA3", "number": 2712, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowMjo0MlrOEYQIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowOTo1M1rOEYQOrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY1NDk3OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowMjo0MlrOHAfPhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNzozOFrOHAfWlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzkyNA==", "bodyText": "I'm concerned, if this change could affect the clients since we changed contract, hope it works", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470273924", "createdAt": "2020-08-13T22:02:42Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTczNQ==", "bodyText": "Unfortunately there isn't much flexibility here. If clients are enqueuing without a transaction then its incorrect. If we start a transaction internally, then that transaction can abort. They're probably not dealing with the TransacationAbort right now", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470275735", "createdAt": "2020-08-13T22:07:38Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzkyNA=="}, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY1NjMzOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowMzoxOFrOHAfQVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoyNToyNVrOHAfxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDEzMg==", "bodyText": "final?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470274132", "createdAt": "2020-08-13T22:03:18Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjUyOQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282529", "createdAt": "2020-08-13T22:25:25Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDEzMg=="}, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY1Njk1OnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowMzozNVrOHAfQuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoyNDo1NFrOHAfwWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDIzMg==", "bodyText": "@AllArgsConstructor ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470274232", "createdAt": "2020-08-13T22:03:35Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjMyOQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282329", "createdAt": "2020-08-13T22:24:54Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDIzMg=="}, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY2Mzg5OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNjoyOVrOHAfU7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoyNzoyMFrOHAfz3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTMwOQ==", "bodyText": "Just a question: Are we ok with IllegalStateException? Maybe we have a more specific exception?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470275309", "createdAt": "2020-08-13T22:06:29Z", "author": {"login": "xnull"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -1,38 +1,58 @@\n package org.corfudb.runtime.collections;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+\n import com.google.common.primitives.UnsignedBytes;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuQueue.CorfuQueueRecord;\n import org.corfudb.runtime.view.AbstractViewTest;\n import org.corfudb.util.serializer.Serializers;\n import org.junit.Test;\n \n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n /**\n  * Created by Sundar Sridharan on May 22, 2019\n  */\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n /**\n  * Simple test of basic operations to check that insert order is preserved in the queue.\n  * Created by hisundar on 05/27/2019\n  */\n+@Slf4j\n public class CorfuQueueTest extends AbstractViewTest {\n \n+    @Test\n+    public void failNonTxnEnqueue() {\n+        CorfuQueue<String>\n+                corfuQueue = new CorfuQueue<>(getDefaultRuntime(), \"test\");\n+        Assertions.assertThatThrownBy(() -> corfuQueue.enqueue(\"c\"))\n+                .isInstanceOf(IllegalStateException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MzIyOQ==", "bodyText": "I think this should suffice. This exception signals an incorrect usage of the API. There is nothing to handle per-se\n * Signals that a method has been invoked at an illegal or\n * inappropriate time.  In other words, the Java environment or\n * Java application is not in an appropriate state for the requested\n * operation.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470283229", "createdAt": "2020-08-13T22:27:20Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/runtime/collections/CorfuQueueTest.java", "diffHunk": "@@ -1,38 +1,58 @@\n package org.corfudb.runtime.collections;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+\n import com.google.common.primitives.UnsignedBytes;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.assertj.core.api.Assertions;\n+import org.corfudb.runtime.CorfuRuntime;\n import org.corfudb.runtime.collections.CorfuQueue.CorfuQueueRecord;\n import org.corfudb.runtime.view.AbstractViewTest;\n import org.corfudb.util.serializer.Serializers;\n import org.junit.Test;\n \n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n /**\n  * Created by Sundar Sridharan on May 22, 2019\n  */\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n /**\n  * Simple test of basic operations to check that insert order is preserved in the queue.\n  * Created by hisundar on 05/27/2019\n  */\n+@Slf4j\n public class CorfuQueueTest extends AbstractViewTest {\n \n+    @Test\n+    public void failNonTxnEnqueue() {\n+        CorfuQueue<String>\n+                corfuQueue = new CorfuQueue<>(getDefaultRuntime(), \"test\");\n+        Assertions.assertThatThrownBy(() -> corfuQueue.enqueue(\"c\"))\n+                .isInstanceOf(IllegalStateException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTMwOQ=="}, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODY3MTgxOnYy", "diffSide": "RIGHT", "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowOTo1M1rOHAfZ2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjoyNDo0MVrOHAfwEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjU2OA==", "bodyText": "@hisundar we never clean PreCommitListeners? Is it ok?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470276568", "createdAt": "2020-08-13T22:09:53Z", "author": {"login": "xnull"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {\n+                 this.recordId = recordId;\n+             }\n+\n+             /**\n+              * If we are in a transaction, determine the commit address and fix it up in\n+              * the queue entry.\n+              * @param tokenResponse\n+              */\n+             @Override\n+             public void preCommitCallback(TokenResponse tokenResponse) {\n+                 recordId.setTxSequence(tokenResponse.getSequence());\n+                 log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n+             }\n+         }\n+\n+         QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n+         log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n+         TransactionalContext.getRootContext().addPreCommitListener(addressGetter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4MjI1OQ==", "bodyText": "The listener is part of the TransactionalContext which is thread local. After the transaction completes or fails it will be garbage collected.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2712#discussion_r470282259", "createdAt": "2020-08-13T22:24:41Z", "author": {"login": "Maithem"}, "path": "runtime/src/main/java/org/corfudb/runtime/collections/CorfuQueue.java", "diffHunk": "@@ -157,40 +160,38 @@ public int hashCode() {\n      *         element prevents it from being added to this queue\n      */\n     public CorfuRecordId enqueue(E e) {\n+        checkState(TransactionalContext.isInTransaction(), \"must be called within a transaction!\");\n         final CorfuRecordId id = new CorfuRecordId(0, guidGenerator.nextLong());\n \n-        // If we are in a transaction, then we need the commit address of this transaction\n-        // to fix up as the txSequence\n-        if (TransactionalContext.isInTransaction()) {\n-            /**\n-             * This is a callback that is placed into the root transaction's context on\n-             * the thread local stack which will be invoked right after this transaction\n-             * is deemed successful and has obtained a final sequence number to write.\n-             */\n-            class QueueEntryAddressGetter implements PreCommitListener {\n-                private CorfuRecordId recordId;\n-                private QueueEntryAddressGetter(CorfuRecordId recordId) {\n-                    this.recordId = recordId;\n-                }\n-\n-                /**\n-                 * If we are in a transaction, determine the commit address and fix it up in\n-                 * the queue entry.\n-                 * @param tokenResponse\n-                 */\n-                @Override\n-                public void preCommitCallback(TokenResponse tokenResponse) {\n-                    recordId.setTxSequence(tokenResponse.getSequence());\n-                    log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n-                }\n-            }\n-            QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n-            log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n-            TransactionalContext.getRootContext().addPreCommitListener(addressGetter);\n-        }\n-\n-        corfuTable.put(id, e);\n-        return id;\n+        /**\n+         * This is a callback that is placed into the root transaction's context on\n+         * the thread local stack which will be invoked right after this transaction\n+         * is deemed successful and has obtained a final sequence number to write.\n+         */\n+         class QueueEntryAddressGetter implements PreCommitListener {\n+             private CorfuRecordId recordId;\n+             private QueueEntryAddressGetter(CorfuRecordId recordId) {\n+                 this.recordId = recordId;\n+             }\n+\n+             /**\n+              * If we are in a transaction, determine the commit address and fix it up in\n+              * the queue entry.\n+              * @param tokenResponse\n+              */\n+             @Override\n+             public void preCommitCallback(TokenResponse tokenResponse) {\n+                 recordId.setTxSequence(tokenResponse.getSequence());\n+                 log.trace(\"preCommitCallback for Queue: \" + recordId.toString());\n+             }\n+         }\n+\n+         QueueEntryAddressGetter addressGetter = new QueueEntryAddressGetter(id);\n+         log.trace(\"enqueue: Adding preCommitListener for Queue: \" + id.toString());\n+         TransactionalContext.getRootContext().addPreCommitListener(addressGetter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjU2OA=="}, "originalCommit": {"oid": "a2e7c9b86cdd870ad27535afdf98c96ecbad6930"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1941, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}