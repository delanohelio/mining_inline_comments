{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODYzMjkw", "number": 2466, "title": "Revert \"Revert \"Xq/seqcache01 (#2300)\" (#2464)\"", "bodyText": "This reverts commit 7f9c3fe.\nOverview\nDescription:\nWhy should this be merged:\nRelated issue(s) (if applicable): #\nChecklist (Definition of Done):\n\n There are no TODOs left in the code\n Coding conventions (e.g. for logging, unit tests) have been followed\n Change is covered by automated tests\n Public API has Javadoc", "createdAt": "2020-03-09T23:21:19Z", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466", "merged": true, "mergeCommit": {"oid": "3624e8b32666a173e354ef1600f69e2400b6545d"}, "closed": true, "closedAt": "2020-03-30T19:33:05Z", "author": {"login": "xiaoqin2012"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMXQzygFqTM3MjIzODA4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSyCtgAFqTM4NDA4MDQ5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMjM4MDgz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466#pullrequestreview-372238083", "createdAt": "2020-03-10T18:59:21Z", "commit": {"oid": "c4ccfe076428584613a2a670732513fbfb977f77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODo1OToyMVrOF0c2hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODo1OToyMVrOF0c2hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0Mjk4Mw==", "bodyText": "FYI, I did experiment about assertThat and looks assertThat does not assert its parameter is true.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466#discussion_r390542983", "createdAt": "2020-03-10T18:59:21Z", "author": {"login": "zhangn49"}, "path": "test/src/test/java/org/corfudb/runtime/object/transactions/SequencerServerCacheTest.java", "diffHunk": "@@ -68,36 +64,152 @@ public void testSequencerCacheTrim() {\n     public void testCache() {\n         final AtomicBoolean criticalVariable = new AtomicBoolean();\n \n-        SequencerServerCache cache = new SequencerServerCache(1, new CacheWriter<ConflictTxStream, Long>() {\n-            @Override\n-            public void write(@Nonnull ConflictTxStream key, @Nonnull Long value) {\n-                log.info(\"Write: [{}, {}]. Thread: {}\", key, value, Thread.currentThread().getName());\n-            }\n-\n-            @Override\n-            public void delete(@Nonnull ConflictTxStream key, @Nullable Long value, @Nonnull RemovalCause cause) {\n-                log.info(\"Delete record: {}. Thread: {}\", key, Thread.currentThread().getName());\n-                criticalVariable.set(true);\n-            }\n-        });\n-\n-        final ConflictTxStream firstKey = new ConflictTxStream(UUID.randomUUID(), new byte[]{});\n-        final ConflictTxStream secondKey = new ConflictTxStream(UUID.randomUUID(), new byte[]{});\n+        SequencerServerCache cache = new SequencerServerCache(1, Address.NOT_FOUND);\n         final long firstValue = 1L;\n         final long secondValue = 2L;\n         final int iterations = 10;\n+        final ConflictTxStream firstKey = new ConflictTxStream(UUID.randomUUID(), new byte[]{}, firstValue);\n+        final ConflictTxStream secondKey = new ConflictTxStream(UUID.randomUUID(), new byte[]{}, secondValue);\n \n         for (int i = 0; i < iterations; i++) {\n-            criticalVariable.set(false);\n-\n-            cache.put(firstKey, firstValue);\n-            cache.put(secondKey, secondValue);\n+            cache.put(firstKey);\n+            cache.put(secondKey);\n \n             assertThat(cache.size()).isOne();\n-            assertThat(cache.getIfPresent(firstKey)).isNull();\n+            assertThat(cache.get(firstKey)).isEqualTo(Address.NON_ADDRESS);\n+        }\n+    }\n+\n+    public static final int entryPerAddress = 20;\n+    public static final int iterations = 100;\n+    public static final int cacheSize = iterations * entryPerAddress;\n+    public static final int numRemains = 10;\n+\n+    /**\n+     * generate data with given address and verify that the entries with firstAddress are correctly evicted\n+     */\n+    void generateData(HashMap recordMap, SequencerServerCache cache, long address, boolean verifyFirst) {\n+        final ConflictTxStream key = new ConflictTxStream(UUID.randomUUID(), new byte[]{}, address);\n+        if (verifyFirst) {\n+            log.debug(\"cache.firstAddress: \" + cache.firstAddress() + \" cacheSize: \" + cache.size());\n+            assertThat(cache.firstAddress() == address - cacheSize);\n+        }\n+        cache.put(key);\n+        assertThat(cache.get(key) != Address.NON_ADDRESS);\n+        recordMap.put(key, address);\n+        assertThat(cache.size() <= cacheSize);\n+    }\n+\n+    /**\n+     * Verify cache contains all the data in recordMap that address >= firstAddress.\n+     * @param recordMap\n+     * @param cache\n+     */\n+    void verifyData(HashMap<ConflictTxStream, Long> recordMap, SequencerServerCache cache) {\n+        for (ConflictTxStream oldKey : recordMap.keySet()) {\n+            long oldAddress = oldKey.txVersion;\n+            if (oldAddress < cache.firstAddress()) {\n+                continue;\n+            }\n+            ConflictTxStream key = new ConflictTxStream(oldKey.getStreamId(), oldKey.getConflictParam(), 0);\n+            log.debug(\"address \" + cache.get(key) + \" expected \" + oldAddress);\n+            assertThat(cache.get(key) == oldAddress);\n+        }\n+    }\n+\n+    @Test\n+    /*\n+        Test the evication the firstAddress while the cache is full, by generating address out of order\n+     */\n+    public void testSequencerCacheEvict1() {\n+        SequencerServerCache cache = new SequencerServerCache(cacheSize, Address.NOT_FOUND);\n+        long address = 0;\n+        HashMap<ConflictTxStream, Long> recordMap = new HashMap<>();\n+\n+        // put entries to the cache with duplicate address not in order\n+        while (cache.size() < cacheSize) {\n+            address = 0;\n+            for (int i = 0; i < cacheSize / entryPerAddress; i++) {\n+                generateData(recordMap, cache, address++, false);\n+            }\n+        }\n+\n+        assertThat(cache.size() == cacheSize);\n+        verifyData(recordMap, cache);\n+\n+        // Each put should evict all streams with the same address\n+        for (int i = 0; i < iterations; i++, address++) {\n+            generateData(recordMap, cache, address, true);\n+        }\n+\n+        verifyData(recordMap, cache);\n+\n+        cache.invalidateUpTo(address - 1);\n+        assertThat(cache.size() == 1);\n+        cache.invalidateUpTo(address);\n+        assertThat(cache.size() == 0);\n+    }\n+\n+    @Test\n+    /*\n+        Test the evication the firstAddress while the cache is full, by generating address in order\n+     */\n+    public void testSequencerCacheEvict2() {\n+        SequencerServerCache cache = new SequencerServerCache(cacheSize, Address.NOT_FOUND);\n+        long address = 0;\n+        HashMap<ConflictTxStream, Long> recordMap = new HashMap<>();\n+\n+        // put entries to the cache, make it full, some entries have the same address\n+        while (cache.size() < cacheSize) {\n+            for (int j = 0; j < entryPerAddress; j++) {\n+                generateData(recordMap, cache, address++, false);\n+            }\n+        }\n+\n+        verifyData(recordMap, cache);\n+\n+        assertThat(cache.size() == cacheSize);\n+        // Each put should evict all streams with the same address\n+        for (int i = 0; i < iterations; i++, address++) {\n+            generateData(recordMap, cache, address, true);\n+        }\n+\n+        verifyData(recordMap, cache);\n+        log.info(\"cacheSize {} cacheByteSize {} cacheEntriesBytes {} \", cache.size(), cache.byteSize(), cache.byteSize());\n+        long entrySize = cache.byteSize() / cache.size();\n+\n+        cache.invalidateUpTo(address - numRemains);\n+        assertThat(cache.size() == numRemains);\n+\n+        // this assume that the all conflickstreams has the same size of the parameters.\n+        assertThat(entrySize == cache.byteSize() / cache.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ccfe076428584613a2a670732513fbfb977f77"}, "originalPosition": 172}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDg4ODMz", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466#pullrequestreview-383088833", "createdAt": "2020-03-27T18:04:11Z", "commit": {"oid": "872dea49ea7c527dac28bc7d470056cbb15b0a5e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDg5NDI3", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466#pullrequestreview-383089427", "createdAt": "2020-03-27T18:05:06Z", "commit": {"oid": "872dea49ea7c527dac28bc7d470056cbb15b0a5e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b9e43f4b741fab13c5d949ecec2741c04f76f34", "author": {"user": {"login": "xiaoqin2012", "name": "Xiaoqin Ma"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/5b9e43f4b741fab13c5d949ecec2741c04f76f34", "committedDate": "2020-03-30T03:00:21Z", "message": "Revert \"Revert \"Xq/seqcache01 (#2300)\" (#2464)\"\n\nThis reverts commit 7f9c3fef9fcca6b0ced3f1ea92c3b42af67525b3."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ead4675cfec58b4a95021226cef428e7246551", "author": {"user": {"login": "xiaoqin2012", "name": "Xiaoqin Ma"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/24ead4675cfec58b4a95021226cef428e7246551", "committedDate": "2020-03-30T03:00:21Z", "message": "Use proper assert function.\n* Add the element first before eviction."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e012fd58912a8bf6260ea2fc6bc2acedd4c576ff", "author": {"user": {"login": "xiaoqin2012", "name": "Xiaoqin Ma"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/e012fd58912a8bf6260ea2fc6bc2acedd4c576ff", "committedDate": "2020-03-30T03:00:34Z", "message": "Merge branch 'xq/new_seqcache01' of https://github.com/CorfuDB/CorfuDB into xq/new_seqcache01"}, "afterCommit": {"oid": "24ead4675cfec58b4a95021226cef428e7246551", "author": {"user": {"login": "xiaoqin2012", "name": "Xiaoqin Ma"}}, "url": "https://github.com/CorfuDB/CorfuDB/commit/24ead4675cfec58b4a95021226cef428e7246551", "committedDate": "2020-03-30T03:00:21Z", "message": "Use proper assert function.\n* Add the element first before eviction."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MDgwNDk4", "url": "https://github.com/CorfuDB/CorfuDB/pull/2466#pullrequestreview-384080498", "createdAt": "2020-03-30T17:34:56Z", "commit": {"oid": "24ead4675cfec58b4a95021226cef428e7246551"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3364, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}