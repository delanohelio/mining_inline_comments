{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MzYzMjY0", "number": 2772, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozNDoyNFrOEmulfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxODo0ODowMlrOEpKOWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDQ0NjA1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozNDoyNFrOHW7d3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozNDoyNFrOHW7d3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNTAyMw==", "bodyText": "Can we move this above 762, so we print in the log.info the ID of the new forced Snapshot Sync? (for debugging purposes)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r493805023", "createdAt": "2020-09-23T18:34:24Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -752,21 +752,24 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     @Override\n-    public void forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n+    public UUID forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n         if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n             String errorStr = \"The forceSnapshotSync command is not supported on standby cluster.\";\n             log.error(errorStr);\n             throw new LogReplicationDiscoveryServiceException(errorStr);\n         }\n \n-        log.info(\"Received the forceSnapshotSync command.\");\n+        log.info(\"Received the forceSnapshotSync command for standby cluster {}\", clusterId);\n \n-        /**\n-         * write to the event to the event corfu table\n-         */\n+        // Write to the event to the event corfu table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0271a394a0b038ef7b1ce87ed022c603688eff1"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDQ1MDc1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozNTozN1rOHW7gqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozNTozN1rOHW7gqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNTczOA==", "bodyText": "are we missing the setType(LogReplicationMetadata.ReplicationEventType.FORCE_SNAPSHOT_SYNC)?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r493805738", "createdAt": "2020-09-23T18:35:37Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -752,21 +752,24 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     @Override\n-    public void forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n+    public UUID forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n         if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n             String errorStr = \"The forceSnapshotSync command is not supported on standby cluster.\";\n             log.error(errorStr);\n             throw new LogReplicationDiscoveryServiceException(errorStr);\n         }\n \n-        log.info(\"Received the forceSnapshotSync command.\");\n+        log.info(\"Received the forceSnapshotSync command for standby cluster {}\", clusterId);\n \n-        /**\n-         * write to the event to the event corfu table\n-         */\n+        // Write to the event to the event corfu table\n+        UUID forceSyncId = UUID.randomUUID();\n         ReplicationEventKey key = ReplicationEventKey.newBuilder().setKey(System.currentTimeMillis() + \" \"+ clusterId).build();\n-        ReplicationEvent event = ReplicationEvent.newBuilder().setClusterId(clusterId).setType(LogReplicationMetadata.ReplicationEventType.FORCE_SNAPSHOT_SYNC).build();\n+        ReplicationEvent event = ReplicationEvent.newBuilder()\n+                .setClusterId(clusterId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0271a394a0b038ef7b1ce87ed022c603688eff1"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDQ2NDQ1OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/LogReplicationEventListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozOToxOFrOHW7o6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozOToxOFrOHW7o6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNzg0OA==", "bodyText": "Can we add to the log.info data relevant to the event being processed? I think ReplicationEvent does not have the String annotation or overwrite so it would just print the reference.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r493807848", "createdAt": "2020-09-23T18:39:18Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/LogReplicationEventListener.java", "diffHunk": "@@ -39,21 +38,23 @@ public void onNext(CorfuStreamEntries results) {\n             log.info(\"LogReplicationEventListener onNext {} will be processed at node {} in the cluster {}\",\n                     results, discoveryService.getLocalNodeDescriptor(), discoveryService.getLocalClusterDescriptor());\n \n-            /**\n-             * If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n-             */\n+\n+            // If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n             for (List<CorfuStreamEntry> entryList : results.getEntries().values()) {\n                 for (CorfuStreamEntry entry : entryList) {\n                     ReplicationEvent event = (ReplicationEvent) entry.getPayload();\n                     log.info(\"ReplicationEventListener put an event {} to its local discoveryServiceQueue\", event);\n-                    discoveryService.input(new DiscoveryServiceEvent(DiscoveryServiceEvent.DiscoveryServiceEventType.ENFORCE_SNAPSHOT_SYNC, event.getClusterId()));\n+                    discoveryService.input(new DiscoveryServiceEvent(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0271a394a0b038ef7b1ce87ed022c603688eff1"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTk0NDkxOnYy", "diffSide": "RIGHT", "path": "infrastructure/proto/log_replication_metadata.proto", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzoyMTo1N1rOHXv0bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzoyMTo1N1rOHXv0bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2Mjc2NA==", "bodyText": "Planning to cancel the periodic task in LogReplicationAckReader explicitly or put a flag.\nOtherwise, some special status like error or not started will get overwritten.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r494662764", "createdAt": "2020-09-24T23:21:57Z", "author": {"login": "zhangn49"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,44 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTE0NjQ2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxODoxNzoxNFrOHYN7HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMjozNDo1MVrOHaEi7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE1NTk5Ng==", "bodyText": "I think this has an issue, cause this schedules the task right away and for the calculation of remaining entries we need the logEntryReader, hence we'll have a NPE.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495155996", "createdAt": "2020-09-25T18:17:14Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -89,8 +92,7 @@ public void setSyncType(LogReplicationMetadata.ReplicationStatusVal.SyncType syn\n         }\n     }\n \n-    public void startAckReader(LogEntryReader logEntryReader) {\n-        this.logEntryReader = logEntryReader;\n+    public void startAckReader() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTczNQ==", "bodyText": "There was a NPE before I made this change. I'll revisit this part when I run some test later", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496219735", "createdAt": "2020-09-28T20:41:40Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -89,8 +92,7 @@ public void setSyncType(LogReplicationMetadata.ReplicationStatusVal.SyncType syn\n         }\n     }\n \n-    public void startAckReader(LogEntryReader logEntryReader) {\n-        this.logEntryReader = logEntryReader;\n+    public void startAckReader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE1NTk5Ng=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1OTkyMQ==", "bodyText": "ok, cool. Cause yes I think we still might have an issue until the LogEntryReader is set.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496959921", "createdAt": "2020-09-29T18:44:22Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -89,8 +92,7 @@ public void setSyncType(LogReplicationMetadata.ReplicationStatusVal.SyncType syn\n         }\n     }\n \n-    public void startAckReader(LogEntryReader logEntryReader) {\n-        this.logEntryReader = logEntryReader;\n+    public void startAckReader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE1NTk5Ng=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA5OTUwMQ==", "bodyText": "Brought it back. LogReplicationFSMTest did not start ackReader, so there was a NPE.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497099501", "createdAt": "2020-09-29T22:34:51Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -89,8 +92,7 @@ public void setSyncType(LogReplicationMetadata.ReplicationStatusVal.SyncType syn\n         }\n     }\n \n-    public void startAckReader(LogEntryReader logEntryReader) {\n-        this.logEntryReader = logEntryReader;\n+    public void startAckReader() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE1NTk5Ng=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTE5NTU2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxODozMjo1NFrOHYOZhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODozMjoxN1rOHZ7nfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2Mzc4MA==", "bodyText": "I think we should be using System.nanoTime(), Medhavi mentioned an NTP issue with using Instant.now()", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495163780", "createdAt": "2020-09-25T18:32:54Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMDMyOQ==", "bodyText": "Could you please explain a bit more about NTP? I don't find anything about NTP on google and I see lock store uses Instant too.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496220329", "createdAt": "2020-09-28T20:42:48Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2Mzc4MA=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1MzIxNA==", "bodyText": "Yes, we were trying to change the lock store one but ran into some issue. Actually there's a PR opened for that change, in which we still need to understand why some tests started failing.\nThis is what I recall of the use of Instant (which was an issue that Srinivas ran into). He explained that Instant.now() gives wall clock time, therefore a manual or NTP driven change in the wall clock will lead to the wrong conclusion. But I guess this is in the case of computations in between times, for example to compute a duration. If you're only using it as a point time (no computation), I think we should be fine!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496953214", "createdAt": "2020-09-29T18:32:17Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2Mzc4MA=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTIwODUzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxODozNzowOFrOHYOhmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxODozNzowOFrOHYOhmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTg1MA==", "bodyText": "nit -> white space ( new", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495165850", "createdAt": "2020-09-25T18:37:08Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationSourceManager.java", "diffHunk": "@@ -131,11 +131,23 @@ public LogReplicationSourceManager(LogReplicationRuntimeParameters params,\n      * @return unique identifier for this snapshot sync request.\n      */\n     public UUID startSnapshotSync() {\n+        return startSnapshotSync(new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_REQUEST), false);\n+    }\n+\n+    /**\n+     * Signal start of a forced snapshot sync\n+     *\n+     * @param snapshotSyncRequestId unique identifier of the forced snapshot sync (already provided to the caller)\n+     */\n+    public void startForcedSnapshotSync(UUID snapshotSyncRequestId) {\n+        startSnapshotSync( new LogReplicationEvent(LogReplicationEventType.SNAPSHOT_SYNC_REQUEST, snapshotSyncRequestId), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3MjY4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/LogReplicationFSM.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozMjo1MlrOHYQGNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozMjo1MlrOHYQGNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MTYwNQ==", "bodyText": "I think we might have an issue here, please look at the comment in LogReplicationAckReader with regards to this.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495191605", "createdAt": "2020-09-25T19:32:52Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/LogReplicationFSM.java", "diffHunk": "@@ -253,6 +253,9 @@ public LogReplicationFSM(CorfuRuntime runtime, SnapshotReader snapshotReader, Da\n         // Initialize Log Replication 5 FSM states - single instance per state\n         initializeStates(snapshotSender, logEntrySender, dataSender);\n \n+        // Assign logEntryReader to ackReader\n+        this.ackReader.setLogEntryReader(logEntryReader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3OTQwOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNToxN1rOHYQKYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODozMjo0OFrOHZ7ohw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjY3NQ==", "bodyText": "why is this no longer valid?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495192675", "createdAt": "2020-09-25T19:35:17Z", "author": {"login": "annym"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -743,7 +743,7 @@ public void testEnforceSnapshotSync() throws Exception {\n         txKey = LogReplicationMetadataKey.newBuilder().setKey(LAST_SNAPSHOT_STARTED.getVal()).build();\n         long newSnapshotTimestamp = Long.parseLong(metadataTable.get(txKey).getPayload().getVal());\n         assertThat(lastAppliedSnapshot).isLessThan(newSnapshotTimestamp);\n-        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());\n+//        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMTQyMg==", "bodyText": "It failed because the replication status is being updated a few more times.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496221422", "createdAt": "2020-09-28T20:44:53Z", "author": {"login": "zhangn49"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -743,7 +743,7 @@ public void testEnforceSnapshotSync() throws Exception {\n         txKey = LogReplicationMetadataKey.newBuilder().setKey(LAST_SNAPSHOT_STARTED.getVal()).build();\n         long newSnapshotTimestamp = Long.parseLong(metadataTable.get(txKey).getPayload().getVal());\n         assertThat(lastAppliedSnapshot).isLessThan(newSnapshotTimestamp);\n-        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());\n+//        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjY3NQ=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1MzQ3OQ==", "bodyText": "ok, I see. Then just delete this line!", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496953479", "createdAt": "2020-09-29T18:32:48Z", "author": {"login": "annym"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -743,7 +743,7 @@ public void testEnforceSnapshotSync() throws Exception {\n         txKey = LogReplicationMetadataKey.newBuilder().setKey(LAST_SNAPSHOT_STARTED.getVal()).build();\n         long newSnapshotTimestamp = Long.parseLong(metadataTable.get(txKey).getPayload().getVal());\n         assertThat(lastAppliedSnapshot).isLessThan(newSnapshotTimestamp);\n-        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());\n+//        assertThat(newSnapshotTimestamp).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjY3NQ=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM3OTg1OnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNToyNFrOHYQKnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNToyNFrOHYQKnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjczMg==", "bodyText": "same here?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495192732", "createdAt": "2020-09-25T19:35:24Z", "author": {"login": "annym"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -753,7 +753,7 @@ public void testEnforceSnapshotSync() throws Exception {\n         log.info(\"NewSnapshot Timestamp {} active logTail {} after full snapshot sync!\", newSnapshotTimestamp, activeRuntime.getAddressSpaceView().getLogTail());\n \n         // The enforced snapshot sync completed.\n-        assertThat(newSnapshotTimestamp).isEqualTo(Long.parseLong(metadataTable.get(txKey).getPayload().getVal()));\n+//        assertThat(newSnapshotTimestamp).isEqualTo(Long.parseLong(metadataTable.get(txKey).getPayload().getVal()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM4MTcyOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozNjowM1rOHYQLuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDo1MzozNFrOHZPN9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MzAxNg==", "bodyText": "Nan, is it possible to include checks on any of our existing ITs, to validate that the replication status is being set correctly?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495193016", "createdAt": "2020-09-25T19:36:03Z", "author": {"login": "annym"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -699,7 +699,7 @@ public void testEnforceSnapshotSync() throws Exception {\n                         \"is {}, standby corfu[{}] log tail is {} lastAppliedSnapshot {}\",\n                 firstBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n                 standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail(), lastAppliedSnapshot);\n-        assertThat(lastAppliedSnapshot).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());\n+//        assertThat(lastAppliedSnapshot).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNTc4Mw==", "bodyText": "Yes, I will add some validations to a few ITs.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496225783", "createdAt": "2020-09-28T20:53:34Z", "author": {"login": "zhangn49"}, "path": "test/src/test/java/org/corfudb/integration/CorfuReplicationClusterConfigIT.java", "diffHunk": "@@ -699,7 +699,7 @@ public void testEnforceSnapshotSync() throws Exception {\n                         \"is {}, standby corfu[{}] log tail is {} lastAppliedSnapshot {}\",\n                 firstBatch, activeClusterCorfuPort, activeRuntime.getAddressSpaceView().getLogTail(),\n                 standbyClusterCorfuPort, standbyRuntime.getAddressSpaceView().getLogTail(), lastAppliedSnapshot);\n-        assertThat(lastAppliedSnapshot).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());\n+//        assertThat(lastAppliedSnapshot).isEqualTo(activeRuntime.getAddressSpaceView().getLogTail());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MzAxNg=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM4OTUxOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozODo0N1rOHYQQhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODozMzozMlrOHZ7qHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NDI0Ng==", "bodyText": "this is only valid for a Standby, isn't it more intuitive if they see the status is ongoing? or do we aim to reflect the status of the replication from an active's point of view? In which case should we add a status that reflects that? cause it can be misleading, thinking that data is not consistent cause replication is stopped, when in reality the active is transferring data.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495194246", "createdAt": "2020-09-25T19:38:47Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -378,7 +510,10 @@ public ReplicationStatusVal getReplicationRemainingEntries(String clusterId) {\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder()\n+                .setStatus(LogReplicationMetadata.SyncStatus.STOPPED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNzY4MQ==", "bodyText": "Yes, ongoing makes more sense than stopped. If the user is able to check the status for each standby from the active side, I think empty status might be better.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496117681", "createdAt": "2020-09-28T17:29:13Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -378,7 +510,10 @@ public ReplicationStatusVal getReplicationRemainingEntries(String clusterId) {\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder()\n+                .setStatus(LogReplicationMetadata.SyncStatus.STOPPED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NDI0Ng=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk1Mzg4Nw==", "bodyText": "yep, I agree empty status would be better.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496953887", "createdAt": "2020-09-29T18:33:32Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -378,7 +510,10 @@ public ReplicationStatusVal getReplicationRemainingEntries(String clusterId) {\n \n     public void setDataConsistentOnStandby(boolean isConsistent) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(localClusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setDataConsistent(isConsistent).build();\n+        ReplicationStatusVal val = ReplicationStatusVal.newBuilder()\n+                .setStatus(LogReplicationMetadata.SyncStatus.STOPPED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NDI0Ng=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTM5MTg4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozOTo0NFrOHYQSKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTozOTo0NFrOHYQSKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NDY2NQ==", "bodyText": "nit -> as ongoing?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495194665", "createdAt": "2020-09-25T19:39:44Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTQxMzU3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTo0NzoyNVrOHYQfrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDo0NjoyM1rOHZPAHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5ODEyNQ==", "bodyText": "In the case it was not set and we're coming from negotiation saying we can continue with LOGENTRY, on negotiation don't we get info of the last baseSnapshotTimestamp that at least we could populate? Maybe it's not worth the work but something to consider, what do you think? or we can leave a todo..", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495198125", "createdAt": "2020-09-25T19:47:25Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();\n+        Timestamp timestamp = Timestamp.newBuilder().setSeconds(time.getEpochSecond())\n+                .setNanos(time.getNano()).build();\n+\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            LogReplicationMetadata.SnapshotSyncInfo previousSyncInfo = previous.getSnapshotSyncInfo();\n+\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo = previousSyncInfo.toBuilder()\n+                    .setStatus(LogReplicationMetadata.SyncStatus.COMPLETED)\n+                    .setCompletedTime(timestamp)\n+                    .build();\n+\n+            ReplicationStatusVal current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(previous.getRemainingEntriesToSend())\n+                    .setSyncType(ReplicationStatusVal.SyncType.LOG_ENTRY)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(currentSyncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as completed: clusterId: {}, syncInfo: {}\",\n+                    clusterId, currentSyncInfo);\n+        }\n+    }\n+\n+    /**\n+     * Set replication status table.\n+     * If the current sync type is log entry sync, keep Snapshot Sync Info.\n+     *\n+     * @param clusterId standby cluster id\n+     * @param remainingEntries num of remaining entries to send\n+     * @param type sync type\n+     */\n+    public void setReplicationStatusTable(String clusterId, long remainingEntries,\n+                                          ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        LogReplicationMetadata.SnapshotSyncInfo syncInfo = null;\n+        ReplicationStatusVal current;\n+\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            syncInfo = previous.getSnapshotSyncInfo();\n+        }\n+\n+        if (type == ReplicationStatusVal.SyncType.LOG_ENTRY) {\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during LOG_ENTRY sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMjIzOA==", "bodyText": "I don't think syncInfo is null if we come from negotiation. It should have a previous round snapshot sync, and syncInfo should be kept.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496222238", "createdAt": "2020-09-28T20:46:23Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();\n+        Timestamp timestamp = Timestamp.newBuilder().setSeconds(time.getEpochSecond())\n+                .setNanos(time.getNano()).build();\n+\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            LogReplicationMetadata.SnapshotSyncInfo previousSyncInfo = previous.getSnapshotSyncInfo();\n+\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo = previousSyncInfo.toBuilder()\n+                    .setStatus(LogReplicationMetadata.SyncStatus.COMPLETED)\n+                    .setCompletedTime(timestamp)\n+                    .build();\n+\n+            ReplicationStatusVal current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(previous.getRemainingEntriesToSend())\n+                    .setSyncType(ReplicationStatusVal.SyncType.LOG_ENTRY)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(currentSyncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as completed: clusterId: {}, syncInfo: {}\",\n+                    clusterId, currentSyncInfo);\n+        }\n+    }\n+\n+    /**\n+     * Set replication status table.\n+     * If the current sync type is log entry sync, keep Snapshot Sync Info.\n+     *\n+     * @param clusterId standby cluster id\n+     * @param remainingEntries num of remaining entries to send\n+     * @param type sync type\n+     */\n+    public void setReplicationStatusTable(String clusterId, long remainingEntries,\n+                                          ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        LogReplicationMetadata.SnapshotSyncInfo syncInfo = null;\n+        ReplicationStatusVal current;\n+\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            syncInfo = previous.getSnapshotSyncInfo();\n+        }\n+\n+        if (type == ReplicationStatusVal.SyncType.LOG_ENTRY) {\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during LOG_ENTRY sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5ODEyNQ=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTQzMDY4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxOTo1Mjo1NlrOHYQpsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDo1MzowNVrOHZPNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwMDY5MA==", "bodyText": "if we reach this and the snapshotSyncInfo is not present, shouldn't we set it to NOT_STARTED? as the path once it is started will set it to ONGOING... how do we handle potential TAE's from here and from the other async updateSnapshotSyncInfo? cause we could then overwrite a ONGOING, with a NOT_STARTED...", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r495200690", "createdAt": "2020-09-25T19:52:56Z", "author": {"login": "annym"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();\n+        Timestamp timestamp = Timestamp.newBuilder().setSeconds(time.getEpochSecond())\n+                .setNanos(time.getNano()).build();\n+\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            LogReplicationMetadata.SnapshotSyncInfo previousSyncInfo = previous.getSnapshotSyncInfo();\n+\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo = previousSyncInfo.toBuilder()\n+                    .setStatus(LogReplicationMetadata.SyncStatus.COMPLETED)\n+                    .setCompletedTime(timestamp)\n+                    .build();\n+\n+            ReplicationStatusVal current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(previous.getRemainingEntriesToSend())\n+                    .setSyncType(ReplicationStatusVal.SyncType.LOG_ENTRY)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(currentSyncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as completed: clusterId: {}, syncInfo: {}\",\n+                    clusterId, currentSyncInfo);\n+        }\n+    }\n+\n+    /**\n+     * Set replication status table.\n+     * If the current sync type is log entry sync, keep Snapshot Sync Info.\n+     *\n+     * @param clusterId standby cluster id\n+     * @param remainingEntries num of remaining entries to send\n+     * @param type sync type\n+     */\n+    public void setReplicationStatusTable(String clusterId, long remainingEntries,\n+                                          ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        LogReplicationMetadata.SnapshotSyncInfo syncInfo = null;\n+        ReplicationStatusVal current;\n+\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            syncInfo = previous.getSnapshotSyncInfo();\n+        }\n+\n+        if (type == ReplicationStatusVal.SyncType.LOG_ENTRY) {\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during LOG_ENTRY sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            }\n+\n+            current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(type)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"setReplicationStatusTable: clusterId: {}, remainingEntries: {}, type: {}, syncInfo: {}\",\n+                    clusterId, remainingEntries, type, syncInfo);\n+        } else if (type == ReplicationStatusVal.SyncType.SNAPSHOT) {\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo;\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during SNAPSHOT sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                currentSyncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            } else {\n+                currentSyncInfo = syncInfo.toBuilder()\n+                        .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzk0MA==", "bodyText": "If we reach here, current sync type is snapshot sync. So I have to keep both statuses as ongoing...\nAll replication status updates are protected by the lock in the ackReader, so TAE should be fine right now.\nI added a flag to avoid overwriting by the periodic task.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496223940", "createdAt": "2020-09-28T20:49:56Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();\n+        Timestamp timestamp = Timestamp.newBuilder().setSeconds(time.getEpochSecond())\n+                .setNanos(time.getNano()).build();\n+\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            LogReplicationMetadata.SnapshotSyncInfo previousSyncInfo = previous.getSnapshotSyncInfo();\n+\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo = previousSyncInfo.toBuilder()\n+                    .setStatus(LogReplicationMetadata.SyncStatus.COMPLETED)\n+                    .setCompletedTime(timestamp)\n+                    .build();\n+\n+            ReplicationStatusVal current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(previous.getRemainingEntriesToSend())\n+                    .setSyncType(ReplicationStatusVal.SyncType.LOG_ENTRY)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(currentSyncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as completed: clusterId: {}, syncInfo: {}\",\n+                    clusterId, currentSyncInfo);\n+        }\n+    }\n+\n+    /**\n+     * Set replication status table.\n+     * If the current sync type is log entry sync, keep Snapshot Sync Info.\n+     *\n+     * @param clusterId standby cluster id\n+     * @param remainingEntries num of remaining entries to send\n+     * @param type sync type\n+     */\n+    public void setReplicationStatusTable(String clusterId, long remainingEntries,\n+                                          ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        LogReplicationMetadata.SnapshotSyncInfo syncInfo = null;\n+        ReplicationStatusVal current;\n+\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            syncInfo = previous.getSnapshotSyncInfo();\n+        }\n+\n+        if (type == ReplicationStatusVal.SyncType.LOG_ENTRY) {\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during LOG_ENTRY sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            }\n+\n+            current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(type)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"setReplicationStatusTable: clusterId: {}, remainingEntries: {}, type: {}, syncInfo: {}\",\n+                    clusterId, remainingEntries, type, syncInfo);\n+        } else if (type == ReplicationStatusVal.SyncType.SNAPSHOT) {\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo;\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during SNAPSHOT sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                currentSyncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            } else {\n+                currentSyncInfo = syncInfo.toBuilder()\n+                        .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwMDY5MA=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNTUzNg==", "bodyText": "BTW, I haven't found a way to differentiate NOT_STARTED and STOPPED if the current statue is initialized. All update is based on replication FSM, but negotiation is a runtime state.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r496225536", "createdAt": "2020-09-28T20:53:05Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/receive/LogReplicationMetadataManager.java", "diffHunk": "@@ -335,17 +338,146 @@ public void setSnapshotAppliedComplete(LogReplicationEntry entry) {\n         log.debug(\"Commit snapshot apply complete timestamp={}, for topologyConfigId={}\", ts, topologyConfigId);\n     }\n \n-    public void setReplicationRemainingEntries(String clusterId, long remainingEntries,\n-                                               ReplicationStatusVal.SyncType type) {\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId, boolean forced, UUID eventId,\n+                                       long baseVersion, long remainingEntries) {\n         ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n-        ReplicationStatusVal val = ReplicationStatusVal.newBuilder().setRemainingEntriesToSend(remainingEntries)\n-                .setType(type).build();\n-        TxBuilder txBuilder = corfuStore.tx(NAMESPACE);\n-        txBuilder.update(REPLICATION_STATUS_TABLE, key, val, null);\n-        txBuilder.commit();\n \n-        log.debug(\"setReplicationRemainingEntries: clusterId: {}, remainingEntries: {}, type: {}\",\n-                clusterId, remainingEntries, type);\n+        LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType syncType = forced ?\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.FORCED :\n+                LogReplicationMetadata.SnapshotSyncInfo.SnapshotSyncType.DEFAULT;\n+\n+            LogReplicationMetadata.SnapshotSyncInfo syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder()\n+                    .setType(syncType)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotRequestId(eventId.toString())\n+                    .setBaseSnapshot(baseVersion)\n+                    .build();\n+\n+            ReplicationStatusVal status = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(ReplicationStatusVal.SyncType.SNAPSHOT)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, status, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as ongoing: clusterId: {}, syncInfo: {}\",\n+                    clusterId, syncInfo);\n+    }\n+\n+    /**\n+     * Update replication status table's snapshot sync info as completed.\n+     *\n+     * @param clusterId standby cluster id\n+     */\n+    public void updateSnapshotSyncInfo(String clusterId) {\n+        Instant time = Instant.now();\n+        Timestamp timestamp = Timestamp.newBuilder().setSeconds(time.getEpochSecond())\n+                .setNanos(time.getNano()).build();\n+\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            LogReplicationMetadata.SnapshotSyncInfo previousSyncInfo = previous.getSnapshotSyncInfo();\n+\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo = previousSyncInfo.toBuilder()\n+                    .setStatus(LogReplicationMetadata.SyncStatus.COMPLETED)\n+                    .setCompletedTime(timestamp)\n+                    .build();\n+\n+            ReplicationStatusVal current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(previous.getRemainingEntriesToSend())\n+                    .setSyncType(ReplicationStatusVal.SyncType.LOG_ENTRY)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(currentSyncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"updateSnapshotSyncInfo as completed: clusterId: {}, syncInfo: {}\",\n+                    clusterId, currentSyncInfo);\n+        }\n+    }\n+\n+    /**\n+     * Set replication status table.\n+     * If the current sync type is log entry sync, keep Snapshot Sync Info.\n+     *\n+     * @param clusterId standby cluster id\n+     * @param remainingEntries num of remaining entries to send\n+     * @param type sync type\n+     */\n+    public void setReplicationStatusTable(String clusterId, long remainingEntries,\n+                                          ReplicationStatusVal.SyncType type) {\n+        ReplicationStatusKey key = ReplicationStatusKey.newBuilder().setClusterId(clusterId).build();\n+        LogReplicationMetadata.SnapshotSyncInfo syncInfo = null;\n+        ReplicationStatusVal current;\n+\n+        CorfuRecord<ReplicationStatusVal, Message> record =\n+                corfuStore.query(NAMESPACE).getRecord(REPLICATION_STATUS_TABLE, key);\n+        if (record != null) {\n+            ReplicationStatusVal previous = record.getPayload();\n+            syncInfo = previous.getSnapshotSyncInfo();\n+        }\n+\n+        if (type == ReplicationStatusVal.SyncType.LOG_ENTRY) {\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during LOG_ENTRY sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                syncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            }\n+\n+            current = ReplicationStatusVal.newBuilder()\n+                    .setRemainingEntriesToSend(remainingEntries)\n+                    .setSyncType(type)\n+                    .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)\n+                    .setSnapshotSyncInfo(syncInfo)\n+                    .build();\n+\n+            corfuStore.tx(NAMESPACE)\n+                    .update(REPLICATION_STATUS_TABLE, key, current, null)\n+                    .commit();\n+\n+            log.debug(\"setReplicationStatusTable: clusterId: {}, remainingEntries: {}, type: {}, syncInfo: {}\",\n+                    clusterId, remainingEntries, type, syncInfo);\n+        } else if (type == ReplicationStatusVal.SyncType.SNAPSHOT) {\n+            LogReplicationMetadata.SnapshotSyncInfo currentSyncInfo;\n+            if (syncInfo == null){\n+                log.warn(\"setReplicationStatusTable during SNAPSHOT sync, \" +\n+                        \"previous status is not present for cluster: {}\", clusterId);\n+                currentSyncInfo = LogReplicationMetadata.SnapshotSyncInfo.newBuilder().build();\n+            } else {\n+                currentSyncInfo = syncInfo.toBuilder()\n+                        .setStatus(LogReplicationMetadata.SyncStatus.ONGOING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwMDY5MA=="}, "originalCommit": {"oid": "111bd83ecff23c7fbdea83c22ecd99aa90fb4fdf"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTM4MTkzOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTo1MDoxN1rOHZ-tPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOTo1MDoxN1rOHZ-tPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwMzgzOA==", "bodyText": "nit: remove one \"to the event\"", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497003838", "createdAt": "2020-09-29T19:50:17Z", "author": {"login": "PavelZaytsev"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -752,21 +753,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     @Override\n-    public void forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n+    public UUID forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n         if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n             String errorStr = \"The forceSnapshotSync command is not supported on standby cluster.\";\n             log.error(errorStr);\n             throw new LogReplicationDiscoveryServiceException(errorStr);\n         }\n \n-        log.info(\"Received the forceSnapshotSync command.\");\n+        UUID forceSyncId = UUID.randomUUID();\n+        log.info(\"Received the forceSnapshotSync command for standby cluster {}, forced sync id {}\",\n+                clusterId, forceSyncId);\n \n-        /**\n-         * write to the event to the event corfu table\n-         */\n+        // Write to the event to the event corfu table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2978ba75d3a9fe5950bb2ed38ce67e0d34bccefc"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU0OTQ1OnYy", "diffSide": "RIGHT", "path": "infrastructure/proto/log_replication_metadata.proto", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMToxOTo0MFrOHaKJXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjo1Mzo1NlrOHaLiSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTI2Mw==", "bodyText": "this is available in the replication metadata, correct?  Is it required here again?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497191263", "createdAt": "2020-09-30T01:19:40Z", "author": {"login": "pankti-m"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,48 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;\n+  SnapshotSyncInfo snapshotSyncInfo = 5;\n }\n \n-enum ReplicationEventType {\n-  FORCE_SNAPSHOT_SYNC = 0;\n+/*\n+ * Snapshot Sync Info\n+ *\n+ * If replication is in SNAPSHOT sync, this provides details of the\n+ * ongoing snapshot sync. If replication is in LOG ENTRY sync (delta).\n+ * this provides details of the previous SNAPSHOT sync leading up to\n+ * the log entry sync.\n+ */\n+message SnapshotSyncInfo {\n+  enum SnapshotSyncType {\n+    DEFAULT = 0;\n+    FORCED = 1;\n+  }\n+  SnapshotSyncType type = 1;\n+  SyncStatus status = 2;\n+  string snapshotRequestId = 3;\n+  google.protobuf.Timestamp completedTime = 4;\n+  uint64 baseSnapshot = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNDAyNg==", "bodyText": "Yes, it is required to represent the base snapshot version of the latest snapshot sync.\nLog Entry Sync -> Last snapshot sync's data\nSnapshot Sync -> current one's data", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497214026", "createdAt": "2020-09-30T02:53:56Z", "author": {"login": "zhangn49"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,48 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;\n+  SnapshotSyncInfo snapshotSyncInfo = 5;\n }\n \n-enum ReplicationEventType {\n-  FORCE_SNAPSHOT_SYNC = 0;\n+/*\n+ * Snapshot Sync Info\n+ *\n+ * If replication is in SNAPSHOT sync, this provides details of the\n+ * ongoing snapshot sync. If replication is in LOG ENTRY sync (delta).\n+ * this provides details of the previous SNAPSHOT sync leading up to\n+ * the log entry sync.\n+ */\n+message SnapshotSyncInfo {\n+  enum SnapshotSyncType {\n+    DEFAULT = 0;\n+    FORCED = 1;\n+  }\n+  SnapshotSyncType type = 1;\n+  SyncStatus status = 2;\n+  string snapshotRequestId = 3;\n+  google.protobuf.Timestamp completedTime = 4;\n+  uint64 baseSnapshot = 5;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTI2Mw=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU1MTcwOnYy", "diffSide": "RIGHT", "path": "infrastructure/proto/log_replication_metadata.proto", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMToyMDo1NVrOHaKKlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjo1NTo1NVrOHaLkRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTU3NQ==", "bodyText": "what is the difference between Error and Stopped?  it will be good to add in a comment here", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497191575", "createdAt": "2020-09-30T01:20:55Z", "author": {"login": "pankti-m"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,48 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;\n+  SnapshotSyncInfo snapshotSyncInfo = 5;\n }\n \n-enum ReplicationEventType {\n-  FORCE_SNAPSHOT_SYNC = 0;\n+/*\n+ * Snapshot Sync Info\n+ *\n+ * If replication is in SNAPSHOT sync, this provides details of the\n+ * ongoing snapshot sync. If replication is in LOG ENTRY sync (delta).\n+ * this provides details of the previous SNAPSHOT sync leading up to\n+ * the log entry sync.\n+ */\n+message SnapshotSyncInfo {\n+  enum SnapshotSyncType {\n+    DEFAULT = 0;\n+    FORCED = 1;\n+  }\n+  SnapshotSyncType type = 1;\n+  SyncStatus status = 2;\n+  string snapshotRequestId = 3;\n+  google.protobuf.Timestamp completedTime = 4;\n+  uint64 baseSnapshot = 5;\n+}\n+\n+enum SyncStatus {\n+  ONGOING = 0;\n+  COMPLETED = 1;\n+  ERROR = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNDUwOA==", "bodyText": "The error means it is unrecoverable and Stopped is used when state is initialized(not in sync or wait for sync completion)", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497214508", "createdAt": "2020-09-30T02:55:48Z", "author": {"login": "zhangn49"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,48 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;\n+  SnapshotSyncInfo snapshotSyncInfo = 5;\n }\n \n-enum ReplicationEventType {\n-  FORCE_SNAPSHOT_SYNC = 0;\n+/*\n+ * Snapshot Sync Info\n+ *\n+ * If replication is in SNAPSHOT sync, this provides details of the\n+ * ongoing snapshot sync. If replication is in LOG ENTRY sync (delta).\n+ * this provides details of the previous SNAPSHOT sync leading up to\n+ * the log entry sync.\n+ */\n+message SnapshotSyncInfo {\n+  enum SnapshotSyncType {\n+    DEFAULT = 0;\n+    FORCED = 1;\n+  }\n+  SnapshotSyncType type = 1;\n+  SyncStatus status = 2;\n+  string snapshotRequestId = 3;\n+  google.protobuf.Timestamp completedTime = 4;\n+  uint64 baseSnapshot = 5;\n+}\n+\n+enum SyncStatus {\n+  ONGOING = 0;\n+  COMPLETED = 1;\n+  ERROR = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTU3NQ=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNDUzNA==", "bodyText": "Will add comment", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497214534", "createdAt": "2020-09-30T02:55:55Z", "author": {"login": "zhangn49"}, "path": "infrastructure/proto/log_replication_metadata.proto", "diffHunk": "@@ -44,17 +47,48 @@ message ReplicationStatusVal {\n     SNAPSHOT = 0;\n     LOG_ENTRY = 1;\n   }\n-  SyncType type = 3;\n+  SyncType syncType = 3;\n+  SyncStatus status = 4;\n+  SnapshotSyncInfo snapshotSyncInfo = 5;\n }\n \n-enum ReplicationEventType {\n-  FORCE_SNAPSHOT_SYNC = 0;\n+/*\n+ * Snapshot Sync Info\n+ *\n+ * If replication is in SNAPSHOT sync, this provides details of the\n+ * ongoing snapshot sync. If replication is in LOG ENTRY sync (delta).\n+ * this provides details of the previous SNAPSHOT sync leading up to\n+ * the log entry sync.\n+ */\n+message SnapshotSyncInfo {\n+  enum SnapshotSyncType {\n+    DEFAULT = 0;\n+    FORCED = 1;\n+  }\n+  SnapshotSyncType type = 1;\n+  SyncStatus status = 2;\n+  string snapshotRequestId = 3;\n+  google.protobuf.Timestamp completedTime = 4;\n+  uint64 baseSnapshot = 5;\n+}\n+\n+enum SyncStatus {\n+  ONGOING = 0;\n+  COMPLETED = 1;\n+  ERROR = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5MTU3NQ=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU2NzUyOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTozMDoxN1rOHaKT7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjo1NzoxM1rOHaLlXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Mzk2Nw==", "bodyText": "update comment on L208 as force snapshot sync is not started for all clusters", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497193967", "createdAt": "2020-09-30T01:30:17Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -216,7 +215,7 @@ public void enforceSnapshotSync(DiscoveryServiceEvent event) {\n         } else {\n             log.info(\"EnforceSnapshotSync for cluster {}\", standbyRuntime.getRemoteClusterId());\n             standbyRuntime.getSourceManager().stopLogReplication();\n-            standbyRuntime.getSourceManager().startSnapshotSync();\n+            standbyRuntime.getSourceManager().startForcedSnapshotSync(event.getEventId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNDgxMw==", "bodyText": "Done. Thanks.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497214813", "createdAt": "2020-09-30T02:57:13Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationManager.java", "diffHunk": "@@ -216,7 +215,7 @@ public void enforceSnapshotSync(DiscoveryServiceEvent event) {\n         } else {\n             log.info(\"EnforceSnapshotSync for cluster {}\", standbyRuntime.getRemoteClusterId());\n             standbyRuntime.getSourceManager().stopLogReplication();\n-            standbyRuntime.getSourceManager().startSnapshotSync();\n+            standbyRuntime.getSourceManager().startForcedSnapshotSync(event.getEventId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Mzk2Nw=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU2OTkxOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTozMjowMVrOHaKVVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjo1ODozM1rOHaLmZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5NDMyNg==", "bodyText": "remove", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497194326", "createdAt": "2020-09-30T01:32:01Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "diffHunk": "@@ -1,35 +1,41 @@\n package org.corfudb.infrastructure.logreplication.infrastructure;\n \n import lombok.Getter;\n-import lombok.Setter;\n-\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n \n+import java.util.UUID;\n+\n+@Getter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNTA3OQ==", "bodyText": "It is used get its fields, like getType() or getEventId()", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497215079", "createdAt": "2020-09-30T02:58:33Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "diffHunk": "@@ -1,35 +1,41 @@\n package org.corfudb.infrastructure.logreplication.infrastructure;\n \n import lombok.Getter;\n-import lombok.Setter;\n-\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n \n+import java.util.UUID;\n+\n+@Getter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5NDMyNg=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU3ODUwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTozNzoyNFrOHaKaNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzowNDo1N1rOHaLsIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5NTU3NA==", "bodyText": "are we making an assumption that if we are here, the local cluster is active?  It may be good to add a comment for it..", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497195574", "createdAt": "2020-09-30T01:37:24Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "diffHunk": "@@ -1,35 +1,41 @@\n package org.corfudb.infrastructure.logreplication.infrastructure;\n \n import lombok.Getter;\n-import lombok.Setter;\n-\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n \n+import java.util.UUID;\n+\n+@Getter\n public class DiscoveryServiceEvent {\n-    DiscoveryServiceEventType type;\n \n-    @Getter\n-    TopologyConfigurationMsg topologyConfig = null;\n+    private final DiscoveryServiceEventType type;\n+\n+    private TopologyConfigurationMsg topologyConfig = null;\n \n-    @Getter\n-    @Setter\n-    ClusterDescriptor remoteClusterInfo;\n+    private ClusterDescriptor remoteClusterInfo;\n+\n+    private UUID eventId = null;\n \n     public DiscoveryServiceEvent(DiscoveryServiceEventType type) {\n        this.type = type;\n     }\n \n     public DiscoveryServiceEvent(DiscoveryServiceEventType type, String clusterId) {\n         this.type = type;\n-        remoteClusterInfo = new ClusterDescriptor(clusterId, LogReplicationClusterInfo.ClusterRole.STANDBY);\n+        this.remoteClusterInfo = new ClusterDescriptor(clusterId, LogReplicationClusterInfo.ClusterRole.STANDBY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNjU0NA==", "bodyText": "It is legacy code. Removed role.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497216544", "createdAt": "2020-09-30T03:04:57Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/DiscoveryServiceEvent.java", "diffHunk": "@@ -1,35 +1,41 @@\n package org.corfudb.infrastructure.logreplication.infrastructure;\n \n import lombok.Getter;\n-import lombok.Setter;\n-\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo;\n import org.corfudb.infrastructure.logreplication.proto.LogReplicationClusterInfo.TopologyConfigurationMsg;\n \n+import java.util.UUID;\n+\n+@Getter\n public class DiscoveryServiceEvent {\n-    DiscoveryServiceEventType type;\n \n-    @Getter\n-    TopologyConfigurationMsg topologyConfig = null;\n+    private final DiscoveryServiceEventType type;\n+\n+    private TopologyConfigurationMsg topologyConfig = null;\n \n-    @Getter\n-    @Setter\n-    ClusterDescriptor remoteClusterInfo;\n+    private ClusterDescriptor remoteClusterInfo;\n+\n+    private UUID eventId = null;\n \n     public DiscoveryServiceEvent(DiscoveryServiceEventType type) {\n        this.type = type;\n     }\n \n     public DiscoveryServiceEvent(DiscoveryServiceEventType type, String clusterId) {\n         this.type = type;\n-        remoteClusterInfo = new ClusterDescriptor(clusterId, LogReplicationClusterInfo.ClusterRole.STANDBY);\n+        this.remoteClusterInfo = new ClusterDescriptor(clusterId, LogReplicationClusterInfo.ClusterRole.STANDBY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5NTU3NA=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjU4Njg3OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/LogReplicationEventListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTo0MjowNVrOHaKe4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzowNToyMVrOHaLsnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Njc3MQ==", "bodyText": "nit - space after \"clusterId\"", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497196771", "createdAt": "2020-09-30T01:42:05Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/LogReplicationEventListener.java", "diffHunk": "@@ -39,21 +38,26 @@ public void onNext(CorfuStreamEntries results) {\n             log.info(\"LogReplicationEventListener onNext {} will be processed at node {} in the cluster {}\",\n                     results, discoveryService.getLocalNodeDescriptor(), discoveryService.getLocalClusterDescriptor());\n \n-            /**\n-             * If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n-             */\n+\n+            // If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n             for (List<CorfuStreamEntry> entryList : results.getEntries().values()) {\n                 for (CorfuStreamEntry entry : entryList) {\n                     ReplicationEvent event = (ReplicationEvent) entry.getPayload();\n-                    log.info(\"ReplicationEventListener put an event {} to its local discoveryServiceQueue\", event);\n-                    discoveryService.input(new DiscoveryServiceEvent(DiscoveryServiceEvent.DiscoveryServiceEventType.ENFORCE_SNAPSHOT_SYNC, event.getClusterId()));\n+                    log.info(\"ReplicationEventListener received an event with id {}, type {}, cluster id{}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxNjY3MQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497216671", "createdAt": "2020-09-30T03:05:21Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/LogReplicationEventListener.java", "diffHunk": "@@ -39,21 +38,26 @@ public void onNext(CorfuStreamEntries results) {\n             log.info(\"LogReplicationEventListener onNext {} will be processed at node {} in the cluster {}\",\n                     results, discoveryService.getLocalNodeDescriptor(), discoveryService.getLocalClusterDescriptor());\n \n-            /**\n-             * If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n-             */\n+\n+            // If the current node is the leader, it generates a discovery event and put it into the discovery service event queue.\n             for (List<CorfuStreamEntry> entryList : results.getEntries().values()) {\n                 for (CorfuStreamEntry entry : entryList) {\n                     ReplicationEvent event = (ReplicationEvent) entry.getPayload();\n-                    log.info(\"ReplicationEventListener put an event {} to its local discoveryServiceQueue\", event);\n-                    discoveryService.input(new DiscoveryServiceEvent(DiscoveryServiceEvent.DiscoveryServiceEventType.ENFORCE_SNAPSHOT_SYNC, event.getClusterId()));\n+                    log.info(\"ReplicationEventListener received an event with id {}, type {}, cluster id{}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5Njc3MQ=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjYwMjY4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTo1MTowNVrOHaKnug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzoxMjowM1rOHaLy8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTAzNA==", "bodyText": "can you add a comment explaining what this flag does?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497199034", "createdAt": "2020-09-30T01:51:05Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -19,30 +18,38 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import static org.corfudb.runtime.view.ObjectsView.TRANSACTION_STREAM_ID;\n+\n @Slf4j\n public class LogReplicationAckReader {\n-    private LogReplicationMetadataManager metadataManager;\n-    private LogReplicationConfig config;\n-    private CorfuRuntime runtime;\n-    private String remoteClusterId;\n+    private final LogReplicationMetadataManager metadataManager;\n+    private final LogReplicationConfig config;\n+    private final CorfuRuntime runtime;\n+    private final String remoteClusterId;\n+\n     // Log tail when the current snapshot sync started.  We do not need to synchronize access to it because it will not\n     // be read(calculateRemainingEntriesToSend) and written(setBaseSnapshot) concurrently.\n     private long baseSnapshotTimestamp;\n \n+    // Flag for the periodic task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxODI4OQ==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497218289", "createdAt": "2020-09-30T03:12:03Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -19,30 +18,38 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import static org.corfudb.runtime.view.ObjectsView.TRANSACTION_STREAM_ID;\n+\n @Slf4j\n public class LogReplicationAckReader {\n-    private LogReplicationMetadataManager metadataManager;\n-    private LogReplicationConfig config;\n-    private CorfuRuntime runtime;\n-    private String remoteClusterId;\n+    private final LogReplicationMetadataManager metadataManager;\n+    private final LogReplicationConfig config;\n+    private final CorfuRuntime runtime;\n+    private final String remoteClusterId;\n+\n     // Log tail when the current snapshot sync started.  We do not need to synchronize access to it because it will not\n     // be read(calculateRemainingEntriesToSend) and written(setBaseSnapshot) concurrently.\n     private long baseSnapshotTimestamp;\n \n+    // Flag for the periodic task", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTAzNA=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjYxNjE2OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTo1OToxOFrOHaKvkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzoxNTozM1rOHaL2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTA0MQ==", "bodyText": "why do we need this special call?  The getReplicationStatus() already reports the status", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497201041", "createdAt": "2020-09-30T01:59:18Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "diffHunk": "@@ -106,12 +113,14 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n                     UUID newSnapshotSyncId = UUID.randomUUID();\n                     log.debug(\"Starting new snapshot sync after cancellation id={}\", newSnapshotSyncId);\n                     inSnapshotSyncState.setTransitionEventId(newSnapshotSyncId);\n+                    ((InSnapshotSyncState)inSnapshotSyncState).setForcedSnapshotSync(false);\n                     snapshotSender.reset();\n+                    fsm.getAckReader().markSnapshotSyncInfoOngoing(forcedSnapshotSync, transitionEventId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxOTE2Nw==", "bodyText": "There are a few more fields that ackReader is not aware of, like if the snapshot is forced or not.\nAnd the periodic task is triggered every 15 seconds, we might not able to observe some status.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497219167", "createdAt": "2020-09-30T03:15:33Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "diffHunk": "@@ -106,12 +113,14 @@ public LogReplicationState processEvent(LogReplicationEvent event) throws Illega\n                     UUID newSnapshotSyncId = UUID.randomUUID();\n                     log.debug(\"Starting new snapshot sync after cancellation id={}\", newSnapshotSyncId);\n                     inSnapshotSyncState.setTransitionEventId(newSnapshotSyncId);\n+                    ((InSnapshotSyncState)inSnapshotSyncState).setForcedSnapshotSync(false);\n                     snapshotSender.reset();\n+                    fsm.getAckReader().markSnapshotSyncInfoOngoing(forcedSnapshotSync, transitionEventId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTA0MQ=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjYxNjUxOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTo1OToyN1rOHaKvvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMTo1OToyN1rOHaKvvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMTA4Nw==", "bodyText": "same here", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497201087", "createdAt": "2020-09-30T01:59:27Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/InSnapshotSyncState.java", "diffHunk": "@@ -139,6 +148,7 @@ public void onEntry(LogReplicationState from) {\n             // If the transition is to itself, the snapshot sync is continuing, no need to reset the sender\n             if (from != this) {\n                 snapshotSender.reset();\n+                fsm.getAckReader().markSnapshotSyncInfoOngoing(forcedSnapshotSync, transitionEventId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjYyNjQwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/WaitSnapshotApplyState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjowNTo0M1rOHaK1Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzoxNjozNVrOHaL3RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMjQ5NA==", "bodyText": "is forceSnapshotSync guaranteed to be false?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497202494", "createdAt": "2020-09-30T02:05:43Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/WaitSnapshotApplyState.java", "diffHunk": "@@ -73,14 +73,16 @@ public WaitSnapshotApplyState(LogReplicationFSM logReplicationFSM, DataSender da\n     public LogReplicationState processEvent(LogReplicationEvent event) throws IllegalTransitionException {\n         switch (event.getType()) {\n             case SNAPSHOT_SYNC_REQUEST:\n-                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventID(), getTransitionEventId());\n+                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventId(), getTransitionEventId());\n                 LogReplicationState snapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n-                snapshotSyncState.setTransitionEventId(event.getEventID());\n+                snapshotSyncState.setTransitionEventId(event.getEventId());\n+                ((InSnapshotSyncState)snapshotSyncState).setForcedSnapshotSync(event.getMetadata().isForcedSnapshotSync());\n                 return snapshotSyncState;\n             case SYNC_CANCEL:\n                 log.debug(\"Sync has been canceled while waiting for Snapshot Sync {} to complete apply. Restart.\", transitionEventId);\n                 LogReplicationState inSnapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n                 inSnapshotSyncState.setTransitionEventId(UUID.randomUUID());\n+                ((InSnapshotSyncState)inSnapshotSyncState).setForcedSnapshotSync(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxOTM5Nw==", "bodyText": "In the case of SYNC_CANCEL, it will automatically start a new round of snapshot sync, which means it is not forced.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497219397", "createdAt": "2020-09-30T03:16:35Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/fsm/WaitSnapshotApplyState.java", "diffHunk": "@@ -73,14 +73,16 @@ public WaitSnapshotApplyState(LogReplicationFSM logReplicationFSM, DataSender da\n     public LogReplicationState processEvent(LogReplicationEvent event) throws IllegalTransitionException {\n         switch (event.getType()) {\n             case SNAPSHOT_SYNC_REQUEST:\n-                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventID(), getTransitionEventId());\n+                log.info(\"Snapshot Sync requested {} while waiting for {} to complete.\", event.getEventId(), getTransitionEventId());\n                 LogReplicationState snapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n-                snapshotSyncState.setTransitionEventId(event.getEventID());\n+                snapshotSyncState.setTransitionEventId(event.getEventId());\n+                ((InSnapshotSyncState)snapshotSyncState).setForcedSnapshotSync(event.getMetadata().isForcedSnapshotSync());\n                 return snapshotSyncState;\n             case SYNC_CANCEL:\n                 log.debug(\"Sync has been canceled while waiting for Snapshot Sync {} to complete apply. Restart.\", transitionEventId);\n                 LogReplicationState inSnapshotSyncState = fsm.getStates().get(LogReplicationStateType.IN_SNAPSHOT_SYNC);\n                 inSnapshotSyncState.setTransitionEventId(UUID.randomUUID());\n+                ((InSnapshotSyncState)inSnapshotSyncState).setForcedSnapshotSync(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwMjQ5NA=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMjYzOTM0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMjoxMzo0MlrOHaK83g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwMzoxODowMlrOHaL4qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwNDQ0Ng==", "bodyText": "why do we need a special method to mark the sync as complete?  Cant it be inferred from the remainingReplicationEntries?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497204446", "createdAt": "2020-09-30T02:13:42Z", "author": {"login": "pankti-m"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -327,19 +335,61 @@ public void setBaseSnapshot(long baseSnapshotTimestamp) {\n         this.baseSnapshotTimestamp = baseSnapshotTimestamp;\n     }\n \n+    public void markSnapshotSyncInfoCompleted() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxOTc1Mw==", "bodyText": "remainingReplicationEntries is not 100% accurate and will have 0-15s latency to update status. So I am using the FSM transitions to update status.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497219753", "createdAt": "2020-09-30T03:18:02Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -327,19 +335,61 @@ public void setBaseSnapshot(long baseSnapshotTimestamp) {\n         this.baseSnapshotTimestamp = baseSnapshotTimestamp;\n     }\n \n+    public void markSnapshotSyncInfoCompleted() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwNDQ0Ng=="}, "originalCommit": {"oid": "0e6e933b3205d6ca3a6e618f1c0e2f7e732f14d0"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTg4MDkwOnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxODoyOTo0NlrOHaqOvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxODoxMDozNVrOHbVrJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNjkyNQ==", "bodyText": "Since this method throws LogReplicationDiscoveryServiceException, it makes sense to handle the exceptions that might come from calling getLogReplicationMetadataManager().updateLogReplicationEventTable(key, event) in it. Otherwise, the caller might not know how to handle TxAbortedException for example", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497716925", "createdAt": "2020-09-30T18:29:46Z", "author": {"login": "PavelZaytsev"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -752,21 +753,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     @Override\n-    public void forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n+    public UUID forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n         if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n             String errorStr = \"The forceSnapshotSync command is not supported on standby cluster.\";\n             log.error(errorStr);\n             throw new LogReplicationDiscoveryServiceException(errorStr);\n         }\n \n-        log.info(\"Received the forceSnapshotSync command.\");\n+        UUID forceSyncId = UUID.randomUUID();\n+        log.info(\"Received the forceSnapshotSync command for standby cluster {}, forced sync id {}\",\n+                clusterId, forceSyncId);\n \n-        /**\n-         * write to the event to the event corfu table\n-         */\n+        // Write to the event to the event corfu table\n         ReplicationEventKey key = ReplicationEventKey.newBuilder().setKey(System.currentTimeMillis() + \" \"+ clusterId).build();\n-        ReplicationEvent event = ReplicationEvent.newBuilder().setClusterId(clusterId).setType(LogReplicationMetadata.ReplicationEventType.FORCE_SNAPSHOT_SYNC).build();\n+        ReplicationEvent event = ReplicationEvent.newBuilder()\n+                .setClusterId(clusterId)\n+                .setEventId(forceSyncId.toString())\n+                .setType(ReplicationEvent.ReplicationEventType.FORCE_SNAPSHOT_SYNC)\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd06a9c097aaa77fb4cb6a424bcc7a26b916313d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyODcxMQ==", "bodyText": "Yes, will address the metadata manager's TAE handling issue in the next PR.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r498428711", "createdAt": "2020-10-01T18:10:35Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/infrastructure/CorfuReplicationDiscoveryService.java", "diffHunk": "@@ -752,21 +753,26 @@ public void updateTopology(LogReplicationClusterInfo.TopologyConfigurationMsg to\n     }\n \n     @Override\n-    public void forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n+    public UUID forceSnapshotSync(String clusterId) throws LogReplicationDiscoveryServiceException {\n         if (localClusterDescriptor.getRole() == ClusterRole.STANDBY) {\n             String errorStr = \"The forceSnapshotSync command is not supported on standby cluster.\";\n             log.error(errorStr);\n             throw new LogReplicationDiscoveryServiceException(errorStr);\n         }\n \n-        log.info(\"Received the forceSnapshotSync command.\");\n+        UUID forceSyncId = UUID.randomUUID();\n+        log.info(\"Received the forceSnapshotSync command for standby cluster {}, forced sync id {}\",\n+                clusterId, forceSyncId);\n \n-        /**\n-         * write to the event to the event corfu table\n-         */\n+        // Write to the event to the event corfu table\n         ReplicationEventKey key = ReplicationEventKey.newBuilder().setKey(System.currentTimeMillis() + \" \"+ clusterId).build();\n-        ReplicationEvent event = ReplicationEvent.newBuilder().setClusterId(clusterId).setType(LogReplicationMetadata.ReplicationEventType.FORCE_SNAPSHOT_SYNC).build();\n+        ReplicationEvent event = ReplicationEvent.newBuilder()\n+                .setClusterId(clusterId)\n+                .setEventId(forceSyncId.toString())\n+                .setType(ReplicationEvent.ReplicationEventType.FORCE_SNAPSHOT_SYNC)\n+                .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNjkyNQ=="}, "originalCommit": {"oid": "bd06a9c097aaa77fb4cb6a424bcc7a26b916313d"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTk0NTg0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxODo0ODowMlrOHaq21w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxODo0ODowMlrOHaq21w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyNzE5MQ==", "bodyText": "final", "url": "https://github.com/CorfuDB/CorfuDB/pull/2772#discussion_r497727191", "createdAt": "2020-09-30T18:48:02Z", "author": {"login": "PavelZaytsev"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/logreplication/replication/LogReplicationAckReader.java", "diffHunk": "@@ -19,30 +18,39 @@\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import static org.corfudb.runtime.view.ObjectsView.TRANSACTION_STREAM_ID;\n+\n @Slf4j\n public class LogReplicationAckReader {\n-    private LogReplicationMetadataManager metadataManager;\n-    private LogReplicationConfig config;\n-    private CorfuRuntime runtime;\n-    private String remoteClusterId;\n+    private final LogReplicationMetadataManager metadataManager;\n+    private final LogReplicationConfig config;\n+    private final CorfuRuntime runtime;\n+    private final String remoteClusterId;\n+\n     // Log tail when the current snapshot sync started.  We do not need to synchronize access to it because it will not\n     // be read(calculateRemainingEntriesToSend) and written(setBaseSnapshot) concurrently.\n     private long baseSnapshotTimestamp;\n \n+    // Flag for the periodic task. It will protect status table from overriding by the periodic task\n+    // if current replication state is initialized or stopped\n+    @Getter\n+    private AtomicBoolean ongoing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd06a9c097aaa77fb4cb6a424bcc7a26b916313d"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1701, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}