{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3Mjg2MjE4", "number": 2612, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzowMDo0N1rOEO_WpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDowMTo1MFrOERqAPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTUzNTA5OnYy", "diffSide": "LEFT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzowMDo0N1rOGycvDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMToxNTo0MFrOGy9Dng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA==", "bodyText": "This is actually a bug on master, if a multi read encounters a data corruption exception, it will keep timing out. This patches fixes this bug.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r455552780", "createdAt": "2020-07-16T07:00:47Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MTQyMA==", "bodyText": "Why it will keep timing out? Because it does not pass the current read address?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456051420", "createdAt": "2020-07-16T20:15:51Z", "author": {"login": "zhangn49"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3MTk5OQ==", "bodyText": "Yes, the message is invalid without passing a long, so the server will fail every time i tries to respond with that message type. The the client's request will start timing out and retrying.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456071999", "createdAt": "2020-07-16T20:54:34Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3MjkxNw==", "bodyText": "Another issue that makes it hard to debug is exceptions throwing inside the netty pipeline stages are not propagated to the producer of the channel write (i.e. client sending message/server sending a response).", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456072917", "createdAt": "2020-07-16T20:56:21Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3OTM0Mg==", "bodyText": "@Maithem I was helping Chetan debugging a similar issue yesterday where pipeline exceptions were not propagated to producer, failing silently. Eventually I found the problem when waiting on the future returned by channel.writeAndFlush(). So I think in the routers, we need to attach a listener to the future returned by channel.writeAndFlush(). For server's router, the listener can log an error if it fails, on client side, the returned future can be chained with this writeAndFlush future. We can do this in the new RPC project.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456079342", "createdAt": "2020-07-16T21:09:16Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MjMzNA==", "bodyText": "Yep, its annoying.\nThe void promise was apparently done for \"performance\" reasons, but I remember removing it last year and I couldn't see any performance difference.\nWe need to do something like this:\nchannel.writeAndFlush(sendBuf).addListener(res -> {\n            if (!res.isSuccess()) {\n                // fail with unavailable?\n                CompletableFuture<TurboAPI.BaseCommand> resp = pendingRequests.remove(requestId);\n                if (resp != null && !resp.isDone()) {\n                    // res.cause()\n                    resp.completeExceptionally(res.getThrowable());\n                }\n            }\n        });", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r456082334", "createdAt": "2020-07-16T21:15:40Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -326,7 +308,8 @@ public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerCo\n             }\n             r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n         } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1Mjc4MA=="}, "originalCommit": {"oid": "17752408d4c35d689d7e152502be3ace50474299"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTQ4MjQ0OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzo1NTozOVrOG2fZIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjowMjozNFrOG2kAoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MDYyNA==", "bodyText": "Can we use long instead of Long and get rid of the currentRead variable?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459790624", "createdAt": "2020-07-23T23:55:39Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NjI3Mg==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459866272", "createdAt": "2020-07-24T06:02:34Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MDYyNA=="}, "originalCommit": {"oid": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTQ5NDM4OnYy", "diffSide": "RIGHT", "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMDowMTo1MFrOG2ff3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQwMTo1NDozOFrOG3Bicw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MjM0OQ==", "bodyText": "address is primitive long, do we really need currentAddress?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r459792349", "createdAt": "2020-07-24T00:01:50Z", "author": {"login": "WenbinZhu"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;\n+        ILogData logData = dataCache.get(address, cacheable);\n+        if (logData == null) {\n+          rr.put(address, LogData.getEmpty(address));\n+        } else {\n+          rr.put(address, (LogData) logData);\n         }\n+      }\n+      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+    } catch (DataCorruptionException e) {\n+      log.error(\n+          \"Data corruption exception while reading addresses {}\",\n+          msg.getPayload().getAddresses(),\n+          e);\n+      r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentRead));\n     }\n+  }\n \n     @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n     public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n                                  ChannelHandlerContext ctx, IServerRouter r) {\n-        log.trace(\"inspectAddresses: {}\", msg.getPayload().getAddresses());\n+        List<Long> addresses = msg.getPayload().getAddresses();\n+        log.trace(\"inspectAddresses: {}\", addresses);\n         InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n+\n+    long currentAddress = Address.NON_ADDRESS;\n         try {\n-            for (long address : msg.getPayload().getAddresses()) {\n+            for (long address : addresses) {\n+                currentAddress = address;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDM1MDA2Nw==", "bodyText": "Done.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2612#discussion_r460350067", "createdAt": "2020-07-25T01:54:38Z", "author": {"login": "Maithem"}, "path": "infrastructure/src/main/java/org/corfudb/infrastructure/LogUnitServer.java", "diffHunk": "@@ -288,55 +288,46 @@ private void prefixTrim(CorfuPayloadMsg<TrimRequest> msg, ChannelHandlerContext\n                 });\n     }\n \n-    @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n-    public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        long address = msg.getPayload().getAddress();\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddress(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            ILogData logData = dataCache.get(address, cacheable);\n-            if (logData == null) {\n-                rr.put(address, LogData.getEmpty(address));\n-            } else {\n-                rr.put(address, (LogData) logData);\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            log.error(\"Data corruption exception while reading address {}\", address, e);\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(address));\n-        }\n+  @ServerHandler(type = CorfuMsgType.READ_REQUEST)\n+  public void read(CorfuPayloadMsg<ReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n+    boolean cacheable = msg.getPayload().isCacheReadResult();\n+    if (log.isTraceEnabled()) {\n+      log.trace(\"read: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n     }\n \n-    @ServerHandler(type = CorfuMsgType.MULTIPLE_READ_REQUEST)\n-    public void multiRead(CorfuPayloadMsg<MultipleReadRequest> msg, ChannelHandlerContext ctx, IServerRouter r) {\n-        boolean cacheable = msg.getPayload().isCacheReadResult();\n-        log.trace(\"multiRead: {}, cacheable: {}\", msg.getPayload().getAddresses(), cacheable);\n-\n-        ReadResponse rr = new ReadResponse();\n-        try {\n-            for (Long address : msg.getPayload().getAddresses()) {\n-                ILogData logData = dataCache.get(address, cacheable);\n-                if (logData == null) {\n-                    rr.put(address, LogData.getEmpty(address));\n-                } else {\n-                    rr.put(address, (LogData) logData);\n-                }\n-            }\n-            r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n-        } catch (DataCorruptionException e) {\n-            r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.msg());\n+    ReadResponse rr = new ReadResponse();\n+    long currentRead = Address.NON_ADDRESS;\n+    try {\n+      for (Long address : msg.getPayload().getAddresses()) {\n+        currentRead = address;\n+        ILogData logData = dataCache.get(address, cacheable);\n+        if (logData == null) {\n+          rr.put(address, LogData.getEmpty(address));\n+        } else {\n+          rr.put(address, (LogData) logData);\n         }\n+      }\n+      r.sendResponse(ctx, msg, CorfuMsgType.READ_RESPONSE.payloadMsg(rr));\n+    } catch (DataCorruptionException e) {\n+      log.error(\n+          \"Data corruption exception while reading addresses {}\",\n+          msg.getPayload().getAddresses(),\n+          e);\n+      r.sendResponse(ctx, msg, CorfuMsgType.ERROR_DATA_CORRUPTION.payloadMsg(currentRead));\n     }\n+  }\n \n     @ServerHandler(type = CorfuMsgType.INSPECT_ADDRESSES_REQUEST)\n     public void inspectAddresses(CorfuPayloadMsg<InspectAddressesRequest> msg,\n                                  ChannelHandlerContext ctx, IServerRouter r) {\n-        log.trace(\"inspectAddresses: {}\", msg.getPayload().getAddresses());\n+        List<Long> addresses = msg.getPayload().getAddresses();\n+        log.trace(\"inspectAddresses: {}\", addresses);\n         InspectAddressesResponse inspectResponse = new InspectAddressesResponse();\n+\n+    long currentAddress = Address.NON_ADDRESS;\n         try {\n-            for (long address : msg.getPayload().getAddresses()) {\n+            for (long address : addresses) {\n+                currentAddress = address;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc5MjM0OQ=="}, "originalCommit": {"oid": "0d7ab293dec3ecc48854f4e56bee4c0753a9a859"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1837, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}