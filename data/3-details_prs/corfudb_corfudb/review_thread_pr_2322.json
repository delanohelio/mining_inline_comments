{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2MTUyMzY2", "number": 2322, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzo0MDoxNFrODaWMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDoxMzo0N1rODeI12w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4OTUzMTU1OnYy", "diffSide": "RIGHT", "path": "runtime/proto/corfu_store_metadata.proto", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QyMzo0MDoxNFrOFhQKCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDozNDowMFrOFiQmDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMjA0Mg==", "bodyText": "The metadata is for a distributed object, but the path of is local information. Does it make sense to store it in this registry ?", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r370412042", "createdAt": "2020-01-23T23:40:14Z", "author": {"login": "Maithem"}, "path": "runtime/proto/corfu_store_metadata.proto", "diffHunk": "@@ -30,8 +30,12 @@ message TableMetadata {\n     TableName table_name = 1;\n     // True if the CorfuStore is disk based and False if it can be contained in memory.\n     bool disk_based = 2;\n+\n+    // Full path to disk based location if this table is disk based\n+    string disk_based_path = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "787a9603f8047796abf42d73528dc0dc281e6832"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMDI4NQ==", "bodyText": "Technically true, but in practice all distributed clients pass the same path.\nIn any way we require a way to communicate the location of the disk path from the client's table to the checkpointer so the latter can use the exact same path as a prefix, otherwise we risk in IO overload if the disk path points to a separate disk.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r370910285", "createdAt": "2020-01-25T03:11:47Z", "author": {"login": "hisundar"}, "path": "runtime/proto/corfu_store_metadata.proto", "diffHunk": "@@ -30,8 +30,12 @@ message TableMetadata {\n     TableName table_name = 1;\n     // True if the CorfuStore is disk based and False if it can be contained in memory.\n     bool disk_based = 2;\n+\n+    // Full path to disk based location if this table is disk based\n+    string disk_based_path = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMjA0Mg=="}, "originalCommit": {"oid": "787a9603f8047796abf42d73528dc0dc281e6832"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4NjA3MA==", "bodyText": "I see.\nBut what happens if the client and the checkpointer run on the same machine. Wouldn't they both point to the same path?\nSince during open the DB in the destination path is destroyed https://github.com/CorfuDB/CorfuDB/blob/master/runtime/src/main/java/org/corfudb/runtime/collections/PersistedStreamingMap.java#L54 , this will crash one of the clients.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r371086070", "createdAt": "2020-01-27T07:08:24Z", "author": {"login": "Maithem"}, "path": "runtime/proto/corfu_store_metadata.proto", "diffHunk": "@@ -30,8 +30,12 @@ message TableMetadata {\n     TableName table_name = 1;\n     // True if the CorfuStore is disk based and False if it can be contained in memory.\n     bool disk_based = 2;\n+\n+    // Full path to disk based location if this table is disk based\n+    string disk_based_path = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMjA0Mg=="}, "originalCommit": {"oid": "787a9603f8047796abf42d73528dc0dc281e6832"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2Nzc5MQ==", "bodyText": "This path location added in this PR is info-only. It is up to the clients to ensure that they do not pass conflicting paths and open the same table from multiple clients. For example the checkpointer client will suffix the table with a subfolder like _compactor_tablename/ to ensure that it does not conflict. We can at best add a few comments explaining this.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r371467791", "createdAt": "2020-01-27T20:34:00Z", "author": {"login": "hisundar"}, "path": "runtime/proto/corfu_store_metadata.proto", "diffHunk": "@@ -30,8 +30,12 @@ message TableMetadata {\n     TableName table_name = 1;\n     // True if the CorfuStore is disk based and False if it can be contained in memory.\n     bool disk_based = 2;\n+\n+    // Full path to disk based location if this table is disk based\n+    string disk_based_path = 3;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQxMjA0Mg=="}, "originalCommit": {"oid": "787a9603f8047796abf42d73528dc0dc281e6832"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTI4NzMxOnYy", "diffSide": "RIGHT", "path": "test/src/test/java/org/corfudb/integration/CorfuStoreIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDoxMzo0N1rOFnI_0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTozMDo1NVrOFqBWvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4NjE5NQ==", "bodyText": "I know you are just using the provided API, but we really need to clean this interface. Creating a disk back CorfuTable should be as easy as creating an in-memory table.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r376586195", "createdAt": "2020-02-07T20:13:47Z", "author": {"login": "Maithem"}, "path": "test/src/test/java/org/corfudb/integration/CorfuStoreIT.java", "diffHunk": "@@ -232,4 +244,122 @@ public void readDataWithDynamicMessages() throws Exception {\n \n         assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n     }\n+\n+    public Token checkpointAndTrimCorfuStore(CorfuRuntime runtimeC, boolean skipTrim, String tempDiskPath) {\n+\n+        TableRegistry tableRegistry = runtimeC.getTableRegistry();\n+        CorfuTable<CorfuStoreMetadata.TableName,\n+                CorfuRecord<CorfuStoreMetadata.TableDescriptors,\n+                        CorfuStoreMetadata.TableMetadata>>\n+                        tableRegistryCT = tableRegistry.getRegistryTable();\n+\n+        // Save the regular serializer first..\n+        ISerializer protobufSerializer = Serializers.getSerializer(ProtobufSerializer.PROTOBUF_SERIALIZER_CODE);\n+\n+        // Must register dynamicProtobufSerializer *AFTER* the getTableRegistry() call to ensure that\n+        // the serializer does not go back to the regular ProtobufSerializer\n+        ISerializer dynamicProtobufSerializer = new DynamicProtobufSerializer(runtimeC);\n+        Serializers.registerSerializer(dynamicProtobufSerializer);\n+\n+        // First checkpoint the TableRegistry system table\n+        MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter<>();\n+\n+        Token trimToken = new Token(Token.UNINITIALIZED.getEpoch(), Token.UNINITIALIZED.getSequence());\n+        for (CorfuStoreMetadata.TableName tableName : tableRegistry.listTables(null)) {\n+            String fullTableName = TableRegistry.getFullyQualifiedTableName(\n+                    tableName.getNamespace(), tableName.getTableName()\n+                    );\n+            SMRObject.Builder<CorfuTable<CorfuDynamicKey, CorfuDynamicRecord>> corfuTableBuilder = runtimeC.getObjectsView().build()\n+                    .setTypeToken(new TypeToken<CorfuTable<CorfuDynamicKey, CorfuDynamicRecord>>() {})\n+                    .setStreamName(fullTableName)\n+                    .setSerializer(dynamicProtobufSerializer);\n+\n+            // Find out if a table needs to be backed up by disk path to even checkpoint\n+            boolean diskBased = tableRegistryCT.get(tableName).getMetadata().getDiskBased();\n+            if (diskBased) {\n+                final Path persistedCacheLocation = Paths.get(tempDiskPath + tableName.getTableName());\n+                final Options options = new Options().setCreateIfMissing(true);\n+                final Supplier<StreamingMap<CorfuDynamicKey, CorfuDynamicRecord>> mapSupplier = () -> new PersistedStreamingMap<>(\n+                        persistedCacheLocation, options,\n+                        dynamicProtobufSerializer, runtimeC);\n+                corfuTableBuilder.setArguments(mapSupplier, ICorfuVersionPolicy.MONOTONIC);\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c65ee77870dad55d02b35fedbda59c4c173304ab"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNjcxNw==", "bodyText": "I completely agree. The api is super messy right now.", "url": "https://github.com/CorfuDB/CorfuDB/pull/2322#discussion_r379606717", "createdAt": "2020-02-14T19:30:55Z", "author": {"login": "hisundar"}, "path": "test/src/test/java/org/corfudb/integration/CorfuStoreIT.java", "diffHunk": "@@ -232,4 +244,122 @@ public void readDataWithDynamicMessages() throws Exception {\n \n         assertThat(shutdownCorfuServer(corfuServer)).isTrue();\n     }\n+\n+    public Token checkpointAndTrimCorfuStore(CorfuRuntime runtimeC, boolean skipTrim, String tempDiskPath) {\n+\n+        TableRegistry tableRegistry = runtimeC.getTableRegistry();\n+        CorfuTable<CorfuStoreMetadata.TableName,\n+                CorfuRecord<CorfuStoreMetadata.TableDescriptors,\n+                        CorfuStoreMetadata.TableMetadata>>\n+                        tableRegistryCT = tableRegistry.getRegistryTable();\n+\n+        // Save the regular serializer first..\n+        ISerializer protobufSerializer = Serializers.getSerializer(ProtobufSerializer.PROTOBUF_SERIALIZER_CODE);\n+\n+        // Must register dynamicProtobufSerializer *AFTER* the getTableRegistry() call to ensure that\n+        // the serializer does not go back to the regular ProtobufSerializer\n+        ISerializer dynamicProtobufSerializer = new DynamicProtobufSerializer(runtimeC);\n+        Serializers.registerSerializer(dynamicProtobufSerializer);\n+\n+        // First checkpoint the TableRegistry system table\n+        MultiCheckpointWriter<CorfuTable> mcw = new MultiCheckpointWriter<>();\n+\n+        Token trimToken = new Token(Token.UNINITIALIZED.getEpoch(), Token.UNINITIALIZED.getSequence());\n+        for (CorfuStoreMetadata.TableName tableName : tableRegistry.listTables(null)) {\n+            String fullTableName = TableRegistry.getFullyQualifiedTableName(\n+                    tableName.getNamespace(), tableName.getTableName()\n+                    );\n+            SMRObject.Builder<CorfuTable<CorfuDynamicKey, CorfuDynamicRecord>> corfuTableBuilder = runtimeC.getObjectsView().build()\n+                    .setTypeToken(new TypeToken<CorfuTable<CorfuDynamicKey, CorfuDynamicRecord>>() {})\n+                    .setStreamName(fullTableName)\n+                    .setSerializer(dynamicProtobufSerializer);\n+\n+            // Find out if a table needs to be backed up by disk path to even checkpoint\n+            boolean diskBased = tableRegistryCT.get(tableName).getMetadata().getDiskBased();\n+            if (diskBased) {\n+                final Path persistedCacheLocation = Paths.get(tempDiskPath + tableName.getTableName());\n+                final Options options = new Options().setCreateIfMissing(true);\n+                final Supplier<StreamingMap<CorfuDynamicKey, CorfuDynamicRecord>> mapSupplier = () -> new PersistedStreamingMap<>(\n+                        persistedCacheLocation, options,\n+                        dynamicProtobufSerializer, runtimeC);\n+                corfuTableBuilder.setArguments(mapSupplier, ICorfuVersionPolicy.MONOTONIC);\n+            }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU4NjE5NQ=="}, "originalCommit": {"oid": "c65ee77870dad55d02b35fedbda59c4c173304ab"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2056, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}