{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNjY0MDMy", "number": 5066, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozMTowNlrOFIFpiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozNToyNVrOFIFvCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDI1NDgwOnYy", "diffSide": "RIGHT", "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozMTowNlrOIJ0d4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozMTowNlrOIJ0d4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NzcxNQ==", "bodyText": "Nice idea.", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547167715", "createdAt": "2020-12-22T09:31:06Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -119,87 +115,28 @@\n     @Inject\n     private MetricsService metricsService;\n \n-    private final ConcurrentMap<String, ConcurrentMap<String, FaultToleranceMethodContextImpl>> contextByAppNameAndMethodId = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<MethodKey, FaultToleranceMethodContextImpl> contextByMethod = new ConcurrentHashMap<>();\n     private final ConcurrentMap<String, BindableFaultToleranceConfig> configByAppName = new ConcurrentHashMap<>();\n-    private ThreadPoolExecutor asyncExecutorService;\n+    private ExecutorService asyncExecutorService;\n     private ScheduledExecutorService delayExecutorService;\n \n     @PostConstruct\n-    public void postConstruct() {\n+    public void postConstruct() throws NamingException {\n         events.register(this);\n         invocationManager = serviceLocator.getService(InvocationManager.class);\n         requestTracingService = serviceLocator.getService(RequestTracingService.class);\n         config = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n-        delayExecutorService = Executors.newScheduledThreadPool(getMaxDelayPoolSize());\n-        asyncExecutorService = new ThreadPoolExecutor(0, getMaxAsyncPoolSize(), getAsyncPoolKeepAliveInSeconds(),\n-                TimeUnit.SECONDS, new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n-        int interval = getCleanupIntervalInMinutes();\n-        delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, interval, interval, TimeUnit.MINUTES);\n-        if (config != null) {\n-            if (!\"concurrent/__defaultManagedExecutorService\".equals(config.getManagedExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedExecutorService());\n-            }\n-            if (!\"concurrent/__defaultManagedScheduledExecutorService\".equals(config.getManagedScheduledExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedScheduledExecutorService());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Since {@link Map#compute(Object, java.util.function.BiFunction)} locks the key entry for\n-     * {@link ConcurrentHashMap} it is safe to remove the entry in case\n-     * {@link FaultToleranceMethodContextImpl#isExpired(long)} as concurrent call to\n-     * {@link Map#computeIfAbsent(Object, java.util.function.Function)} are going to wait for the completion of\n-     * {@link Map#compute(Object, java.util.function.BiFunction)}.\n-     */\n-    private void cleanMethodContexts() {\n-        final long ttl = TimeUnit.MINUTES.toMillis(1);\n-        int cleaned = 0;\n-        for (Map<String, FaultToleranceMethodContextImpl> appEntry : contextByAppNameAndMethodId.values()) {\n-            for (String key : new HashSet<>(appEntry.keySet())) {\n-                try {\n-                    Object newValue = appEntry.compute(key,\n-                            (k, methodContext) -> methodContext.isExpired(ttl) ? null : methodContext);\n-                    if (newValue == null) {\n-                        cleaned++;\n-                    }\n-                } catch (Exception e) {\n-                    logger.log(Level.WARNING, \"Failed to clean FT method context for \" + key, e);\n-                }\n-            }\n-        }\n-        if (cleaned > 0) {\n-            String allClean = contextByAppNameAndMethodId.isEmpty() ? \".All clean.\" : \".\";\n-            logger.log(Level.INFO, \"Cleaned {0} expired FT method contexts\" + allClean, cleaned);\n-        }\n-    }\n-\n-    private int getMaxDelayPoolSize() {\n-        return config == null ? 20 : parseInt(config.getDelayMaxPoolSize());\n-    }\n-\n-    private int getMaxAsyncPoolSize() {\n-        return config == null ? 2000 : parseInt(config.getAsyncMaxPoolSize());\n-    }\n-\n-    private int getAsyncPoolKeepAliveInSeconds() {\n-        return config == null ? 60 : parseInt(config.getAsyncPoolKeepAliveInSeconds());\n-    }\n-\n-    private int getCleanupIntervalInMinutes() {\n-        return config == null ? 1 : parseInt(config.getCleanupIntervalInMinutes());\n+        InitialContext context = new InitialContext();\n+        asyncExecutorService = (ManagedExecutorService) context.lookup(config.getManagedExecutorService());\n+        delayExecutorService = (ManagedScheduledExecutorService) context.lookup(config.getManagedScheduledExecutorService());\n     }\n \n     @Override\n     public void event(Event<?> event) {\n         if (event.is(Deployment.APPLICATION_UNLOADED)) {\n             ApplicationInfo info = (ApplicationInfo) event.hook();\n-            deregisterApplication(info.getName());\n-            FaultTolerancePolicy.clean();\n+            deregisterApplication(info);\n+            FaultTolerancePolicy.clean(info.getAppClassLoader());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDI2ODkwOnYy", "diffSide": "RIGHT", "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/MethodKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozNToyNVrOIJ0mdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMDozNjoyMVrOIJ2dwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2OTkxMQ==", "bodyText": "I assume you are happy to have this run in parallel threads in worst case as the result will be the same.", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547169911", "createdAt": "2020-12-22T09:35:25Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/MethodKey.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package fish.payara.microprofile.faulttolerance.service;\n+\n+import javax.interceptor.InvocationContext;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+/**\n+ * Identifier of method-related data in Fault Tolerance.\n+ * It is essential that the computed signature is referring to the {@link Method} as defined by the target\n+ * {@link Object} class not its declaring {@link Class} as this could be different when called via an abstract\n+ * {@link Method} implemented or overridden by the target {@link Class}.\n+ *\n+ * Since MP FT 3.0 all instances of a class share same state object for the same method. Or in other words the FT\n+ * context is not specific to an instance but to the annotated class and method.\n+ */\n+final class MethodKey {\n+    final Class<?> targetClass;\n+    final Method method;\n+    private String methodId;\n+\n+    MethodKey(InvocationContext ctx) {\n+        this.targetClass = ctx.getTarget().getClass();\n+        this.method = ctx.getMethod();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        MethodKey methodKey = (MethodKey) o;\n+        return targetClass.equals(methodKey.targetClass) && method.equals(methodKey.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(targetClass, method);\n+    }\n+\n+    String getMethodId() {\n+        if (methodId != null) {\n+            return methodId;\n+        }\n+        StringBuilder idBuilder = new StringBuilder();\n+        idBuilder.append(targetClass.getName()).append('.').append(method.getName());\n+        if (method.getParameterCount() > 0) {\n+            idBuilder.append('(');\n+            for (Class<?> param : method.getParameterTypes()) {\n+                idBuilder.append(param.getName()).append(' ');\n+            }\n+            idBuilder.append(')');\n+        }\n+        methodId = idBuilder.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIwMDQ0OA==", "bodyText": "Yes, that was my thoughts.", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547200448", "createdAt": "2020-12-22T10:36:21Z", "author": {"login": "pdudits"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/MethodKey.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package fish.payara.microprofile.faulttolerance.service;\n+\n+import javax.interceptor.InvocationContext;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+/**\n+ * Identifier of method-related data in Fault Tolerance.\n+ * It is essential that the computed signature is referring to the {@link Method} as defined by the target\n+ * {@link Object} class not its declaring {@link Class} as this could be different when called via an abstract\n+ * {@link Method} implemented or overridden by the target {@link Class}.\n+ *\n+ * Since MP FT 3.0 all instances of a class share same state object for the same method. Or in other words the FT\n+ * context is not specific to an instance but to the annotated class and method.\n+ */\n+final class MethodKey {\n+    final Class<?> targetClass;\n+    final Method method;\n+    private String methodId;\n+\n+    MethodKey(InvocationContext ctx) {\n+        this.targetClass = ctx.getTarget().getClass();\n+        this.method = ctx.getMethod();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        MethodKey methodKey = (MethodKey) o;\n+        return targetClass.equals(methodKey.targetClass) && method.equals(methodKey.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(targetClass, method);\n+    }\n+\n+    String getMethodId() {\n+        if (methodId != null) {\n+            return methodId;\n+        }\n+        StringBuilder idBuilder = new StringBuilder();\n+        idBuilder.append(targetClass.getName()).append('.').append(method.getName());\n+        if (method.getParameterCount() > 0) {\n+            idBuilder.append('(');\n+            for (Class<?> param : method.getParameterTypes()) {\n+                idBuilder.append(param.getName()).append(' ');\n+            }\n+            idBuilder.append(')');\n+        }\n+        methodId = idBuilder.toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2OTkxMQ=="}, "originalCommit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1196, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}