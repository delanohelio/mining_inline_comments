{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5Njk1NjE0", "number": 4534, "title": "APPSERV-55 Addresses causes of FT & Metrics TCK failures", "bodyText": "Background\nBoth FT and Metrics TCK contain tests that are are not stably successful running against Payara.\nIn particular the test experience unexpected timeouts and a breech of the bulkhead limit.\nThe timeouts seem related to overall too slow processing of the tests. Investigations suggest that this is due to lack of a worker actually starting the asynchronous task. The obvious reason would be that the executor service is busy running other tasks and/or that it does not offer the number of threads (and therefore concurrency) expected by the tests.\nSummary\nGoal of this PR is to improve the MicroProfile FT and Metrics implementation so that they pass the TCK stably.\nCauses\nFindings on some potential causes:\n\nexecutor service used to run asynchronous execution did not offer sufficient parallelism and throughput. This is especially important since the TCK tests use @Asynchronous as part of the test program to effectively call the method under test from multiple caller threads and because the executor used so far was also doing other tasks within the server.\nperformance of processing FT semantics was degraded by substantial amount of individual map lookups some of which would create temporary intermediate data structures. Also this unnecessarily increased the surface area for race conditions as there were many paths accessing different aspects of the FT state for the same annotated method which were made thread-safe at the finest possible level of granularity.\nprocessing of bulkhead semantics was hard to reason about because of the way it nested and had to use try-finally blocks.\nMetricRegistry was not thread-safe. The get or create semantics would not be atomic, that is a single point in execution would determine thread-safe and correctly for all concurrent threads if the lookup was a get or a create and which thread would end up creating the instance that should be received by others. Also there were some minor issues with Metadata validation edge cases and the thread-safe consistency between Metrics and Metadata.\nTHE race condition causing breaching of the bulkhead was introduced by use of the InvocationManager to get current application name which become part of the key to lookup the state for the FT annotated method. It is not thread-safe (even though it really should be). An internal issue is opened to address the race condition itself.\n\nImprovements\n\nthe ExecutorService that runs asynchronous execution is exclusive and tuned towards a high throughput for many short living tasks. This is given by using a ThreadPoolExecutor (same as returned by Executors.newCachedThreadPool()) which dynamically scales the number of threads in the pool between 0 and some maximum depending on demand for running tasks. The maximum is now configured via asadmin commands. Changes are applied directly.\nthe ScheduledExecutorService to delay execution and detect timeouts is now equally exclusive making sure that this executor is not busy with long running tasks scheduled by other sources.\nThe default pool size is 20. Changes to the size require a restart as the scheduler does not support changes after creation.\nTHE race condition caused by use of InvocationManager is circumvented by not using it any longer. Instead the state for each method is solely identified by an identifier derived from its signature and target object. No longer needed method state is disposed using a cleanup thread. The cleanup is scheduled using the delay scheduler. This is fine as the cleanup is equally a very fast task with little actual work as identifying a no longer needed state object can be done by reading a counter and comparing a timestamp. Also this will always only be a single task. Cleanup runs once every minute. This has the benefit of getting rid of outdated state more aggressively then before where all state would always exist until the application would be undeployed.\nThe organisation of FT state was simplified a lot from multiple maps with several lookups (with lazy creation) per method during processing to a single state object for each method that is created at the beginning of an invocation and is effectively immutable during the execution. This both reduced surface area for race conditions and contributes positive to less thread contention and faster execution. It also is significantly easier to understand and follow when reading the code.\nThe FT bulkhead stage was re-implemented using a completely different approach. Originally done to exclude the somewhat hard to reason about semaphore based solution as the origin of the race condition causing TCK failures. While we now know that the semaphore based implementation was most likely not source of errors I kept the new solution because it is more elegant and easy to reason about regarding its correctness - of limiting threads to a certain number. It does so by treating the bulkhead as if it was a fairground ride with a certain maximum capacity which include both the people on the ride and those queuing. One counter counts people as they enter and exit the ride \"area\". Then a FIFO queue tracks people on the ride and the queuing people are waiting to get into this queue representing the ride. The big advantage of this way of counting and waiting is that it is the very same logic for both styles of bulkheads just that the semaphore style (spec name) has a waiting queue length of zero. So anyone not fitting on the ride would immediately give up.\nThe MetricRegistryImpl internal organisation of data was revised so that lookups and creation is atomic and thread-safe while also keeping Metadata and Metrics consistent with each other. To ensure correctness of behaviour new tests were added. As those changes meant that some of the read-only collection accessor methods would need to compute the returned collections the usage of such methods was avoided as far as possible and replaced with direct lookup methods. As the registry lacks methods for key based lookup in its API this would done via service which internally has access to additional methods of the implementation class. A request  eclipse/microprofile-metrics#543 has been made (and received positive) to FT metrics to improve the MetricRegistry API so it offers key based access.\n\nTests\nDuring the investigation a whole range of unit tests testing the correctness of the bulkhead in concurrent scenarios were added. These were not able to find problems as the race condition was outside the FT logic. When InvocationManager was returning wrong app name it would lead to creation of more then one state object for the same method allow twice as much threads in a bulkhead.\nThe revised MetricRegistryImpl got covered 78%. This should cover every possible illegal case and most of the possible legal cases. These do not check thread-safety but correctness of behaviour.\nTests Performed\nRunning the FT TCK 2.0. tck-suite2.0-stable.xml is successful. tck-suite2.0.xml can fail on BulkheadMetricTest methods with a java.util.NoSuchElementException: No value present. This is from getBulkheadConcurrentExecutions().get() on an empty Optional which should have hold the number of concurrent executions from the gauge provided by the bulkhead. As far as I can tell this is a race condition in the tests and I suggest to ignore those tests for now and hope for TCK improvements. When run individually they often succeed so the general behaviour is fine.\nAlso there is still a change to get the odd Work is not being done simultaneously enough error. Nothing we can do about that except giving it more threads and a bigger machine to run on. Again we have to hope on TCK improvements which are discussed in FT group in regards to this.\nSide note: TCK execution time went down from 20isch minutes to about 7 on my laptop. \ud83c\udf89\nThe changed asadmin commands where tested manually.\nasadmin get-fault-tolerance-configuration\nasadmin set-fault-tolerance-configuration --async-max-pool-size=2000\n\nThe cleanup of FT state can be verified from logs. After running FT TCK there should appear messages like\n\nCleaned 55 expired FT method contexts\n\nafter a while (runs once per minute)\nLogging\nThe server will now print a log statement on INFO level each time a new FT method state is created, an example:\n\nCreating FT method context for 1b75bfbc@org.eclipse.microprofile.fault.tolerance.tck.interceptor.xmlInterceptorEnabling.InterceptorComponent$Proxy$_$$_WeldSubclass.asyncGetString\n\nand a summary entry, each time such objects are cleaned, for example:\n\nCleaned 10 expired FT method contexts\n\nI decided that these would be good on INFO level as they would not occur too frequent and help as a basis of and FT related problem analysis done \"post-mortem\".\nAlso adds a warning in case configuration had a non-default value for the outdated configuration of managed executor names.", "createdAt": "2020-02-25T16:57:03Z", "url": "https://github.com/payara/Payara/pull/4534", "merged": true, "mergeCommit": {"oid": "119bd2b6f1f01bdc45ba0388f4a0541ab165e805"}, "closed": true, "closedAt": "2020-03-06T07:36:00Z", "author": {"login": "jbee"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHuS_uAH2gAyMzc5Njk1NjE0OmNhNGMwZmI2YTYxNDU1NmI5NjU3NTA0ZmIzNDU1NDIxMTRkN2EyY2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKtsqPAFqTM2OTY5NTk2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ca4c0fb6a614556b9657504fb345542114d7a2cc", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/ca4c0fb6a614556b9657504fb345542114d7a2cc", "committedDate": "2020-02-25T08:59:56Z", "message": "APPSERV-55 more detailed bulkhead tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37905230f89e46721b7174e8ea024b4a13940083", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/37905230f89e46721b7174e8ea024b4a13940083", "committedDate": "2020-02-25T10:35:21Z", "message": "APPSERV-55 more tests for exception cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2154a9cce3c6f0e5b713e8976da9bb37e4a88fee", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/2154a9cce3c6f0e5b713e8976da9bb37e4a88fee", "committedDate": "2020-02-25T11:53:43Z", "message": "APPSERV-55 checks method result propagation, adds first converted TCK test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d438ec0543c11b08fe9cc3dd26dec8948dcf7fe4", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/d438ec0543c11b08fe9cc3dd26dec8948dcf7fe4", "committedDate": "2020-02-25T16:54:01Z", "message": "APPSERV-55 synchronisation via single map - fixes remove semantics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1492ca7374e31ddf3b42be35cd1e3f55170a23f5", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/1492ca7374e31ddf3b42be35cd1e3f55170a23f5", "committedDate": "2020-02-26T12:54:28Z", "message": "APPSERV-55 adds tests (and fixes) for MetricRegistryImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "589c7adc7afef848e38b1b45ed39fae4ac27750f", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/589c7adc7afef848e38b1b45ed39fae4ac27750f", "committedDate": "2020-02-26T13:00:45Z", "message": "APPSERV-55 updates copyright headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef0b70c5a9d65f508fbc4702b9a7e67038e0820a", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/ef0b70c5a9d65f508fbc4702b9a7e67038e0820a", "committedDate": "2020-02-26T16:41:49Z", "message": "APPSERV-55 changes metric access to direct access by ID (performance)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6022b3bd11a5b2f468a0118d3d2d96568021488", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/d6022b3bd11a5b2f468a0118d3d2d96568021488", "committedDate": "2020-02-26T17:20:28Z", "message": "APPSERV-55 fixes FT Gauge linking (when Gauge already exists)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2064c40f89e03fa0045626e24b1bd57069ebaa95", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/2064c40f89e03fa0045626e24b1bd57069ebaa95", "committedDate": "2020-02-27T10:22:21Z", "message": "APPSERV-55 only create a bound FT metrics implementation per method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aea1ef19b757e0e37c8c8500817ae1377b564af9", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/aea1ef19b757e0e37c8c8500817ae1377b564af9", "committedDate": "2020-02-27T10:23:05Z", "message": "Merge branch 'APPSERV-55-bulkhead-race' into APPSERV-55-metrics-race"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3055c0ed0701b9bf33c85bd6592e042f086cd874", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/3055c0ed0701b9bf33c85bd6592e042f086cd874", "committedDate": "2020-02-27T12:12:32Z", "message": "APPSERV-55 adds more converted TCK tests for Bulkhead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b67581bf381e753e6ce20f9fe5c891e8b6cf6b82", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/b67581bf381e753e6ce20f9fe5c891e8b6cf6b82", "committedDate": "2020-02-27T13:56:19Z", "message": "APPSERV-55 improves bulkhead concurrency unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1OTkxMDk0", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-365991094", "createdAt": "2020-02-27T20:55:23Z", "commit": {"oid": "2064c40f89e03fa0045626e24b1bd57069ebaa95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDo1NToyNFrOFvg34A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMDo1NToyNFrOFvg34A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2NTk4NA==", "bodyText": "How about using an Optional here?", "url": "https://github.com/payara/Payara/pull/4534#discussion_r385365984", "createdAt": "2020-02-27T20:55:24Z", "author": {"login": "svendiedrichsen"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -200,9 +205,17 @@ public FaultToleranceConfig getConfig(InvocationContext context, Stereotypes ste\n \n     @Override\n     public FaultToleranceMetrics getMetrics(InvocationContext context) {\n+\n         FaultToleranceApplicationState appState = getApplicationState(getApplicationContext(context));\n-        return appState.getMetrics().updateAndGet(\n-                metrics -> metrics != null ? metrics : new BindableFaultToleranceMetrics()).bindTo(context);\n+        return appState.getMetrics(this::getApplicationMetricRegistry, FaultToleranceUtils.getCanonicalMethodName(context));\n+    }\n+\n+    private MetricRegistry getApplicationMetricRegistry() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2064c40f89e03fa0045626e24b1bd57069ebaa95"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5549c32179971aff23e4bce929108b7467fded4c", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/5549c32179971aff23e4bce929108b7467fded4c", "committedDate": "2020-02-28T11:02:15Z", "message": "APPSERV-55 single context binding per FT method invocation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b09c35f3d58f3c36f97d20e12d034199d4d1b6a", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/2b09c35f3d58f3c36f97d20e12d034199d4d1b6a", "committedDate": "2020-03-02T09:56:36Z", "message": "APPSERV-55 implements Bulkhead in a more obvious correct way"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25e54db87f1b26fd39d387b03b1d21989044a37e", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/25e54db87f1b26fd39d387b03b1d21989044a37e", "committedDate": "2020-03-02T11:57:49Z", "message": "APPSERV-55 adds more tests for bulkhead without queue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "360033ca0b46f55954e658cc767d9ba3aaab4835", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/360033ca0b46f55954e658cc767d9ba3aaab4835", "committedDate": "2020-03-02T12:47:58Z", "message": "APPSERV-55 better testing for BulkheadException in case of queue and running space exceeded"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94553e21e62e4b797d1eeb0655dc09939da9d584", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/94553e21e62e4b797d1eeb0655dc09939da9d584", "committedDate": "2020-03-02T16:23:04Z", "message": "APPSERV-55 simpifies the map holding FT state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5d28ac8ca547bf714b443ea93a3decf576392c6", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/c5d28ac8ca547bf714b443ea93a3decf576392c6", "committedDate": "2020-03-03T08:43:57Z", "message": "APPSERV-55 fixes metrics with different tags wrongly colliding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d14ace50c80f741c0c159e87cb5d53ff953e3d0", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/0d14ace50c80f741c0c159e87cb5d53ff953e3d0", "committedDate": "2020-03-03T09:02:21Z", "message": "APPSERV-55 fixes JMX metrics Metadata reuse detection by implementing equals and hashCode"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3ODAzMTE3", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-367803117", "createdAt": "2020-03-03T09:06:04Z", "commit": {"oid": "0d14ace50c80f741c0c159e87cb5d53ff953e3d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTowNjowNFrOFw9Tyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTowNjowNFrOFw9Tyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg4MDQ1OQ==", "bodyText": "NB. Both methods are copied straight from DefaultMetadata so they follow the same logic. This is needed because the registry checks for illegal reuse comparing new and existing Metadata with equals. Not having it implemented fails the test and considers them not equal and therefore illegal for reuse. It is beyond me how this did not pop up earlier.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r386880459", "createdAt": "2020-03-03T09:06:04Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/metrics/src/main/java/fish/payara/microprofile/metrics/jmx/MBeanMetadata.java", "diffHunk": "@@ -259,16 +233,43 @@ public MetricType getTypeRaw() {\n     public boolean isReusable() {\n         return reusable;\n     }\n-    \n+\n     public void setTags(List<XmlTag> tags) {\n         this.tags = tags;\n     }\n-    \n+\n     public void addTags(List<XmlTag> tags) {\n         if (this.tags == null) {\n             this.tags = new ArrayList<>();\n         }\n         this.tags.addAll(tags);\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d14ace50c80f741c0c159e87cb5d53ff953e3d0"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3ODAzNTQ2", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-367803546", "createdAt": "2020-03-03T09:06:44Z", "commit": {"oid": "0d14ace50c80f741c0c159e87cb5d53ff953e3d0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTowNjo0NVrOFw9VQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwOTowNjo0NVrOFw9VQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg4MDgzMw==", "bodyText": "NB. getNames() is a view, whereas getMetadata() is computed collection, therefore the change.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r386880833", "createdAt": "2020-03-03T09:06:45Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/metrics/src/main/java/fish/payara/microprofile/metrics/jmx/MBeanMetadataHelper.java", "diffHunk": "@@ -88,7 +88,7 @@\n     public List<MBeanMetadata> registerMetadata(MetricRegistry metricRegistry,\n             List<MBeanMetadata> metadataList, boolean isRetry) {\n \n-        if (!metricRegistry.getMetadata().isEmpty() && !isRetry) {\n+        if (!metricRegistry.getNames().isEmpty() && !isRetry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d14ace50c80f741c0c159e87cb5d53ff953e3d0"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "799e60007ad097cabe2c200573c9b71fd3da8f37", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/799e60007ad097cabe2c200573c9b71fd3da8f37", "committedDate": "2020-03-03T09:57:56Z", "message": "APPSERV-55 updates/adds copyright header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bae292992e60bce3057b2ed91e81af0e0f28670", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/3bae292992e60bce3057b2ed91e81af0e0f28670", "committedDate": "2020-03-03T13:13:02Z", "message": "APPSERV-55 changes FT service config from executor names to max pool sizes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e37c6cbb3f5d9fc5ea1720d2eb1747dc522c138", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/4e37c6cbb3f5d9fc5ea1720d2eb1747dc522c138", "committedDate": "2020-03-03T14:22:16Z", "message": "APPSERV-55 binds policy at start of FT invocation and logs a warning in case FT bulkhead would be breeched"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8316f42a27f1113d3bf2394bcc8b5ae525ad9fd2", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/8316f42a27f1113d3bf2394bcc8b5ae525ad9fd2", "committedDate": "2020-03-04T08:42:17Z", "message": "APPSERV-55 fixes race condition in FT due to race condition in InvocationManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/a1965574b6c1f5eda1d95397631df25f7a3672e0", "committedDate": "2020-03-04T10:12:11Z", "message": "APPSERV-55 fallback on disabled metrics if MetricRegistry cannot be resolved"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzQwNzUw", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-368740750", "createdAt": "2020-03-04T12:36:01Z", "commit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjozNjowMlrOFxrihA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxMjozNjowMlrOFxrihA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzNzg5Mg==", "bodyText": "NB. Makes sure multiple calls to the supplier function always result in the same config instance.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387637892", "createdAt": "2020-03-04T12:36:02Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/cdi/FaultToleranceInterceptor.java", "diffHunk": "@@ -74,9 +77,12 @@ public Object intercept(InvocationContext context) throws Exception {\n         try {\n             FaultToleranceService env =\n                     Globals.getDefaultBaseServiceLocator().getService(FaultToleranceService.class);\n-            FaultTolerancePolicy policy = FaultTolerancePolicy.get(context, () -> env.getConfig(context, this));\n+            AtomicReference<FaultToleranceConfig> lazyConfig = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjM4Nzg5", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-368638789", "createdAt": "2020-03-04T09:55:03Z", "commit": {"oid": "8316f42a27f1113d3bf2394bcc8b5ae525ad9fd2"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwOTo1NTowM1rOFxmoRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQxNDozODo0MVrOFxvytg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU1NzQ0NA==", "bodyText": "It would probably be nicer to deprecate these rather than immediately ripping them out.\nThere's an obsolete attribute for the Param annotation which:\n\nproduce warnings when used in asadmin, are ignored, and are not included in the command usage.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387557444", "createdAt": "2020-03-04T09:55:03Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/admin/SetFaultToleranceConfigurationCommand.java", "diffHunk": "@@ -74,42 +75,40 @@\n             description = \"Sets the Fault Tolerance Configuration\")\n })\n public class SetFaultToleranceConfigurationCommand implements AdminCommand {\n-    \n+\n     private static final Logger logger = Logger.getLogger(SetFaultToleranceConfigurationCommand.class.getName());\n-    \n+\n     @Inject\n     private Target targetUtil;\n-    \n-    @Param(optional = true, alias = \"managedexecutorservicename\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8316f42a27f1113d3bf2394bcc8b5ae525ad9fd2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2MzI3MA==", "bodyText": "The most minor of gripes - but Asynch triggers me \ud83d\ude06\nI assume you're trying to mirror the class name in the TCK, but I can't help but read it as cinch rather than sink (closest homophones).", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387563270", "createdAt": "2020-03-04T10:05:15Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/test/java/fish/payara/microprofile/faulttolerance/policy/BulkheadTckAsynchRetryTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.faulttolerance.policy;\n+\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+\n+import org.eclipse.microprofile.faulttolerance.Asynchronous;\n+import org.eclipse.microprofile.faulttolerance.Bulkhead;\n+import org.eclipse.microprofile.faulttolerance.Retry;\n+import org.eclipse.microprofile.faulttolerance.exceptions.BulkheadException;\n+import org.junit.Test;\n+\n+/**\n+ * Runs test similar to {@code org.eclipse.microprofile.fault.tolerance.tck.bulkhead.BulkheadAsynchRetryTest} as JUnit\n+ * tests.\n+ * \n+ * Uses the same test method names and tries the duplicate the test as good as possible on the\n+ * {@link FaultTolerancePolicy} level. For many identifiers the terminology of the TCK test is used to make them easier\n+ * to compare.\n+ */\n+public class BulkheadTckAsynchRetryTest extends AbstractBulkheadTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8316f42a27f1113d3bf2394bcc8b5ae525ad9fd2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMTkwNw==", "bodyText": "See comments on deprecating rather than removing.\nWe might want to leave this for now so that it can still be accessed via get/set commands if necessary.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387631907", "createdAt": "2020-03-04T12:23:30Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/FaultToleranceServiceConfiguration.java", "diffHunk": "@@ -39,22 +39,38 @@\n  */\n package fish.payara.microprofile.faulttolerance;\n \n+import javax.validation.constraints.Min;\n+\n import org.glassfish.api.admin.config.ConfigExtension;\n import org.jvnet.hk2.config.Attribute;\n import org.jvnet.hk2.config.Configured;\n \n /**\n  * Configuration for the Fault Tolerance Service.\n- * @author Andrew Pielage\n+ *\n+ * @author Andrew Pielage (initial)\n+ * @author Jan Bernitt (change to pool size)\n  */\n @Configured(name = \"microprofile-fault-tolerance-configuration\")\n public interface FaultToleranceServiceConfiguration extends ConfigExtension {\n \n-    @Attribute(defaultValue = \"concurrent/__defaultManagedExecutorService\", dataType = String.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzNzE4Mw==", "bodyText": "Another reason for leaving this in is the potential for domain validation exceptions on an upgrade - ottomh I can't remember what happens if there's an attribute in the domain.xml which isn't mapped to a config class, but I have a feeling it might throw an error.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387637183", "createdAt": "2020-03-04T12:34:26Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/FaultToleranceServiceConfiguration.java", "diffHunk": "@@ -39,22 +39,38 @@\n  */\n package fish.payara.microprofile.faulttolerance;\n \n+import javax.validation.constraints.Min;\n+\n import org.glassfish.api.admin.config.ConfigExtension;\n import org.jvnet.hk2.config.Attribute;\n import org.jvnet.hk2.config.Configured;\n \n /**\n  * Configuration for the Fault Tolerance Service.\n- * @author Andrew Pielage\n+ *\n+ * @author Andrew Pielage (initial)\n+ * @author Jan Bernitt (change to pool size)\n  */\n @Configured(name = \"microprofile-fault-tolerance-configuration\")\n public interface FaultToleranceServiceConfiguration extends ConfigExtension {\n \n-    @Attribute(defaultValue = \"concurrent/__defaultManagedExecutorService\", dataType = String.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYzMTkwNw=="}, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzY5OTM5OQ==", "bodyText": "Only just noticed this since apparently it's already there in the CircuitBreakerState for some method names: SuccessFul shouldn't have a capital 'F'\no((>\u03c9< ))o", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387699399", "createdAt": "2020-03-04T14:26:20Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -148,112 +171,63 @@ public void event(Event<?> event) {\n     }\n \n     @Override\n+    @MonitoringData(ns = \"ft\")\n     public void collect(MonitoringDataCollector collector) {\n-        MonitoringDataCollector ftCollector = collector.in(\"ft\");\n-        for (Entry<String, FaultToleranceApplicationState> appStateEntry : stateByApplication.entrySet()) {\n-            String appName = appStateEntry.getKey();\n-            FaultToleranceApplicationState appState = appStateEntry.getValue();\n-            collectMethodState(ftCollector, appName, \"execution\",\n-                    appState.getBulkheadExecutionSemaphores(), FaultToleranceServiceImpl::collectBulkheadSemaphores);\n-            collectMethodState(ftCollector, appName, \"queue\",\n-                    appState.getBulkheadExecutionQueueSemaphores(), FaultToleranceServiceImpl::collectBulkheadSemaphores);\n-            collectMethodState(ftCollector, appName, \"circuit-breaker\",\n-                    appState.getCircuitBreakerStates(), FaultToleranceServiceImpl::collectCircuitBreakerState);\n-\n+        for (Entry<String, FaultToleranceMethodContextImpl> methodValue : methodByTargetObjectAndName.entrySet()) {\n+            String group = methodValue.getKey();\n+            MonitoringDataCollector methodCollector = collector.group(group);\n+            FaultToleranceMethodContext context = methodValue.getValue();\n+            BlockingQueue<Thread> concurrentExecutions = context.getConcurrentExecutions(-1);\n+            if (concurrentExecutions != null) {\n+                collectBulkheadSemaphores(methodCollector, concurrentExecutions);\n+                collectBulkheadSemaphores(methodCollector, concurrentExecutions, context.getQueuingOrRunningPopulation());\n+            }\n+            collectCircuitBreakerState(methodCollector, context.getState(-1));\n         }\n     }\n \n-    private static <V> void collectMethodState(MonitoringDataCollector collector, String appName, String type,\n-            Map<Object, Map<String, V>> entries, BiConsumer<MonitoringDataCollector, V> collect) {\n-        for (Entry<Object, Map<String, V>> entry : entries.entrySet()) {\n-            Object target = entry.getKey();\n-            String targetValue = System.identityHashCode(target) + \"@\" + target.getClass().getSimpleName();\n-            for (Entry<String, V> methodValue : entry.getValue().entrySet()) {\n-                String group = appName + \"-\" + type + \"-\" + targetValue + \"-\" + methodValue.getKey();\n-                collect.accept(collector.group(group), methodValue.getValue());\n-            }\n-        }\n+    private static void collectBulkheadSemaphores(MonitoringDataCollector collector,\n+            BlockingQueue<Thread> concurrentExecutions) {\n+        collector\n+            .collect(\"RemainingConcurrentExecutionsCapacity\", concurrentExecutions.remainingCapacity())\n+            .collect(\"ConcurrentExecutions\", concurrentExecutions.size());\n     }\n \n-    private static void collectBulkheadSemaphores(MonitoringDataCollector collector, BulkheadSemaphore semaphore) {\n+    private static void collectBulkheadSemaphores(MonitoringDataCollector collector,\n+            BlockingQueue<Thread> concurrentExecutions, AtomicInteger queuingOrRunningPopulation) {\n         collector\n-            .collect(\"availablePermits\", semaphore.availablePermits())\n-            .collect(\"acquiredPermits\", semaphore.acquiredPermits());\n+            .collect(\"WaitingQueuePopulation\", queuingOrRunningPopulation.get() - concurrentExecutions.size());\n     }\n \n     private static void collectCircuitBreakerState(MonitoringDataCollector collector, CircuitBreakerState state) {\n+        if (state == null) {\n+            return;\n+        }\n         collector\n-            .collect(\"halfOpenSuccessFul\", state.getHalfOpenSuccessFulResultCounter())\n-            .collect(\"state\", state.getCircuitState().name().charAt(0));\n+            .collect(\"circuitBreakerHalfOpenSuccessFul\", state.getHalfOpenSuccessFulResultCounter())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzA2NQ==", "bodyText": "Just some food for thought: do we want the timeout and core pool size to be configurable? Even as hidden parameters of the set command so the uninitiated don't use them.\nProbably fine as is but just planting the seed of thought (and/or doubt) \ud83d\ude42", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387707065", "createdAt": "2020-03-04T14:37:54Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -122,20 +113,52 @@\n     @Inject\n     private Events events;\n \n-    private final Map<String, FaultToleranceApplicationState> stateByApplication = new ConcurrentHashMap<>();\n-    private ManagedScheduledExecutorService defaultScheduledExecutorService;\n-    private ManagedExecutorService defaultExecutorService;\n+    @Inject\n+    private MetricsService metricsService;\n+\n+    private final ConcurrentMap<String, FaultToleranceMethodContextImpl> methodByTargetObjectAndName = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, BindableFaultToleranceConfig> configByApplication = new ConcurrentHashMap<>();\n+    private ThreadPoolExecutor asyncExecutorService;\n+    private ScheduledExecutorService delayExecutorService;\n \n     @PostConstruct\n-    public void postConstruct() throws NamingException {\n+    public void postConstruct() {\n         events.register(this);\n-        serviceConfig = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n         invocationManager = serviceLocator.getService(InvocationManager.class);\n         requestTracingService = serviceLocator.getService(RequestTracingService.class);\n-        InitialContext context = new InitialContext();\n-        defaultExecutorService = (ManagedExecutorService) context.lookup(\"java:comp/DefaultManagedExecutorService\");\n-        defaultScheduledExecutorService = (ManagedScheduledExecutorService) context\n-                .lookup(\"java:comp/DefaultManagedScheduledExecutorService\");\n+        config = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n+        delayExecutorService = Executors.newScheduledThreadPool(getMaxDelayPoolSize());\n+        asyncExecutorService = new ThreadPoolExecutor(0, getMaxAsyncPoolSize(), 60L, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcwNzU3NA==", "bodyText": "See note above - do we want to have some hidden configuration knobs we can turn if this rate isn't ideal?", "url": "https://github.com/payara/Payara/pull/4534#discussion_r387707574", "createdAt": "2020-03-04T14:38:41Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -122,20 +113,52 @@\n     @Inject\n     private Events events;\n \n-    private final Map<String, FaultToleranceApplicationState> stateByApplication = new ConcurrentHashMap<>();\n-    private ManagedScheduledExecutorService defaultScheduledExecutorService;\n-    private ManagedExecutorService defaultExecutorService;\n+    @Inject\n+    private MetricsService metricsService;\n+\n+    private final ConcurrentMap<String, FaultToleranceMethodContextImpl> methodByTargetObjectAndName = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<String, BindableFaultToleranceConfig> configByApplication = new ConcurrentHashMap<>();\n+    private ThreadPoolExecutor asyncExecutorService;\n+    private ScheduledExecutorService delayExecutorService;\n \n     @PostConstruct\n-    public void postConstruct() throws NamingException {\n+    public void postConstruct() {\n         events.register(this);\n-        serviceConfig = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n         invocationManager = serviceLocator.getService(InvocationManager.class);\n         requestTracingService = serviceLocator.getService(RequestTracingService.class);\n-        InitialContext context = new InitialContext();\n-        defaultExecutorService = (ManagedExecutorService) context.lookup(\"java:comp/DefaultManagedExecutorService\");\n-        defaultScheduledExecutorService = (ManagedScheduledExecutorService) context\n-                .lookup(\"java:comp/DefaultManagedScheduledExecutorService\");\n+        config = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n+        delayExecutorService = Executors.newScheduledThreadPool(getMaxDelayPoolSize());\n+        asyncExecutorService = new ThreadPoolExecutor(0, getMaxAsyncPoolSize(), 60L, TimeUnit.SECONDS,\n+                new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n+        delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, 1L, 1L, TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1965574b6c1f5eda1d95397631df25f7a3672e0"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "742fe9aa78f4b804fb4f6b8c22cb85727ac86ea4", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/742fe9aa78f4b804fb4f6b8c22cb85727ac86ea4", "committedDate": "2020-03-04T16:17:23Z", "message": "APPSERV-55 addressed Andrew's comment and fixed expired detection for FT state cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf511d83cafc8df4d1ee826c78bd044b26901e0", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/abf511d83cafc8df4d1ee826c78bd044b26901e0", "committedDate": "2020-03-05T09:52:46Z", "message": "APPSERV-55 adds warning in case non default managed executor configuration was used"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDkwNjI3", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-369490627", "createdAt": "2020-03-05T11:24:46Z", "commit": {"oid": "abf511d83cafc8df4d1ee826c78bd044b26901e0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNDo0NlrOFyP5SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMToyNToyM1rOFyP6Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzU0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of the used pool.\",\n          \n          \n            \n                                    \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n          \n      \n    \n    \n  \n\nJust some extra clarity :)", "url": "https://github.com/payara/Payara/pull/4534#discussion_r388233544", "createdAt": "2020-03-05T11:24:46Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -133,6 +133,18 @@ public void postConstruct() {\n                 TimeUnit.SECONDS, new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n         int interval = getCleanupIntervalInMinutes();\n         delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, interval, interval, TimeUnit.MINUTES);\n+        if (config != null) {\n+            if (!\"concurrent/__defaultManagedExecutorService\".equals(config.getManagedExecutorService())) {\n+                logger.log(Level.WARNING,\n+                        \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of the used pool.\",\n+                        config.getManagedExecutorService());\n+            }\n+            if (!\"concurrent/__defaultManagedScheduledExecutorService\".equals(config.getManagedScheduledExecutorService())) {\n+                logger.log(Level.WARNING,\n+                        \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of the used pool.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf511d83cafc8df4d1ee826c78bd044b26901e0"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIzMzgyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of the used pool.\",\n          \n          \n            \n                                    \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n          \n      \n    \n    \n  \n\nDitto.", "url": "https://github.com/payara/Payara/pull/4534#discussion_r388233823", "createdAt": "2020-03-05T11:25:23Z", "author": {"login": "Pandrex247"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -133,6 +133,18 @@ public void postConstruct() {\n                 TimeUnit.SECONDS, new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n         int interval = getCleanupIntervalInMinutes();\n         delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, interval, interval, TimeUnit.MINUTES);\n+        if (config != null) {\n+            if (!\"concurrent/__defaultManagedExecutorService\".equals(config.getManagedExecutorService())) {\n+                logger.log(Level.WARNING,\n+                        \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of the used pool.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abf511d83cafc8df4d1ee826c78bd044b26901e0"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63c830917a0385f5e1ac0ba74fb27b4763a00e0e", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/63c830917a0385f5e1ac0ba74fb27b4763a00e0e", "committedDate": "2020-03-05T14:20:56Z", "message": "Update appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java\n\nCo-Authored-By: Andrew Pielage <pandrex247@hotmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c9b65a7d0516333d3a7722bcf0dd72a0a812ead", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/4c9b65a7d0516333d3a7722bcf0dd72a0a812ead", "committedDate": "2020-03-05T14:21:20Z", "message": "Update appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java\n\nCo-Authored-By: Andrew Pielage <pandrex247@hotmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab90bca3b0e0f2c6a305cb689c746781dd9ec649", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/ab90bca3b0e0f2c6a305cb689c746781dd9ec649", "committedDate": "2020-03-05T15:46:48Z", "message": "APPSERV-55 changes admin GUI to new FT settings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29ba3e5c50ec6fc02ba02a6787b7e4b12f5316c7", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/29ba3e5c50ec6fc02ba02a6787b7e4b12f5316c7", "committedDate": "2020-03-05T15:46:59Z", "message": "Merge branch 'APPSERV-55-metrics-race' of github.com:jbee/Payara into APPSERV-55-metrics-race"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Njk1OTYy", "url": "https://github.com/payara/Payara/pull/4534#pullrequestreview-369695962", "createdAt": "2020-03-05T15:59:50Z", "commit": {"oid": "29ba3e5c50ec6fc02ba02a6787b7e4b12f5316c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 772, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}