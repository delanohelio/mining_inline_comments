{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NzAzNzMx", "number": 4694, "title": "APPSERV-149 Add Command to Generate Self-Signed Certificate", "bodyText": "Description\nAdds a CLI command for generating a self-signed certificate and storing in a target instance's or listener's key and trust stores.\n\nSYNOPSIS\ngenerate-self-signed-certificate [--help]\n[--domain_name domain-name] [--domaindir domain-dir]\n[--target instance-name] [--listener listener-name]\n[alternativenames (type:value)[;type:value]*]\n--distinguishedname\nalias\nDESCRIPTION\nThe generate-self-signed-certificate subcommand generates a self-\nsigned certificate using the provided distinguished name, alias, and\nany provided alternative names. This certificate is then placed in\nthe key and trust store of the target instance or listener.\n   If the instance or listener is configured to use the default key and\n   trust store, the command will instead synchronise the instance with\n   the DAS (under the assumption the certificate has been added to the\n   default key and trust store of the DAS), since any certificates added\n   to the instance stores would be lost upon next synchronisation.\n\nOPTIONS\n--help, -?\nDisplays the help text for the subcommand.\n   --domain_name\n       The unique name of the domain you want to start. This operand is\n       optional, defaulting to domain1 if not provided.\n\n   --domaindir\n       The domain root directory, which contains the directory of the\n       target domain. If specified, the path must be accessible in the\n       file system. The default location of the domain root directory\n       is as-install/domains.\n\n   --target\n       The name of the instance to add the generated certificate to the\n       key and trust store of. Defaults to server (the DAS).\n\n   --listener\n       The name of the HTTP or IIOP listener to add the generated\n       certificate to the key and trust store of. Only applicable if\n       the listener has a key or trust store different to that of the\n       instance itself.\n\n   --alternativenames, --altnames\n       The subject alternative names to add to the generated certificate.\n       Takes the form of a semi-colon separated list of type:value. If no\n       type is given, it is assumed to be DNS.\n\nOPERANDS\n--distinguishedname, --dn\nThe distinguished name to use when generating the certificate.\n   alias\n       The alias to use when generating the certificate and storing it\n       in the key and trust stores. If the alias already exists in the\n       key store, the command will fail. If the alias already exists in\n       the trust store, this trusted certificate will be overwritten.\n\nEXAMPLES\nExample 1, Creating a Self-Signed Certificate for the DAS\n       This example creates a self-signed certificate for the DAS.\n\n           asadmin> generate-self-signed-certificate --dn \"CN=test.payara.fish\" test_cert1\n\n   Example 2, Created a Self-Signed Certificate for a Listener\n\n       This example creates a self-signed certificate with alternative\n       names for the http-listner-2 listener of an instance named Guppy1.\n\n           asadmin> generate-self-signed-certificate --dn \"CN=test.payara.fish\"\n           --listener http-listener-2\n           --alternativenames \"test2.payara.fish;DNS:test3.payara.fish,IP:127.0.0.1,EMAIL:anon@payara.fish\"\n           --target Guppy1\n           test_cert2\n\n\nTesting\nNew tests\nUnit test that ensures that alternatives names are added to the keytool command in the expected format.\nTesting Performed\n\nAdd cert to default DAS using default key and trust stores\nAdd cert to default DAS using custom key store and default trust store\nAdd cert to default DAS using custom trust store and default key store\nAdd cert to default DAS using custom key store and custom trust store\nAdd cert to non-default DAS using default key and trust stores\nAdd cert to non-default DAS using custom key store and custom trust store\nAdd cert to default DAS using default key and trust stores in non-default domaindir\nAdd cert to instance using default key and trust stores - should reject and attempt to sync with DAS\nAdd cert to instance using custom key and default trust stores - should reject and attempt to sync with DAS, warning user to manually add cert to key store\nAdd cert to instance using default key and custom trust stores - should reject and attempt to sync with DAS, warning user to manually add cert to trust store\nAdd cert to instance using custom key and custom trust stores - should generate certificate and place in key and trust store\nAdd cert to default DAS using default key and trust stores when cert already exists - should reject\nAdd cert to default DAS using default key and trust stores when cert already exists only in key store - should reject\nAdd cert to default DAS using default key and trust stores when cert already exists only in trust store - should add cert to key store and override cert in trust store.\nAdd cert to default DAS http2-listener using default key and trust stores - should add cert to key and trust stores if not already present\nAdd cert to default DAS http2-listener using custom key and trust stores - should add cert to key and trust stores if not already present\nAdd cert to default DAS http2-listener using custom key and default trust stores - should add cert to key and trust stores if not already present\nAdd cert to instance http2-listener using custom key and default trust stores -  should reject and attempt to sync with DAS, warning user to manually add cert to key store\nAdd cert to default DAS using default key and trust stores with changed master password\nAdd cert to default DAS http2-listener using custom key and trust stores with stores protected by a different password to the master (store passwords set using set command)\nAdd cert to default DAS http2-listener using different custom key and trust stores with stores protected by a different passwords to the master (store passwords set using set command)\nAdd cert to default DAS http2-listener using custom key and trust stores with stores protected by a password alias (store passwords set using set command)\n\nTesting Environment\nWindows 10, JDK 8.\nNotes for Reviewers\nHTTP and IIOP listeners do not automatically reload any changes to their configuration, which includes changes to a configured key store or certificate. You do not need to restart the server to refresh the configuration however, you can simply restart the listener by disabling and re-enabling it.\nAlso note listeners are lazy loaded.\nI'd appreciate it if you also redid all (or at least some) of my manual tests, or any scenarios I've missed.\nTo build please specify the BuildExtras profile and manually copy-pasta the Jar from appserver/extras/certificate-management/ into the payara5/glassfish/lib/asadmin directory.", "createdAt": "2020-06-02T16:42:20Z", "url": "https://github.com/payara/Payara/pull/4694", "merged": true, "mergeCommit": {"oid": "4e865c4926292b9e6643a51e65fc829951d21d1c"}, "closed": true, "closedAt": "2020-06-05T11:12:06Z", "author": {"login": "Pandrex247"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclagy7AH2gAyNDI2NzAzNzMxOjRjNTVhYzQwNGI1OGY0ZGVjNDYyODBmZWMyZTY2MmZmZDFlZmRkOGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn_clPAFqTQyNDU0NDkwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4c55ac404b58f4dec46280fec2e662ffd1efdd8b", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/4c55ac404b58f4dec46280fec2e662ffd1efdd8b", "committedDate": "2020-05-27T14:54:38Z", "message": "APPSERV-149 Initial asadmin commands for generating self-signed certs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66693c7f52ef0c26d6a0f949de41df0330cebb83", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/66693c7f52ef0c26d6a0f949de41df0330cebb83", "committedDate": "2020-05-27T14:55:05Z", "message": "APPSERV-149 Move local instance command under original command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4c4aaf472eec07c933b2ec0a88d0f94b43e01c3", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/d4c4aaf472eec07c933b2ec0a88d0f94b43e01c3", "committedDate": "2020-05-27T14:55:11Z", "message": "APPSERV-149 Remove unnecessary reload parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5ae88989c9672fd3ea631e18dfdb7d0813e6aff", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/b5ae88989c9672fd3ea631e18dfdb7d0813e6aff", "committedDate": "2020-05-29T13:45:24Z", "message": "APPSERV-149 Add support for password aliases, remove redundant code, and add javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03620e048a2e2b41b34fecf9a0ee012281b55336", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/03620e048a2e2b41b34fecf9a0ee012281b55336", "committedDate": "2020-06-01T07:59:50Z", "message": "APPSERV-149 Fix copyright and some formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8aa19953948c595af5ed8267b876fa51dfa7952", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/e8aa19953948c595af5ed8267b876fa51dfa7952", "committedDate": "2020-06-01T14:40:29Z", "message": "APPSERV-149 Add help text for command"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8f3bd918f3c1344db0267625093e3f534c84d49", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/b8f3bd918f3c1344db0267625093e3f534c84d49", "committedDate": "2020-06-02T15:01:09Z", "message": "APPSERV-149 Move to extras and remove from featureset and packager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/ba57e865db8de429fb07c224de8d442479dfdf98", "committedDate": "2020-06-02T15:03:08Z", "message": "APPSERV-149 Move under BuildExtras profile"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzI3MTM0", "url": "https://github.com/payara/Payara/pull/4694#pullrequestreview-424327134", "createdAt": "2020-06-04T10:55:31Z", "commit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMDo1NTozMVrOGfAd3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0ODo0M1rOGfG07w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE2NjY4NA==", "bodyText": "domainName0 - is that intentional?", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435166684", "createdAt": "2020-06-04T10:55:31Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommand.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLICommand;\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CLI command for generating self-signed certificates and placing them in an instance or listener's key\n+ * and trust stores.\n+ *\n+ * @author Andrew Pielage\n+ */\n+@Service(name = \"generate-self-signed-certificate\")\n+@PerLookup\n+public class GenerateSelfSignedCertificateCommand extends LocalDomainCommand {\n+\n+    private static final Logger logger = Logger.getLogger(CLICommand.class.getPackage().getName());\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4ODY0Ng==", "bodyText": "Extending the util has a bit of a taste. I'd prefer using static method imports to use the util methods without qualified access.", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435188646", "createdAt": "2020-06-04T11:39:06Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/test/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommandTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class GenerateSelfSignedCertificateCommandTest extends CertificateManagementUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzMTUwMg==", "bodyText": "Testing suggests that this should be if (keystorePassword != null && keystorePassword.length > 0) {", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435231502", "createdAt": "2020-06-04T12:57:09Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateSelfSignedCertificateCommand.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLICommand;\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CLI command for generating self-signed certificates and placing them in an instance or listener's key\n+ * and trust stores.\n+ *\n+ * @author Andrew Pielage\n+ */\n+@Service(name = \"generate-self-signed-certificate\")\n+@PerLookup\n+public class GenerateSelfSignedCertificateCommand extends LocalDomainCommand {\n+\n+    private static final Logger logger = Logger.getLogger(CLICommand.class.getPackage().getName());\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;\n+\n+    @Param(name = \"distinguishedname\", alias = \"dn\")\n+    private String dn;\n+\n+    @Param(name = \"alternativenames\", optional = true, alias = \"altnames\", separator = ';')\n+    private String[] altnames;\n+\n+    @Param(name = \"listener\", optional = true)\n+    private String listener;\n+\n+    @Param(name = \"target\", optional = true, defaultValue = SystemPropertyConstants.DAS_SERVER_NAME)\n+    private String target;\n+\n+    @Param(name = \"alias\", primary = true)\n+    private String alias;\n+\n+    private File keystore;\n+    private File truststore;\n+    private char[] keystorePassword;\n+    private char[] truststorePassword;\n+    private char[] masterPassword;\n+\n+    @Override\n+    protected void validate() throws CommandException {\n+        setDomainName(domainName0);\n+        super.validate();\n+    }\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        // If we're targetting an instance that isn't the DAS, use a different command\n+        if (target != null && !target.equals(SystemPropertyConstants.DAS_SERVER_NAME)) {\n+            GenerateSelfSignedCertificateLocalInstanceCommand localInstanceCommand =\n+                    new GenerateSelfSignedCertificateLocalInstanceCommand(programOpts, env);\n+            localInstanceCommand.validate();\n+            return localInstanceCommand.executeCommand();\n+        }\n+\n+        // Parse the location of the key and trust stores, and the passwords required to access them\n+        try {\n+            MiniXmlParser parser = new MiniXmlParser(getDomainXml(), target);\n+            keystore = CertificateManagementUtils.resolveKeyStore(parser, listener, getDomainRootDir());\n+            truststore = CertificateManagementUtils.resolveTrustStore(parser, listener, getDomainRootDir());\n+            getStorePasswords(parser, listener, getDomainRootDir());\n+        } catch (MiniXmlParserException miniXmlParserException) {\n+            throw new CommandException(\"Error parsing domain.xml\", miniXmlParserException);\n+        }\n+\n+        // Run keytool command to generate self-signed cert and place in keystore\n+        try {\n+            addToKeystore();\n+        } catch (CommandException ce) {\n+            return CLIConstants.ERROR;\n+        }\n+\n+        try {\n+            addToTruststore();\n+        } catch (CommandException ce) {\n+            return CLIConstants.WARNING;\n+        }\n+\n+        return CLIConstants.SUCCESS;\n+    }\n+\n+    /**\n+     * Gets the passwords for the key and trust store.\n+     *\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the HTTP or IIOP listener to get the key or trust store passwords from. Can be null.\n+     * @param serverDir The directory of the target instance, used for accessing the domain-passwords store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     * @throws CommandException       If there's an issue getting the master password\n+     */\n+    private void getStorePasswords(MiniXmlParser parser, String listener, File serverDir)\n+            throws MiniXmlParserException, CommandException {\n+        if (listener != null) {\n+            // Check if listener has a password set\n+            keystorePassword = CertificateManagementUtils.getPasswordFromListener(parser, listener, \"key-store-password\");\n+            truststorePassword = CertificateManagementUtils.getPasswordFromListener(parser, listener, \"trust-store-password\");\n+        }\n+\n+        if (keystorePassword != null || keystorePassword.length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MDg5NQ==", "bodyText": "This causes a NPE when listenerAttributes does not have a password attribute which I apparently managed to create as test case. I suspect the same applies to the assignment in 312.", "url": "https://github.com/payara/Payara/pull/4694#discussion_r435270895", "createdAt": "2020-06-04T13:48:43Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementUtils.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management;\n+\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+\n+import java.io.File;\n+import java.util.Map;\n+\n+import static com.sun.enterprise.util.StringUtils.ok;\n+\n+/**\n+ * Helper methods for various Certificate Management commands.\n+ *\n+ * @author Andrew Pielage\n+ */\n+public class CertificateManagementUtils {\n+\n+    public static final String DEFAULT_KEYSTORE = \"${com.sun.aas.instanceRoot}\"\n+            + File.separator + \"config\" + File.separator + \"keystore.jks\";\n+    public static final String DEFAULT_TRUSTSTORE = \"${com.sun.aas.instanceRoot}\"\n+            + File.separator + \"config\" + File.separator + \"cacerts.jks\";\n+\n+    /**\n+     * Determines and returns the key store.\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener    The name of the HTTP or IIOP listener to get the key store from. Can be null.\n+     * @param instanceDir The directory of the target instance, used for relative paths\n+     * @return The key store of the target\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    public static File resolveKeyStore(MiniXmlParser parser, String listener, File instanceDir)\n+            throws MiniXmlParserException {\n+        File keystore = null;\n+        if (listener != null) {\n+            // Check if listener is an HTTP listener\n+            keystore = getStoreFromHttpListeners(parser, listener, \"key-store\", instanceDir);\n+\n+            if (keystore == null) {\n+                // Check if listener is an IIOP listener\n+                keystore = getStoreFromIiopListeners(parser, listener, \"key-store\", instanceDir);\n+            }\n+        }\n+\n+        // Default to getting it from the JVM options if no non-default value found\n+        if (keystore == null) {\n+            keystore = getStoreFromJvmOptions(parser, \"keyStore\", instanceDir);\n+        }\n+\n+        // If it's STILL null, just go with default\n+        if (keystore == null) {\n+            keystore = new File(DEFAULT_KEYSTORE);\n+        }\n+\n+        return keystore;\n+    }\n+\n+    /**\n+     * Determines and returns the trust store.\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener    The name of the HTTP or IIOP listener to get the trust store from. Can be null.\n+     * @param instanceDir The directory of the target instance, used for relative paths\n+     * @return The trust store of the target\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    public static File resolveTrustStore(MiniXmlParser parser, String listener, File instanceDir)\n+            throws MiniXmlParserException {\n+        File truststore = null;\n+        if (listener != null) {\n+            // Check if listener is an HTTP listener\n+            truststore = getStoreFromHttpListeners(parser, listener, \"trust-store\", instanceDir);\n+\n+            if (truststore == null) {\n+                // Check if listener is an IIOP listener\n+                truststore = getStoreFromIiopListeners(parser, listener, \"trust-store\", instanceDir);\n+            }\n+        }\n+\n+        // Default to getting it from the JVM options if no non-default value found\n+        if (truststore == null) {\n+            truststore = getStoreFromJvmOptions(parser, \"trustStore\", instanceDir);\n+        }\n+\n+        // If it's STILL null, just go with default\n+        if (truststore == null) {\n+            truststore = new File(DEFAULT_TRUSTSTORE);\n+        }\n+\n+        return truststore;\n+    }\n+\n+    /**\n+     * Gets the store from a target HTTP listener\n+     *\n+     * @param parser         The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener       The name of the HTTP listener to get the store from.\n+     * @param storeAttribute The name of the store attribute to get (should be \"key-store\" or \"trust-store\")\n+     * @param instanceDir    The directory of the target instance, used for relative paths\n+     * @return The store of the target, or null if no matching listener or no store configured\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromHttpListeners(MiniXmlParser parser, String listener,\n+            String storeAttribute, File instanceDir) throws MiniXmlParserException {\n+        for (Map<String, String> listenerAttributes : parser.getProtocolAttributes()) {\n+            if (listenerAttributes.get(\"name\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                return getStoreFromListenerAttribute(listenerAttributes.get(storeAttribute), instanceDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the store from a target IIOP listener\n+     *\n+     * @param parser         The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener       The name of the IIOP listener to get the store from.\n+     * @param storeAttribute The name of the store attribute to get (should be \"key-store\" or \"trust-store\")\n+     * @param instanceDir    The directory of the target instance, used for relative paths\n+     * @return The store of the target, or null if no matching listener or no store configured\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromIiopListeners(MiniXmlParser parser, String listener,\n+            String storeAttribute, File instanceDir) throws MiniXmlParserException {\n+        for (Map<String, String> listenerAttributes : parser.getIiopSslAttributes()) {\n+            if (listenerAttributes.get(\"id\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                return getStoreFromListenerAttribute(listenerAttributes.get(storeAttribute), instanceDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Helper method that returns the store from a target listener's config attribute,\n+     * making any relative paths absolute.\n+     *\n+     * @param storePath   The path to the store to return as a {@link File}\n+     * @param instanceDir The instance directory, used for making relative paths absolute\n+     * @return The absolute path of the target store, or null if no store given\n+     */\n+    private static File getStoreFromListenerAttribute(String storePath, File instanceDir) {\n+        if (!ok(storePath)) {\n+            return null;\n+        }\n+\n+        File store = new File(storePath);\n+        if (!store.isAbsolute()) {\n+            store = new File(instanceDir.getAbsolutePath() + File.separator + store.getPath());\n+        }\n+\n+        return store;\n+    }\n+\n+    /**\n+     * Gets the store from a target config's JVM options\n+     *\n+     * @param parser      The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param storeName   The JVM option name of the store (should be keyStore or trustStore)\n+     * @param instanceDir The instance directory, used for SystemProperty substitution\n+     * @return The absolute path of the target store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     */\n+    private static File getStoreFromJvmOptions(MiniXmlParser parser, String storeName, File instanceDir)\n+            throws MiniXmlParserException {\n+        for (MiniXmlParser.JvmOption jvmOption : parser.getJvmOptions()) {\n+            if (jvmOption.toString().startsWith(\"-Djavax.net.ssl.\" + storeName + \"=\")) {\n+                return new File(jvmOption.toString().split(\"=\")[1]\n+                        .replace(\"${com.sun.aas.instanceRoot}\", instanceDir.getAbsolutePath()));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    protected static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);\n+\n+        return expandedKeytoolCmd;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for adding the self-signed cert to the trust store\n+     *\n+     * @param keystore           The target key store that the certificate was added to\n+     * @param truststore         The target trust store to add the certificate to\n+     * @param keystorePassword   The password for the key store\n+     * @param truststorePassword The password for the trust store\n+     * @param alias              The alias of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructImportCertKeytoolCommand(File keystore, File truststore, char[] keystorePassword,\n+            char[] truststorePassword, String alias) {\n+        String[] keytoolCmd = new String[]{\"-importkeystore\", \"-srckeystore\", keystore.getAbsolutePath(),\n+                \"-destkeystore\", truststore.getAbsolutePath(), \"-srcalias\", alias, \"-destalias\", alias,\n+                \"-srcstorepass\", new String(keystorePassword), \"-deststorepass\", new String(truststorePassword),\n+                \"-srckeypass\", new String(keystorePassword), \"-destkeypass\", new String(truststorePassword),\n+                \"-noprompt\"};\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the listener to get the password from.\n+     * @param attribute The name of the store password attribute (should be key-store-password or trust-store-password)\n+     * @return A char array containing the password of the target listener, or null if no matches or password found\n+     * @throws MiniXmlParserException if there's an issue reading the domain.xml\n+     */\n+    public static char[] getPasswordFromListener(MiniXmlParser parser, String listener, String attribute)\n+            throws MiniXmlParserException {\n+        char[] password = null;\n+        for (Map<String, String> listenerAttributes : parser.getProtocolAttributes()) {\n+            if (listenerAttributes.get(\"name\").equals(listener)) {\n+                // Get the keystore from the listener if it has a custom one\n+                password = listenerAttributes.get(attribute).toCharArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba57e865db8de429fb07c224de8d442479dfdf98"}, "originalPosition": 304}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1107cf25c8a8dc4de2793519934af758eaf5d76", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/a1107cf25c8a8dc4de2793519934af758eaf5d76", "committedDate": "2020-06-04T14:59:22Z", "message": "APPSERV-149 Fix NPEs and remove test inheritance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NTQ0OTA0", "url": "https://github.com/payara/Payara/pull/4694#pullrequestreview-424544904", "createdAt": "2020-06-04T15:04:22Z", "commit": {"oid": "a1107cf25c8a8dc4de2793519934af758eaf5d76"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 715, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}