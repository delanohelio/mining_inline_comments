{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MzYxNzIz", "number": 4700, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxNTo1N1rOEC6nWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozMDozMVrOEC618w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDkyOTUzOnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxNTo1N1rOGfqdOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxNTo1N1rOGfqdOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDY1MQ==", "bodyText": "header", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435854651", "createdAt": "2020-06-05T11:15:57Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDkzOTQzOnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxOTo1MlrOGfqjOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToxOTo1MlrOGfqjOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjE4Ng==", "bodyText": "Better to compute the value and then assign it to the array. Keeps the array out of the value computation.", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435856186", "createdAt": "2020-06-05T11:19:52Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;\n+\n+import java.io.File;\n+\n+public class CertificateManagementKeytoolCommands {\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    public static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk0MjM2OnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMDo1NlrOGfqlAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyMDo1NlrOGfqlAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjY0MQ==", "bodyText": "I would not mind if the other commands are formatted like here where each pair is on its own line.", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435856641", "createdAt": "2020-06-05T11:20:56Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;\n+\n+import java.io.File;\n+\n+public class CertificateManagementKeytoolCommands {\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    public static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);\n+\n+        return expandedKeytoolCmd;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for adding the self-signed cert to the trust store\n+     *\n+     * @param keystore           The target key store that the certificate was added to\n+     * @param truststore         The target trust store to add the certificate to\n+     * @param keystorePassword   The password for the key store\n+     * @param truststorePassword The password for the trust store\n+     * @param alias              The alias of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructImportCertKeytoolCommand(File keystore, File truststore, char[] keystorePassword,\n+            char[] truststorePassword, String alias) {\n+        String[] keytoolCmd = new String[]{\"-importkeystore\", \"-srckeystore\", keystore.getAbsolutePath(),\n+                \"-destkeystore\", truststore.getAbsolutePath(), \"-srcalias\", alias, \"-destalias\", alias,\n+                \"-srcstorepass\", new String(keystorePassword), \"-deststorepass\", new String(truststorePassword),\n+                \"-srckeypass\", new String(keystorePassword), \"-destkeypass\", new String(truststorePassword),\n+                \"-noprompt\"};\n+\n+        return keytoolCmd;\n+    }\n+\n+    public static String[] constructGenerateCertRequestKeytoolCommand(File keystore, char[] password,\n+            File outputFile, String alias) {\n+        String[] keytoolCmd = new String[]{\"-certreq\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias,\n+                \"-storepass\", new String(password),\n+                \"-keypass\", new String(password),\n+                \"-noprompt\", \"-file\", outputFile.getAbsolutePath()};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk1NzI1OnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateCsrCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyNjo0OVrOGfquXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyNjo0OVrOGfquXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTAzNg==", "bodyText": "At some point it would be nice to move all the XML processing to one place. Maybe not now.", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435859036", "createdAt": "2020-06-05T11:26:49Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateCsrCommand.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementKeytoolCommands;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+\n+@Service(name = \"generate-csr\")\n+@PerLookup\n+public class GenerateCsrCommand extends LocalDomainCommand {\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;\n+\n+    @Param(name = \"listener\", optional = true)\n+    private String listener;\n+\n+    @Param(name = \"target\", optional = true, defaultValue = SystemPropertyConstants.DAS_SERVER_NAME)\n+    private String target;\n+\n+    @Param(name = \"alias\", primary = true)\n+    private String alias;\n+\n+    private File keystore;\n+    private char[] keystorePassword;\n+    private char[] masterPassword;\n+\n+    @Override\n+    protected void validate() throws CommandException {\n+        setDomainName(domainName0);\n+        super.validate();\n+    }\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        // If we're targetting an instance that isn't the DAS, use a different command\n+        if (target != null && !target.equals(SystemPropertyConstants.DAS_SERVER_NAME)) {\n+            GenerateCsrLocalInstanceCommand localInstanceCommand =\n+                    new GenerateCsrLocalInstanceCommand(programOpts, env);\n+            localInstanceCommand.validate();\n+            return localInstanceCommand.executeCommand();\n+        }\n+\n+        // Parse the location of the key store, and the password required to access it\n+        try {\n+            MiniXmlParser parser = new MiniXmlParser(getDomainXml(), target);\n+            keystore = CertificateManagementUtils.resolveKeyStore(parser, listener, getDomainRootDir());\n+            getStorePasswords(parser, listener, getDomainRootDir());\n+        } catch (MiniXmlParserException miniXmlParserException) {\n+            throw new CommandException(\"Error parsing domain.xml\", miniXmlParserException);\n+        }\n+\n+        // Run keytool command to generate CSR and place in csrLocation\n+        try {\n+            generateCsr();\n+        } catch (CommandException ce) {\n+            return CLIConstants.ERROR;\n+        }\n+\n+        return CLIConstants.SUCCESS;\n+    }\n+\n+    /**\n+     * Generates a CSR\n+     *\n+     * @throws CommandException If there's an issue adding the certificate to the key store\n+     */\n+    private void generateCsr() throws CommandException {\n+        // Get CSR install dir and ensure it actually exists\n+        File csrLocation = new File(getInstallRootPath() + File.separator + \"tls\");\n+        if (!csrLocation.exists()) {\n+            csrLocation.mkdir();\n+        }\n+\n+        // Run keytool command to generate self-signed cert\n+        KeystoreManager.KeytoolExecutor keytoolExecutor = new KeystoreManager.KeytoolExecutor(\n+                CertificateManagementKeytoolCommands.constructGenerateCertRequestKeytoolCommand(\n+                        keystore, keystorePassword,\n+                        new File(csrLocation.getAbsolutePath() + File.separator + alias + \".csr\"),\n+                        alias),\n+                60);\n+\n+        try {\n+            keytoolExecutor.execute(\"csrNotCreated\", keystore);\n+        } catch (RepositoryException re) {\n+            logger.severe(re.getCause().getMessage()\n+                    .replace(\"keytool error: java.lang.Exception: \", \"\")\n+                    .replace(\"keytool error: java.io.IOException: \", \"\"));\n+            throw new CommandException(re);\n+        }\n+    }\n+\n+    /**\n+     * Gets the passwords for the key and trust store.\n+     *\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the HTTP or IIOP listener to get the key or trust store passwords from. Can be null.\n+     * @param serverDir The directory of the target instance, used for accessing the domain-passwords store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     * @throws CommandException       If there's an issue getting the master password\n+     */\n+    private void getStorePasswords(MiniXmlParser parser, String listener, File serverDir)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk2MjYzOnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/manpages/fish/payara/certificate/management/admin/generate-csr.1", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyODo0N1rOGfqxxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMToyODo0N1rOGfqxxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTkwOQ==", "bodyText": "generate-self-signed-certificate c&p error?", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435859909", "createdAt": "2020-06-05T11:28:47Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/manpages/fish/payara/certificate/management/admin/generate-csr.1", "diffHunk": "@@ -0,0 +1,73 @@\n+generate-csr(1)  asadmin Utility Subcommands generate-csr(1)\n+\n+NAME\n+       generate-csr - generates a certificate signing request from the certificate in\n+       the target instance or listener's key store that matches the provided alias. A\n+       user can then send this CSR to their chosen Certificate Authority (CA) to\n+       receive a CA issued certificate and replace the self-signed certificate. The\n+       CSRs are placed in payara5/glassfish/tls and match the name of the alias.\n+\n+SYNOPSIS\n+           generate-self-signed-certificate [--help]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDk2NjkxOnYy", "diffSide": "RIGHT", "path": "appserver/extras/certificate-management/src/main/manpages/fish/payara/certificate/management/admin/generate-csr.1", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozMDozMVrOGfq0gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMTozMDozMVrOGfq0gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MDYxMA==", "bodyText": "This appears to repeat the DESCRIPTION section - I assume it should just state the name?", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435860610", "createdAt": "2020-06-05T11:30:31Z", "author": {"login": "jbee"}, "path": "appserver/extras/certificate-management/src/main/manpages/fish/payara/certificate/management/admin/generate-csr.1", "diffHunk": "@@ -0,0 +1,73 @@\n+generate-csr(1)  asadmin Utility Subcommands generate-csr(1)\n+\n+NAME\n+       generate-csr - generates a certificate signing request from the certificate in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1260, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}