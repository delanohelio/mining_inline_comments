{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMjg2MzI1", "number": 5062, "title": "FISH-868 JWT public key is cached for a configurable amount of time.", "bodyText": "Description\nThis is a PR for feature request #5027. With this change, the loaded JWT public key is cached for subsequent requests to use. While the PR is aimed at helping with remote public keys, it handles key caching from any source the same.\nI original wrote the feature request with HTTP cache headers in mind but since it is much simpler to have a default cache TTL configurable by payara-mp-jwt.properties, I thought that would be a better place to start. A new configuration publicKey.cache.ttl sets the TTL in seconds and defaults to 5 minutes (probably want to discuss what the default could be). If set to 0 or less, the cache is disabled and public key loads are no longer synchronized.\nLast, I omitted a feature I entertained in #5027 where receiving an unrecognized JWT key ID would hint to the server that the public key cache was stale and needed to be refreshed. If that's something we think would be helpful, I can definitely add it.\nTesting\nNew tests\nI held off on writing tests because I'm not sure how tests are being handled for this module. I do not see any unit test. For what it's worth, I did manually test the feature with embedded and remote public keys.\nNotes for Reviewers\nThe PR looks a bit bigger than it actually is. With the extra complexity to loading public keys, it seemed like a good time to move that responsibility out of SignedJWTIdentityStore and into its own class, JwtPublicKeyStore. Most of the \"read MP public key\" methods were copied verbatim except they now return the public key as a string instead of parsing it first.\nI went back and forth on whether to cache the public key before or after parsing. I landed on before because it was the least disruptive to how key IDs, PEMs and JWKS is working right now but I also recognize that each request then has to re-parse the public key. I thought it was an ok tradeoff but I could be easily swayed.\nI really wanted to use org.glassfish.jersey.internal.guava.LoadingCache but it does not seem to support expireAfterWrite. I added a simple double checking synchronized cache wrapper but I'd rather delete it if there's a better option already available in the project.", "createdAt": "2020-12-18T04:53:32Z", "url": "https://github.com/payara/Payara/pull/5062", "merged": true, "mergeCommit": {"oid": "8d67d87666f832a77b4be11ff26da1848f3af54f"}, "closed": true, "closedAt": "2021-01-29T11:28:01Z", "author": {"login": "ghunteranderson"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdnQHLOAH2gAyNTQyMjg2MzI1OjU1YmFiODVlNWM0NjViZDcwYWQ0NzM5NTAwNzNhNDYyMTllMmJiYzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd0sgb-gFqTU3ODc5NzgyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3", "author": {"user": {"login": "ghunteranderson", "name": "Hunter Anderson"}}, "url": "https://github.com/payara/Payara/commit/55bab85e5c465bd70ad473950073a46219e2bbc3", "committedDate": "2020-12-18T04:06:36Z", "message": "FISH-868 JWT public key is cached for a configurable amount of time."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDc1NDYx", "url": "https://github.com/payara/Payara/pull/5062#pullrequestreview-556075461", "createdAt": "2020-12-21T00:06:54Z", "commit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwMDowNjo1NFrOIJJDOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQwMDowNjo1NFrOIJJDOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA==", "bodyText": "Does it make sense to read the HTTP cache headers here and use an eventually provided TTL for caching? Just as an override to the configured one. Especially if there is none configured.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r546456378", "createdAt": "2020-12-21T00:06:54Z", "author": {"login": "svendiedrichsen"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3NjM5NTU3", "url": "https://github.com/payara/Payara/pull/5062#pullrequestreview-567639557", "createdAt": "2021-01-13T21:06:04Z", "commit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTowNjowNFrOITCFEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo0ODoxMFrOITEcSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNzkyMw==", "bodyText": "Add the brackets to these statements for consistent code.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556827923", "createdAt": "2021-01-13T21:06:04Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyOTQwMg==", "bodyText": "Missing brackets.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556829402", "createdAt": "2021-01-13T21:08:44Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;\n+        private long lastUpdated;\n+        private Optional<String> publicKey;\n+        \n+        \n+        public PublicKeyLoadingCache(long ttl, Supplier<Optional<String>> loadingFunction) {\n+            this.ttl = ttl;\n+            this.loadingFunction = loadingFunction;\n+            this.lastUpdated = 0;\n+        }\n+        \n+        public Optional<String> get() {\n+            long now = System.currentTimeMillis();\n+            if(now - lastUpdated > ttl)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjY5OA==", "bodyText": "It is a bit confusing that this variable is named cache since it is not technically a cache. Better to name it to cacheSupplier.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556852698", "createdAt": "2021-01-13T21:35:35Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NzM2NQ==", "bodyText": "Better to rename this class field to keySupplier instead to keep the consistency of the class.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556857365", "createdAt": "2021-01-13T21:39:56Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1ODY3MA==", "bodyText": "This statement is redundant since the value has been already initialized to 0.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556858670", "createdAt": "2021-01-13T21:41:10Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;\n+        private long lastUpdated;\n+        private Optional<String> publicKey;\n+        \n+        \n+        public PublicKeyLoadingCache(long ttl, Supplier<Optional<String>> loadingFunction) {\n+            this.ttl = ttl;\n+            this.loadingFunction = loadingFunction;\n+            this.lastUpdated = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDk1Mw==", "bodyText": "Shouldn't this value be in milliseconds? The code in the PublicKeyLoadingCache class treats the TTL as milliseconds on its calculations for the refresh method. Either convert the value to milliseconds here or specify that the publicKey.cache.ttl property needs to be described in milliseconds.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556864953", "createdAt": "2021-01-13T21:47:02Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/SignedJWTIdentityStore.java", "diffHunk": "@@ -179,141 +151,13 @@ public CredentialValidationResult validate(SignedJWTCredential signedJWTCredenti\n     private Optional<Boolean> readDisableTypeVerification(Optional<Properties> properties) {\n         return properties.isPresent() ? Optional.ofNullable(Boolean.valueOf(properties.get().getProperty(\"disable.type.verification\", \"false\"))) : Optional.empty();\n     }\n-\n-    private Optional<PublicKey> readDefaultPublicKey() throws Exception {\n-        return readPublicKeyFromLocation(\"/publicKey.pem\", null);\n-    }\n-\n-    private Optional<PublicKey> readMPEmbeddedPublicKey(String keyID) throws Exception {\n-        Optional<String> key = config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n-        if (!key.isPresent()) {\n-            return Optional.empty();\n-        }\n-        return createPublicKey(key.get(), keyID);\n-    }\n-\n-    private Optional<PublicKey> readMPPublicKeyFromLocation(String keyID) throws Exception {\n-        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n-\n-        if (!locationOpt.isPresent()) {\n-            return Optional.empty();\n-        }\n-\n-        String publicKeyLocation = locationOpt.get();\n-\n-        return readPublicKeyFromLocation(publicKeyLocation, keyID);\n-    }\n-\n-    private Optional<PublicKey> readPublicKeyFromLocation(String publicKeyLocation, String keyID) throws Exception {\n-\n-        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n-\n-        if (publicKeyURL == null) {\n-            try {\n-                publicKeyURL = new URL(publicKeyLocation);\n-            } catch (MalformedURLException ex) {\n-                publicKeyURL = null;\n-            }\n-        }\n-        if (publicKeyURL == null) {\n-            return Optional.empty();\n-        }\n-\n-        URLConnection urlConnection = publicKeyURL.openConnection();\n-        Charset charset = Charset.defaultCharset();\n-        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n-        if(contentType != null) {\n-            String charEncoding = contentType.getCharacterEncoding();\n-            if(charEncoding != null) {\n-                try {\n-                    if (!Charset.isSupported(charEncoding)) {\n-                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n-                    } else {\n-                        charset = Charset.forName(contentType.getCharacterEncoding());\n-                    }\n-                }catch (IllegalCharsetNameException ex){\n-                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n-                }\n-            }\n-        }\n-        try (InputStream inputStream = urlConnection.getInputStream();\n-             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n-            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n-            return createPublicKey(keyContents, keyID);\n-        }\n+    \n+    private Long readPublicKeyCacheTTL(Optional<Properties> properties) {\n+        return properties\n+        \t\t.map(props -> props.getProperty(\"publicKey.cache.ttl\"))\n+        \t\t.map(Long::valueOf)\n+        \t\t.orElseGet( () -> TimeUnit.SECONDS.convert(5, TimeUnit.MINUTES));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NjYzNQ==", "bodyText": "@ghunteranderson, will you make the changes to consider the TTL in the cache headers of the response then?", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556866635", "createdAt": "2021-01-13T21:48:10Z", "author": {"login": "fturizo"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, "originalCommit": {"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2276d6a1ac047be2dd18a764bf482960961b7fba", "author": {"user": {"login": "ghunteranderson", "name": "Hunter Anderson"}}, "url": "https://github.com/payara/Payara/commit/2276d6a1ac047be2dd18a764bf482960961b7fba", "committedDate": "2021-01-16T15:26:47Z", "message": "FISH-868 Fixing a few styling and naming inconsistencies."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494", "author": {"user": {"login": "ghunteranderson", "name": "Hunter Anderson"}}, "url": "https://github.com/payara/Payara/commit/6bd8fb3c3cafd1837667a1bfb0fd1a63169af494", "committedDate": "2021-01-16T18:37:56Z", "message": "FISH-868 JWT public key cache TTL can be set by HTTP header max-age."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5OTU5ODcy", "url": "https://github.com/payara/Payara/pull/5062#pullrequestreview-569959872", "createdAt": "2021-01-16T18:52:34Z", "commit": {"oid": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQxODo1MjozNFrOIVG3XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQxODo1MjozNFrOIVG3XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwMzQ4NQ==", "bodyText": "@fturizo To fix the time unit discrepancies, I change the type from long to java.time.Duration.\nI left the unit of publicKey.cache.ttl as milliseconds but I could see an argument for using seconds instead. Let me know if you have any thoughts on that.", "url": "https://github.com/payara/Payara/pull/5062#discussion_r559003485", "createdAt": "2021-01-16T18:52:34Z", "author": {"login": "ghunteranderson"}, "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/SignedJWTIdentityStore.java", "diffHunk": "@@ -179,141 +151,14 @@ public CredentialValidationResult validate(SignedJWTCredential signedJWTCredenti\n     private Optional<Boolean> readDisableTypeVerification(Optional<Properties> properties) {\n         return properties.isPresent() ? Optional.ofNullable(Boolean.valueOf(properties.get().getProperty(\"disable.type.verification\", \"false\"))) : Optional.empty();\n     }\n-\n-    private Optional<PublicKey> readDefaultPublicKey() throws Exception {\n-        return readPublicKeyFromLocation(\"/publicKey.pem\", null);\n-    }\n-\n-    private Optional<PublicKey> readMPEmbeddedPublicKey(String keyID) throws Exception {\n-        Optional<String> key = config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n-        if (!key.isPresent()) {\n-            return Optional.empty();\n-        }\n-        return createPublicKey(key.get(), keyID);\n-    }\n-\n-    private Optional<PublicKey> readMPPublicKeyFromLocation(String keyID) throws Exception {\n-        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n-\n-        if (!locationOpt.isPresent()) {\n-            return Optional.empty();\n-        }\n-\n-        String publicKeyLocation = locationOpt.get();\n-\n-        return readPublicKeyFromLocation(publicKeyLocation, keyID);\n-    }\n-\n-    private Optional<PublicKey> readPublicKeyFromLocation(String publicKeyLocation, String keyID) throws Exception {\n-\n-        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n-\n-        if (publicKeyURL == null) {\n-            try {\n-                publicKeyURL = new URL(publicKeyLocation);\n-            } catch (MalformedURLException ex) {\n-                publicKeyURL = null;\n-            }\n-        }\n-        if (publicKeyURL == null) {\n-            return Optional.empty();\n-        }\n-\n-        URLConnection urlConnection = publicKeyURL.openConnection();\n-        Charset charset = Charset.defaultCharset();\n-        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n-        if(contentType != null) {\n-            String charEncoding = contentType.getCharacterEncoding();\n-            if(charEncoding != null) {\n-                try {\n-                    if (!Charset.isSupported(charEncoding)) {\n-                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n-                    } else {\n-                        charset = Charset.forName(contentType.getCharacterEncoding());\n-                    }\n-                }catch (IllegalCharsetNameException ex){\n-                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n-                }\n-            }\n-        }\n-        try (InputStream inputStream = urlConnection.getInputStream();\n-             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n-            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n-            return createPublicKey(keyContents, keyID);\n-        }\n+    \n+    private Duration readPublicKeyCacheTTL(Optional<Properties> properties) {\n+        return properties\n+        \t\t.map(props -> props.getProperty(\"publicKey.cache.ttl\"))\n+        \t\t.map(Long::valueOf)\n+        \t\t.map(Duration::ofMillis)\n+        \t\t.orElseGet( () -> Duration.ofMinutes(5));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc4Nzk3ODI3", "url": "https://github.com/payara/Payara/pull/5062#pullrequestreview-578797827", "createdAt": "2021-01-28T22:32:33Z", "commit": {"oid": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 643, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}