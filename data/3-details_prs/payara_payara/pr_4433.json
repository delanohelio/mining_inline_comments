{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNzU2OTg5", "number": 4433, "title": "PAYARA-3324 APPSERV-16 APPSERV-23 Allow Encryption of Web Session Data and SFSBs Stored in Hazelcast", "bodyText": "Description\nThis is a new feature to replace the encryption that used to be provided by Shoal (GMS).\nIn short, this is done by generating a symmetric encryption key, propagating it to each instance in the domain (in the same manner as the keystore), and changing the Hazelcast backing store used by the web and ejb containers to use the clustered store service (rather than accessing Hazelcast directly themselves) which checks whether or not it should encrypt/decode the values it stores/retrieves respectively (keys are not encrypted).\nValues are stored in a new value-holder class to prevent Hazelcast jumping in front with its own non-overridable serialiser.\nThis PR brings in a new Asadmin CLI command, generate-encryption-key, which requires the master password and the domain to not be running. Encryption is enabled using the set-hazelcast-configuration command with a new option --encryptdatagrid: this only applies after a restart, regardless of whether or not --dynamic was specified. This is also a domain-wide option, it is not config specific.\nTesting\nNew tests\nNew test added under appserver/tests/payara-samples/samples/datagrid-encryption/sfsb-passivation.\nThis test has a very simple EJB that stores data, which is poked a number of times to store data. The bean is then passivated by spamming a lookup of 1200 EJBs (default cache size is 512) before requesting it again to check if the data is still there and correct.\nAs part of the test set-up it generates a symmetric key, enables encryption, and restarts the domain to apply the changes - these changes are removed once the test has completed.\nTesting Performed\nThe above test, plus essentially these two blogs:\nConfiguring Sticky Sessions for Payara Server with Apache Web Server & Session Replication in Payara Server with Hazelcast\nDatagrid encryption was enabled before adding session data to the clusterjsp application noted in the blog. One instance was then killed to force failover, before starting it back up again and killing the other to force a second failover (checking that the data was correct on each instance between failovers).\nThis is a bit tricky to reliably automate in a portable fashion!\nI also manually tested that the changes on whether encryption should or should not occur are only applied after a restart.\nTest suites executed\n\nJava EE7 Samples (with datagrid encryption enabled and disabled)\n\nTesting Environment\nWindows 10 64-bit, Zulu JDK 8u212.\nDocumentation\npayara/Payara-Server-Documentation#696", "createdAt": "2020-01-14T17:36:06Z", "url": "https://github.com/payara/Payara/pull/4433", "merged": true, "mergeCommit": {"oid": "23485190728045a71fccc013b87e5837264d412a"}, "closed": true, "closedAt": "2020-01-23T16:15:57Z", "author": {"login": "Pandrex247"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6T2UmAH2gAyMzYyNzU2OTg5OjJkZGIyYjQzZGUxY2QzNDVmM2FlNDZmMmNhZjJiMTI3MzIzZjc0YTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb83eSpgH2gAyMzYyNzU2OTg5OmJhYjJlNmI4NjBjYTk2NTBkYTIzOWVjZTNmYzQ2MDRlNDkxNmFiOGM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2ddb2b43de1cd345f3ae46f2caf2b127323f74a6", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/2ddb2b43de1cd345f3ae46f2caf2b127323f74a6", "committedDate": "2020-01-14T16:50:04Z", "message": "PAYARA-3324 Generate encryption key and initial symmetric encryptor impl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a427d94a45af5ea70858a79c9167b0f2d3ba409", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/0a427d94a45af5ea70858a79c9167b0f2d3ba409", "committedDate": "2020-01-14T16:50:24Z", "message": "PAYARA-3324 sync datagrid key, and throw unprocessed event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a3f9423f21322caa22a99544a7d725412432f5e", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/9a3f9423f21322caa22a99544a7d725412432f5e", "committedDate": "2020-01-14T16:50:35Z", "message": "PAYARA-3324 Don't apply changes until restart and correct logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "363119bc56fe5cdc5b1c09244653eb9378218327", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/363119bc56fe5cdc5b1c09244653eb9378218327", "committedDate": "2020-01-14T16:50:54Z", "message": "PAYARA-3324 APPSERV-23 Initial impl of session data encryption"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf36e0d5384f536911760495ac81e3f4507c0e19", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/cf36e0d5384f536911760495ac81e3f4507c0e19", "committedDate": "2020-01-14T16:50:54Z", "message": "PAYARA-3324 Add SFSB Test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62bcc30923c8bdb4bfcd0eb5446b971885817e4a", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/62bcc30923c8bdb4bfcd0eb5446b971885817e4a", "committedDate": "2020-01-14T16:50:56Z", "message": "PAYARA-3324 Copyright and formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36c779e5b3ff4fd48062de7c3b8d71c6f7cf3067", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/36c779e5b3ff4fd48062de7c3b8d71c6f7cf3067", "committedDate": "2020-01-14T17:30:17Z", "message": "PAYARA-3324 Moar copyright"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/93024348d2b320a12991bcc36a1c12bf08bb3408", "committedDate": "2020-01-15T17:08:12Z", "message": "PAYARA-3324 Prompt for key regeneration upon changing master password"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzYyNTIw", "url": "https://github.com/payara/Payara/pull/4433#pullrequestreview-343762520", "createdAt": "2020-01-16T09:09:40Z", "commit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTowOTo0MFrOFeSa2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMTowNToxOVrOFeVwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzM4NA==", "bodyText": "I assume you have thought about it decided not throwing an exception is the way to go. Just want to point this out once more as it looks like a \"throw exception\" situation.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367303384", "createdAt": "2020-01-16T09:09:40Z", "author": {"login": "jbee"}, "path": "appserver/ha/ha-hazelcast-store/src/main/java/fish/payara/ha/hazelcast/store/HazelcastBackingStore.java", "diffHunk": "@@ -73,40 +74,45 @@ public BackingStoreFactory getBackingStoreFactory() {\n     @Override\n     public V load(K k, String string) throws BackingStoreException {\n         init();\n-        return imap.get(k);\n+        try {\n+            return (V) clusteredStore.get(storeName, k);\n+        } catch (ClassCastException cce) {\n+            Logger.getLogger(HazelcastBackingStore.class.getName()).log(Level.WARNING,\n+                    \"ClassCastException when reading value from store, returning null\", cce);\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzMzY1MA==", "bodyText": "The TestEjb could implement toString to do this. The current implementation also has basically the same code twice which also should benefit from such a toString implementation.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367333650", "createdAt": "2020-01-16T10:12:26Z", "author": {"login": "jbee"}, "path": "appserver/tests/payara-samples/samples/datagrid-encryption/sfsb-passivation/src/main/java/fish/payara/samples/datagridencryption/sfsb/TestEjbEndpoints.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.samples.datagridencryption.sfsb;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import java.io.Serializable;\n+import java.util.Random;\n+\n+/**\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ */\n+@ApplicationScoped\n+@Path(\"/TestEjb\")\n+public class TestEjbEndpoints implements Serializable {\n+\n+    @Inject\n+    TestEjb testEjb;\n+\n+    @Inject\n+    TestEjb testEjb2;\n+\n+    @GET\n+    public String testEjb() {\n+        testEjb.addItem(\"apple\");\n+        testEjb.addItem(\"pear\");\n+        testEjb.addItem(\"bear\");\n+        testEjb.removeItem(\"bear\");\n+\n+        String items = \"\";\n+        for (String item : testEjb.getItems()) {\n+            items += item + \",\";\n+        }\n+        items = items.substring(0, items.length() - 1);\n+        return items;\n+    }\n+\n+    @GET\n+    @Path(\"2\")\n+    public String testEjb2() {\n+        testEjb2.addItem(\"bapple\");\n+        testEjb2.addItem(\"bear\");\n+        testEjb2.addItem(\"care\");\n+        testEjb2.removeItem(\"bear\");\n+\n+        String items = \"\";\n+        for (String item : testEjb2.getItems()) {\n+            items += item + \",\";\n+        }\n+        items = items.substring(0, items.length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzNjMzNQ==", "bodyText": "A helper method void runCommand(String logMsg, String... cmdArgs) would make the above much more readable.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367336335", "createdAt": "2020-01-16T10:17:59Z", "author": {"login": "jbee"}, "path": "appserver/tests/payara-samples/test-utils/src/main/java/fish/payara/samples/ServerOperations.java", "diffHunk": "@@ -739,5 +739,84 @@ public static KeyStore getKeyStore(\n             throw new RuntimeException(ex);\n         }\n     }\n+\n+    public static void enableDataGridEncryption() {\n+        String javaEEServer = System.getProperty(\"javaEEServer\");\n+        if (\"payara-remote\".equals(javaEEServer)) {\n+            System.out.println(\"Enabling Data Grid Encryption\");\n+            List<String> cmd = new ArrayList<>();\n+            cmd.add(\"set-hazelcast-configuration\");\n+            cmd.add(\"--encryptdatagrid\");\n+            cmd.add(\"true\");\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Stopping Server\");\n+            String domain = System.getProperty(\"payara.domain.name\", \"domain1\");\n+            if (domain != null) {\n+                domain = getPayaraDomainFromServer();\n+                if (domain != null && !domain.equals(\"null\")) {\n+                    logger.info(\"Using domain \\\"\" + domain + \"\\\" obtained from server. \" +\n+                            \"If this is not correct use -Dpayara.domain.name to override.\");\n+                } else {\n+                    // Default to domain1\n+                    domain = \"domain1\";\n+                }\n+            }\n+            cmd = new ArrayList<>();\n+            cmd.add(\"stop-domain\");\n+            cmd.add(domain);\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Generating Encryption Key\");\n+            cmd = new ArrayList<>();\n+            cmd.add(\"-W\");\n+            cmd.add(Paths.get(\"\").toAbsolutePath() + \"/src/test/resources/passwordfile.txt\");\n+            cmd.add(\"generate-encryption-key\");\n+            CliCommands.payaraGlassFish(cmd);\n+\n+            System.out.println(\"Restarting Server\");\n+            cmd = new ArrayList<>();\n+            cmd.add(\"start-domain\");\n+            cmd.add(domain);\n+            CliCommands.payaraGlassFish(cmd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzODYzNw==", "bodyText": "ouch", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367338637", "createdAt": "2020-01-16T10:22:36Z", "author": {"login": "jbee"}, "path": "nucleus/admin/server-mgmt/src/main/java/com/sun/enterprise/admin/servermgmt/cli/ChangeMasterPasswordCommandDAS.java", "diffHunk": "@@ -120,11 +127,29 @@ protected int executeCommand() throws CommandException {\n             domainConfig.put(DomainConfig.K_SAVE_MASTER_PASSWORD, savemp);\n             manager.changeMasterPassword(domainConfig);\n \n+            try {\n+                if (dataGridEncryptionEnabled()) {\n+                    logger.warning(\"Data grid encryption is enabled - \" +\n+                            \"you will need to regenerate the encryption key\");\n+                }\n+            } catch (IOException | SAXException | ParserConfigurationException | NullPointerException exception) {\n+                logger.warning(\"Could not determine if data grid encryption is enabled - \" +\n+                        \"you will need to regenerate the encryption key if it is\");\n+            }\n+\n             return 0;\n         } catch(Exception e) {\n             throw new CommandException(e.getMessage(),e);\n         }\n     }\n+\n+    private boolean dataGridEncryptionEnabled() throws IOException, SAXException, ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder builder = factory.newDocumentBuilder();\n+        Document document = builder.parse(getDomainXml());\n+        return Boolean.valueOf(document.getElementsByTagName(\"hazelcast-runtime-configuration\")\n+                .item(0).getAttributes().getNamedItem(\"datagrid-encryption-enabled\").getNodeValue());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0MTA2Mg==", "bodyText": "Choice of name is a bit unfortunate as there is a method of the same name in the super class which returns something else.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367341062", "createdAt": "2020-01-16T10:27:38Z", "author": {"login": "jbee"}, "path": "nucleus/admin/server-mgmt/src/main/java/fish/payara/admin/servermgmt/cli/GenerateEncryptionKey.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.admin.servermgmt.cli;\n+\n+import com.sun.enterprise.admin.servermgmt.cli.ChangeMasterPasswordCommandDAS;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.i18n.LocalStringsImpl;\n+import com.sun.enterprise.util.HostAndPort;\n+import com.sun.enterprise.util.net.NetUtils;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.glassfish.security.common.FileProtectionUtility;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+\n+@Service(name = \"generate-encryption-key\")\n+@PerLookup\n+public class GenerateEncryptionKey extends LocalDomainCommand {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final LocalStringsImpl SERVERMGMT_CLI_STRINGS =\n+            new LocalStringsImpl(ChangeMasterPasswordCommandDAS.class);\n+    private static final Random random = new SecureRandom();\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static final String AES = \"AES\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        checkDomainIsNotRunning();\n+        char[] masterPasswordChars = verifyMasterPassword();\n+\n+        File datagridKeyFile = new File(getServerDirs().getConfigDir(), DATAGRID_KEY_FILE);\n+        if (!datagridKeyFile.exists()) {\n+            createDatagridEncryptionKeyFile(datagridKeyFile);\n+        }\n+\n+        byte[] encodedKey = generateAndEncryptKey(masterPasswordChars);\n+\n+        try {\n+            Files.write(datagridKeyFile.toPath(), encodedKey);\n+        } catch (IOException ioe) {\n+            throw new CommandException(\"Error writing encoded key to file\", ioe);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void checkDomainIsNotRunning() throws CommandException {\n+        HostAndPort adminAddress = getAdminAddress();\n+        if (NetUtils.isRunning(adminAddress.getHost(), adminAddress.getPort())) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"domain.is.running\",\n+                    getDomainName(), getDomainRootDir()));\n+        }\n+    }\n+\n+    private char[] verifyMasterPassword() throws CommandException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjU2Nw==", "bodyText": "I'm no security expert but the use of random salt confuses me. If the salt is random there is no way to redo this even if we would know the master password. Hence, the master password is irrelevant for this and we could equally just use random bytes. AFAIK salt usually is a fix yet configurable string that isn't accessible from the \"outside\".\n@rdebusscher WDYT?\nWith random salt I assume there is no way to verify that an encryption key belongs to a certain master password? So we rely on that password and encryption key change together? Is this how this kind of thing is done?", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367346567", "createdAt": "2020-01-16T10:39:25Z", "author": {"login": "jbee"}, "path": "nucleus/admin/server-mgmt/src/main/java/fish/payara/admin/servermgmt/cli/GenerateEncryptionKey.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.admin.servermgmt.cli;\n+\n+import com.sun.enterprise.admin.servermgmt.cli.ChangeMasterPasswordCommandDAS;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.i18n.LocalStringsImpl;\n+import com.sun.enterprise.util.HostAndPort;\n+import com.sun.enterprise.util.net.NetUtils;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.glassfish.security.common.FileProtectionUtility;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+\n+@Service(name = \"generate-encryption-key\")\n+@PerLookup\n+public class GenerateEncryptionKey extends LocalDomainCommand {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final LocalStringsImpl SERVERMGMT_CLI_STRINGS =\n+            new LocalStringsImpl(ChangeMasterPasswordCommandDAS.class);\n+    private static final Random random = new SecureRandom();\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static final String AES = \"AES\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        checkDomainIsNotRunning();\n+        char[] masterPasswordChars = verifyMasterPassword();\n+\n+        File datagridKeyFile = new File(getServerDirs().getConfigDir(), DATAGRID_KEY_FILE);\n+        if (!datagridKeyFile.exists()) {\n+            createDatagridEncryptionKeyFile(datagridKeyFile);\n+        }\n+\n+        byte[] encodedKey = generateAndEncryptKey(masterPasswordChars);\n+\n+        try {\n+            Files.write(datagridKeyFile.toPath(), encodedKey);\n+        } catch (IOException ioe) {\n+            throw new CommandException(\"Error writing encoded key to file\", ioe);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void checkDomainIsNotRunning() throws CommandException {\n+        HostAndPort adminAddress = getAdminAddress();\n+        if (NetUtils.isRunning(adminAddress.getHost(), adminAddress.getPort())) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"domain.is.running\",\n+                    getDomainName(), getDomainRootDir()));\n+        }\n+    }\n+\n+    private char[] verifyMasterPassword() throws CommandException {\n+        String masterpassword = super.readFromMasterPasswordFile();\n+        if (masterpassword == null) {\n+            masterpassword = passwords.get(\"AS_ADMIN_MASTERPASSWORD\");\n+            if (masterpassword == null) {\n+                char[] masterpasswordChars = super.readPassword(SERVERMGMT_CLI_STRINGS.get(\"current.mp\"));\n+                masterpassword = masterpasswordChars != null ? new String(masterpasswordChars) : null;\n+            }\n+        }\n+        if (masterpassword == null) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"no.console\"));\n+        }\n+        if (!super.verifyMasterPassword(masterpassword)) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"incorrect.mp\"));\n+        }\n+\n+        return masterpassword.toCharArray();\n+    }\n+\n+    private void createDatagridEncryptionKeyFile(File datagridKeyFile) throws CommandException {\n+        try {\n+            // Windows defaults to essentially \"7\" for current user, Admins, and System\n+            Files.createFile(datagridKeyFile.toPath());\n+            FileProtectionUtility.chmod0600(datagridKeyFile);\n+        } catch (IOException ioe) {\n+            throw new CommandException(ioe.getMessage(), ioe);\n+        }\n+    }\n+\n+    private byte[] generateAndEncryptKey(char[] masterpasswordChars) throws CommandException {\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0Nzg1Ng==", "bodyText": "This code looks familiar...", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367347856", "createdAt": "2020-01-16T10:42:09Z", "author": {"login": "jbee"}, "path": "nucleus/cluster/cli/src/main/java/com/sun/enterprise/admin/cli/cluster/ChangeNodeMasterPasswordCommand.java", "diffHunk": "@@ -242,4 +259,12 @@ private boolean isRunning(File instanceDir) throws CommandException {\n         }\n     }\n \n+    private boolean dataGridEncryptionEnabled() throws IOException, SAXException, ParserConfigurationException {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder builder = factory.newDocumentBuilder();\n+        Document document = builder.parse(getDomainXml());\n+        return Boolean.valueOf(document.getElementsByTagName(\"hazelcast-runtime-configuration\")\n+                .item(0).getAttributes().getNamedItem(\"datagrid-encryption-enabled\").getNodeValue());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0ODI1OQ==", "bodyText": "Multi-threading?", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367348259", "createdAt": "2020-01-16T10:43:03Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -116,6 +118,8 @@\n     private String memberName;\n     private String memberGroup;\n \n+    private boolean datagridEncryptionChanged = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MDAzMA==", "bodyText": "Could be return datagridEncryptionChanged ^ configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\")\nbut I don't get who a method called isDatagridEncryptionEnabled would return true when the configuration is false. That does not make sense for me even if the encryption has changed.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367350030", "createdAt": "2020-01-16T10:46:54Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -555,6 +561,26 @@ public int getPort() {\n \n     @Override\n     public UnprocessedChangeEvents changed(PropertyChangeEvent[] pces) {\n-        return null;\n+        List<UnprocessedChangeEvent> unprocessedChanges = new ArrayList<>();\n+        for (PropertyChangeEvent pce : pces) {\n+            if (pce.getPropertyName().equalsIgnoreCase(\"datagrid-encryption-enabled\")) {\n+                datagridEncryptionChanged = true;\n+                unprocessedChanges.add(new UnprocessedChangeEvent(pce, \"Hazelcast encryption settings changed\"));\n+            }\n+        }\n+\n+        if (unprocessedChanges.isEmpty()) {\n+            return null;\n+        }\n+        return new UnprocessedChangeEvents(unprocessedChanges);\n+    }\n+\n+    public boolean isDatagridEncryptionEnabled() {\n+        // If the datagrid encryption settings have changed, we want to return the opposite of the current setting\n+        // to prevent the server changing encryption behaviour without a restart\n+        if (datagridEncryptionChanged) {\n+            return !configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");\n+        }\n+        return  configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1MTU3Mg==", "bodyText": "Looks exactly like the code generating the key if I'm not mistaken.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367351572", "createdAt": "2020-01-16T10:50:15Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();\n+    }\n+\n+    public static String encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return Base64.getEncoder().encodeToString(buffer);\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NDc1Mg==", "bodyText": "I don't see why this would be a String instead of byte[] directly. The extra step of encoding that as String again seems unnecessary and a potential source or trouble.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367354752", "createdAt": "2020-01-16T10:57:34Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/PayaraHazelcastEncryptedValueHolder.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ */\n+public class PayaraHazelcastEncryptedValueHolder implements Serializable {\n+\n+    private String encryptedObjectString;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NTUxOQ==", "bodyText": "Is this intentionally build so it will not change until JVM is restarted even in case the underlying source (file?) should change?", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367355519", "createdAt": "2020-01-16T10:59:12Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1NjE4NQ==", "bodyText": "What about encrypting null references?\nIf I read code in store correctly nulls are not wrapped and stored \"plain\".", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367356185", "createdAt": "2020-01-16T11:00:43Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/SymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class SymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        secretKey = readAndDecryptSecretKey();\n+    }\n+\n+    public static String encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return Base64.getEncoder().encodeToString(buffer);\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException\n+                | InvalidParameterSpecException | BadPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] decode(String encryptedText) {\n+        byte[] decryptedTextBytes;\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(Base64.getDecoder().decode((encryptedText)));\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            byte[] encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+\n+            buffer.get(encryptedTextBytes);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(ivBytes));\n+            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n+        } catch (BadPaddingException exception) {\n+            // BadPaddingException -> Wrong key\n+            throw new HazelcastException(\"BadPaddingException caught decoding data, \" +\n+                    \"this can be caused by an incorrect or changed key: \", exception);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+\n+        return decryptedTextBytes;\n+    }\n+\n+    private static SecretKey readAndDecryptSecretKey() {\n+        ServerEnvironment serverEnvironment = Globals.getDefaultBaseServiceLocator().getService(ServerEnvironment.class);\n+        char[] masterPassword = Globals.getDefaultBaseServiceLocator().getService(MasterPasswordImpl.class).getMasterPassword();\n+\n+        byte[] encryptedBytes = null;\n+        try {\n+            encryptedBytes = Files.readAllBytes(\n+                    new File(serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE).toPath());\n+        } catch (IOException ioe) {\n+            Logger.getLogger(SymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error reading datagrid key, please check if it's accessible at expected location: \"\n+                            + serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE);\n+            throw new HazelcastException(\"Error reading encrypted key\", ioe);\n+        }\n+\n+        if (encryptedBytes == null) {\n+            throw new HazelcastException(\"Encrypted key appears to be null\");\n+        }\n+\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(Base64.getDecoder().decode(encryptedBytes));\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            byte[] encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+            buffer.get(encryptedTextBytes);\n+\n+            // Deriving the key\n+            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBKDF_ALGORITHM);\n+            PBEKeySpec spec = new PBEKeySpec(masterPassword, saltBytes, ITERATION_COUNT, KEYSIZE);\n+            SecretKey secretKeySpec = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), AES);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(ivBytes));\n+            return new SecretKeySpec(cipher.doFinal(encryptedTextBytes), \"AES\");\n+        } catch (BadPaddingException bpe) {\n+            throw new HazelcastException(\"BadPaddingException caught decrypting data grid key\" +\n+                    \"- likely caused by an incorrect or changed master password\", bpe);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | InvalidKeySpecException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] objectToByteArray(Object object) {\n+        byte[] bytes = null;\n+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos)) {\n+            out.writeObject(object);\n+            bytes = bos.toByteArray();\n+        } catch (IOException ioe) {\n+            // See \"if (bytes == null)\"\n+        }\n+        if (bytes == null) {\n+            throw new HazelcastException(\"Error converting Object to Byte Array\");\n+        }\n+        return bytes;\n+    }\n+\n+    public static Object byteArrayToObject(byte[] bytes) {\n+        Object object;\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes)) {\n+            object = IOUtil.newObjectInputStream(Thread.currentThread().getContextClassLoader(), null, bis).readObject();\n+        } catch (IOException | ClassNotFoundException exception) {\n+            throw new HazelcastException(\"Error converting Byte Array to Object\", exception);\n+        }\n+        if (object == null) {\n+            throw new HazelcastException(\"Object appears to be null, something probably went wrong converting Byte Array to Object\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM1ODA2MQ==", "bodyText": "Same code as above L194-200\nBTW: instanceof \"includes\" a check != null as a null reference will come out as false", "url": "https://github.com/payara/Payara/pull/4433#discussion_r367358061", "createdAt": "2020-01-16T11:05:19Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/store/ClusteredStore.java", "diffHunk": "@@ -212,26 +226,19 @@ public void event(Event event) {\n             if (map != null) {\n                 Set<Serializable> keys = map.keySet();\n                 for (Serializable key : keys) {\n-                    result.put(key, (Serializable) map.get(key));\n+                    Serializable value = (Serializable) map.get(key);\n+\n+                    if (value != null && hzCore.isDatagridEncryptionEnabled()\n+                            && value instanceof PayaraHazelcastEncryptedValueHolder) {\n+                        value = (Serializable) SymmetricEncryptor.byteArrayToObject(\n+                                SymmetricEncryptor.decode(\n+                                        ((PayaraHazelcastEncryptedValueHolder) value).getEncryptedObjectString()));\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d545b6ebb7598b7194def1bd2eb232d13f4fcf3", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/4d545b6ebb7598b7194def1bd2eb232d13f4fcf3", "committedDate": "2020-01-16T11:58:03Z", "message": "PAYARA-3324 Kill Hazelcast if error reading encryption key"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d449bf7b9b98cd749077937fdd0a7d1470edc1f", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/7d449bf7b9b98cd749077937fdd0a7d1470edc1f", "committedDate": "2020-01-16T12:21:16Z", "message": "PAYARA-3324 Better null handling when checking if encryption is enabled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b0369f09b6d68c77be29de279fc6f3da0afca3", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/34b0369f09b6d68c77be29de279fc6f3da0afca3", "committedDate": "2020-01-17T11:58:41Z", "message": "PAYARA-3324 Address most review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjgyMzc1", "url": "https://github.com/payara/Payara/pull/4433#pullrequestreview-344682375", "createdAt": "2020-01-17T16:08:57Z", "commit": {"oid": "34b0369f09b6d68c77be29de279fc6f3da0afca3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjowODo1N1rOFe90dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjowODo1N1rOFe90dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNDQ1NQ==", "bodyText": "If oldDatagridEncryptionValue is returned in case it is different to datagridEncryptionEnabled this method can be simplified to just return oldDatagridEncryptionValue.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368014455", "createdAt": "2020-01-17T16:08:57Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/HazelcastCore.java", "diffHunk": "@@ -555,6 +561,26 @@ public int getPort() {\n \n     @Override\n     public UnprocessedChangeEvents changed(PropertyChangeEvent[] pces) {\n-        return null;\n+        List<UnprocessedChangeEvent> unprocessedChanges = new ArrayList<>();\n+        for (PropertyChangeEvent pce : pces) {\n+            if (pce.getPropertyName().equalsIgnoreCase(\"datagrid-encryption-enabled\")) {\n+                unprocessedChanges.add(new UnprocessedChangeEvent(pce, \"Hazelcast encryption settings changed\"));\n+            }\n+        }\n+\n+        if (unprocessedChanges.isEmpty()) {\n+            return null;\n+        }\n+        return new UnprocessedChangeEvents(unprocessedChanges);\n+    }\n+\n+    public boolean isDatagridEncryptionEnabled() {\n+        // If the datagrid encryption settings have changed, we want to return the opposite of the current setting\n+        // to prevent the server changing encryption behaviour without a restart\n+        boolean datagridEncryptionEnabled = configuration.getDatagridEncryptionEnabled().equalsIgnoreCase(\"true\");\n+        if (oldDatagridEncryptionValue != datagridEncryptionEnabled) {\n+            return oldDatagridEncryptionValue;\n+        }\n+        return datagridEncryptionEnabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34b0369f09b6d68c77be29de279fc6f3da0afca3"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/7a84767d6d1414fa5306fd394fb6d51d878804f2", "committedDate": "2020-01-17T17:01:53Z", "message": "D'oh!"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTY4MjUw", "url": "https://github.com/payara/Payara/pull/4433#pullrequestreview-345168250", "createdAt": "2020-01-20T09:20:10Z", "commit": {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQwOToyMDoxMFrOFfXvZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMDozMDoxOFrOFfZ3mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQzOTE0Mw==", "bodyText": "If the salt is random there is no way to redo this even if we would know the master password. With random salt I assume there is no way to verify that an encryption key belongs to a certain master password?\n\n@jbee Correct, but we also store the salt when we need the symmetric key. This implementation is correct. Lets recap the process.\n\nWe need a Symmetric Key for the encryption with the Data Grid (call it DataGridSymKey).\nThis key needs to be stored on disk because it needs to be transferred to to other nodes/instances. So we need to encrypt it when stored on disk.\nWe need to encrypt it with something user/domain specific which is already safely stored, like the master password\nPassword are bad for encryption because they are mostly too short, hence the use of the Key Derivation function.\nPBKDF needs a salt and password to generate an enhanced 'password' (which is again a Symmetric Key EncryptionSymKey, which can be used to encrypt the DataGridSymKey.\nWhen decoding to retrieve the DataGridSymKey, we need the EncryptionSymKey. This can be generated again using the Master password and the salt.\nThat is the reason why the salt is also part of the output (see line 165 and next)\n\nSo the salt is used to generate a unique key, although 2 systems have the same master password, the key is different .", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368439143", "createdAt": "2020-01-20T09:20:10Z", "author": {"login": "rdebusscher"}, "path": "nucleus/admin/server-mgmt/src/main/java/fish/payara/admin/servermgmt/cli/GenerateEncryptionKey.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.admin.servermgmt.cli;\n+\n+import com.sun.enterprise.admin.servermgmt.cli.ChangeMasterPasswordCommandDAS;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.i18n.LocalStringsImpl;\n+import com.sun.enterprise.util.HostAndPort;\n+import com.sun.enterprise.util.net.NetUtils;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.glassfish.security.common.FileProtectionUtility;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Base64;\n+import java.util.Random;\n+\n+@Service(name = \"generate-encryption-key\")\n+@PerLookup\n+public class GenerateEncryptionKey extends LocalDomainCommand {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final LocalStringsImpl SERVERMGMT_CLI_STRINGS =\n+            new LocalStringsImpl(ChangeMasterPasswordCommandDAS.class);\n+    private static final Random random = new SecureRandom();\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static final String AES = \"AES\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        checkDomainIsNotRunning();\n+        char[] masterPasswordChars = verifyMasterPassword();\n+\n+        File datagridKeyFile = new File(getServerDirs().getConfigDir(), DATAGRID_KEY_FILE);\n+        if (!datagridKeyFile.exists()) {\n+            createDatagridEncryptionKeyFile(datagridKeyFile);\n+        }\n+\n+        byte[] encodedKey = generateAndEncryptKey(masterPasswordChars);\n+\n+        try {\n+            Files.write(datagridKeyFile.toPath(), encodedKey);\n+        } catch (IOException ioe) {\n+            throw new CommandException(\"Error writing encoded key to file\", ioe);\n+        }\n+\n+        return 0;\n+    }\n+\n+    private void checkDomainIsNotRunning() throws CommandException {\n+        HostAndPort adminAddress = getAdminAddress();\n+        if (NetUtils.isRunning(adminAddress.getHost(), adminAddress.getPort())) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"domain.is.running\",\n+                    getDomainName(), getDomainRootDir()));\n+        }\n+    }\n+\n+    private char[] verifyMasterPassword() throws CommandException {\n+        String masterpassword = super.readFromMasterPasswordFile();\n+        if (masterpassword == null) {\n+            masterpassword = passwords.get(\"AS_ADMIN_MASTERPASSWORD\");\n+            if (masterpassword == null) {\n+                char[] masterpasswordChars = super.readPassword(SERVERMGMT_CLI_STRINGS.get(\"current.mp\"));\n+                masterpassword = masterpasswordChars != null ? new String(masterpasswordChars) : null;\n+            }\n+        }\n+        if (masterpassword == null) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"no.console\"));\n+        }\n+        if (!super.verifyMasterPassword(masterpassword)) {\n+            throw new CommandException(SERVERMGMT_CLI_STRINGS.get(\"incorrect.mp\"));\n+        }\n+\n+        return masterpassword.toCharArray();\n+    }\n+\n+    private void createDatagridEncryptionKeyFile(File datagridKeyFile) throws CommandException {\n+        try {\n+            // Windows defaults to essentially \"7\" for current user, Admins, and System\n+            Files.createFile(datagridKeyFile.toPath());\n+            FileProtectionUtility.chmod0600(datagridKeyFile);\n+        } catch (IOException ioe) {\n+            throw new CommandException(ioe.getMessage(), ioe);\n+        }\n+    }\n+\n+    private byte[] generateAndEncryptKey(char[] masterpasswordChars) throws CommandException {\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NjU2Nw=="}, "originalCommit": {"oid": "93024348d2b320a12991bcc36a1c12bf08bb3408"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjExMA==", "bodyText": "With Boolean.parseBoolean there is no autoboxing in the code.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368472110", "createdAt": "2020-01-20T10:26:29Z", "author": {"login": "rdebusscher"}, "path": "nucleus/admin/server-mgmt/src/main/java/com/sun/enterprise/admin/servermgmt/cli/LocalServerCommand.java", "diffHunk": "@@ -612,4 +619,25 @@ private long getEndTime() {\n         return CLIConstants.WAIT_FOR_DAS_TIME_MS + now();\n     }\n \n+    protected boolean dataGridEncryptionEnabled() throws IOException, XMLStreamException {\n+        // We can't access config beans from this invocation due to it being CLI vs. ASAdmin command - it's not\n+        // executing against a running server. This means we need to read directly from the domain.xml.\n+        XMLEventReader xmlReader = XMLInputFactory.newInstance().createXMLEventReader(new FileInputStream(getDomainXml()));\n+        while (xmlReader.hasNext()) {\n+            XMLEvent event = xmlReader.nextEvent();\n+\n+            if (event.isStartElement()\n+                    && event.asStartElement().getName().getLocalPart().equals(\"hazelcast-runtime-configuration\")) {\n+                Attribute attribute = event.asStartElement().getAttributeByName(new QName(\"datagrid-encryption-enabled\"));\n+                if (attribute == null) {\n+                    return false;\n+                }\n+                return Boolean.valueOf(attribute.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjYwMg==", "bodyText": "Explicit types not needed.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368472602", "createdAt": "2020-01-20T10:27:28Z", "author": {"login": "rdebusscher"}, "path": "appserver/ha/ha-hazelcast-store/src/main/java/fish/payara/ha/hazelcast/store/HazelcastBackingStoreFactory.java", "diffHunk": "@@ -36,9 +60,12 @@ and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n     @Inject\n     HazelcastCore core;\n \n+    @Inject\n+    ClusteredStore clusteredStore;\n+\n     @Override\n     public <K extends Serializable, V extends Serializable> BackingStore<K, V> createBackingStore(BackingStoreConfiguration<K, V> bsc) throws BackingStoreException {\n-        return new HazelcastBackingStore<K, V>(this, bsc.getStoreName(), core);\n+        return new HazelcastBackingStore<K, V>(this, bsc.getStoreName(), clusteredStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3NDAxMQ==", "bodyText": "encryptedBytes is never null as Files.readAllBytes never returns null.", "url": "https://github.com/payara/Payara/pull/4433#discussion_r368474011", "createdAt": "2020-01-20T10:30:18Z", "author": {"login": "rdebusscher"}, "path": "nucleus/payara-modules/hazelcast-bootstrap/src/main/java/fish/payara/nucleus/hazelcast/encryption/HazelcastSymmetricEncryptor.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.hazelcast.encryption;\n+\n+import com.hazelcast.core.HazelcastException;\n+import com.hazelcast.nio.IOUtil;\n+import com.sun.enterprise.security.ssl.impl.MasterPasswordImpl;\n+import fish.payara.nucleus.hazelcast.HazelcastCore;\n+import org.glassfish.api.admin.ServerEnvironment;\n+import org.glassfish.internal.api.Globals;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Random;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Class that encodes and decodes symmetric keys.\n+ *\n+ * @author Andrew Pielage <andrew.pielage@payara.fish>\n+ * @author Rudy De Busscher <rudy.de.busscher@payara.fish>\n+ */\n+public class HazelcastSymmetricEncryptor {\n+\n+    private static final String DATAGRID_KEY_FILE = \"datagrid-key\";\n+    private static final String AES_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n+    private static final String PBKDF_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+    private static final String AES = \"AES\";\n+    private static final int ITERATION_COUNT = 65556;\n+    private static final int KEYSIZE = 256;\n+    private static Random random = new SecureRandom();\n+    private static SecretKey secretKey;\n+\n+    static {\n+        try {\n+            secretKey = readAndDecryptSecretKey();\n+        } catch (Exception exception) {\n+            // Shutting down Payara from the thread we're running in can only be done in fairly brutal ways\n+            Logger.getLogger(HazelcastSymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error starting Hazelcast due to exception reading encryption key\", exception);\n+            Globals.get(HazelcastCore.class).getInstance().shutdown();\n+        }\n+    }\n+\n+    public static byte[] encode(byte[] value) {\n+        // Generate IV.\n+        byte[] saltBytes = new byte[20];\n+        random.nextBytes(saltBytes);\n+\n+        try {\n+            // Encrypting the data\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n+            AlgorithmParameters params = cipher.getParameters();\n+            byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            byte[] encryptedTextBytes = cipher.doFinal(value);\n+\n+            // Prepend salt and IV\n+            byte[] buffer = new byte[saltBytes.length + ivBytes.length + encryptedTextBytes.length];\n+            System.arraycopy(saltBytes, 0, buffer, 0, saltBytes.length);\n+            System.arraycopy(ivBytes, 0, buffer, saltBytes.length, ivBytes.length);\n+            System.arraycopy(encryptedTextBytes, 0, buffer, saltBytes.length + ivBytes.length,\n+                    encryptedTextBytes.length);\n+            return buffer;\n+        } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException\n+                | InvalidParameterSpecException | BadPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+    }\n+\n+    public static byte[] decode(byte[] encryptedTextBytes) {\n+        byte[] decryptedTextBytes;\n+        try {\n+            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n+            // Strip off the salt and IV\n+            ByteBuffer buffer = ByteBuffer.wrap(encryptedTextBytes);\n+            byte[] saltBytes = new byte[20];\n+            buffer.get(saltBytes, 0, saltBytes.length);\n+            byte[] ivBytes = new byte[cipher.getBlockSize()];\n+            buffer.get(ivBytes, 0, ivBytes.length);\n+            encryptedTextBytes = new byte[buffer.capacity() - saltBytes.length - ivBytes.length];\n+\n+            buffer.get(encryptedTextBytes);\n+            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(ivBytes));\n+            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n+        } catch (BadPaddingException exception) {\n+            // BadPaddingException -> Wrong key\n+            throw new HazelcastException(\"BadPaddingException caught decoding data, \" +\n+                    \"this can be caused by an incorrect or changed key: \", exception);\n+        } catch (IllegalBlockSizeException | NoSuchAlgorithmException | InvalidAlgorithmParameterException\n+                | InvalidKeyException | NoSuchPaddingException exception) {\n+            throw new HazelcastException(exception);\n+        }\n+\n+        return decryptedTextBytes;\n+    }\n+\n+    private static SecretKey readAndDecryptSecretKey() {\n+        ServerEnvironment serverEnvironment = Globals.getDefaultBaseServiceLocator().getService(ServerEnvironment.class);\n+        char[] masterPassword = Globals.getDefaultBaseServiceLocator().getService(MasterPasswordImpl.class).getMasterPassword();\n+\n+        byte[] encryptedBytes = null;\n+        try {\n+            encryptedBytes = Files.readAllBytes(\n+                    new File(serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE).toPath());\n+        } catch (IOException ioe) {\n+            Logger.getLogger(HazelcastSymmetricEncryptor.class.getName()).log(Level.SEVERE,\n+                    \"Error reading datagrid key, please check if it's accessible at expected location: \"\n+                            + serverEnvironment.getConfigDirPath() + File.separator + DATAGRID_KEY_FILE);\n+            throw new HazelcastException(\"Error reading encrypted key\", ioe);\n+        }\n+\n+        if (encryptedBytes == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a84767d6d1414fa5306fd394fb6d51d878804f2"}, "originalPosition": 172}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "969f3cff70a0bf27ad98ff698fa6723bbc7350dc", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/969f3cff70a0bf27ad98ff698fa6723bbc7350dc", "committedDate": "2020-01-21T10:57:06Z", "message": "Rdebusscher Review Comments\n\nRemove unnecessary autoboxing and null check, and use diamond operator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTEyMzQz", "url": "https://github.com/payara/Payara/pull/4433#pullrequestreview-346512343", "createdAt": "2020-01-22T11:17:49Z", "commit": {"oid": "969f3cff70a0bf27ad98ff698fa6723bbc7350dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bab2e6b860ca9650da239ece3fc4604e4916ab8c", "author": {"user": {"login": "Pandrex247", "name": "Andrew Pielage"}}, "url": "https://github.com/payara/Payara/commit/bab2e6b860ca9650da239ece3fc4604e4916ab8c", "committedDate": "2020-01-22T15:28:15Z", "message": "APPSERV-41 Add encryption enabled log messages"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 840, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}