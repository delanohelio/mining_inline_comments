{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NDYwMTgz", "number": 4602, "title": "APPSERV-114 Addresses possible sources of Race Conditions in InvocationManager", "bodyText": "Background\nRunning FT TCK strongly suggested that a race condition in or around the InvocationManger leads to inconsistent context when trying to derive the current application like shown below:\n ComponentInvocation current = invocationManager.getCurrentInvocation();\n if (current == null) {\n     return invocationManager.peekAppEnvironment().getName();\n }\n String appName = current.getAppName();\n if (appName == null) {\n     appName = current.getModuleName();\n }\n if (appName == null) {\n     appName = current.getComponentId();\n }\nreturn appName;\nThe issue observed was that different application names were returned in a non deterministic manner for the actual same application processing tests.\nSummary\nThe most likely cause is related to the frames that push and pop the stack which is peeked by getCurrentInvocation(). But it could also be related to application environment stack peeked by peekAppEnvironment() for case that not ComponentInvocation was on the stack.\nThe issue can either be within the implementation of the InvocationMangerImpl but also on the outside as the  ComponentInvocation is essentially managed from the outside by calling preInvoke and postInvoke.\nChanges:\n\nremoves the unnecessary generic of the InvocationArray / InvocationFrames (renamed) inner class\nreplaces use of Stack with ConcurrentLinkedDeque (synchronized vs. CAS based synchronisation)\nreplaces ArrayList as bases of frames stack with ConcurrentLinkedDeque (as this is only used via thread local non synchronised should not be an issue but to be sure and to provide better readability of the base class was changed)\nreplaces ComponentInvocationHandler[] handlers with a single ComponentInvocationHandler that is initialised with ListComponentInvocationHandler in case multiple handlers are actually needed. The underlying List uses ArrayList as it is read-only after being initialised. This allows to simplify the rest of the implementation that only has to assume a single handler.\nuses ListComponentInvocationHandler to manage RegisteredComponentInvocationHandler. In this case the underlying List uses a CopyOnWriteArrayList as multiple threads might register handlers concurrently.\nreplaces the Map for RegisteredComponentInvocationHandler (that are per type) with a thread-safe ConcurrentHashMap as multiple threads can register handlers concurrently.\nadds try-finally to preInvoke to make sure that any exception thrown by handlers does not prevent adding of the invocation instance (I'd say this is the best candidate for the observed issue)\n\nTesting\nThe implementation of InvocationMangerImpl got covered with unit tests to a coverage > 95%.\nThis mostly intends to make sure the changes in the implementation do not cause unexpected behaviour, in particular throwing exceptions when it should not. The tests do include a few tests that include multiple threads to verify the thread parent-child stack inheritance behaviour, not to show that the class is thread-safe. To allow better reasoning about thread safety the implementation was cleaned and simplified so the use of collection becomes more clear.\nTesting Performed\nThe unit tests were added mostly to make sure changes did not introduce new bugs like NPEs and alike and that the implementation does behave as expected from reading the code.\nIn addition I ran the FT TCK as that had shown issues before and since it deploying lots of applications.", "createdAt": "2020-04-02T09:28:30Z", "url": "https://github.com/payara/Payara/pull/4602", "merged": true, "mergeCommit": {"oid": "fbbd633a745c9aa827eddc42a4b50cf6faa4afbf"}, "closed": true, "closedAt": "2020-04-22T10:10:15Z", "author": {"login": "jbee"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTUzoCAH2gAyMzk3NDYwMTgzOjRiYjc1MDMxZmQ1N2FmMDRjYjIyMjJkNTkxODc4OGQ3ODIyNzJlYTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaEPyvgH2gAyMzk3NDYwMTgzOmI1YmRhYTIyNzkxY2JmZWIzNjE0MDUxMTM0MDgyNWEyNTUyZjdlODQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4bb75031fd57af04cb2222d5918788d782272ea1", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/4bb75031fd57af04cb2222d5918788d782272ea1", "committedDate": "2020-04-01T10:05:08Z", "message": "APPSERV-114 cleanup invocation handlers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b585421ebe9ca2307a0533f353f7c0ba4990a4a3", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/b585421ebe9ca2307a0533f353f7c0ba4990a4a3", "committedDate": "2020-04-02T08:42:31Z", "message": "APPSERV-114 use of concurrent collections in InvocationManagerImpl; adds tests for invocation frame logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/1eca37c1479fc38ea61aa667b5393b26b3218a99", "committedDate": "2020-04-02T09:02:25Z", "message": "APPSERV-114 adds tests for AppEnvironment and WebServiceMethod stacks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjU3MDkx", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-386257091", "createdAt": "2020-04-02T09:32:00Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTozMjowMFrOF_jAlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTozMjowMFrOF_jAlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE3ODE5OA==", "bodyText": "NB: while the use of thread local should ensure that multiple calls to getCurrentInvocation() should return the same instance it is better to not take changes and do it once. Also improves readability.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402178198", "createdAt": "2020-04-02T09:32:00Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/metrics/src/main/java/fish/payara/microprofile/metrics/MetricsService.java", "diffHunk": "@@ -418,15 +419,16 @@ private void deregisterApplication(String applicationName) {\n     public String getApplicationName() {\n         InvocationManager invocationManager = Globals.getDefaultBaseServiceLocator()\n                 .getService(InvocationManager.class);\n-        if (invocationManager.getCurrentInvocation() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY5MTk1", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-386269195", "createdAt": "2020-04-02T09:48:29Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0ODozMFrOF_jndQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0ODozMFrOF_jndQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4ODE0OQ==", "bodyText": "NB. Using HashMap here is definitely not thread-safe but should be. But is is hard to see how this can cause the observed issues. However, we do talk about multi-threading so everything is possible :D", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402188149", "createdAt": "2020-04-02T09:48:30Z", "author": {"login": "jbee"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjY5OTUx", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-386269951", "createdAt": "2020-04-02T09:49:30Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0OTozMFrOF_jpwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo0OTozMFrOF_jpwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4ODczNw==", "bodyText": "NB. Replacing Stack here is more of a modernisation to avoid sychronized in favour of CAS based synchronisation.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402188737", "createdAt": "2020-04-02T09:49:30Z", "author": {"login": "jbee"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjcyNjY3", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-386272667", "createdAt": "2020-04-02T09:53:11Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1MzoxMVrOF_jyRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1MzoxMVrOF_jyRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5MDkxOA==", "bodyText": "NB. Missing try-finally here to make sure the frames.addLast(invocation); will definitely happen is my best guess on what might have caused the issue observed,", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402190918", "createdAt": "2020-04-02T09:53:11Z", "author": {"login": "jbee"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2Mjc4MTg2", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-386278186", "createdAt": "2020-04-02T10:00:39Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowMDo0MFrOF_kETw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDowMDo0MFrOF_kETw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5NTUzNQ==", "bodyText": "NB. You might have noticed that invocation is passed to afterPostInvoke instead of curInv. I believe this is just a inconsistency in the chosen way to express the logic. At this point curInv is (or really should be) invocation. To avoid any future confusion I unified it to use invocation everywhere as it is done in preInvoke and as I think it makes most sense as this is what is passed to the method as \"current\". It is unfortunate how the API was designed and that it leaves room for inconsistencies like calling postInvoke with a different value then preInvoke. postInvoke really should not have had an argument as the current is that pushed to the stack when invoking preInvoke. Or the API should have made clear that the argument is only passed to postInvoke to verify that the nesting is correct and that it indeed is the current top of the stack.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r402195535", "createdAt": "2020-04-02T10:00:40Z", "author": {"login": "jbee"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwOTQ5NDE4", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-390949418", "createdAt": "2020-04-09T16:30:28Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Mjg2ODg2", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-395286886", "createdAt": "2020-04-17T09:07:40Z", "commit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwOTowNzo0MFrOGHGGhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMDoxMDo0OFrOGHIL9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5MzE4OA==", "bodyText": "Isn't ArrayDequeue sufficient here, since it is guaranteed there will not be any cross-thread access as it is thread-local?", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410093188", "createdAt": "2020-04-17T09:07:40Z", "author": {"login": "pdudits"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNjIwMQ==", "bodyText": "Also here I don't see InvocationFrames being used outside thread locals, so I'd infer it doesn't need additional CAS overhead and an ArrayDequeue is sufficient.\nI'm also afraid that extending rather than delegating makes too many public methods available.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410116201", "createdAt": "2020-04-17T09:49:26Z", "author": {"login": "pdudits"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().afterPostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n         }\n-\n     }\n \n     /**\n-     * return true iff no invocations on the stack for this thread\n-     * @return\n+     * @return true iff no invocations on the stack for this thread\n      */\n     @Override\n     public boolean isInvocationStackEmpty() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        return invocations == null || invocations.size() == 0;\n+        InvocationFrames invocations = framesByThread.get();\n+        return invocations == null || invocations.isEmpty();\n     }\n \n     /**\n-     * return the Invocation object of the component being called\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the component being called\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getCurrentInvocation() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize == 0) {\n-            return null;\n-        }\n-\n-        return (T) invocations.get(invocationsSize - 1);\n+        return (T) framesByThread.get().peekLast();\n     }\n \n     /**\n-     * return the Invocation object of the caller\n-     * return null if none exist (e.g. caller is from another VM)\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the caller or null if none exist (e.g. caller is from another VM)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getPreviousInvocation() throws InvocationException {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize < 2) {\n+        Iterator<ComponentInvocation> iter = framesByThread.get().descendingIterator();\n+        if (!iter.hasNext()) {\n             return null;\n         }\n-\n-        return (T) invocations.get(invocationsSize - 2);\n+        iter.next();\n+        if (!iter.hasNext()) {\n+            return null;\n+        }\n+        return (T) iter.next();\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> getAllInvocations() {\n-        return frames.get();\n+        InvocationFrames frames = framesByThread.get();\n+        return frames == null ? emptyList() : new ArrayList<>(frames);\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> popAllInvocations() {\n-        List<? extends ComponentInvocation> result = frames.get();\n-        frames.set(null);\n+        List<? extends ComponentInvocation> result = getAllInvocations();\n+        framesByThread.set(null);\n         return result;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public void putAllInvocations(List<? extends ComponentInvocation> invocations) {\n-        frames.set(new InvocationArray<>((List<ComponentInvocation>) invocations));\n+        framesByThread.set(InvocationFrames.valueOf(invocations));\n     }\n \n-    private InvocationArray<ComponentInvocation> computeChildTheadInvocation(InvocationArray<ComponentInvocation> parentValue) {\n-\n-        // Always creates a new ArrayList\n-        InvocationArray<ComponentInvocation> childInvocationArray = new InvocationArray<ComponentInvocation>();\n-        InvocationArray<ComponentInvocation> parentInvocationArray = parentValue;\n+    static InvocationFrames computeChildTheadInvocation(InvocationFrames parent) {\n+        InvocationFrames childFrames = new InvocationFrames();\n+        InvocationFrames parentFrames = parent;\n \n-        if (parentInvocationArray != null && parentInvocationArray.size() > 0 && parentInvocationArray.outsideStartup()) {\n+        if (parentFrames != null && !parentFrames.isEmpty() && !parentFrames.isStartup()) {\n \n             // Get current invocation\n-            ComponentInvocation parentInvocation = parentInvocationArray.get(parentInvocationArray.size() - 1);\n+            ComponentInvocation parentFrame = parentFrames.getLast();\n \n             // TODO: The following is ugly. The logic of what needs to be in the\n             // new ComponentInvocation should be with the respective container\n \n-            if (parentInvocation.getInvocationType() == SERVLET_INVOCATION) {\n+            ComponentInvocationType parentType = parentFrame.getInvocationType();\n+            if (parentType == SERVLET_INVOCATION) {\n \n                 // If this is a thread created by user in servlet's service method\n                 // create a new ComponentInvocation with transaction\n                 // left to null and instance left to null\n                 // so that the resource won't be enlisted or registered\n \n                 ComponentInvocation invocation = new ComponentInvocation();\n-                invocation.setComponentInvocationType(parentInvocation.getInvocationType());\n-                invocation.setComponentId(parentInvocation.getComponentId());\n-                invocation.setAppName(parentInvocation.getAppName());\n-                invocation.setModuleName(parentInvocation.getModuleName());\n-                invocation.setContainer(parentInvocation.getContainer());\n-                invocation.setJndiEnvironment(parentInvocation.getJndiEnvironment());\n-\n-                childInvocationArray.add(invocation);\n-            } else if (parentInvocation.getInvocationType() != EJB_INVOCATION) {\n-\n+                invocation.setComponentInvocationType(parentType);\n+                invocation.setComponentId(parentFrame.getComponentId());\n+                invocation.setAppName(parentFrame.getAppName());\n+                invocation.setModuleName(parentFrame.getModuleName());\n+                invocation.setContainer(parentFrame.getContainer());\n+                invocation.setJndiEnvironment(parentFrame.getJndiEnvironment());\n+\n+                childFrames.add(invocation);\n+            } else if (parentType != EJB_INVOCATION) {\n                 // Push a copy of invocation onto the new result\n-                // ArrayList\n-                ComponentInvocation cpy = new ComponentInvocation();\n-                cpy.componentId = parentInvocation.getComponentId();\n-                cpy.setComponentInvocationType(parentInvocation.getInvocationType());\n-                cpy.instance = parentInvocation.getInstance();\n-                cpy.container = parentInvocation.getContainerContext();\n-                cpy.transaction = parentInvocation.getTransaction();\n-\n-                childInvocationArray.add(cpy);\n+                childFrames.add(new ComponentInvocation(\n+                        parentFrame.getComponentId(),\n+                        parentType,\n+                        parentFrame.getInstance(),\n+                        parentFrame.getContainerContext(),\n+                        parentFrame.getTransaction()));\n             }\n         }\n \n-        return childInvocationArray;\n+        return childFrames;\n     }\n \n \n-    static class InvocationArray<T extends ComponentInvocation> extends ArrayList<T> {\n+    static final class InvocationFrames extends ConcurrentLinkedDeque<ComponentInvocation> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExNzgwMg==", "bodyText": "Isn't this thread safety requirement valid for all constructions of ListComponentInvocationHandler? If so, it is better handled in its constructors by copying whatever list is on input into its own list.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410117802", "createdAt": "2020-04-17T09:52:17Z", "author": {"login": "pdudits"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().afterPostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.afterPostInvoke(type, prev, invocation);\n             }\n-\n         }\n-\n     }\n \n     /**\n-     * return true iff no invocations on the stack for this thread\n-     * @return\n+     * @return true iff no invocations on the stack for this thread\n      */\n     @Override\n     public boolean isInvocationStackEmpty() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        return invocations == null || invocations.size() == 0;\n+        InvocationFrames invocations = framesByThread.get();\n+        return invocations == null || invocations.isEmpty();\n     }\n \n     /**\n-     * return the Invocation object of the component being called\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the component being called\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getCurrentInvocation() {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize == 0) {\n-            return null;\n-        }\n-\n-        return (T) invocations.get(invocationsSize - 1);\n+        return (T) framesByThread.get().peekLast();\n     }\n \n     /**\n-     * return the Invocation object of the caller\n-     * return null if none exist (e.g. caller is from another VM)\n-     * @param <T>\n-     * @return\n+     * @return the Invocation object of the caller or null if none exist (e.g. caller is from another VM)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T extends ComponentInvocation> T getPreviousInvocation() throws InvocationException {\n-        InvocationArray<ComponentInvocation> invocations = frames.get();\n-        int invocationsSize = invocations.size();\n-        if (invocationsSize < 2) {\n+        Iterator<ComponentInvocation> iter = framesByThread.get().descendingIterator();\n+        if (!iter.hasNext()) {\n             return null;\n         }\n-\n-        return (T) invocations.get(invocationsSize - 2);\n+        iter.next();\n+        if (!iter.hasNext()) {\n+            return null;\n+        }\n+        return (T) iter.next();\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> getAllInvocations() {\n-        return frames.get();\n+        InvocationFrames frames = framesByThread.get();\n+        return frames == null ? emptyList() : new ArrayList<>(frames);\n     }\n \n     @Override\n     public List<? extends ComponentInvocation> popAllInvocations() {\n-        List<? extends ComponentInvocation> result = frames.get();\n-        frames.set(null);\n+        List<? extends ComponentInvocation> result = getAllInvocations();\n+        framesByThread.set(null);\n         return result;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public void putAllInvocations(List<? extends ComponentInvocation> invocations) {\n-        frames.set(new InvocationArray<>((List<ComponentInvocation>) invocations));\n+        framesByThread.set(InvocationFrames.valueOf(invocations));\n     }\n \n-    private InvocationArray<ComponentInvocation> computeChildTheadInvocation(InvocationArray<ComponentInvocation> parentValue) {\n-\n-        // Always creates a new ArrayList\n-        InvocationArray<ComponentInvocation> childInvocationArray = new InvocationArray<ComponentInvocation>();\n-        InvocationArray<ComponentInvocation> parentInvocationArray = parentValue;\n+    static InvocationFrames computeChildTheadInvocation(InvocationFrames parent) {\n+        InvocationFrames childFrames = new InvocationFrames();\n+        InvocationFrames parentFrames = parent;\n \n-        if (parentInvocationArray != null && parentInvocationArray.size() > 0 && parentInvocationArray.outsideStartup()) {\n+        if (parentFrames != null && !parentFrames.isEmpty() && !parentFrames.isStartup()) {\n \n             // Get current invocation\n-            ComponentInvocation parentInvocation = parentInvocationArray.get(parentInvocationArray.size() - 1);\n+            ComponentInvocation parentFrame = parentFrames.getLast();\n \n             // TODO: The following is ugly. The logic of what needs to be in the\n             // new ComponentInvocation should be with the respective container\n \n-            if (parentInvocation.getInvocationType() == SERVLET_INVOCATION) {\n+            ComponentInvocationType parentType = parentFrame.getInvocationType();\n+            if (parentType == SERVLET_INVOCATION) {\n \n                 // If this is a thread created by user in servlet's service method\n                 // create a new ComponentInvocation with transaction\n                 // left to null and instance left to null\n                 // so that the resource won't be enlisted or registered\n \n                 ComponentInvocation invocation = new ComponentInvocation();\n-                invocation.setComponentInvocationType(parentInvocation.getInvocationType());\n-                invocation.setComponentId(parentInvocation.getComponentId());\n-                invocation.setAppName(parentInvocation.getAppName());\n-                invocation.setModuleName(parentInvocation.getModuleName());\n-                invocation.setContainer(parentInvocation.getContainer());\n-                invocation.setJndiEnvironment(parentInvocation.getJndiEnvironment());\n-\n-                childInvocationArray.add(invocation);\n-            } else if (parentInvocation.getInvocationType() != EJB_INVOCATION) {\n-\n+                invocation.setComponentInvocationType(parentType);\n+                invocation.setComponentId(parentFrame.getComponentId());\n+                invocation.setAppName(parentFrame.getAppName());\n+                invocation.setModuleName(parentFrame.getModuleName());\n+                invocation.setContainer(parentFrame.getContainer());\n+                invocation.setJndiEnvironment(parentFrame.getJndiEnvironment());\n+\n+                childFrames.add(invocation);\n+            } else if (parentType != EJB_INVOCATION) {\n                 // Push a copy of invocation onto the new result\n-                // ArrayList\n-                ComponentInvocation cpy = new ComponentInvocation();\n-                cpy.componentId = parentInvocation.getComponentId();\n-                cpy.setComponentInvocationType(parentInvocation.getInvocationType());\n-                cpy.instance = parentInvocation.getInstance();\n-                cpy.container = parentInvocation.getContainerContext();\n-                cpy.transaction = parentInvocation.getTransaction();\n-\n-                childInvocationArray.add(cpy);\n+                childFrames.add(new ComponentInvocation(\n+                        parentFrame.getComponentId(),\n+                        parentType,\n+                        parentFrame.getInstance(),\n+                        parentFrame.getContainerContext(),\n+                        parentFrame.getTransaction()));\n             }\n         }\n \n-        return childInvocationArray;\n+        return childFrames;\n     }\n \n \n-    static class InvocationArray<T extends ComponentInvocation> extends ArrayList<T> {\n+    static final class InvocationFrames extends ConcurrentLinkedDeque<ComponentInvocation> {\n \n         private static final long serialVersionUID = 1L;\n \n-        private ComponentInvocationType invocationAttribute;\n+        private ComponentInvocationType state;\n \n-        private InvocationArray(List<T> invocations) {\n-            super(invocations);\n+        static InvocationFrames valueOf(Collection<? extends ComponentInvocation> invocations) {\n+            return invocations instanceof InvocationFrames\n+                    ? (InvocationFrames) invocations\n+                    : new InvocationFrames(invocations == null ? emptyList() : invocations);\n         }\n \n-        private InvocationArray() {\n+        private InvocationFrames(Collection<? extends ComponentInvocation> invocations) {\n+            super(invocations);\n         }\n \n-        public void setInvocationAttribute(ComponentInvocationType attribute) {\n-            this.invocationAttribute = attribute;\n+        InvocationFrames() {\n         }\n \n-        public ComponentInvocationType getInvocationAttribute() {\n-            return invocationAttribute;\n+        void setState(ComponentInvocationType state) {\n+            this.state = state;\n         }\n \n-        public boolean outsideStartup() {\n-            return getInvocationAttribute() != SERVICE_STARTUP;\n+        boolean isStartup() {\n+            return state == SERVICE_STARTUP;\n         }\n     }\n \n     @Override\n     public void registerComponentInvocationHandler(ComponentInvocationType type, RegisteredComponentInvocationHandler handler) {\n-        List<RegisteredComponentInvocationHandler> setRegCompInvHandlers = regCompInvHandlerMap.get(type);\n-\n-        if (setRegCompInvHandlers == null) {\n-            setRegCompInvHandlers = new ArrayList<RegisteredComponentInvocationHandler>();\n-            regCompInvHandlerMap.put(type, setRegCompInvHandlers);\n-        }\n-\n-        if (setRegCompInvHandlers.size() == 0) {\n-            setRegCompInvHandlers.add(handler);\n-        }\n+        typeHandlers.computeIfAbsent(type,\n+                key -> new ListComponentInvocationHandler(new CopyOnWriteArrayList<>())) // OBS! must be thread safe List here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDEyNzM1MQ==", "bodyText": "I think it is worth a warning when this assumption doesn't hold and you actually have a good spot since you already jump over the invocation head.\nThis might disclose bugs we have around nested transactions or cleanups.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r410127351", "createdAt": "2020-04-17T10:10:48Z", "author": {"login": "pdudits"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -68,347 +71,334 @@\n @Singleton\n public class InvocationManagerImpl implements InvocationManager {\n \n-    // This TLS variable stores an ArrayList.\n-    // The ArrayList contains ComponentInvocation objects which represent\n-    // the stack of invocations on this thread. Accesses to the ArrayList\n-    // don't need to be synchronized because each thread has its own ArrayList.\n-    private InheritableThreadLocal<InvocationArray<ComponentInvocation>> frames;\n-\n-    private final ThreadLocal<Stack<ApplicationEnvironment>> applicationEnvironments = withInitial(Stack<ApplicationEnvironment>::new);\n-    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ArrayDeque<Method>::new);\n-\n-    private Map<ComponentInvocationType, List<RegisteredComponentInvocationHandler>> regCompInvHandlerMap = new HashMap<>();\n-\n-    private final ComponentInvocationHandler[] invHandlers;\n+    private final InheritableThreadLocal<InvocationFrames> framesByThread;\n+    private final ThreadLocal<Deque<ApplicationEnvironment>> appEnvironments = withInitial(ConcurrentLinkedDeque::new);\n+    private final ThreadLocal<Deque<Method>> webServiceMethods = withInitial(ConcurrentLinkedDeque::new);\n+    private final ConcurrentMap<ComponentInvocationType, ListComponentInvocationHandler> typeHandlers = new ConcurrentHashMap<>();\n+    private final ComponentInvocationHandler allTypesHandler;\n \n     public InvocationManagerImpl() {\n-        this(null);\n+        this((ComponentInvocationHandler) null);\n+    }\n+\n+    public InvocationManagerImpl(ComponentInvocationHandler... handlers) {\n+        this(Arrays.asList(handlers));\n     }\n \n     @Inject\n     private InvocationManagerImpl(@Optional IterableProvider<ComponentInvocationHandler> handlers) {\n-        if (handlers == null) {\n-            invHandlers = null;\n-        } else {\n-            LinkedList<ComponentInvocationHandler> localHandlers = new LinkedList<ComponentInvocationHandler>();\n-            for (ComponentInvocationHandler handler : handlers) {\n-                localHandlers.add(handler);\n-            }\n+        this((Iterable<ComponentInvocationHandler>) handlers);\n+    }\n \n-            if (localHandlers.size() > 0) {\n-                invHandlers = localHandlers.toArray(new ComponentInvocationHandler[localHandlers.size()]);\n-            } else {\n-                invHandlers = null;\n-            }\n-        }\n+    private InvocationManagerImpl(Iterable<ComponentInvocationHandler> handlers) {\n+        this.allTypesHandler = initInvocationHandlers(handlers);\n \n-        frames = new InheritableThreadLocal<InvocationArray<ComponentInvocation>>() {\n+        framesByThread = new InheritableThreadLocal<InvocationFrames>() {\n \n-            protected InvocationArray<ComponentInvocation> initialValue() {\n-                return new InvocationArray<>();\n+            @Override\n+            protected InvocationFrames initialValue() {\n+                return new InvocationFrames();\n             }\n \n-            protected InvocationArray<ComponentInvocation> childValue(InvocationArray<ComponentInvocation> parentValue) {\n+            @Override\n+            protected InvocationFrames childValue(InvocationFrames parentValue) {\n                 return computeChildTheadInvocation(parentValue);\n             }\n         };\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n+    private static ComponentInvocationHandler initInvocationHandlers(Iterable<ComponentInvocationHandler> handlers) {\n+        if (handlers == null) {\n+            return null;\n+        }\n+        List<ComponentInvocationHandler> hs = new ArrayList<>();\n+        handlers.forEach(hs::add);\n+        if (hs.isEmpty()) {\n+            return null;\n+        }\n+        if (hs.size() == 1) {\n+            return hs.get(0);\n+        }\n+        return new ListComponentInvocationHandler(hs);\n+    }\n+\n     @Override\n     public void setThreadInheritableInvocation(List<? extends ComponentInvocation> parentValue) {\n-        frames.set(computeChildTheadInvocation((InvocationArray<ComponentInvocation>) parentValue));\n+        framesByThread.set(computeChildTheadInvocation(InvocationFrames.valueOf(parentValue)));\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void preInvoke(T invocation) throws InvocationException {\n \n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(SERVICE_STARTUP);\n+            frames.setState(SERVICE_STARTUP);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        ComponentInvocation previousInvocation = beforeSize > 0 ? invocationArray.get(beforeSize - 1) : null;\n-\n-        // If ejb call EJBSecurityManager, for servlet call RealmAdapter\n-        ComponentInvocationType invocationType = invocation.getInvocationType();\n+        ComponentInvocation prev = frames.peekLast();\n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.beforePreInvoke(invocationType, previousInvocation, invocation);\n+        try {\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invocationType);\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().beforePreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.beforePreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        // Push this invocation on the stack\n-        invocationArray.add(invocation);\n+        } finally {\n+            // Push this invocation on the stack\n+            frames.addLast(invocation);\n \n-        if (invHandlers != null) {\n-            for (ComponentInvocationHandler handler : invHandlers) {\n-                handler.afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (allTypesHandler != null) {\n+                allTypesHandler.afterPreInvoke(type, prev, invocation);\n             }\n-        }\n-\n-        if (setCIH != null) {\n-            for (int i = 0; i < setCIH.size(); i++) {\n-                setCIH.get(i).getComponentInvocationHandler().afterPreInvoke(invocationType, previousInvocation, invocation);\n+            if (typeHandler != null) {\n+                typeHandler.afterPreInvoke(type, prev, invocation);\n             }\n         }\n-\n     }\n \n+    @Override\n     public <T extends ComponentInvocation> void postInvoke(T invocation) throws InvocationException {\n-\n-        // Get this thread's ArrayList\n-        InvocationArray<ComponentInvocation> invocationArray = frames.get();\n+        InvocationFrames frames = framesByThread.get();\n         if (invocation.getInvocationType() == SERVICE_STARTUP) {\n-            invocationArray.setInvocationAttribute(UN_INITIALIZED);\n+            frames.setState(UN_INITIALIZED);\n             return;\n         }\n \n-        int beforeSize = invocationArray.size();\n-        if (beforeSize == 0) {\n+        Iterator<ComponentInvocation> iter = frames.descendingIterator();\n+        if (!iter.hasNext()) {\n             throw new InvocationException();\n         }\n \n-        ComponentInvocation prevInv = beforeSize > 1 ? invocationArray.get(beforeSize - 2) : null;\n-        ComponentInvocation curInv = invocationArray.get(beforeSize - 1);\n+        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation prev = iter.hasNext() ? iter.next() : null;\n \n+        ComponentInvocationType type = invocation.getInvocationType();\n+        ComponentInvocationHandler typeHandler = typeHandlers.get(type);\n         try {\n-            ComponentInvocationType invType = invocation.getInvocationType();\n-\n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (allTypesHandler != null) {\n+                allTypesHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n-            List<RegisteredComponentInvocationHandler> setCIH = regCompInvHandlerMap.get(invType);\n-            if (setCIH != null) {\n-                for (int i = 0; i < setCIH.size(); i++) {\n-                    setCIH.get(i).getComponentInvocationHandler().beforePostInvoke(invType, prevInv, curInv);\n-                }\n+            if (typeHandler != null) {\n+                typeHandler.beforePostInvoke(type, prev, invocation);\n             }\n-\n         } finally {\n             // pop the stack\n-            invocationArray.remove(beforeSize - 1);\n+            frames.removeLast();\n \n-            if (invHandlers != null) {\n-                for (ComponentInvocationHandler handler : invHandlers) {\n-                    handler.afterPostInvoke(invocation.getInvocationType(), prevInv, invocation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5NTUzNQ=="}, "originalCommit": {"oid": "1eca37c1479fc38ea61aa667b5393b26b3218a99"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5691328622ef5cba6361ce2561d465e0c57143e", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/d5691328622ef5cba6361ce2561d465e0c57143e", "committedDate": "2020-04-20T11:52:13Z", "message": "APPSERV-114 uses unsynchronised collections withoin thread locals; adds warning in case postInvoke called with an unecpected invocation instance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzM4NDQ3", "url": "https://github.com/payara/Payara/pull/4602#pullrequestreview-397338447", "createdAt": "2020-04-21T13:38:25Z", "commit": {"oid": "d5691328622ef5cba6361ce2561d465e0c57143e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozODoyNlrOGJGNgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozODoyNlrOGJGNgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MjEzMQ==", "bodyText": "Last Nitpick would be, that only EjbInvocation provides reasonable toString(). It would be great to add one into WebComponentInvocation and ComponentInvocation.", "url": "https://github.com/payara/Payara/pull/4602#discussion_r412192131", "createdAt": "2020-04-21T13:38:26Z", "author": {"login": "pdudits"}, "path": "nucleus/common/glassfish-api/src/main/java/org/glassfish/api/invocation/InvocationManagerImpl.java", "diffHunk": "@@ -173,7 +177,11 @@ public void setThreadInheritableInvocation(List<? extends ComponentInvocation> p\n             throw new InvocationException();\n         }\n \n-        iter.next(); // the last is the current is \"invocation\"\n+        ComponentInvocation current = iter.next(); // the last is the current is \"invocation\"\n+        if (invocation != current) {\n+            LOGGER.log(WARNING, \"postInvoke not called with top of the invocation stack. Expected {0} but was: {1}\",\n+                    new Object[] { current, invocation });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5691328622ef5cba6361ce2561d465e0c57143e"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5bdaa22791cbfeb36140511340825a2552f7e84", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/b5bdaa22791cbfeb36140511340825a2552f7e84", "committedDate": "2020-04-22T08:44:59Z", "message": "APPSERV-114 adds toString to ComponentInvocation to provide relevant info in log messages"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 800, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}