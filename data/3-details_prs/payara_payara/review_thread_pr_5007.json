{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDg5MzQw", "number": 5007, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1MjoxMVrOE9UKuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxMjo0NDo1M1rOFTEjug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzI5MDE5OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1MjoxMVrOH58Kfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMTo1NzoyMlrOH6YY1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg==", "bodyText": "Personally, I would avoid using wildcard imports - however, I'll leave it to a consensus", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530516606", "createdAt": "2020-11-25T16:52:11Z", "author": {"login": "AlanRoth"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -43,12 +43,10 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjAzNA==", "bodyText": "Oh that was IntelliJ automagic. Happy to switch back again.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530612034", "createdAt": "2020-11-25T19:55:50Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -43,12 +43,10 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg=="}, "originalCommit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3OTAyOA==", "bodyText": "Done with 74288cb", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530979028", "createdAt": "2020-11-26T11:57:22Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -43,12 +43,10 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg=="}, "originalCommit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTE5NzU3OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0OToxN1rOH6gnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNTo1OTo1MVrOIZt4rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ==", "bodyText": "I might be mistaken but I think proper thread-safety would require using a single map with an entry class holding the three fields. Otherwise the individual maps could be updated inconsistently. At the very least this makes it very hard to reason about if this would still be correct.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531113799", "createdAt": "2020-11-26T15:49:17Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNTgxNg==", "bodyText": "Ok, will create a small inner class for this.\nCurious: why should this be more thread safe?", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531435816", "createdAt": "2020-11-27T08:01:39Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyOTg1NQ==", "bodyText": "The concurrent map only makes updating entries an atomic operation. So you can update map1 while another thread is reading map1 (updated) and map2 (not yet updated) so the picture this thread sees is only partially updated and generally must be considered inconsistent. In most cases such inconsistencies are exactly what we cannot have and avoiding it is what we mean when we say it is thread-safe. If we have one map with an entry with 3 fields updating these 3 is \"atomic\" and no other thread can observe one field already updated while the other fields have not been updated yet (given we don't mutate in place but work with immutable entry instances). For the same reason get + put isn't a good idea as essentially in the meantime the situation you did read might no longer be valid. This disappears when using compute or computeIfAbsent.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531629855", "createdAt": "2020-11-27T14:22:57Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNzEwMA==", "bodyText": "This has been taken care of.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563837100", "createdAt": "2021-01-25T15:59:51Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTIxNDMyOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1MzozOVrOH6gxKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjowMDozMVrOIZt61A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA==", "bodyText": "As this would run every time a miss occurs and continue to do so in case such a property does indeed not exist I wonder if this should not leave an \"empty\" entry behind so we do remember this is a miss. In connection with making it a map of a record with 3 fields such \"empty\" entries are simply entries where the value is null and where time modified is the moment we insert the entry for the first time.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531116328", "createdAt": "2020-11-26T15:53:39Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzODA2Mg==", "bodyText": "I'm not sure what you are trying to do with that information. A value that had no property file on disk before is always a miss in the map cache, returning null, leading to execution of this else branch.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531438062", "createdAt": "2020-11-27T08:07:01Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYzNTIxNg==", "bodyText": "Yeah it depends on what we want. If we want to make sure we \"see\" added files as soon as they are written we need to check for it which makes me think that the best way to do update at all is not checking but registering a file watcher that is watching the secret dir directory for changes and updates the map as they occur. No per request checks needed any more reducing the file IO to just the IO actually needed.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531635216", "createdAt": "2020-11-27T14:33:40Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNzY1Mg==", "bodyText": "The file watcher has been implemented.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563837652", "createdAt": "2021-01-25T16:00:31Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTIzMTQ2OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1ODowNlrOH6g7fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODowMjo0NFrOH60S-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg==", "bodyText": "I don't think that updating individual entries \"on demand\" should their origin file be modified is a good way to update. It is hard to reason about, inefficient and potentially creates \"phantom entries\" in case an entry was removed from a file. I think this kind of works but is yet another constellation to reason about. I'd much prefer updating all properties of a file as soon as we detect that the file is outdated.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531118972", "createdAt": "2020-11-26T15:58:06Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQyOTQ0OQ==", "bodyText": "Left this comment before I realised that each file is a single property and forgot to remove it later.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531429449", "createdAt": "2020-11-27T07:46:01Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNjI4MQ==", "bodyText": "OK I'll resolve this comment then.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531436281", "createdAt": "2020-11-27T08:02:44Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTI1MjE1OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNjowNDowOFrOH6hIeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjowMDo1OVrOIZt8PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA==", "bodyText": "This should use Files.readAllBytes to create a new String", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531122298", "createdAt": "2020-11-26T16:04:08Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -143,39 +153,49 @@ private void findFile() {\n         }\n     }\n \n-    private String readFile(String name) {\n+    private String readFile(Path file) throws IOException {\n         String result = null;\n-        if (Files.exists(secretsDir) && Files.isDirectory(secretsDir) && Files.isReadable(secretsDir)) {\n-            try {\n-                Path file = Paths.get(secretsDir.toString(), name);\n-                if (Files.exists(file) && Files.isReadable(file)) {\n-                    StringBuilder collector = new StringBuilder();\n-                    for (String line : Files.readAllLines(file)) {\n-                        collector.append(line);\n-                    }\n-                    result = collector.toString();\n-                }\n-            } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+        if (Files.exists(file) && Files.isRegularFile(file) && Files.isReadable(file)) {\n+            StringBuilder collector = new StringBuilder();\n+            for (String line : Files.readAllLines(file)) {\n+                collector.append(line);\n             }\n+            result = collector.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzODUyMQ==", "bodyText": "OK will look into it. \ud83d\ude3a", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531438521", "createdAt": "2020-11-27T08:08:04Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -143,39 +153,49 @@ private void findFile() {\n         }\n     }\n \n-    private String readFile(String name) {\n+    private String readFile(Path file) throws IOException {\n         String result = null;\n-        if (Files.exists(secretsDir) && Files.isDirectory(secretsDir) && Files.isReadable(secretsDir)) {\n-            try {\n-                Path file = Paths.get(secretsDir.toString(), name);\n-                if (Files.exists(file) && Files.isReadable(file)) {\n-                    StringBuilder collector = new StringBuilder();\n-                    for (String line : Files.readAllLines(file)) {\n-                        collector.append(line);\n-                    }\n-                    result = collector.toString();\n-                }\n-            } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+        if (Files.exists(file) && Files.isRegularFile(file) && Files.isReadable(file)) {\n+            StringBuilder collector = new StringBuilder();\n+            for (String line : Files.readAllLines(file)) {\n+                collector.append(line);\n             }\n+            result = collector.toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzODAxMw==", "bodyText": "This has been taken care of.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563838013", "createdAt": "2021-01-25T16:00:59Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -143,39 +153,49 @@ private void findFile() {\n         }\n     }\n \n-    private String readFile(String name) {\n+    private String readFile(Path file) throws IOException {\n         String result = null;\n-        if (Files.exists(secretsDir) && Files.isDirectory(secretsDir) && Files.isReadable(secretsDir)) {\n-            try {\n-                Path file = Paths.get(secretsDir.toString(), name);\n-                if (Files.exists(file) && Files.isReadable(file)) {\n-                    StringBuilder collector = new StringBuilder();\n-                    for (String line : Files.readAllLines(file)) {\n-                        collector.append(line);\n-                    }\n-                    result = collector.toString();\n-                }\n-            } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+        if (Files.exists(file) && Files.isRegularFile(file) && Files.isReadable(file)) {\n+            StringBuilder collector = new StringBuilder();\n+            for (String line : Files.readAllLines(file)) {\n+                collector.append(line);\n             }\n+            result = collector.toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTI2MDQyOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNjowNjozNVrOH6hNYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjowMjozOVrOIZuA-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw==", "bodyText": "to be thread-safe get should be avoided and computeIfAbseent should take its place.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531123553", "createdAt": "2020-11-26T16:06:35Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNjEwMw==", "bodyText": "\"Noice\". Didn't knew about computeIfAbsent.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531436103", "createdAt": "2020-11-27T08:02:21Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTIyNw==", "bodyText": "Outdated, as the properties are stored in an inner class now.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839227", "createdAt": "2021-01-25T16:02:39Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw=="}, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjc0MDkyOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MDozN1rOH8IjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MDozN1rOH8IjOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjY5Ng==", "bodyText": "This might as well be moved to an anonymous definition inside initializePropertiesFromPath(). Had been moved here for potential reuse, but didn't happen.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532816696", "createdAt": "2020-11-30T18:40:37Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n+        /**\n+         * Ignore hidden directories\n+         */\n+        @Override\n+        public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+            return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+        }\n+    \n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+            updatePropertyFromPath(path, mainAtts);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk0OTA4OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozNDoyNFrOH8Kfbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDo1NjowNlrOIAhEeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODQ5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirProperty {\n          \n          \n            \n                private static final class DirProperty {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848495", "createdAt": "2020-11-30T19:34:24Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxMjcyOA==", "bodyText": "Done, but still scope package to allow easier testing.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537412728", "createdAt": "2020-12-07T10:56:06Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODQ5NQ=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk1MTIyOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozNDo1NlrOH8Kgwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjowMzoxMFrOIZuCgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirPropertyWatcher implements Runnable {\n          \n          \n            \n                private static final class DirPropertyWatcher implements Runnable {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848834", "createdAt": "2020-11-30T19:34:56Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDAyMQ==", "bodyText": "Final ok, but remain in package scope and non-static. Package makes testing easier. Static wouldn't allow us to access the update methods or the DirConfigSource class attributes.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414021", "createdAt": "2020-12-07T10:58:07Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTYxOQ==", "bodyText": "Done as described.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839619", "createdAt": "2021-01-25T16:03:10Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk1MjcwOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozNToxNlrOH8KhnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjowMzoyMlrOIZuDNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532849053", "createdAt": "2020-11-30T19:35:16Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDM5Mw==", "bodyText": "Final OK. Static: can't do that in non-static inner class.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414393", "createdAt": "2020-12-07T10:58:42Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTc5OQ==", "bodyText": "Done as described.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839799", "createdAt": "2021-01-25T16:03:22Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk2NzE0OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozOTowMVrOH8KqUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozOTowMVrOH8KqUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTI4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    WatchService watcher = FileSystems.getDefault().newWatchService();\n          \n          \n            \n                    private final WatchService watcher = FileSystems.getDefault().newWatchService();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851281", "createdAt": "2020-11-30T19:39:01Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk2NzgxOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozOToxNlrOH8Kqvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozOToxNlrOH8Kqvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTM5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n          \n          \n            \n                    private final ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851391", "createdAt": "2020-11-30T19:39:16Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk3ODI2OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo0MjowNlrOH8KxLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo0MjowNlrOH8KxLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzAzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String property;\n          \n          \n            \n                    FileTime lastModifiedTime;\n          \n          \n            \n                    Path path;\n          \n          \n            \n                    int pathDepth;\n          \n          \n            \n                    final String property;\n          \n          \n            \n                    final FileTime lastModifiedTime;\n          \n          \n            \n                    final Path path;\n          \n          \n            \n                    final int pathDepth;", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532853039", "createdAt": "2020-11-30T19:42:06Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Mjk5ODg0OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo0NzoxN1rOH8K9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMDo1OTozM1rOIAhNGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NjI2Nw==", "bodyText": "just keys is a bit generic, maybe watchedFiles (by keys)?", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532856267", "createdAt": "2020-11-30T19:47:17Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDkzOA==", "bodyText": "\"watchedFileKeys\"", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414938", "createdAt": "2020-12-07T10:59:33Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NjI2Nw=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzAzNTkxOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo1Mjo0NFrOH8LWJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjoyNTowNFrOIZvFBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjUwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n          \n          \n            \n                private static final class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532862500", "createdAt": "2020-11-30T19:52:44Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg1NjY0NA==", "bodyText": "This is outdated, as the visitor has been moved to anonymous definition.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563856644", "createdAt": "2021-01-25T16:25:04Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjUwMA=="}, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3NDQwOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0ODo0M1rOH8rF_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzozNTo0OVrOIZ-3dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjY1Mw==", "bodyText": "Better to return the found dir instead of initialising the field so this method becomes independent of the class.\nIt might become a method elsewhere or a static method that accepts a Config (from MPConfig) returning the dir which then can be passed as constructor argument to initialise this class. This allows to use this class with directory coming from MP config or any other source. Normally testing would be another candidate that then uses this parameter. You could think about moving the watcher part out of the constructor into a method that is called after constructing the instance passing in the executor service.\nvoid updateUsingFileWatcher(PayaraExecutorService executorService) {\n    //...\n    executorService.submit(new DirPropertyWatcher(this.directory));\n    //...\n}\nThis would allow to not trigger this in tests while you use it when creating the list of config sources.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533382653", "createdAt": "2020-12-01T12:48:43Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDExNTMxNw==", "bodyText": "I think this is done as you intended. Please feel free to re-open if not.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564115317", "createdAt": "2021-01-25T23:35:49Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjY1Mw=="}, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3ODUzOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0OTo0MFrOH8rIVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNjoyNjoxM1rOIZvI3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzI1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Path directory;\n          \n          \n            \n                private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n          \n          \n            \n                private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n            \n          \n          \n            \n                private final Path directory;\n          \n          \n            \n                private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533383254", "createdAt": "2020-12-01T12:49:40Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg1NzYzMQ==", "bodyText": "Almost done like this. Kept directory non-final to be able to change outside of constructor.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563857631", "createdAt": "2021-01-25T16:26:13Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzI1NA=="}, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjQwNDAzOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1NjozOVrOH8rXaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo1NjozOVrOH8rXaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NzExNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return unmodifiableMap(properties\n          \n          \n            \n                                                .entrySet()\n          \n          \n            \n                                                .stream()\n          \n          \n            \n                                                .collect(\n          \n          \n            \n                                                    Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n          \n          \n            \n                                                ));\n          \n          \n            \n                    return unmodifiableMap(properties.entrySet().stream().collect(\n          \n          \n            \n                        toMap(Map.Entry::getKey, e -> e.getValue().property)));\n          \n      \n    \n    \n  \n\nneeds toMap being imported statically", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533387115", "createdAt": "2020-12-01T12:56:39Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NjUzNTk3OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToyMDo1NFrOH-NLTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMToyMToxNlrOIAiBkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY0NQ==", "bodyText": "I think you want to specify the encoding explicitly here.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r534989645", "createdAt": "2020-12-03T09:20:54Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(configService.getMPConfig().getSecretDir()),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), configService.getMPConfig().getSecretDir())\n+                                );\n+        for (Path candidate : candidates) {\n+            if (Files.exists(candidate) || Files.isDirectory(candidate) || Files.isReadable(candidate)) {\n+                this.directory = candidate;\n+                return;\n+            }\n+        }\n+    }\n+    \n+    void initializePropertiesFromPath(Path topmostDir) throws IOException {\n+        if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+            // initialize properties on first run\n+            Files.walkFileTree(topmostDir, new SimpleFileVisitor<Path>() {\n+                // Ignore hidden directories\n+                @Override\n+                public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    updatePropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } else {\n+            throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+        }\n+    }\n+    \n+    void updatePropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        // do not read hidden files, as K8s Secret filenames are symlinks to hidden files with data.\n+        // also ignore files > 512KB, as they are most likely no text config files...\n+        if (Files.isRegularFile(path) && ! Files.isHidden(path) && Files.isReadable(path) && mainAtts.size() < 512*1024) {\n+            // retrieve the property name from the file path\n+            String property = parsePropertyNameFromPath(path);\n+            \n+            // Conflict handling:\n+            // When this property is already present, check how to solve the conflict.\n+            // This property file will be skipped if the file we already have is deeper in the file tree...\n+            if (checkLongestMatchForPath(property, path)) {\n+                return;\n+            }\n+            \n+            properties.put(property, readPropertyFromPath(path, mainAtts));\n+        }\n+    }\n+    \n+    void removePropertyFromPath(Path path) {\n+        String property = parsePropertyNameFromPath(path);\n+    \n+        // not present? go away silently.\n+        if (! properties.containsKey(property)) return;\n+    \n+        // only delete from the map if the file that has been deleted is the same as the one stored in the map\n+        // -> deleting a file less specific but matching a property should not remove from the map\n+        // -> deleting a file more specific than in map shouldn't occur (it had to slip through longest match check then).\n+        if (path.equals(properties.get(property).path)) {\n+            properties.remove(property);\n+        }\n+        \n+    }\n+    \n+    String parsePropertyNameFromPath(Path path) {\n+        // 1. get relative path based on the config dir (\"/config\"),\n+        String property = directory.relativize(path.getParent()).toString();\n+        // 2. ignore all file suffixes after last dot\n+        property += path.getFileName().toString().substring(0, path.getFileName().toString().lastIndexOf('.')-1);\n+        // 3. replace all path seps with a \".\",\n+        property = property.replace(File.separatorChar, '.');\n+        // so \"/config/foo/bar/test/one.txt\" becomes \"foo/bar/test/one.txt\" becomes \"foo.bar.test.one\" property name\n+        return property;\n+    }\n+    \n+    /**\n+     * Check if the path given is a more specific path to a value for the given property\n+     * @param property\n+     * @param path\n+     * @return true if more specific, false if not\n+     */\n+    boolean checkLongestMatchForPath(String property, Path path) {\n+        // Make path relative to config directory\n+        // NOTE: we will never have a path containing \"..\", as our tree walkers are always inside this \"root\".\n+        Path relativePath = directory.relativize(path);\n+        \n+        // No property -> path is new and more specific\n+        if (! properties.containsKey(property))\n+            return true;\n+        DirProperty old = properties.get(property);\n+        \n+        // Check if this element has a higher path depth (longest match)\n+        // Example: \"foo.bar/test/one.txt\" (depth 2) wins over \"foo.bar.test.one.txt\" (depth 0)\n+        boolean depth = old.pathDepth > relativePath.getNameCount();\n+        \n+        // In case that both pathes have the same depth, we need to check on the position of dots.\n+        // Example: /config/foo.bar/test/one.txt is less specific than /config/foo/bar.test/one.txt\n+        if (old.pathDepth == relativePath.getNameCount()) {\n+            String oldPath = old.path.toString();\n+            String newPath = path.toAbsolutePath().toString();\n+            int offset = 0;\n+            while (offset > -1) {\n+                if (newPath.indexOf(\".\", offset) > oldPath.indexOf(\".\", offset)) return true;\n+                offset = oldPath.indexOf(\".\", offset + 1);\n+            }\n+        }\n+        return depth;\n+    }\n+    \n+    DirProperty readPropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            return new DirProperty(\n+                new String(Files.readAllBytes(path)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQyODM2OA==", "bodyText": "Using UTF-8.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537428368", "createdAt": "2020-12-07T11:21:16Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(configService.getMPConfig().getSecretDir()),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), configService.getMPConfig().getSecretDir())\n+                                );\n+        for (Path candidate : candidates) {\n+            if (Files.exists(candidate) || Files.isDirectory(candidate) || Files.isReadable(candidate)) {\n+                this.directory = candidate;\n+                return;\n+            }\n+        }\n+    }\n+    \n+    void initializePropertiesFromPath(Path topmostDir) throws IOException {\n+        if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+            // initialize properties on first run\n+            Files.walkFileTree(topmostDir, new SimpleFileVisitor<Path>() {\n+                // Ignore hidden directories\n+                @Override\n+                public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    updatePropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } else {\n+            throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+        }\n+    }\n+    \n+    void updatePropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        // do not read hidden files, as K8s Secret filenames are symlinks to hidden files with data.\n+        // also ignore files > 512KB, as they are most likely no text config files...\n+        if (Files.isRegularFile(path) && ! Files.isHidden(path) && Files.isReadable(path) && mainAtts.size() < 512*1024) {\n+            // retrieve the property name from the file path\n+            String property = parsePropertyNameFromPath(path);\n+            \n+            // Conflict handling:\n+            // When this property is already present, check how to solve the conflict.\n+            // This property file will be skipped if the file we already have is deeper in the file tree...\n+            if (checkLongestMatchForPath(property, path)) {\n+                return;\n+            }\n+            \n+            properties.put(property, readPropertyFromPath(path, mainAtts));\n+        }\n+    }\n+    \n+    void removePropertyFromPath(Path path) {\n+        String property = parsePropertyNameFromPath(path);\n+    \n+        // not present? go away silently.\n+        if (! properties.containsKey(property)) return;\n+    \n+        // only delete from the map if the file that has been deleted is the same as the one stored in the map\n+        // -> deleting a file less specific but matching a property should not remove from the map\n+        // -> deleting a file more specific than in map shouldn't occur (it had to slip through longest match check then).\n+        if (path.equals(properties.get(property).path)) {\n+            properties.remove(property);\n+        }\n+        \n+    }\n+    \n+    String parsePropertyNameFromPath(Path path) {\n+        // 1. get relative path based on the config dir (\"/config\"),\n+        String property = directory.relativize(path.getParent()).toString();\n+        // 2. ignore all file suffixes after last dot\n+        property += path.getFileName().toString().substring(0, path.getFileName().toString().lastIndexOf('.')-1);\n+        // 3. replace all path seps with a \".\",\n+        property = property.replace(File.separatorChar, '.');\n+        // so \"/config/foo/bar/test/one.txt\" becomes \"foo/bar/test/one.txt\" becomes \"foo.bar.test.one\" property name\n+        return property;\n+    }\n+    \n+    /**\n+     * Check if the path given is a more specific path to a value for the given property\n+     * @param property\n+     * @param path\n+     * @return true if more specific, false if not\n+     */\n+    boolean checkLongestMatchForPath(String property, Path path) {\n+        // Make path relative to config directory\n+        // NOTE: we will never have a path containing \"..\", as our tree walkers are always inside this \"root\".\n+        Path relativePath = directory.relativize(path);\n+        \n+        // No property -> path is new and more specific\n+        if (! properties.containsKey(property))\n+            return true;\n+        DirProperty old = properties.get(property);\n+        \n+        // Check if this element has a higher path depth (longest match)\n+        // Example: \"foo.bar/test/one.txt\" (depth 2) wins over \"foo.bar.test.one.txt\" (depth 0)\n+        boolean depth = old.pathDepth > relativePath.getNameCount();\n+        \n+        // In case that both pathes have the same depth, we need to check on the position of dots.\n+        // Example: /config/foo.bar/test/one.txt is less specific than /config/foo/bar.test/one.txt\n+        if (old.pathDepth == relativePath.getNameCount()) {\n+            String oldPath = old.path.toString();\n+            String newPath = path.toAbsolutePath().toString();\n+            int offset = 0;\n+            while (offset > -1) {\n+                if (newPath.indexOf(\".\", offset) > oldPath.indexOf(\".\", offset)) return true;\n+                offset = oldPath.indexOf(\".\", offset + 1);\n+            }\n+        }\n+        return depth;\n+    }\n+    \n+    DirProperty readPropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            return new DirProperty(\n+                new String(Files.readAllBytes(path)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY0NQ=="}, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUxMTIwOnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowODo0MlrOIG9jvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNTo1ODoxMVrOIZtzUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDk0MA==", "bodyText": "PayaraExecutorService tries to terminate gracefully via awaitTermination first. This loop therefore delays shutdown of the server by 5 seconds.\nConsider scheduling single take every few seconds instead, or polling synchronously during get.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544170940", "createdAt": "2020-12-16T10:08:42Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = rootPath.relativize(path).getNameCount();\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNTczMA==", "bodyText": "This issue has been taken care of.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563835730", "createdAt": "2021-01-25T15:58:11Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = rootPath.relativize(path).getNameCount();\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDk0MA=="}, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUzMzk2OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/test/java/fish/payara/nucleus/microprofile/config/source/DirConfigSourceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMzo0MFrOIG9xBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMzozNjozNFrOIZ-4jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDM0MQ==", "bodyText": "This fails on Windows, because it has different condition for a hidden file. Consider explicit check for dot at start rather than isHidden.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544174341", "createdAt": "2020-12-16T10:13:40Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/test/java/fish/payara/nucleus/microprofile/config/source/DirConfigSourceTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2017-2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.junit.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+public class DirConfigSourceTest {\n+\n+    private static Path testDirectory;\n+    private static DirConfigSource source;\n+    \n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        testDirectory = Files.createTempDirectory(\"microprofile-config-test-\");\n+        // create & load\n+        source = new DirConfigSource(testDirectory);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws IOException {\n+        Files.walk(testDirectory)\n+            .sorted(Comparator.reverseOrder())\n+            .map(Path::toFile)\n+            .forEach(File::delete);\n+    }\n+    \n+    @Test\n+    public void testParsePropertyNameFromPath() {\n+        // given\n+        Map<Path,String> examples = new HashMap<>();\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"), \"foo.bar.test.ex\");\n+        \n+        // we ignore the last file extension. always. this might lead to unexpected behaviour for a user.\n+        // best advice: do not use dots in filename, only in directory names.\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.txt\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.tar.gz\"), \"foo.bar.test.ex.tar\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test.ex\"), \"foo.bar.test\");\n+        \n+        // when & then\n+        for (Map.Entry<Path, String> ex : examples.entrySet()) {\n+            System.out.println(ex.getKey()+\" = \"+ex.getValue());\n+            assertEquals(ex.getValue(), source.parsePropertyNameFromPath(ex.getKey()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthLessSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+                  new DirConfigSource.DirProperty(\n+                      \"test\", FileTime.from(Instant.now()),\n+                      Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"),\n+                      testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertFalse(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar.test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar/test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthEqualMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo.bar/test/ex.one.txt\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PropNotPresent() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(\"foo.bar.test.ex.two\", Paths.get(testDirectory.toString(), \"foo.bar/test/ex.two.txt\")));\n+    }\n+    \n+    @Test\n+    public void testRemovePropertyFromPath() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo/bar/test\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        assertEquals(\"test\", source.getValue(property));\n+        \n+        // when\n+        source.removePropertyFromPath(Paths.get(testDirectory.toString(), \"foo/bar/test\"));\n+        // then\n+        assertTrue(source.getValue(property) == null);\n+        \n+    }\n+\n+    @Test\n+    public void testInitializeProperties_SimpleFiles() throws IOException {\n+        // given\n+        // only the most specific should be picked up (=test3)\n+        writeFile(testDirectory, \"foo.bar.test\", \"test\");\n+        writeFile(testDirectory, \"foo.bar/test\", \"test2\");\n+        writeFile(testDirectory, \"foo/bar/test\", \"test3\");\n+        \n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        \n+        //then\n+        assertEquals(\"test3\", source.getValue(\"foo.bar.test\"));\n+    }\n+    \n+    @Test\n+    public void testInitializeProperties_IgnoreHidden() throws IOException {\n+        // given\n+        // none of these should be picked up (hidden file or dir)\n+        writeFile(testDirectory, \".hidden.bar.test\", \"test\");\n+        writeFile(testDirectory, \".hidden/bar.test\", \"test\");\n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        //then\n+        assertEquals(null, source.getValue(\"hidden.bar.test\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDExNTU5OQ==", "bodyText": "Done. It should work now.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564115599", "createdAt": "2021-01-25T23:36:34Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/test/java/fish/payara/nucleus/microprofile/config/source/DirConfigSourceTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2017-2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.junit.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+public class DirConfigSourceTest {\n+\n+    private static Path testDirectory;\n+    private static DirConfigSource source;\n+    \n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        testDirectory = Files.createTempDirectory(\"microprofile-config-test-\");\n+        // create & load\n+        source = new DirConfigSource(testDirectory);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws IOException {\n+        Files.walk(testDirectory)\n+            .sorted(Comparator.reverseOrder())\n+            .map(Path::toFile)\n+            .forEach(File::delete);\n+    }\n+    \n+    @Test\n+    public void testParsePropertyNameFromPath() {\n+        // given\n+        Map<Path,String> examples = new HashMap<>();\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"), \"foo.bar.test.ex\");\n+        \n+        // we ignore the last file extension. always. this might lead to unexpected behaviour for a user.\n+        // best advice: do not use dots in filename, only in directory names.\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.txt\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.tar.gz\"), \"foo.bar.test.ex.tar\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test.ex\"), \"foo.bar.test\");\n+        \n+        // when & then\n+        for (Map.Entry<Path, String> ex : examples.entrySet()) {\n+            System.out.println(ex.getKey()+\" = \"+ex.getValue());\n+            assertEquals(ex.getValue(), source.parsePropertyNameFromPath(ex.getKey()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthLessSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+                  new DirConfigSource.DirProperty(\n+                      \"test\", FileTime.from(Instant.now()),\n+                      Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"),\n+                      testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertFalse(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar.test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar/test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthEqualMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo.bar/test/ex.one.txt\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PropNotPresent() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(\"foo.bar.test.ex.two\", Paths.get(testDirectory.toString(), \"foo.bar/test/ex.two.txt\")));\n+    }\n+    \n+    @Test\n+    public void testRemovePropertyFromPath() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo/bar/test\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        assertEquals(\"test\", source.getValue(property));\n+        \n+        // when\n+        source.removePropertyFromPath(Paths.get(testDirectory.toString(), \"foo/bar/test\"));\n+        // then\n+        assertTrue(source.getValue(property) == null);\n+        \n+    }\n+\n+    @Test\n+    public void testInitializeProperties_SimpleFiles() throws IOException {\n+        // given\n+        // only the most specific should be picked up (=test3)\n+        writeFile(testDirectory, \"foo.bar.test\", \"test\");\n+        writeFile(testDirectory, \"foo.bar/test\", \"test2\");\n+        writeFile(testDirectory, \"foo/bar/test\", \"test3\");\n+        \n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        \n+        //then\n+        assertEquals(\"test3\", source.getValue(\"foo.bar.test\"));\n+    }\n+    \n+    @Test\n+    public void testInitializeProperties_IgnoreHidden() throws IOException {\n+        // given\n+        // none of these should be picked up (hidden file or dir)\n+        writeFile(testDirectory, \".hidden.bar.test\", \"test\");\n+        writeFile(testDirectory, \".hidden/bar.test\", \"test\");\n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        //then\n+        assertEquals(null, source.getValue(\"hidden.bar.test\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDM0MQ=="}, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1NTQxOTQ2OnYy", "diffSide": "RIGHT", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxMjo0NDo1M1rOIaVR0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QxMTo1MDo0MFrOIbD9HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQ4MjUxNQ==", "bodyText": "Another Windows FS-related trap here when configured with absolute path, this happens:\njava.nio.file.InvalidPathException: Illegal char <:> at index 100: C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\config\\secrets\n\nSo you might want to be more specific here, checking if Path.isAbsolute before constructing relative one", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564482515", "createdAt": "2021-01-26T12:44:53Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.SEVERE;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this(propertyValue, lastModifiedTime, path, rootPath.relativize(path).getNameCount());\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+    \n+        /**\n+         * Register file watchers recursively (as they don't attach themselfs to sub directories...)\n+         * and initialize values from files present and suitable.\n+         * @param dir Topmost directory to start recursive traversal from\n+         * @throws IOException\n+         */\n+        final void registerAll(Path dir) throws IOException {\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    // only register subdirectories if the directory itself is suitable.\n+                    if ( isAptDir(dir) ) {\n+                        register(dir);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    // file will be checked before upserting.\n+                    upsertPropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        final void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+            logger.finer(\"MPCONFIG DirConfigSource: registered \\\"\"+dir+\"\\\" as key \\\"\"+key+\"\\\".\");\n+        }\n+        \n+        @Override\n+        public final void run() {\n+            // wait infinitely until we receive an event (or the executor is shutting down)\n+            WatchKey key;\n+            try {\n+                key = watcher.take();\n+            } catch (InterruptedException ex) {\n+                logger.info(\"MPCONFIG DirConfigSource: shutting down watcher thread.\");\n+                return;\n+            }\n+            \n+            Path workDir = watchedFileKeys.get(key);\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                WatchEvent.Kind<?> kind = event.kind();\n+        \n+                @SuppressWarnings(\"unchecked\")\n+                WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                Path fileName = ev.context();\n+                Path path = workDir.resolve(fileName);\n+\n+                logger.finer(\"MPCONFIG DirConfigSource: detected change: \"+fileName.toString()+\" : \"+kind.toString());\n+        \n+                try {\n+                    // new directory to be watched and traversed\n+                    if (kind == ENTRY_CREATE && isAptDir(path)) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: registering new paths.\");\n+                        registerAll(path);\n+                    }\n+                    // new or updated file found (new = create + modify on content save)\n+                    // or new symlink found (symlinks are create only!) (also, aptness of file is checked inside update routine)\n+                    if ( kind == ENTRY_MODIFY || (kind == ENTRY_CREATE && Files.isSymbolicLink(path)) ) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: processing new or updated file \\\"\"+path.toString()+\"\\\".\");\n+                        BasicFileAttributes atts = Files.readAttributes(path, BasicFileAttributes.class);\n+                        upsertPropertyFromPath(path, atts);\n+                    }\n+                    if (Files.notExists(path) && ! watchedFileKeys.containsValue(path) && kind == ENTRY_DELETE) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: removing deleted file \\\"\"+path.toString()+\"\\\".\");\n+                        removePropertyFromPath(path);\n+                    }\n+                } catch (IOException e) {\n+                    logger.log(WARNING, \"MPCONFIG DirConfigSource: could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                }\n+            }\n+\n+            // Reset key (obligatory) and remove from set if directory no longer accessible\n+            boolean valid = key.reset();\n+            if (!valid) {\n+                logger.finer(\"MPCONFIG DirConfigSource: removing watcher for key \\\"\"+key+\"\\\".\");\n+                watchedFileKeys.remove(key);\n+            }\n+        }\n+    }\n+    \n+    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    private Path directory;\n+    private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    \n+    public DirConfigSource() {\n+        try {\n+            // get the directory from the app server config\n+            this.directory = findDir();\n+            // create the watcher for the directory\n+            configService.getExecutor().scheduleWithFixedDelay(createWatcher(this.directory), 0, 1, SECONDS);\n+        } catch (IOException e) {\n+            logger.log(SEVERE, \"MPCONFIG DirConfigSource: error during setup.\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory) {\n+        super(true);\n+        this.directory = directory;\n+    }\n+    \n+    // Used for testing only\n+    DirPropertyWatcher createWatcher(Path topmostDirectory) throws IOException {\n+        return new DirPropertyWatcher(topmostDirectory);\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties.entrySet().stream()\n+                                    .collect(toMap(Map.Entry::getKey, e -> e.getValue().propertyValue)));\n+    }\n+    \n+    // Used for testing only\n+    void setProperties(Map<String, DirProperty> properties) {\n+        this.properties.clear();\n+        this.properties.putAll(properties);\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.propertyValue;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private Path findDir() throws IOException {\n+        String path = configService.getMPConfig().getSecretDir();\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(path),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), path)\n+                                );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NzI2MA==", "bodyText": "Addressed this in dc78c29. Also added unit tests to make sure this fails early. Going to resolve this, but if this isn't working properly on Windows, please reopen or create a new review.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r565247260", "createdAt": "2021-01-27T11:50:40Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.SEVERE;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this(propertyValue, lastModifiedTime, path, rootPath.relativize(path).getNameCount());\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+    \n+        /**\n+         * Register file watchers recursively (as they don't attach themselfs to sub directories...)\n+         * and initialize values from files present and suitable.\n+         * @param dir Topmost directory to start recursive traversal from\n+         * @throws IOException\n+         */\n+        final void registerAll(Path dir) throws IOException {\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    // only register subdirectories if the directory itself is suitable.\n+                    if ( isAptDir(dir) ) {\n+                        register(dir);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    // file will be checked before upserting.\n+                    upsertPropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        final void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+            logger.finer(\"MPCONFIG DirConfigSource: registered \\\"\"+dir+\"\\\" as key \\\"\"+key+\"\\\".\");\n+        }\n+        \n+        @Override\n+        public final void run() {\n+            // wait infinitely until we receive an event (or the executor is shutting down)\n+            WatchKey key;\n+            try {\n+                key = watcher.take();\n+            } catch (InterruptedException ex) {\n+                logger.info(\"MPCONFIG DirConfigSource: shutting down watcher thread.\");\n+                return;\n+            }\n+            \n+            Path workDir = watchedFileKeys.get(key);\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                WatchEvent.Kind<?> kind = event.kind();\n+        \n+                @SuppressWarnings(\"unchecked\")\n+                WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                Path fileName = ev.context();\n+                Path path = workDir.resolve(fileName);\n+\n+                logger.finer(\"MPCONFIG DirConfigSource: detected change: \"+fileName.toString()+\" : \"+kind.toString());\n+        \n+                try {\n+                    // new directory to be watched and traversed\n+                    if (kind == ENTRY_CREATE && isAptDir(path)) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: registering new paths.\");\n+                        registerAll(path);\n+                    }\n+                    // new or updated file found (new = create + modify on content save)\n+                    // or new symlink found (symlinks are create only!) (also, aptness of file is checked inside update routine)\n+                    if ( kind == ENTRY_MODIFY || (kind == ENTRY_CREATE && Files.isSymbolicLink(path)) ) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: processing new or updated file \\\"\"+path.toString()+\"\\\".\");\n+                        BasicFileAttributes atts = Files.readAttributes(path, BasicFileAttributes.class);\n+                        upsertPropertyFromPath(path, atts);\n+                    }\n+                    if (Files.notExists(path) && ! watchedFileKeys.containsValue(path) && kind == ENTRY_DELETE) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: removing deleted file \\\"\"+path.toString()+\"\\\".\");\n+                        removePropertyFromPath(path);\n+                    }\n+                } catch (IOException e) {\n+                    logger.log(WARNING, \"MPCONFIG DirConfigSource: could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                }\n+            }\n+\n+            // Reset key (obligatory) and remove from set if directory no longer accessible\n+            boolean valid = key.reset();\n+            if (!valid) {\n+                logger.finer(\"MPCONFIG DirConfigSource: removing watcher for key \\\"\"+key+\"\\\".\");\n+                watchedFileKeys.remove(key);\n+            }\n+        }\n+    }\n+    \n+    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    private Path directory;\n+    private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    \n+    public DirConfigSource() {\n+        try {\n+            // get the directory from the app server config\n+            this.directory = findDir();\n+            // create the watcher for the directory\n+            configService.getExecutor().scheduleWithFixedDelay(createWatcher(this.directory), 0, 1, SECONDS);\n+        } catch (IOException e) {\n+            logger.log(SEVERE, \"MPCONFIG DirConfigSource: error during setup.\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory) {\n+        super(true);\n+        this.directory = directory;\n+    }\n+    \n+    // Used for testing only\n+    DirPropertyWatcher createWatcher(Path topmostDirectory) throws IOException {\n+        return new DirPropertyWatcher(topmostDirectory);\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties.entrySet().stream()\n+                                    .collect(toMap(Map.Entry::getKey, e -> e.getValue().propertyValue)));\n+    }\n+    \n+    // Used for testing only\n+    void setProperties(Map<String, DirProperty> properties) {\n+        this.properties.clear();\n+        this.properties.putAll(properties);\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.propertyValue;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private Path findDir() throws IOException {\n+        String path = configService.getMPConfig().getSecretDir();\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(path),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), path)\n+                                );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQ4MjUxNQ=="}, "originalCommit": {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f"}, "originalPosition": 283}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1168, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}