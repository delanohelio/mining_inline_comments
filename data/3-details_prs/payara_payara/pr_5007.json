{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDg5MzQw", "number": 5007, "title": "FISH-788 Support sub-directories for MPCONFIG SecretDirConfigSource. #5006", "bodyText": "Description\nCloses #5006\nThis adds support for mounting your secrets (or configmapped values) in subdirectories to create scopes.\nThe relative path is used as the property name. A secret file SECRET_DIR/foo/bar/secret\nwill be available as MPCONFIG value foo.bar.secret.\nYou can still put a file foo.bar.secret in SECRET_DIR and have the same value available.\nAny combination of dots and directories is supported, also the most specific (read: most subdirs and least dots in file and dir names) will win. Updates during runtime are respected and evaluated with longest match, too. An example: SECRET_DIR/foo/bar.secret or SECRET_DIR/foo.bar/secret` is fine, too.\nImportant Info\nBlockers\nNone.\nTesting\nNew tests\nIncluded.\nTesting Performed\nRun tests in SecretsDirConfigSourceTest\nTesting Environment\n\nAdoptOpenJDK (build 11.0.9+11)\nLinux, Fedora 33\nMaven 3.6.3\n\nDocumentation\n\nSee payara/Payara-Community-Documentation#114\nNotes for Reviewers\n\nNone.", "createdAt": "2020-11-25T14:33:33Z", "url": "https://github.com/payara/Payara/pull/5007", "merged": true, "mergeCommit": {"oid": "ef826d74d9244691fe3f8e69d240b1d4bfab1464"}, "closed": true, "closedAt": "2021-01-28T09:34:50Z", "author": {"login": "poikilotherm"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdf_ODBgH2gAyNTI3NDg5MzQwOmYyNzk1ZTJhODdiNTlmN2Q1Mzc3MmYyOTk2ZDI2MTFmOTJmNWY1YzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd0UuT9gFqTU3NzY1NDc5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/f2795e2a87b59f7d53772f2996d2611f92f5f5c1", "committedDate": "2020-11-25T14:28:15Z", "message": "Support sub-directories for MPCONFIG SecretDirConfigSource. #5006\n\nThis adds support for mounting your secrets in subdirectories to create scopes.\nThe relative path is used as the property name. A secret file \"SECRET_DIR/foo/bar/secret\"\nwill be available as MPCONFIG value \"foo.bar.secret\".\n\nYou can still put a file \"foo.bar.secret\" in \"SECRET_DIR\" and have the same value available.\nIf both are present, the topmost file will be picked.\n\nMix'n'match isn't supported. Retrieving \"foo.bar.secret\" from \"SECRET_DIR/foo/bar.secret\"\nwill not work reliably when added at runtime."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Njg4NjM5", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-538688639", "createdAt": "2020-11-25T16:52:11Z", "commit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1MjoxMVrOH58Kfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjo1MjoxMVrOH58Kfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg==", "bodyText": "Personally, I would avoid using wildcard imports - however, I'll leave it to a consensus", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530516606", "createdAt": "2020-11-25T16:52:11Z", "author": {"login": "AlanRoth"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -43,12 +43,10 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/74288cbe744d64f82088a717663c822dcf8462f6", "committedDate": "2020-11-26T11:56:40Z", "message": "Revert glob import from java.nio and java.util introduced in f2795e2a."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NDIyNzQ5", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-539422749", "createdAt": "2020-11-26T15:49:17Z", "commit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0OToxN1rOH6gnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNjowNjozNVrOH6hNYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ==", "bodyText": "I might be mistaken but I think proper thread-safety would require using a single map with an entry class holding the three fields. Otherwise the individual maps could be updated inconsistently. At the very least this makes it very hard to reason about if this would still be correct.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531113799", "createdAt": "2020-11-26T15:49:17Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA==", "bodyText": "As this would run every time a miss occurs and continue to do so in case such a property does indeed not exist I wonder if this should not leave an \"empty\" entry behind so we do remember this is a miss. In connection with making it a map of a record with 3 fields such \"empty\" entries are simply entries where the value is null and where time modified is the moment we insert the entry for the first time.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531116328", "createdAt": "2020-11-26T15:53:39Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg==", "bodyText": "I don't think that updating individual entries \"on demand\" should their origin file be modified is a good way to update. It is hard to reason about, inefficient and potentially creates \"phantom entries\" in case an entry was removed from a file. I think this kind of works but is yet another constellation to reason about. I'd much prefer updating all properties of a file as soon as we detect that the file is outdated.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531118972", "createdAt": "2020-11-26T15:58:06Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA==", "bodyText": "This should use Files.readAllBytes to create a new String", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531122298", "createdAt": "2020-11-26T16:04:08Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -143,39 +153,49 @@ private void findFile() {\n         }\n     }\n \n-    private String readFile(String name) {\n+    private String readFile(Path file) throws IOException {\n         String result = null;\n-        if (Files.exists(secretsDir) && Files.isDirectory(secretsDir) && Files.isReadable(secretsDir)) {\n-            try {\n-                Path file = Paths.get(secretsDir.toString(), name);\n-                if (Files.exists(file) && Files.isReadable(file)) {\n-                    StringBuilder collector = new StringBuilder();\n-                    for (String line : Files.readAllLines(file)) {\n-                        collector.append(line);\n-                    }\n-                    result = collector.toString();\n-                }\n-            } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+        if (Files.exists(file) && Files.isRegularFile(file) && Files.isReadable(file)) {\n+            StringBuilder collector = new StringBuilder();\n+            for (String line : Files.readAllLines(file)) {\n+                collector.append(line);\n             }\n+            result = collector.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw==", "bodyText": "to be thread-safe get should be avoided and computeIfAbseent should take its place.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531123553", "createdAt": "2020-11-26T16:06:35Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74288cbe744d64f82088a717663c822dcf8462f6"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a6f8c385456c0482079a5948fe1ac964c95071f", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/2a6f8c385456c0482079a5948fe1ac964c95071f", "committedDate": "2020-11-30T18:35:06Z", "message": "Add first draft of complete rewrite of the SecretsDirConfigSource moving to DirConfigSource. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/dceb4c70a8b5242849c9ef044d79103f22b21f49", "committedDate": "2020-11-30T18:36:06Z", "message": "Remove SecretsDirConfigSource, replaced with DirConfigSource. #5006"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTg5MzEx", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-541189311", "createdAt": "2020-11-30T18:40:36Z", "commit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MDozN1rOH8IjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODo0MDozN1rOH8IjOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjY5Ng==", "bodyText": "This might as well be moved to an anonymous definition inside initializePropertiesFromPath(). Had been moved here for potential reuse, but didn't happen.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532816696", "createdAt": "2020-11-30T18:40:37Z", "author": {"login": "poikilotherm"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n+        /**\n+         * Ignore hidden directories\n+         */\n+        @Override\n+        public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+            return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+        }\n+    \n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+            updatePropertyFromPath(path, mainAtts);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 177}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b3233a9421f57328d191b59bdc64e40be99e160", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/0b3233a9421f57328d191b59bdc64e40be99e160", "committedDate": "2020-11-30T20:44:44Z", "message": "DirConfigSource: fix imports, add equals() and hashCode() to DirProperty. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/a76cdb4428ef048916ea11b8f269044f8b89f813", "committedDate": "2020-11-30T20:48:02Z", "message": "DirConfigSource: move initial tree walker to anonymous declaration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjI4NTY1", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-541228565", "createdAt": "2020-11-30T19:34:23Z", "commit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTozNDoyNFrOH8Kfbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOToyMDo1NFrOH-NLTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODQ5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirProperty {\n          \n          \n            \n                private static final class DirProperty {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848495", "createdAt": "2020-11-30T19:34:24Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirPropertyWatcher implements Runnable {\n          \n          \n            \n                private static final class DirPropertyWatcher implements Runnable {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848834", "createdAt": "2020-11-30T19:34:56Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532849053", "createdAt": "2020-11-30T19:35:16Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTI4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    WatchService watcher = FileSystems.getDefault().newWatchService();\n          \n          \n            \n                    private final WatchService watcher = FileSystems.getDefault().newWatchService();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851281", "createdAt": "2020-11-30T19:39:01Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTM5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n          \n          \n            \n                    private final ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851391", "createdAt": "2020-11-30T19:39:16Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzAzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String property;\n          \n          \n            \n                    FileTime lastModifiedTime;\n          \n          \n            \n                    Path path;\n          \n          \n            \n                    int pathDepth;\n          \n          \n            \n                    final String property;\n          \n          \n            \n                    final FileTime lastModifiedTime;\n          \n          \n            \n                    final Path path;\n          \n          \n            \n                    final int pathDepth;", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532853039", "createdAt": "2020-11-30T19:42:06Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NjI2Nw==", "bodyText": "just keys is a bit generic, maybe watchedFiles (by keys)?", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532856267", "createdAt": "2020-11-30T19:47:17Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjUwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n          \n          \n            \n                private static final class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532862500", "createdAt": "2020-11-30T19:52:44Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjY1Mw==", "bodyText": "Better to return the found dir instead of initialising the field so this method becomes independent of the class.\nIt might become a method elsewhere or a static method that accepts a Config (from MPConfig) returning the dir which then can be passed as constructor argument to initialise this class. This allows to use this class with directory coming from MP config or any other source. Normally testing would be another candidate that then uses this parameter. You could think about moving the watcher part out of the constructor into a method that is called after constructing the instance passing in the executor service.\nvoid updateUsingFileWatcher(PayaraExecutorService executorService) {\n    //...\n    executorService.submit(new DirPropertyWatcher(this.directory));\n    //...\n}\nThis would allow to not trigger this in tests while you use it when creating the list of config sources.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533382653", "createdAt": "2020-12-01T12:48:43Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Path directory;\n          \n          \n            \n                private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n          \n          \n            \n                private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n            \n          \n          \n            \n                private final Path directory;\n          \n          \n            \n                private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533383254", "createdAt": "2020-12-01T12:49:40Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NzExNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return unmodifiableMap(properties\n          \n          \n            \n                                                .entrySet()\n          \n          \n            \n                                                .stream()\n          \n          \n            \n                                                .collect(\n          \n          \n            \n                                                    Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n          \n          \n            \n                                                ));\n          \n          \n            \n                    return unmodifiableMap(properties.entrySet().stream().collect(\n          \n          \n            \n                        toMap(Map.Entry::getKey, e -> e.getValue().property)));\n          \n      \n    \n    \n  \n\nneeds toMap being imported statically", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533387115", "createdAt": "2020-12-01T12:56:39Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY0NQ==", "bodyText": "I think you want to specify the encoding explicitly here.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r534989645", "createdAt": "2020-12-03T09:20:54Z", "author": {"login": "jbee"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(configService.getMPConfig().getSecretDir()),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), configService.getMPConfig().getSecretDir())\n+                                );\n+        for (Path candidate : candidates) {\n+            if (Files.exists(candidate) || Files.isDirectory(candidate) || Files.isReadable(candidate)) {\n+                this.directory = candidate;\n+                return;\n+            }\n+        }\n+    }\n+    \n+    void initializePropertiesFromPath(Path topmostDir) throws IOException {\n+        if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+            // initialize properties on first run\n+            Files.walkFileTree(topmostDir, new SimpleFileVisitor<Path>() {\n+                // Ignore hidden directories\n+                @Override\n+                public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    updatePropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } else {\n+            throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+        }\n+    }\n+    \n+    void updatePropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        // do not read hidden files, as K8s Secret filenames are symlinks to hidden files with data.\n+        // also ignore files > 512KB, as they are most likely no text config files...\n+        if (Files.isRegularFile(path) && ! Files.isHidden(path) && Files.isReadable(path) && mainAtts.size() < 512*1024) {\n+            // retrieve the property name from the file path\n+            String property = parsePropertyNameFromPath(path);\n+            \n+            // Conflict handling:\n+            // When this property is already present, check how to solve the conflict.\n+            // This property file will be skipped if the file we already have is deeper in the file tree...\n+            if (checkLongestMatchForPath(property, path)) {\n+                return;\n+            }\n+            \n+            properties.put(property, readPropertyFromPath(path, mainAtts));\n+        }\n+    }\n+    \n+    void removePropertyFromPath(Path path) {\n+        String property = parsePropertyNameFromPath(path);\n+    \n+        // not present? go away silently.\n+        if (! properties.containsKey(property)) return;\n+    \n+        // only delete from the map if the file that has been deleted is the same as the one stored in the map\n+        // -> deleting a file less specific but matching a property should not remove from the map\n+        // -> deleting a file more specific than in map shouldn't occur (it had to slip through longest match check then).\n+        if (path.equals(properties.get(property).path)) {\n+            properties.remove(property);\n+        }\n+        \n+    }\n+    \n+    String parsePropertyNameFromPath(Path path) {\n+        // 1. get relative path based on the config dir (\"/config\"),\n+        String property = directory.relativize(path.getParent()).toString();\n+        // 2. ignore all file suffixes after last dot\n+        property += path.getFileName().toString().substring(0, path.getFileName().toString().lastIndexOf('.')-1);\n+        // 3. replace all path seps with a \".\",\n+        property = property.replace(File.separatorChar, '.');\n+        // so \"/config/foo/bar/test/one.txt\" becomes \"foo/bar/test/one.txt\" becomes \"foo.bar.test.one\" property name\n+        return property;\n+    }\n+    \n+    /**\n+     * Check if the path given is a more specific path to a value for the given property\n+     * @param property\n+     * @param path\n+     * @return true if more specific, false if not\n+     */\n+    boolean checkLongestMatchForPath(String property, Path path) {\n+        // Make path relative to config directory\n+        // NOTE: we will never have a path containing \"..\", as our tree walkers are always inside this \"root\".\n+        Path relativePath = directory.relativize(path);\n+        \n+        // No property -> path is new and more specific\n+        if (! properties.containsKey(property))\n+            return true;\n+        DirProperty old = properties.get(property);\n+        \n+        // Check if this element has a higher path depth (longest match)\n+        // Example: \"foo.bar/test/one.txt\" (depth 2) wins over \"foo.bar.test.one.txt\" (depth 0)\n+        boolean depth = old.pathDepth > relativePath.getNameCount();\n+        \n+        // In case that both pathes have the same depth, we need to check on the position of dots.\n+        // Example: /config/foo.bar/test/one.txt is less specific than /config/foo/bar.test/one.txt\n+        if (old.pathDepth == relativePath.getNameCount()) {\n+            String oldPath = old.path.toString();\n+            String newPath = path.toAbsolutePath().toString();\n+            int offset = 0;\n+            while (offset > -1) {\n+                if (newPath.indexOf(\".\", offset) > oldPath.indexOf(\".\", offset)) return true;\n+                offset = oldPath.indexOf(\".\", offset + 1);\n+            }\n+        }\n+        return depth;\n+    }\n+    \n+    DirProperty readPropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            return new DirProperty(\n+                new String(Files.readAllBytes(path)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813"}, "originalPosition": 368}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccde673deae9a9cab5e102ef4409c34de6a4f25c", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/ccde673deae9a9cab5e102ef4409c34de6a4f25c", "committedDate": "2020-12-07T11:31:56Z", "message": "Refactor after review by @jbee. Mostly scope and naming changes. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "763f400bae4ff473a181d8367b8c709974d24d38", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/763f400bae4ff473a181d8367b8c709974d24d38", "committedDate": "2020-12-07T12:03:30Z", "message": "Make DirConfigSource retrieve the executor from the global ConfigProviderResolverImpl instead of explicit dep inject. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7601c8d90169d94c7818506adf311f1a741a79b3", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/7601c8d90169d94c7818506adf311f1a741a79b3", "committedDate": "2020-12-07T14:38:18Z", "message": "Add initial test DirConfigSourceTest and remove SecretDirConfigSourceTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4234a68b0294fb300026bc330fdb84baceea5520", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/4234a68b0294fb300026bc330fdb84baceea5520", "committedDate": "2020-12-07T14:40:59Z", "message": "Fix DirConfigSource.parsePropertyNameFromPath() to fix failing tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb622fca8dd8cb6b5e35fa87862407e470fa3feb", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/eb622fca8dd8cb6b5e35fa87862407e470fa3feb", "committedDate": "2020-12-07T16:30:51Z", "message": "Refactor DirConfigSource.DirProperty and test longest match. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e86e89a8aa4a06018bc247d3824b7bb0eb21eb2", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/8e86e89a8aa4a06018bc247d3824b7bb0eb21eb2", "committedDate": "2020-12-07T17:14:41Z", "message": "Rename DirConfigSource.checkLongestMatchForPath() to isLongerMatchForPath() to be more readable and fix check if property needs update. Adding more tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "committedDate": "2020-12-07T18:33:27Z", "message": "Add more test for initial read of property files in DirConfigSource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTMzNzU5", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-553533759", "createdAt": "2020-12-16T10:08:42Z", "commit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowODo0MlrOIG9jvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMzo0MFrOIG9xBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDk0MA==", "bodyText": "PayaraExecutorService tries to terminate gracefully via awaitTermination first. This loop therefore delays shutdown of the server by 5 seconds.\nConsider scheduling single take every few seconds instead, or polling synchronously during get.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544170940", "createdAt": "2020-12-16T10:08:42Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = rootPath.relativize(path).getNameCount();\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDM0MQ==", "bodyText": "This fails on Windows, because it has different condition for a hidden file. Consider explicit check for dot at start rather than isHidden.", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544174341", "createdAt": "2020-12-16T10:13:40Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/test/java/fish/payara/nucleus/microprofile/config/source/DirConfigSourceTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2017-2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.junit.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+public class DirConfigSourceTest {\n+\n+    private static Path testDirectory;\n+    private static DirConfigSource source;\n+    \n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        testDirectory = Files.createTempDirectory(\"microprofile-config-test-\");\n+        // create & load\n+        source = new DirConfigSource(testDirectory);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws IOException {\n+        Files.walk(testDirectory)\n+            .sorted(Comparator.reverseOrder())\n+            .map(Path::toFile)\n+            .forEach(File::delete);\n+    }\n+    \n+    @Test\n+    public void testParsePropertyNameFromPath() {\n+        // given\n+        Map<Path,String> examples = new HashMap<>();\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"), \"foo.bar.test.ex\");\n+        \n+        // we ignore the last file extension. always. this might lead to unexpected behaviour for a user.\n+        // best advice: do not use dots in filename, only in directory names.\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.txt\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.tar.gz\"), \"foo.bar.test.ex.tar\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test.ex\"), \"foo.bar.test\");\n+        \n+        // when & then\n+        for (Map.Entry<Path, String> ex : examples.entrySet()) {\n+            System.out.println(ex.getKey()+\" = \"+ex.getValue());\n+            assertEquals(ex.getValue(), source.parsePropertyNameFromPath(ex.getKey()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthLessSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+                  new DirConfigSource.DirProperty(\n+                      \"test\", FileTime.from(Instant.now()),\n+                      Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"),\n+                      testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertFalse(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar.test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar/test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthEqualMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo.bar/test/ex.one.txt\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PropNotPresent() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(\"foo.bar.test.ex.two\", Paths.get(testDirectory.toString(), \"foo.bar/test/ex.two.txt\")));\n+    }\n+    \n+    @Test\n+    public void testRemovePropertyFromPath() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo/bar/test\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        assertEquals(\"test\", source.getValue(property));\n+        \n+        // when\n+        source.removePropertyFromPath(Paths.get(testDirectory.toString(), \"foo/bar/test\"));\n+        // then\n+        assertTrue(source.getValue(property) == null);\n+        \n+    }\n+\n+    @Test\n+    public void testInitializeProperties_SimpleFiles() throws IOException {\n+        // given\n+        // only the most specific should be picked up (=test3)\n+        writeFile(testDirectory, \"foo.bar.test\", \"test\");\n+        writeFile(testDirectory, \"foo.bar/test\", \"test2\");\n+        writeFile(testDirectory, \"foo/bar/test\", \"test3\");\n+        \n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        \n+        //then\n+        assertEquals(\"test3\", source.getValue(\"foo.bar.test\"));\n+    }\n+    \n+    @Test\n+    public void testInitializeProperties_IgnoreHidden() throws IOException {\n+        // given\n+        // none of these should be picked up (hidden file or dir)\n+        writeFile(testDirectory, \".hidden.bar.test\", \"test\");\n+        writeFile(testDirectory, \".hidden/bar.test\", \"test\");\n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        //then\n+        assertEquals(null, source.getValue(\"hidden.bar.test\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d"}, "originalPosition": 221}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bda0ae1dcbf6f0a653f7d453383885da631bf57", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/9bda0ae1dcbf6f0a653f7d453383885da631bf57", "committedDate": "2021-01-25T18:16:05Z", "message": "refactor(mpconfig): incorporate review comments by @jbee and @pdudits #5006\n\nThis is kinda major refactoring, including code tested in sample project to ensure this runs on K8s.\n\nIt's still lacking tests! This is a commit to save the status."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a50ad85f504ea43b75174fc4f9e56ba4511ee1ad", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/a50ad85f504ea43b75174fc4f9e56ba4511ee1ad", "committedDate": "2021-01-25T23:27:55Z", "message": "fix(mpconfig): make dirconfigsource match same pathes on update and fix IOE when deleting. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8af024ff0e301a1590b160f288aa4ca23167d88", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/e8af024ff0e301a1590b160f288aa4ca23167d88", "committedDate": "2021-01-25T23:28:26Z", "message": "refactor(mpconfig): Add unit tests for DirConfigSource. #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f", "committedDate": "2021-01-25T23:59:26Z", "message": "test(mpconfig): fix wrong file size test for DirSourceConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2MTMyMDg2", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-576132086", "createdAt": "2021-01-26T08:49:56Z", "commit": {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxMjo0NDo1M1rOIaVR0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxMjo0NDo1M1rOIaVR0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQ4MjUxNQ==", "bodyText": "Another Windows FS-related trap here when configured with absolute path, this happens:\njava.nio.file.InvalidPathException: Illegal char <:> at index 100: C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\config\\secrets\n\nSo you might want to be more specific here, checking if Path.isAbsolute before constructing relative one", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564482515", "createdAt": "2021-01-26T12:44:53Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.SEVERE;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this(propertyValue, lastModifiedTime, path, rootPath.relativize(path).getNameCount());\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+    \n+        /**\n+         * Register file watchers recursively (as they don't attach themselfs to sub directories...)\n+         * and initialize values from files present and suitable.\n+         * @param dir Topmost directory to start recursive traversal from\n+         * @throws IOException\n+         */\n+        final void registerAll(Path dir) throws IOException {\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    // only register subdirectories if the directory itself is suitable.\n+                    if ( isAptDir(dir) ) {\n+                        register(dir);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    // file will be checked before upserting.\n+                    upsertPropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        final void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+            logger.finer(\"MPCONFIG DirConfigSource: registered \\\"\"+dir+\"\\\" as key \\\"\"+key+\"\\\".\");\n+        }\n+        \n+        @Override\n+        public final void run() {\n+            // wait infinitely until we receive an event (or the executor is shutting down)\n+            WatchKey key;\n+            try {\n+                key = watcher.take();\n+            } catch (InterruptedException ex) {\n+                logger.info(\"MPCONFIG DirConfigSource: shutting down watcher thread.\");\n+                return;\n+            }\n+            \n+            Path workDir = watchedFileKeys.get(key);\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                WatchEvent.Kind<?> kind = event.kind();\n+        \n+                @SuppressWarnings(\"unchecked\")\n+                WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                Path fileName = ev.context();\n+                Path path = workDir.resolve(fileName);\n+\n+                logger.finer(\"MPCONFIG DirConfigSource: detected change: \"+fileName.toString()+\" : \"+kind.toString());\n+        \n+                try {\n+                    // new directory to be watched and traversed\n+                    if (kind == ENTRY_CREATE && isAptDir(path)) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: registering new paths.\");\n+                        registerAll(path);\n+                    }\n+                    // new or updated file found (new = create + modify on content save)\n+                    // or new symlink found (symlinks are create only!) (also, aptness of file is checked inside update routine)\n+                    if ( kind == ENTRY_MODIFY || (kind == ENTRY_CREATE && Files.isSymbolicLink(path)) ) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: processing new or updated file \\\"\"+path.toString()+\"\\\".\");\n+                        BasicFileAttributes atts = Files.readAttributes(path, BasicFileAttributes.class);\n+                        upsertPropertyFromPath(path, atts);\n+                    }\n+                    if (Files.notExists(path) && ! watchedFileKeys.containsValue(path) && kind == ENTRY_DELETE) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: removing deleted file \\\"\"+path.toString()+\"\\\".\");\n+                        removePropertyFromPath(path);\n+                    }\n+                } catch (IOException e) {\n+                    logger.log(WARNING, \"MPCONFIG DirConfigSource: could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                }\n+            }\n+\n+            // Reset key (obligatory) and remove from set if directory no longer accessible\n+            boolean valid = key.reset();\n+            if (!valid) {\n+                logger.finer(\"MPCONFIG DirConfigSource: removing watcher for key \\\"\"+key+\"\\\".\");\n+                watchedFileKeys.remove(key);\n+            }\n+        }\n+    }\n+    \n+    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    private Path directory;\n+    private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    \n+    public DirConfigSource() {\n+        try {\n+            // get the directory from the app server config\n+            this.directory = findDir();\n+            // create the watcher for the directory\n+            configService.getExecutor().scheduleWithFixedDelay(createWatcher(this.directory), 0, 1, SECONDS);\n+        } catch (IOException e) {\n+            logger.log(SEVERE, \"MPCONFIG DirConfigSource: error during setup.\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory) {\n+        super(true);\n+        this.directory = directory;\n+    }\n+    \n+    // Used for testing only\n+    DirPropertyWatcher createWatcher(Path topmostDirectory) throws IOException {\n+        return new DirPropertyWatcher(topmostDirectory);\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties.entrySet().stream()\n+                                    .collect(toMap(Map.Entry::getKey, e -> e.getValue().propertyValue)));\n+    }\n+    \n+    // Used for testing only\n+    void setProperties(Map<String, DirProperty> properties) {\n+        this.properties.clear();\n+        this.properties.putAll(properties);\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.propertyValue;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private Path findDir() throws IOException {\n+        String path = configService.getMPConfig().getSecretDir();\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(path),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), path)\n+                                );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f"}, "originalPosition": 283}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc78c29891f616ce5ef9a9b68579a982e75c715a", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/dc78c29891f616ce5ef9a9b68579a982e75c715a", "committedDate": "2021-01-27T11:45:03Z", "message": "fix(mpconfig): Check for absolute pathes in DirConfigSource.findDir()\n\nThis avoids pathes on Windows being invalid, because concatenating\ntwo absolute pathes is not possible on Windows.\n\nPart of a solution for #5006"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7c2046cca0eb6de842d038f6fb8fb13b029723d", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/f7c2046cca0eb6de842d038f6fb8fb13b029723d", "committedDate": "2021-01-27T11:45:55Z", "message": "test(mpconfig): Have DirConfigSource.findDir() covered by tests.\n\nIntroducing some mocks to enable unit testing of findDir().\nNeeded to extend the base class constructors to be able to inject the mock.\n\nRelates to #5006\n\nP.S. Crossing fingers this runs on Windoze."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "784995fc5fffe5423fdf9a1783c1ed937f9cf8e0", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/784995fc5fffe5423fdf9a1783c1ed937f9cf8e0", "committedDate": "2021-01-27T17:26:56Z", "message": "refactor(mpconfig): Make DirConfigSource.isLongestMatch() more testable and use less memory\n\nThis commits make the logic part of isLongestMatch() a static function,\nmuch easier to unit test. The lookup part checking if the path is already\npresent somewhere is handled in a non-static function, so staying compatible\nwith using this config source for multiple locations.\n\nIt also refactored the inner DirProperty class to avoid saving the path depth\nand compute it instead, reducing the waste of resources.\n\nRelates to #5006"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NTk4MTc1", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-577598175", "createdAt": "2021-01-27T17:43:20Z", "commit": {"oid": "784995fc5fffe5423fdf9a1783c1ed937f9cf8e0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "401555dc167bc9ab319e2b35839073360f0e061a", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/401555dc167bc9ab319e2b35839073360f0e061a", "committedDate": "2021-01-27T18:25:50Z", "message": "feat(mpconfig): Make DirConfigSource ignore files with certains extensions\n\nIgnore *.properties, *.yaml, *.yml, *.xml, *.json files, as those are likely\nto contain more complex structures used for other config sources.\n\nRemember: the file name compiles to the property name (up to three letter\nendings silently cut off) and might contain whatever. If you put a\nfile with any of these extensions in the directory on purpose, it should not\nbe used with this config source.\n\n- Relates to #5006\n- Based on request from @pdudits in #5007"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce30d87d4c05366db7451beee69e581b449fafcc", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/ce30d87d4c05366db7451beee69e581b449fafcc", "committedDate": "2021-01-27T18:41:16Z", "message": "revert(mpconfig): by request from @pdudits, this isn't necessary for now.\n\nThis reverts commit 401555dc167bc9ab319e2b35839073360f0e061a."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45d7a33ca55b6237f175f3dcac5c605dbe675a13", "author": {"user": {"login": "poikilotherm", "name": "Oliver Bertuch"}}, "url": "https://github.com/payara/Payara/commit/45d7a33ca55b6237f175f3dcac5c605dbe675a13", "committedDate": "2021-01-27T18:46:11Z", "message": "fix(mpconfig): Do not cutoff file extensions for property names in DirConfigSource\n\nAs requested by @pdudits, do not cut off file extensions silently.\nPeople on Windows can deal with text files without a file extension,\nbetter stay consistent.\n\nRelates to #5006"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjU0Nzk5", "url": "https://github.com/payara/Payara/pull/5007#pullrequestreview-577654799", "createdAt": "2021-01-27T18:49:59Z", "commit": {"oid": "45d7a33ca55b6237f175f3dcac5c605dbe675a13"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 624, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}