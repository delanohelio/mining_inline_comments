{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzNjY0MDMy", "number": 5066, "title": "FISH-659: Fault Tolerance 3.0 full pass", "bodyText": "Description\nSmall refactorings in Fault Tolerance implementation to make all TCK test pass.\nThe core change was to return back to standard managed thread pools. These pools propagate application context correctly so the issue with having incorrect application name on invocation stack no longer applies.\nHowever the need for application name was greatly reduced in next optimization, where actual class and method reference are used as keys into state map, further stabilizing the tests.\nAlso discovered and fixed is memory leak in FaultTolerancePolicy's cache where entires were not deleted upon undeployment, which was troublesome especially for run of TCK. With these two changes together in became apparent that cleanup of method data can be removed, as data has relatively small footprint and keeping them removes confusion on what state of the system is.\nImportant Info\nTesting\nNew tests\n\nFull FT 3.0 TCK passes:\npayara/MicroProfile-TCK-Runners#133\nTesting Environment\n\nApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)\nJava version: 1.8.0_275, vendor: Azul Systems, Inc.\nDefault locale: en_US, platform encoding: Cp1252\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\n\nDocumentation\n\nDocumentation will require update, as all threadpool and cleanup related parameters are not applied anymore.\nNotes for Reviewers\n\n/cc @jbee, if you have bit of time, check if I didn't misunderstood any of the original intentions of the code.", "createdAt": "2020-12-21T18:51:50Z", "url": "https://github.com/payara/Payara/pull/5066", "merged": true, "mergeCommit": {"oid": "6be0836ddc52565a86e9b51bfb3e956db4f3f0bb"}, "closed": true, "closedAt": "2020-12-22T17:11:32Z", "author": {"login": "pdudits"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdnacTuAH2gAyNTQzNjY0MDMyOmY2MGJjZWY3YTYxOWVhZjIwYTIxMWNjNDM4YjY4ZWY1MGFmYjdiNzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdoscAQgH2gAyNTQzNjY0MDMyOjEyZDljMjFjZGZiZjg2ODM4ZjZkOGQ2ZjM0ODQ3MDA3ZmZlNzRlNzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f60bcef7a619eaf20a211cc438b68ef50afb7b73", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/f60bcef7a619eaf20a211cc438b68ef50afb7b73", "committedDate": "2020-12-18T16:08:44Z", "message": "FISH-659: Clear all application-related cache on undeployment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60c62493a079614ca49f2afd3c7917ff6617d452", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/60c62493a079614ca49f2afd3c7917ff6617d452", "committedDate": "2020-12-18T16:19:47Z", "message": "FISH-659: Revert to using managed executors for fault tolerance\n\nManaged executor retain invocation context upon submission, fixing the problem\nof interceptor getting fresh state because invocation manager returned wrong\napplication name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "624e3e42d10012f212b3b885580b59473b57e171", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/624e3e42d10012f212b3b885580b59473b57e171", "committedDate": "2020-12-21T17:21:27Z", "message": "FISH-659: Remove arbitrary limit on bulkhead CAS operation\n\nResulted in \"No free work or queue space\" when CAS would fail just 5 times.\nFix NPE in FaultToleranceInvocation.toString."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e1359f3c85eed347c4849e7c3a233ff8d06412c", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/6e1359f3c85eed347c4849e7c3a233ff8d06412c", "committedDate": "2020-12-21T18:13:28Z", "message": "FISH-659: Optimize initialization of FaultToleranceInterceptor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/b6f5638129116272d7e23bc0e51298995513b0e3", "committedDate": "2020-12-21T18:20:18Z", "message": "FISH-659: Use compound method key for FT data\n\nDetermining app name and composing String methodId unnecessarily slows down.\n\nApp name is determined once per method context now.\n\nFT data are now deleted upon undeployment by matching classes' classloaders\nagainst undeployed app's classloader.\n\nExpiration of the cache was removed, removing need for target object and expiration checks.\n\nFaultToleranceServiceStub introduces StubContext as encapsulation of MethodKey which would\notherwise need to be public."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2OTM5NjI5", "url": "https://github.com/payara/Payara/pull/5066#pullrequestreview-556939629", "createdAt": "2020-12-22T09:31:05Z", "commit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozMTowNlrOIJ0d4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwOTozNToyNVrOIJ0mdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2NzcxNQ==", "bodyText": "Nice idea.", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547167715", "createdAt": "2020-12-22T09:31:06Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/FaultToleranceServiceImpl.java", "diffHunk": "@@ -119,87 +115,28 @@\n     @Inject\n     private MetricsService metricsService;\n \n-    private final ConcurrentMap<String, ConcurrentMap<String, FaultToleranceMethodContextImpl>> contextByAppNameAndMethodId = new ConcurrentHashMap<>();\n+    private final ConcurrentMap<MethodKey, FaultToleranceMethodContextImpl> contextByMethod = new ConcurrentHashMap<>();\n     private final ConcurrentMap<String, BindableFaultToleranceConfig> configByAppName = new ConcurrentHashMap<>();\n-    private ThreadPoolExecutor asyncExecutorService;\n+    private ExecutorService asyncExecutorService;\n     private ScheduledExecutorService delayExecutorService;\n \n     @PostConstruct\n-    public void postConstruct() {\n+    public void postConstruct() throws NamingException {\n         events.register(this);\n         invocationManager = serviceLocator.getService(InvocationManager.class);\n         requestTracingService = serviceLocator.getService(RequestTracingService.class);\n         config = serviceLocator.getService(FaultToleranceServiceConfiguration.class);\n-        delayExecutorService = Executors.newScheduledThreadPool(getMaxDelayPoolSize());\n-        asyncExecutorService = new ThreadPoolExecutor(0, getMaxAsyncPoolSize(), getAsyncPoolKeepAliveInSeconds(),\n-                TimeUnit.SECONDS, new SynchronousQueue<Runnable>(true)); // a fair queue => FIFO\n-        int interval = getCleanupIntervalInMinutes();\n-        delayExecutorService.scheduleAtFixedRate(this::cleanMethodContexts, interval, interval, TimeUnit.MINUTES);\n-        if (config != null) {\n-            if (!\"concurrent/__defaultManagedExecutorService\".equals(config.getManagedExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance executor service was configured to managed executor service {0}. This option has been replaced by 'async-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedExecutorService());\n-            }\n-            if (!\"concurrent/__defaultManagedScheduledExecutorService\".equals(config.getManagedScheduledExecutorService())) {\n-                logger.log(Level.WARNING,\n-                        \"Fault tolerance scheduled executor service was configured to managed scheduled executor service {0}. This option has been replaced by 'delay-max-pool-size' to set the maximum size of a fixed Fault Tolerance pool.\",\n-                        config.getManagedScheduledExecutorService());\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Since {@link Map#compute(Object, java.util.function.BiFunction)} locks the key entry for\n-     * {@link ConcurrentHashMap} it is safe to remove the entry in case\n-     * {@link FaultToleranceMethodContextImpl#isExpired(long)} as concurrent call to\n-     * {@link Map#computeIfAbsent(Object, java.util.function.Function)} are going to wait for the completion of\n-     * {@link Map#compute(Object, java.util.function.BiFunction)}.\n-     */\n-    private void cleanMethodContexts() {\n-        final long ttl = TimeUnit.MINUTES.toMillis(1);\n-        int cleaned = 0;\n-        for (Map<String, FaultToleranceMethodContextImpl> appEntry : contextByAppNameAndMethodId.values()) {\n-            for (String key : new HashSet<>(appEntry.keySet())) {\n-                try {\n-                    Object newValue = appEntry.compute(key,\n-                            (k, methodContext) -> methodContext.isExpired(ttl) ? null : methodContext);\n-                    if (newValue == null) {\n-                        cleaned++;\n-                    }\n-                } catch (Exception e) {\n-                    logger.log(Level.WARNING, \"Failed to clean FT method context for \" + key, e);\n-                }\n-            }\n-        }\n-        if (cleaned > 0) {\n-            String allClean = contextByAppNameAndMethodId.isEmpty() ? \".All clean.\" : \".\";\n-            logger.log(Level.INFO, \"Cleaned {0} expired FT method contexts\" + allClean, cleaned);\n-        }\n-    }\n-\n-    private int getMaxDelayPoolSize() {\n-        return config == null ? 20 : parseInt(config.getDelayMaxPoolSize());\n-    }\n-\n-    private int getMaxAsyncPoolSize() {\n-        return config == null ? 2000 : parseInt(config.getAsyncMaxPoolSize());\n-    }\n-\n-    private int getAsyncPoolKeepAliveInSeconds() {\n-        return config == null ? 60 : parseInt(config.getAsyncPoolKeepAliveInSeconds());\n-    }\n-\n-    private int getCleanupIntervalInMinutes() {\n-        return config == null ? 1 : parseInt(config.getCleanupIntervalInMinutes());\n+        InitialContext context = new InitialContext();\n+        asyncExecutorService = (ManagedExecutorService) context.lookup(config.getManagedExecutorService());\n+        delayExecutorService = (ManagedScheduledExecutorService) context.lookup(config.getManagedScheduledExecutorService());\n     }\n \n     @Override\n     public void event(Event<?> event) {\n         if (event.is(Deployment.APPLICATION_UNLOADED)) {\n             ApplicationInfo info = (ApplicationInfo) event.hook();\n-            deregisterApplication(info.getName());\n-            FaultTolerancePolicy.clean();\n+            deregisterApplication(info);\n+            FaultTolerancePolicy.clean(info.getAppClassLoader());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzE2OTkxMQ==", "bodyText": "I assume you are happy to have this run in parallel threads in worst case as the result will be the same.", "url": "https://github.com/payara/Payara/pull/5066#discussion_r547169911", "createdAt": "2020-12-22T09:35:25Z", "author": {"login": "jbee"}, "path": "appserver/payara-appserver-modules/microprofile/fault-tolerance/src/main/java/fish/payara/microprofile/faulttolerance/service/MethodKey.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package fish.payara.microprofile.faulttolerance.service;\n+\n+import javax.interceptor.InvocationContext;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+/**\n+ * Identifier of method-related data in Fault Tolerance.\n+ * It is essential that the computed signature is referring to the {@link Method} as defined by the target\n+ * {@link Object} class not its declaring {@link Class} as this could be different when called via an abstract\n+ * {@link Method} implemented or overridden by the target {@link Class}.\n+ *\n+ * Since MP FT 3.0 all instances of a class share same state object for the same method. Or in other words the FT\n+ * context is not specific to an instance but to the annotated class and method.\n+ */\n+final class MethodKey {\n+    final Class<?> targetClass;\n+    final Method method;\n+    private String methodId;\n+\n+    MethodKey(InvocationContext ctx) {\n+        this.targetClass = ctx.getTarget().getClass();\n+        this.method = ctx.getMethod();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        MethodKey methodKey = (MethodKey) o;\n+        return targetClass.equals(methodKey.targetClass) && method.equals(methodKey.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(targetClass, method);\n+    }\n+\n+    String getMethodId() {\n+        if (methodId != null) {\n+            return methodId;\n+        }\n+        StringBuilder idBuilder = new StringBuilder();\n+        idBuilder.append(targetClass.getName()).append('.').append(method.getName());\n+        if (method.getParameterCount() > 0) {\n+            idBuilder.append('(');\n+            for (Class<?> param : method.getParameterTypes()) {\n+                idBuilder.append(param.getName()).append(' ');\n+            }\n+            idBuilder.append(')');\n+        }\n+        methodId = idBuilder.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2OTgwNzA0", "url": "https://github.com/payara/Payara/pull/5066#pullrequestreview-556980704", "createdAt": "2020-12-22T10:35:06Z", "commit": {"oid": "b6f5638129116272d7e23bc0e51298995513b0e3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12d9c21cdfbf86838f6d8d6f34847007ffe74e76", "author": {"user": {"login": "pdudits", "name": "Patrik Dudit\u0161"}}, "url": "https://github.com/payara/Payara/commit/12d9c21cdfbf86838f6d8d6f34847007ffe74e76", "committedDate": "2020-12-22T15:40:37Z", "message": "FISH-659: Lookup managed concurrency objects via their logical name\n\nLooking them up via logical name triggers the activator which\nwould create them in domain config if they are not materialized in domain.xml\nyet"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 650, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}