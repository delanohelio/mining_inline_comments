{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNjA1NTUx", "number": 4712, "title": "MicroProfile Config Value Resolver API POC", "bodyText": "Background\nThe programmatic MP Config API currently lacks certain capabilities that are granted when accessing configuration properties using CDI and the @ConfigProperty annotation. Like injecting Lists, Sets for properties with a value with potentially multiple elements. Or to provide a default value in its raw String form as provided by a ConfigSource.\nAs a consequence there was the need to use non standardised APIs when doing this programmatically. Essentially the Config needed to be cast to PayaraConfig to access extra methods available that would allow these operations.\nThe reason these were needed was also to implement the CDI support. This mismatch between the Config API and the standard capabilities granted by the @ConfigProperty annotation isn't news to the standard group. Over time there have been different proposals for a configuration resolver API which offers extended capabilities which among other features would close the gap between programmatic API and CDI semantics.\nDescription\nThis PR is a POC for an extended property value access API. It allows...\n\nuse of raw String defaults\nuse of typed defaults\nuse of ad-hoc converters\nuse of custom cache TTL\nuse trimming on source level values\nconversion to Lists and Sets\ncontrol of exception behaviour\nprocess resolution semantics once, resolve current value over and over with same semantics\n\nThis PR replaces the former \"proprietary\" PayaraConfig specific API with the  ConfigValueResolver API and uses it where appropriate.\nExceptions\nBy default the API is designed so no exception is thrown but instead a default, that must be provided to resolve the value, is returned in case of errors. One can chooses to opt-out of this \"non-throwing\" behaviour into throwing exceptions for missing properties or failed conversion or both.\nBy design it is not possible to resolve a value without providing a default.\nThe idea is to make it easy to always end up with a value that can be used without having to worry to have missed a case that would throw an exception anyway. Only if we decide we'd rather fail we opt-in to exceptions so that they are thrown. This is in contrast to the Config.getValue method which can be used if exceptions are preferred and non of the other extended features is needed.\nCaching\nThe cache used by Payara caches the final converted return value. Therefore the type of value requested for a property has to be part of the key as any property could be resolved as different types of values. If nothing else you could always resolve it as T, T[], List<T> and Set<T> where T is at least String; but often at least one other type, say Integer, and String.\nSimilar to this the TTL becomes part of the key so each TTL value ends up created another cache entry. This way there can be multiple call sites using different TTLs as long as the actual TTL isn't a number that is varying by nature. This has the benefit of changes applied to the default (\"global\") cache duration now have immediate effect as they start to request entries with different TTL as soon as the TTL has been changed.\nUsing Existing Config API\nThe way the extended API is hooked into the existing Config API is by using the existing semantics of the getValue(String,Class) method. A property is requested by its name and as the new extended API type ConfigValueResolver:\nConfigValueResolver resolver = config.getValue(\"my.property\", ConfigValueResolver.class)\nThe returned ConfigValueResolver instance is then used to customise the lookup semantics and finally to resolve the property value.\nList<Integer> ints = resolver.asList(Integer.class);\nList<Integer> ints = resolver.throwOnFailedConversion().asList(Integer.class);\nThis isn't meant for any kind of pre-resolution but it can be used to \"store and reuse\" the semantics of a lookup:\nstatic final ConfigValueResolver myProperty = config.getValue(\"my.property\", ConfigValueResolver.class).withDefault(userInputDefault).throwOnFailedConversion();\n//... repeatedly calling \nmyProperty.as(int.class, 0)\nGoals & Outlook\nMain goals are\n\nto support use cases required to implement CDI\nno longer require direct use of PayaraConfig class.\n\nBeing a POC the ConfigValueResolver API is also a Payara specific API. The POC should help to understand the use cases and see that they can be implemented. In the long run an API such as the ConfigValueResolver might be added to the standard allowing to only rely on standard API when accessing properties from MP Config. Until then we have the benefit of a more formalised, convenient and less error prone access of configuration property values.\nTesting\nTesting Performed\nManually running MP Config, MP Metrics and MP FT TCKs.\nDetailed instructions can be found in Testing section of #4614.\nPlease not that it also makes sense to test MP Config with cache enabled (value > 0) and check that only 2 tests (that depend on changing values) do fail.\nIn addition more then a hundred unit test cases were added to ensure the correct behaviour of the ConfigValueResolver.", "createdAt": "2020-06-12T10:42:05Z", "url": "https://github.com/payara/Payara/pull/4712", "merged": true, "mergeCommit": {"oid": "09e126b88c061736ae0295c7c8538f2beb64bae8"}, "closed": true, "closedAt": "2020-07-07T08:51:49Z", "author": {"login": "jbee"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnQ1gPgH2gAyNDMzNjA1NTUxOjg1NGZmMTRkYzFmMTFiZmY2MDhmYmFiMzY2ZWI0YWI4MzBmM2NlYWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyhtnLgFqTQ0MzY4MTA3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "854ff14dc1f11bff608fbab366eb4ab830f3ceaf", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/854ff14dc1f11bff608fbab366eb4ab830f3ceaf", "committedDate": "2020-06-02T08:46:03Z", "message": "incomplete state - context switch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d313e522325cae226089dc5e2ce02e17c88ef2f", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/7d313e522325cae226089dc5e2ce02e17c88ef2f", "committedDate": "2020-06-09T12:21:34Z", "message": "Initial implementation of ConfigValueResolver and some tests (needs more tests)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07178329f514fd0490f62d3cc0d106e7dd7c70ef", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/07178329f514fd0490f62d3cc0d106e7dd7c70ef", "committedDate": "2020-06-10T10:06:38Z", "message": "adds more unit tests for ConfigValueResolver"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946514822799ba616eb32483fa21b07a9f8c0229", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/946514822799ba616eb32483fa21b07a9f8c0229", "committedDate": "2020-06-10T11:26:29Z", "message": "fixes CDI provider behaviour for missing properties in connection with defaults"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51c18b37469cd077abc4a5e3b5cdea34929a4a16", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/51c18b37469cd077abc4a5e3b5cdea34929a4a16", "committedDate": "2020-06-10T13:34:36Z", "message": "adds tests for arrays and TTL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f4994a6ddae5048a7286c0d55a1db59d4811c4c", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/5f4994a6ddae5048a7286c0d55a1db59d4811c4c", "committedDate": "2020-06-10T14:52:39Z", "message": "adds copyright headers, extracts ArrayConverter to top level class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d194a813e7862ebc2e358260970b471070936a1", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/6d194a813e7862ebc2e358260970b471070936a1", "committedDate": "2020-06-10T15:08:26Z", "message": "adds javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4OTkxNTEy", "url": "https://github.com/payara/Payara/pull/4712#pullrequestreview-438991512", "createdAt": "2020-06-29T08:31:40Z", "commit": {"oid": "5f4994a6ddae5048a7286c0d55a1db59d4811c4c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQwODozMTo0MFrOGqKHMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMzo0MjozNFrOGqRjKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg1OTA1Ng==", "bodyText": "Nitpick - wouldn't immutable empty collections work better as default?", "url": "https://github.com/payara/Payara/pull/4712#discussion_r446859056", "createdAt": "2020-06-29T08:31:40Z", "author": {"login": "pdudits"}, "path": "appserver/payara-appserver-modules/microprofile/config/src/main/java/fish/payara/microprofile/config/cdi/ConfigProducer.java", "diffHunk": "@@ -92,17 +92,20 @@ public Config getConfig() {\n     @ConfigProperty\n     public <T> Set<T> getSetProperty(InjectionPoint ip) {\n         ConfigProperty property = ip.getAnnotated().getAnnotation(ConfigProperty.class);\n-        PayaraConfig config = (PayaraConfig) ConfigProvider.getConfig();\n-        Set<T> result = new HashSet<>();\n+        Config config = ConfigProvider.getConfig();\n         Type type = ip.getType();\n         if (type instanceof ParameterizedType) {\n-            // it is an Optional\n-            // get the class of the generic parameterized Optional\n+         // it is an List, get the element type of the List\n             @SuppressWarnings(\"unchecked\")\n-            Class<T> clazzValue = (Class<T>) ((ParameterizedType) type).getActualTypeArguments()[0];\n-            result = config.getSetValues(property.name(), property.defaultValue(), clazzValue);\n+            Class<T> elementType = (Class<T>) ((ParameterizedType) type).getActualTypeArguments()[0];\n+            String defaultValue = property.defaultValue();\n+            return config.getValue(property.name(), ConfigValueResolver.class)\n+                    .throwOnMissingProperty(defaultValue == null)\n+                    .throwOnFailedConversion()\n+                    .withDefault(defaultValue)\n+                    .asSet(elementType);\n         }\n-        return result;\n+        return new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f4994a6ddae5048a7286c0d55a1db59d4811c4c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk4MDkwNA==", "bodyText": "I don't agree. There's no universal rule when this makes sense and when it doesn't. And there are too many options on how things can be handled.\nThere is large ommision in the TCK not giving out enough negative testcases, and taskcases that would clean confusion around trimming, empty values and so forth. But I think current wording does not give us the freedom to do more things in the stardard converter. There are tests for primitive converters, which do expect IllegalArgumentException to be thrown, just as javadoc of Converter  suggests.\nI see that this behavior is expected in realm classes above, but I think it would be more secure to just extend your nice resolver API, where collection methods would have methods to specify:\n\nTo trim value before converting\nTo ignore some parsing errors (or all parsing errors returning empty collection)\nTo allow empty values (as nulls), to skip them, or to throw errors.", "url": "https://github.com/payara/Payara/pull/4712#discussion_r446980904", "createdAt": "2020-06-29T13:42:34Z", "author": {"login": "pdudits"}, "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/converters/ArrayConverter.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.converters;\n+\n+import java.lang.reflect.Array;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+/**\n+ * Converts reference and primitive arrays.\n+ *\n+ * For convenience the converter skips empty elements as well as elements for which conversion fails. If all\n+ * elements fail to convert the conversion exception is forwarded (thrown). Otherwise a warning is logged and the\n+ * working elements as kept.\n+ *\n+ * This is a grey-area in the standard but from a users point of view it most often makes sense to work with the\n+ * elements that are well defined and ignore the others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f4994a6ddae5048a7286c0d55a1db59d4811c4c"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d6c23e09b0ad5aa2fae2ad197cfae503ddf9805", "author": {"user": {"login": "jbee", "name": "Jan Bernitt"}}, "url": "https://github.com/payara/Payara/commit/4d6c23e09b0ad5aa2fae2ad197cfae503ddf9805", "committedDate": "2020-07-01T08:02:13Z", "message": "addresses Patrik's review feedback: array converter fails when using Config#getValue, resolver skips by default and allows configuration, adds trimming to resolver"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjgxMDc4", "url": "https://github.com/payara/Payara/pull/4712#pullrequestreview-443681078", "createdAt": "2020-07-07T08:38:59Z", "commit": {"oid": "4d6c23e09b0ad5aa2fae2ad197cfae503ddf9805"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 723, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}