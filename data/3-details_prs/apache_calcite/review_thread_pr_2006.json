{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5ODg2MjA2", "number": 2006, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNzo0ODoyNFrOEDQK8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowODo1MlrOEbeTtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODQ2MTI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNzo0ODoyNFrOGgK5uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1MjoyM1rOGg0K1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ==", "bodyText": "I will probably add more comments to these new methods to explain what they are doing.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r436386235", "createdAt": "2020-06-07T17:48:24Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MjM1OA==", "bodyText": "Can you rebase on master? I just updated this file.\nUse ImmutableIntList.incr instead.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062358", "createdAt": "2020-06-08T23:52:23Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjc4MTEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1NDoxNlrOGg0MyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1NDoxNlrOGg0MyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2Mjg1Ng==", "bodyText": "See RelCollations.containsOrderless, you can make the private one public is necessary.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062856", "createdAt": "2020-06-08T23:54:16Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n+    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n+    for (int i : intList) {\n+      arrayList.add(i + offset);\n+    }\n+    return arrayList;\n+  }\n+\n+  private boolean isSubset(List<Integer> a, List<Integer> b) {\n+    if (a.size() > b.size()) {\n+      return false;\n+    }\n+    Set<Integer> set = new HashSet<>(b);\n+    for (int i = 0; i < a.size(); i++) {\n+      if (!set.contains(a.get(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzEyMDk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyMTowNlrOGg3bqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyMTowNlrOGg3bqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTgxOA==", "bodyText": "nice catch. in case the keys are 1,1,2,2. IMHO, we shouldn't see duplicate join keys in physical merge/hash join operators. They should be optimized away, because that means the predicate is not pushed down at all.\nlike foo.a = bar.b and foo.a=bar.c. The predicate bar.b=bar.c should be pushed down for table bar.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437115818", "createdAt": "2020-06-09T03:21:06Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzEyNTU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNDoxM1rOGg3egg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNDoxMToxMFrOGg4Gxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng==", "bodyText": "why do you want to sort it?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437116546", "createdAt": "2020-06-09T03:24:13Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyNjg1NQ==", "bodyText": "isPrefixOrderingNotRequired sorts its input, and reqKeys is used as this function's parameter below.\nBut since you have suggested RelCollations.containsOrderless, I might not need this anymore.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437126855", "createdAt": "2020-06-09T04:11:10Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzEyODU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNjoxNFrOGg3gVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNDozNzowMFrOGiOO9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ==", "bodyText": "You can use RelCollations.containsOrderless", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437117015", "createdAt": "2020-06-09T03:26:14Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4OTAzMg==", "bodyText": "isPrefixOrderingNotRequired probably is the one I cannot use RelCollations.containsOrderless. It is designed for superset case. In which join keys should be 1) an orderless subset 2) prefix of required collations.\nRelCollations.containsOrderless does not consider prefix requirement.\nAlternatively, I am ok to move isPrefixOrderingNotRequired to RelCollations as a util function.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437889032", "createdAt": "2020-06-10T06:32:39Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDEyMg==", "bodyText": "For supset case, for example if required collation is [d, b, a ,c]\nthen join keys [d, b, a] is valid\njoin keys [d,a,c] is not (if push down [d,b,a,c], it does not guarantee the ordering of [d,a,c]", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437890122", "createdAt": "2020-06-10T06:35:37Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODQ0Nw==", "bodyText": "can you explain RelCollations.containsOrderless does not consider prefix requirement.?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438448447", "createdAt": "2020-06-10T22:46:54Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNDI5OQ==", "bodyText": "containsOrderless only consider if one is another's subset, for example:\n[1, 2, 3] is [2, 3, 4, 1]'s subset\n[3, 2, 1] is [2, 1, 3, 4] 's subset\nThe prefix requirement is, still use examples above, but apply sublist:\n[2,3,4,1] -> [2,3,4], then containsOrderless([1,2,3]) = false.\n[2,1,3,4] ->[2,1,3], then containsOrderless([3,2,1]) = true.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438534299", "createdAt": "2020-06-11T04:20:56Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzk3Mg==", "bodyText": "In fact, I mis-read how containsOrderless is implemented. It actually meets the need here.\nHave changed to containsOrderless and dropped unused code.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438537972", "createdAt": "2020-06-11T04:37:00Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjY1NjM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowMTo0MVrOGhaJjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowMTo0MVrOGhaJjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NDYyMA==", "bodyText": "let's use a var to store left.getRowType().getFieldCount().", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437684620", "createdAt": "2020-06-09T20:01:41Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+      // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n+      // (order not matter), also sort keys are all from right join input.\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjY2MzkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowNDoxNFrOGhaOZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNjoyNzowN1rOGhmfpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw==", "bodyText": "can we use reqKeys.stream().allMatch()?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437685863", "createdAt": "2020-06-09T20:04:14Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4Njg4NQ==", "bodyText": "Done! Thanks!", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437886885", "createdAt": "2020-06-10T06:27:07Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw=="}, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTc4Mjc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwMToxOTowNFrOGjaLgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwNDo1NjozM1rOGjaw-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA==", "bodyText": "Why toIntegerList?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782274", "createdAt": "2020-06-14T01:19:04Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzU3Nw==", "bodyText": "To this specific case, toIntegerList to get a list of key indexes (not shifted, so index from 0). Then, later, in superset cases, we can use this list to remove collations that are not on keys. Use this query as an example:\nselect * from foo join bar on foo.a=bar.a and foo.b=bar.b order by bar.a, bar.b, bar.c; \nwe can push\ncollation a b to left\ncollation a, b, c to right\nThus the output of join should still be sorted by a, b, c.\nThen, the toIntegerList helps to to that only a, b needs to pushed to left.  It works along with\nRelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\nMappings.TargetMapping mapping = buildMapping(false);\nRelCollation leftCollation =\n          RexUtil.apply(\n              mapping,\n              removeCollationFieldsNotOnJoinKey(rightCollation, rightKeysNotShifted));", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783577", "createdAt": "2020-06-14T01:51:11Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzczNQ==", "bodyText": "why ImmutableIntList is not suitable?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783735", "createdAt": "2020-06-14T01:54:39Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDc3MA==", "bodyText": "Let me check if this process can be simplified somehow.\nFor the example above, I am only looking for a way to\nleftCollation = requiredCollation.apply(join keys) // only need collation defined on keys for left input,", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784770", "createdAt": "2020-06-14T02:18:37Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4OTc4Nw==", "bodyText": "I still don't understand, why can't just use joinInfo.rightKeys, instead use joinInfo.rightKeys. toIntegerList?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439789787", "createdAt": "2020-06-14T04:13:20Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTg2Ng==", "bodyText": "yes joinInfo.rightKeys can be used because ImmutableIntList implements IndexOf. I will change it to joinInfo.rightKeys", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791866", "createdAt": "2020-06-14T04:56:33Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTc4MzA5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwMToyMDowMlrOGjaLqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoxMToxMVrOHFuhEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ==", "bodyText": "It is not obvious to get the meaning from method name. An example and comment will help.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782315", "createdAt": "2020-06-14T01:20:02Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDE0Ng==", "bodyText": "Let me add some comments with an example (a little bit complicated but let me try).", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784146", "createdAt": "2020-06-14T02:04:07Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwNjI2NQ==", "bodyText": "I also think the method name is counter-intuitive. It is actually not removing anything, it just builds a new collation based on a \"source\" collation, considering only the fields which are part of the joinKeys. I would propose as name e.g. reduceCollation, intersect, or something like that..", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473006265", "createdAt": "2020-08-19T12:55:00Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTMzMA==", "bodyText": "friendly reminder about these comments", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475449330", "createdAt": "2020-08-24T09:09:36Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTYyNg==", "bodyText": "oops. I have missed this comment.\nWill address this one and another comment.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475759626", "createdAt": "2020-08-24T16:57:54Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2NzA1Nw==", "bodyText": "intersectCollationAndJoinKey is a reasonable name for me.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475767057", "createdAt": "2020-08-24T17:11:11Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTc4NDA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwMToyMzozM1rOGjaMIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNDo0ODowOVrOGjjGjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA==", "bodyText": "Do we need to keep the keys order?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782434", "createdAt": "2020-06-14T01:23:33Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDEyMQ==", "bodyText": "No for subset cases. For example, required collation [foo.a, foo.b] defined on foo.a=bar.a and foo.b=bar.b and foo.c=bar.c and foo.d=bar.d, either pass down [foo.a, foo.b, foo.c, foo.d] or pass down [foo.a, foo.b, foo.d, foo.c] will give correct answer (same to push the same collations to right join input).\nIt is because, for MergeJoin implementation, the pointers moves when left tuple not equals to right tuple, and the only requirement is next tuple should be bigger than previous ones.\nStill use example above:\nleft join input and right join input both are sorted by [a, b, d, c]. So\n\nleft_tuple.compare(right_tuple) < 0, move left pointer, of course next tuple will be both bigger than a) the previous left tuple b) the current right tuple (due to they are all sorted by [a, b]).\nsame for ``left_tuple.compare(right_tuple) > 0` case.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784121", "createdAt": "2020-06-14T02:03:31Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDI0OA==", "bodyText": "to add a bit explanation on the example above, the only usefulness of pushed collocations on [d, c], is just to maintain increasing order when move left pointer on left join input during merging. Thus [c, d] will achieve the same thing.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784248", "createdAt": "2020-06-14T02:06:08Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDIzNg==", "bodyText": "Why not just use bitset.except to compute the diff keys?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790236", "createdAt": "2020-06-14T04:24:18Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTcyNw==", "bodyText": "Will check how to use bitset.except.\nMeanwhile, in fact, the ordering does matter for EnumerableMergeJoin, it is because key selector and key comparator are constructed by join key ordering.\nThus we have to follow join key ordering to extend required collations.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791727", "createdAt": "2020-06-14T04:54:36Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODQ2Mw==", "bodyText": "Use bitset.except now to compute diff.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928463", "createdAt": "2020-06-15T04:48:09Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTg0NzQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwNDoxOTo1M1rOGjap8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNDo0ODozMlrOGjjGzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA==", "bodyText": "How can it be true if sort keys are subset of left join keys?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790064", "createdAt": "2020-06-14T04:19:53Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTY4NA==", "bodyText": "You might not notice, I have changed the code of containsOrderless and added this\n    if (colKeys.size() < distinctKeys.size()) {\n      return containsOrderlessSubset(collation.getKeys().toIntegerList(), distinctKeys);\n    } else {\n\nSo firstly, collations contains fields less than join keys is allowed. Then, it is only legal if collations follows the ordering of sort keys (and later at runtime, key selector and key comparator are constructed by sort key ordering).", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791684", "createdAt": "2020-06-14T04:53:12Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTkwMg==", "bodyText": "This breaks the definition of the method name. containsOrderless means the former contains the latter. We can create another method containsOrderless(List<Integer>, List<Integer>) if necessary.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791902", "createdAt": "2020-06-14T04:57:23Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTk1OQ==", "bodyText": "I need to update containsOrderlessSubset to make it consider list ordering.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791959", "createdAt": "2020-06-14T04:58:37Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODUyNw==", "bodyText": "Add containsOrderless(List<Integer>, List<Integer>) now to obey the naming convention.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928527", "createdAt": "2020-06-15T04:48:32Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTY4OTcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0MjozOFrOHC9USQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjoyNToyNlrOHD-aTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw==", "bodyText": "I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472863817", "createdAt": "2020-08-19T08:42:38Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxNjcyNw==", "bodyText": "The reasons that I didn't use overloaded approach\n\nthese names are in the format of A verb B, means the first parameter contains the second parameter. And arguments of these functions have an ordering of A and B. I think this is more readable.\nFor Java, List is the same type. For example, List<Integer>  and List<Collation> are both List<T> thus List<Object>. So we cannot overload, for example collationsContainKeysOrderless and keysContainCollationsOrderless", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473316727", "createdAt": "2020-08-19T21:02:28Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzMDMxOA==", "bodyText": "Ok, I understand, thanks for the explanation.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473930318", "createdAt": "2020-08-20T12:25:26Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NTY5ODkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0NDo1NFrOHC9Z3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0NDo1NFrOHC9Z3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2NTI0NQ==", "bodyText": "minor: typo in 'defiend'", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472865245", "createdAt": "2020-08-19T08:44:54Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,48 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NjE4ODMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMDo1NToyNVrOHDCCew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMDo1NToyNVrOHDCCew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0MTE3OQ==", "bodyText": "Given that containsOrderless already does a Util.distinctList(keys), we could skip it here.\nThe same applies to collationsContainKeysOrderless", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472941179", "createdAt": "2020-08-19T10:55:25Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -227,6 +247,21 @@ public static boolean containsOrderless(List<RelCollation> collations,\n     return false;\n   }\n \n+  /**\n+   * Returns whether one of a list of collations is contained by the given list of keys\n+   * regardless the order.\n+   */\n+  public static boolean keysContainCollationsOrderless(\n+      List<Integer> keys,  List<RelCollation> collations) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NjU3MzkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMjo0NjoyOVrOHDFsLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMToyNzo0MlrOHDaT2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ==", "bodyText": "I think it would be helpful to describe the general logic and all the different cases in a javadoc on passThroughTraits", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473001005", "createdAt": "2020-08-19T12:46:29Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MzY3OA==", "bodyText": "Got it. Will give a summary as java doc.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473193678", "createdAt": "2020-08-19T17:11:01Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzODg0Mg==", "bodyText": "Added a summary.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473338842", "createdAt": "2020-08-19T21:27:42Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1NjgyNDg0OnYy", "diffSide": "RIGHT", "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo0NDoyMlrOHDIFNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjoyNzowNlrOHD-d4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MDE4Mg==", "bodyText": "Warning: the current implementation of EnumerableMergeJoin only supports keys sorted in ascending order nulls last, this will be a limitation if we ever want to actually run a plan like this one.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473040182", "createdAt": "2020-08-19T13:44:22Z", "author": {"login": "rubenada"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -491,6 +491,81 @@ EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n ]]>\n     </Resource>\n   </TestCase>\n+    <TestCase name=\"testSortMergeJoinSubsetKey\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select * from\n+        sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n+        order by r.job desc nulls last]]>\n+        </Resource>\n+        <Resource name=\"planBefore\">\n+            <![CDATA[\n+LogicalSort(sort0=[$2], dir0=[DESC-nulls-last])\n+  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], ENAME0=[$9], JOB0=[$10], SAL0=[$11], COMM0=[$12])\n+    LogicalJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])\n+]]>\n+        </Resource>\n+        <Resource name=\"planAfter\">\n+            <![CDATA[\n+EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+  EnumerableSort(sort0=[$2], sort1=[$1], dir0=[DESC-nulls-last], dir1=[ASC])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MjUxMw==", "bodyText": "Ack! Indeed it is.\nWe have created a JIRA: https://issues.apache.org/jira/browse/CALCITE-4010. After this PR is done, I will ask Feng whether he still has time to work on CALCITE-4010. If not I can take it over to update the EnumerableMergeJoin implementation.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473192513", "createdAt": "2020-08-19T17:08:55Z", "author": {"login": "amaliujia"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -491,6 +491,81 @@ EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n ]]>\n     </Resource>\n   </TestCase>\n+    <TestCase name=\"testSortMergeJoinSubsetKey\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select * from\n+        sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n+        order by r.job desc nulls last]]>\n+        </Resource>\n+        <Resource name=\"planBefore\">\n+            <![CDATA[\n+LogicalSort(sort0=[$2], dir0=[DESC-nulls-last])\n+  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], ENAME0=[$9], JOB0=[$10], SAL0=[$11], COMM0=[$12])\n+    LogicalJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])\n+]]>\n+        </Resource>\n+        <Resource name=\"planAfter\">\n+            <![CDATA[\n+EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+  EnumerableSort(sort0=[$2], sort1=[$1], dir0=[DESC-nulls-last], dir1=[ASC])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MDE4Mg=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzMTIzMw==", "bodyText": "I agree, this will be addressed by CALCITE-4010, I just wanted to make sure that we were aware of this current limitation", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473931233", "createdAt": "2020-08-20T12:27:06Z", "author": {"login": "rubenada"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -491,6 +491,81 @@ EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n ]]>\n     </Resource>\n   </TestCase>\n+    <TestCase name=\"testSortMergeJoinSubsetKey\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select * from\n+        sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n+        order by r.job desc nulls last]]>\n+        </Resource>\n+        <Resource name=\"planBefore\">\n+            <![CDATA[\n+LogicalSort(sort0=[$2], dir0=[DESC-nulls-last])\n+  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], ENAME0=[$9], JOB0=[$10], SAL0=[$11], COMM0=[$12])\n+    LogicalJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])\n+]]>\n+        </Resource>\n+        <Resource name=\"planAfter\">\n+            <![CDATA[\n+EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+  EnumerableSort(sort0=[$2], sort1=[$1], dir0=[DESC-nulls-last], dir1=[ASC])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MDE4Mg=="}, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjQzNTcyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowODo1M1rOHFbGaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowMDoxMlrOHFyWaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw==", "bodyText": "maybe we could also add some unit tests for the new method keysContainCollationsOrderless?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475448937", "createdAt": "2020-08-24T09:08:53Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "diffHunk": "@@ -84,18 +84,36 @@\n         is(true));\n   }\n \n-  /** Unit test for {@link RelCollations#containsOrderless(List, List)}. */\n+  /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyOTg2NA==", "bodyText": "Makes sense. Added the test.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475829864", "createdAt": "2020-08-24T19:00:12Z", "author": {"login": "amaliujia"}, "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "diffHunk": "@@ -84,18 +84,36 @@\n         is(true));\n   }\n \n-  /** Unit test for {@link RelCollations#containsOrderless(List, List)}. */\n+  /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw=="}, "originalCommit": {"oid": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 173, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}