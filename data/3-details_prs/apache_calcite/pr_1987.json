{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNjgwMTQ2", "number": 1987, "title": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer ", "bodyText": "https://issues.apache.org/jira/browse/CALCITE-4020", "createdAt": "2020-05-22T02:29:05Z", "url": "https://github.com/apache/calcite/pull/1987", "merged": true, "mergeCommit": {"oid": "d7eb31b91560e34269a097dc720cbe926983bb0c"}, "closed": true, "closedAt": "2020-06-18T08:18:50Z", "author": {"login": "xy2953396112"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABck7XeqAFqTQxNzkzNjI2Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcraOLxgBqjM0NDI3MzY3MjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3OTM2MjY2", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-417936266", "createdAt": "2020-05-26T02:37:20Z", "commit": {"oid": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozNzoyMVrOGaM7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozNzoyMVrOGaM7pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODAzOQ==", "bodyText": "What's the difference between testCalcFieldTrimmer0  and testCalcFieldTrimmer1?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r430128039", "createdAt": "2020-05-26T02:37:21Z", "author": {"login": "chunweilei"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -183,4 +190,96 @@\n     assertThat(trimmed, hasTree(expected));\n   }\n \n+  @Test public void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d"}, "originalPosition": 30}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/2b7c1ecddfde961f767a418baab5e5dd55b6a94d", "committedDate": "2020-05-22T02:26:25Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}, "afterCommit": {"oid": "a9a4d81ed9732650701307c25b2747623539275b", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/a9a4d81ed9732650701307c25b2747623539275b", "committedDate": "2020-06-09T09:20:31Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9a4d81ed9732650701307c25b2747623539275b", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/a9a4d81ed9732650701307c25b2747623539275b", "committedDate": "2020-06-09T09:20:31Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}, "afterCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "committedDate": "2020-06-12T00:16:51Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NTI0NTEw", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-429524510", "createdAt": "2020-06-12T07:36:29Z", "commit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozNjozMFrOGi6Ipw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozNjozMFrOGi6Ipw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ==", "bodyText": "Hints need to be transferred from the original Calc to the new Calc (see CALCITE-4055).\nAlso, IMHO this piece of code could be refactored, to avoid duplicating instructions at the end of the \"if\" and \"else\" block, something like:\nRexNode newConditionExpr = null;\nif (rexProgram.getCondition() != null) {\n  ...\n  newConditionExpr = conditionExpr.accept(shuttle);\n}\nfinal RexProgram newRexProgram = ...\nfinal LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\nlogicalCalc.withHints(calc.getHints()); // transfer hints\nreturn result(logicalCalc, mapping);", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439257255", "createdAt": "2020-06-12T07:36:30Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+          rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+\n+      final RexNode newConditionExpr =\n+          conditionExpr.accept(shuttle);\n+      final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+          newProjects, newConditionExpr, newRowType.getFieldNames(),\n+          newInputRelNode.getCluster().getRexBuilder());\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+\n+      return result(logicalCalc, mapping);\n+    } else {\n+      final RexProgram newRexProgram = RexProgram\n+          .create(newInputRelNode.getRowType(), newProjects, null,\n+              newRowType.getFieldNames(), newInputRelNode.getCluster().getRexBuilder());\n+\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+      return result(logicalCalc, mapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NTI1ODEy", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-429525812", "createdAt": "2020-06-12T07:38:45Z", "commit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozODo0NVrOGi6MOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozODo0NVrOGi6MOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1ODE2OQ==", "bodyText": "I am not sure if, in this situation, the hints from the original Calc must / can be transferred into the new \"dummy Project\". What do you think @danny0405 ?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439258169", "createdAt": "2020-06-12T07:38:45Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 79}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "committedDate": "2020-06-12T00:16:51Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}, "afterCommit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/0e1c03554808853ef939d290bde3c0d0eaa1f964", "committedDate": "2020-06-13T00:11:01Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTI2NTUx", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-430126551", "createdAt": "2020-06-13T09:20:49Z", "commit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwOToyMDo0OVrOGjWpCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwOToyMDo0OVrOGjWpCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDI5OQ==", "bodyText": "minor: I think in this test it would also make sense to verify that the original Calc (relNode.getInput(0).getInput(0)) contains the hints.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439724299", "createdAt": "2020-06-13T09:20:49Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -306,4 +314,139 @@\n     assertTrue(project.getHints().contains(projectHint));\n   }\n \n+  @Test void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder().\n+        addRuleInstance(ProjectToCalcRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer1() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..2=[{inputs}], expr#3=[100], expr#4=[>($t0, $t3)], proj#0.\"\n+        + \".2=[{exprs}], $condition=[$t4])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..2=[{inputs}], proj#0..2=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1], DEPTNO=[$7])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer2() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .addRuleInstance(CalcMergeRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], expr#2=[100], expr#3=[>($t0, $t2)], proj#0.\"\n+        + \".1=[{exprs}], $condition=[$t3])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcWithHints() {\n+    final RelHint calcHint = RelHint.builder(\"resource\").build();\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    builder.getCluster().setHintStrategies(\n+        HintStrategyTable.builder().hintStrategy(\"resource\", HintPredicates.CALC).build());\n+    final RelNode original =\n+        builder.scan(\"EMP\")\n+            .project(\n+                builder.field(\"EMPNO\"),\n+                builder.field(\"ENAME\"),\n+                builder.field(\"DEPTNO\")\n+            ).hints(calcHint)\n+            .sort(builder.field(\"EMPNO\"))\n+            .project(builder.field(\"EMPNO\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .build();\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(original);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"  LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n+        + \"    LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+\n+    assertTrue(original.getInput(0).getInput(0) instanceof Project);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964"}, "originalPosition": 156}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/0e1c03554808853ef939d290bde3c0d0eaa1f964", "committedDate": "2020-06-13T00:11:01Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}, "afterCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "committedDate": "2020-06-13T09:42:50Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjk0MzE4", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-430294318", "createdAt": "2020-06-15T02:57:01Z", "commit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMjo1NzowMVrOGjhzNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMjo1NzowMVrOGjhzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzEyNw==", "bodyText": "Do we have to use LinkedHashSet ? Looks like HashSet is enough.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439907127", "createdAt": "2020-06-15T02:57:01Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjk2MDkz", "url": "https://github.com/apache/calcite/pull/1987#pullrequestreview-430296093", "createdAt": "2020-06-15T03:04:18Z", "commit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzowNDoxOFrOGjh5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzowNDoxOFrOGjh5WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODY5Nw==", "bodyText": "Should we use Calc#copy to generate new Calc?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439908697", "createdAt": "2020-06-15T03:04:18Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    RexNode newConditionExpr = null;\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+              rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+      newConditionExpr = conditionExpr.accept(shuttle);\n+    }\n+    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+        newProjects, newConditionExpr, newRowType.getFieldNames(),\n+        newInputRelNode.getCluster().getRexBuilder());\n+    final LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+    // transfer hints\n+    return result(logicalCalc.withHints(calc.getHints()), mapping);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "committedDate": "2020-06-15T05:57:22Z", "message": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer (Xu Zhaohui)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "committedDate": "2020-06-13T09:42:50Z", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)"}, "afterCommit": {"oid": "6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "author": {"user": {"login": "xy2953396112", "name": "xzh"}}, "url": "https://github.com/apache/calcite/commit/6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "committedDate": "2020-06-15T05:57:22Z", "message": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer (Xu Zhaohui)"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3433, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}