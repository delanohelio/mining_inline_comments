{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MjkzMjg5", "number": 2109, "title": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "bodyText": "", "createdAt": "2020-08-13T10:23:18Z", "url": "https://github.com/apache/calcite/pull/2109", "merged": true, "mergeCommit": {"oid": "103c73f639443e84fae4a600aa5ab05a8139cf91"}, "closed": true, "closedAt": "2020-09-04T07:52:39Z", "author": {"login": "thomasrebele"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-frN_gFqTQ2NjczOTIzOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdE7MVMABqjM3MTk1NDQ4MTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzM5MjM5", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-466739239", "createdAt": "2020-08-13T13:03:39Z", "commit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMzozOVrOHAKhoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowMzozOVrOHAKhoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDQ5Nw==", "bodyText": "minor: for consistency reasons inside this method, please declare all variables as \"final\" (if they are effectively final)", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469934497", "createdAt": "2020-08-13T13:03:39Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzQ0MDI0", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-466744024", "createdAt": "2020-08-13T13:09:11Z", "commit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowOToxMVrOHAKvaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzowOToxMVrOHAKvaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODAyNA==", "bodyText": "Inside implement method you allow this.fetch to be a dynamic parameter; however here (computeSelfCost) you assume it will be a RexLiteral (I have the impression that arriving at this point with a RexDynamicParam will throw an exception).\nEither we modify cost computation (but it will be impossible to give a precise cost in case of dynamic parameter); or to simplify things we could decide that EnumerableLimitSort only supports fetch (and offset) in the form of RexLiteral (and adapt EnumerableLimitSortRule accordingly).", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469938024", "createdAt": "2020-08-13T13:09:11Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);\n+\n+    PhysType inputPhysType = result.physType;\n+    final Pair<Expression, Expression> pair =\n+        inputPhysType.generateCollationKey(this.collation.getFieldCollations());\n+\n+    Expression fetchVal;\n+    if (this.fetch == null) {\n+      fetchVal = Expressions.constant(Integer.valueOf(Integer.MAX_VALUE));\n+    } else {\n+      fetchVal = getExpression(this.fetch);\n+    }\n+\n+    Expression offsetVal = this.offset == null ? Expressions.constant(Integer.valueOf(0))\n+        : getExpression(this.offset);\n+\n+    builder.add(\n+        Expressions.return_(\n+            null, Expressions.call(\n+                BuiltInMethod.ORDER_BY_WITH_FETCH_AND_OFFSET.method, Expressions.list(\n+                    childExp,\n+                    builder.append(\"keySelector\", pair.left))\n+                    .appendIfNotNull(builder.appendIfNotNull(\"comparator\", pair.right))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"offset\",\n+                            Expressions.constant(offsetVal)))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"fetch\",\n+                            Expressions.constant(fetchVal)))\n+            )));\n+    return implementor.result(physType, builder.toBlock());\n+  }\n+\n+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+    final double rowCount = mq.getRowCount(this.input).doubleValue();\n+    double toSort = this.fetch == null ? rowCount : RexLiteral.intValue(this.fetch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzQ5ODkz", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-466749893", "createdAt": "2020-08-13T13:15:59Z", "commit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzoxNTo1OVrOHALA9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzoxNTo1OVrOHALA9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0MjUxNg==", "bodyText": "this if condition looks wrong/useless", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469942516", "createdAt": "2020-08-13T13:15:59Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(\n+      Enumerable<TSource> source,\n+      Function1<TSource, TKey> keySelector,\n+      Comparator<TKey> comparator,\n+      int offset, int fetch) {\n+    return new AbstractEnumerable<TSource>() {\n+      @Override public Enumerator<TSource> enumerator() {\n+        TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);\n+        long size = 0;\n+        long needed = fetch + offset;\n+\n+        try (Enumerator<TSource> os = source.enumerator()) {\n+          while (os.moveNext()) {\n+            TSource o = os.current();\n+            TKey key = keySelector.apply(o);\n+            if (needed >= 0 && size >= needed) {\n+              if (comparator.compare(key, map.lastKey()) >= 0) {\n+                continue;\n+              }\n+              // remove last entry from tree map\n+              List<TSource> l = map.get(map.lastKey());\n+              if (l.size() == 1) {\n+                map.remove(map.lastKey());\n+              } else {\n+                l.remove(l.size() - 1);\n+              }\n+              size--;\n+            }\n+            map.compute(key, (k, l) -> {\n+              if (l == null) {\n+                return Collections.singletonList(o);\n+              }\n+              if (l.size() == 1) {\n+                l = new ArrayList<>(l);\n+              }\n+              l.add(o);\n+              return l;\n+            });\n+            size++;\n+          }\n+        }\n+\n+        if (offset > 0) {\n+          // search until which key we have to remove entries from the map\n+          int skipped = 0;\n+          TKey until = null;\n+          for (Map.Entry<TKey, List<TSource>> e : map.entrySet()) {\n+            skipped += e.getValue().size();\n+\n+            if (skipped > offset) {\n+              // we might need to remove entries from the list\n+              List<TSource> l = e.getValue();\n+              int toKeep = skipped - offset;\n+              if (toKeep < l.size()) {\n+                l.subList(0, l.size() - toKeep).clear();\n+              }\n+\n+              until = e.getKey();\n+              break;\n+            }\n+          }\n+          if (until == null) {\n+            return Linq4j.emptyEnumerator();\n+          } else if (until != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NzYyNTYz", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-466762563", "createdAt": "2020-08-13T13:30:48Z", "commit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzozMDo0OFrOHALm-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxMzozMDo0OFrOHALm-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ==", "bodyText": "minor: maybe adding here the same comment that we have in toLookup_ to explain the choice of List implementation?\n// for first entry, use a singleton list to save space\n// when we go from 1 to 2 elements, switch to array list", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469952249", "createdAt": "2020-08-13T13:30:48Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(\n+      Enumerable<TSource> source,\n+      Function1<TSource, TKey> keySelector,\n+      Comparator<TKey> comparator,\n+      int offset, int fetch) {\n+    return new AbstractEnumerable<TSource>() {\n+      @Override public Enumerator<TSource> enumerator() {\n+        TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);\n+        long size = 0;\n+        long needed = fetch + offset;\n+\n+        try (Enumerator<TSource> os = source.enumerator()) {\n+          while (os.moveNext()) {\n+            TSource o = os.current();\n+            TKey key = keySelector.apply(o);\n+            if (needed >= 0 && size >= needed) {\n+              if (comparator.compare(key, map.lastKey()) >= 0) {\n+                continue;\n+              }\n+              // remove last entry from tree map\n+              List<TSource> l = map.get(map.lastKey());\n+              if (l.size() == 1) {\n+                map.remove(map.lastKey());\n+              } else {\n+                l.remove(l.size() - 1);\n+              }\n+              size--;\n+            }\n+            map.compute(key, (k, l) -> {\n+              if (l == null) {\n+                return Collections.singletonList(o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTUxNzE5", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-467151719", "createdAt": "2020-08-13T21:43:01Z", "commit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMTo1MDozMVrOHAe8Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowOTo0MFrOHAfZjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2ODkzOA==", "bodyText": "remove the extra //", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470268938", "createdAt": "2020-08-13T21:50:31Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSortRule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelRule;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.logical.LogicalSort;\n+\n+/**\n+ * Rule to convert an {@link EnumerableLimit} of on\n+ * {@link EnumerableSort} into an {@link EnumerableLimitSort}.\n+ */\n+public class EnumerableLimitSortRule extends RelRule<EnumerableLimitSortRule.Config> {\n+\n+  /**\n+   * Creates a EnumerableLimitSortRule.\n+   */\n+  public EnumerableLimitSortRule(Config config) {\n+    super(config);\n+  }\n+\n+  @Override public void onMatch(RelOptRuleCall call) {\n+    final LogicalSort sort = call.rel(0);\n+    RelNode input = sort.getInput();\n+    final Sort o = EnumerableLimitSort.create(//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTIzNg==", "bodyText": "Out of curiosity: why do you decide to extend Sort?", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470271236", "createdAt": "2020-08-13T21:56:04Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MjYyOQ==", "bodyText": "Do you need\n            EnumerableRules.ENUMERABLE_SORT_RULE,\n            EnumerableRules.ENUMERABLE_LIMIT_RULE,\n\nas you have listed EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE in the list?", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470272629", "createdAt": "2020-08-13T21:59:40Z", "author": {"login": "amaliujia"}, "path": "core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java", "diffHunk": "@@ -1039,6 +1039,54 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged) {\n         .check();\n   }\n \n+  /**\n+   * Test if limit and sort are replaced by a limit sort.\n+   * Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3920\">[CALCITE-3920]\n+   * Improve ORDER BY computation in Enumerable convention by exploiting LIMIT</a>.\n+   */\n+  @Test void testLimitSort() {\n+    final String sql = \"select mgr from sales.emp\\n\"\n+        + \"union select mgr from sales.emp\\n\"\n+        + \"order by mgr limit 10 offset 5\";\n+\n+    VolcanoPlanner planner = new VolcanoPlanner(null, null);\n+    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n+    RelOptUtil.registerDefaultRules(planner, false, false);\n+    planner.addRule(EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE);\n+\n+    Tester tester = createTester().withDecorrelation(true)\n+        .withClusterFactory(\n+            relOptCluster -> RelOptCluster.create(planner, relOptCluster.getRexBuilder()));\n+\n+    RelRoot root = tester.convertSqlToRel(sql);\n+\n+    String planBefore = NL + RelOptUtil.toString(root.rel);\n+    getDiffRepos().assertEquals(\"planBefore\", \"${planBefore}\", planBefore);\n+\n+    RuleSet ruleSet =\n+        RuleSets.ofList(\n+            EnumerableRules.ENUMERABLE_SORT_RULE,\n+            EnumerableRules.ENUMERABLE_LIMIT_RULE,\n+            EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDczMg==", "bodyText": "+1. I was also looking for some comments to explain the algorithm briefly.", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470274732", "createdAt": "2020-08-13T22:05:01Z", "author": {"login": "amaliujia"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(\n+      Enumerable<TSource> source,\n+      Function1<TSource, TKey> keySelector,\n+      Comparator<TKey> comparator,\n+      int offset, int fetch) {\n+    return new AbstractEnumerable<TSource>() {\n+      @Override public Enumerator<TSource> enumerator() {\n+        TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);\n+        long size = 0;\n+        long needed = fetch + offset;\n+\n+        try (Enumerator<TSource> os = source.enumerator()) {\n+          while (os.moveNext()) {\n+            TSource o = os.current();\n+            TKey key = keySelector.apply(o);\n+            if (needed >= 0 && size >= needed) {\n+              if (comparator.compare(key, map.lastKey()) >= 0) {\n+                continue;\n+              }\n+              // remove last entry from tree map\n+              List<TSource> l = map.get(map.lastKey());\n+              if (l.size() == 1) {\n+                map.remove(map.lastKey());\n+              } else {\n+                l.remove(l.size() - 1);\n+              }\n+              size--;\n+            }\n+            map.compute(key, (k, l) -> {\n+              if (l == null) {\n+                return Collections.singletonList(o);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ=="}, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjA3Nw==", "bodyText": "Does it make sense to name this function as topNOrderBy or topNSortLimit?", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470276077", "createdAt": "2020-08-13T22:08:36Z", "author": {"login": "amaliujia"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjQ5Mg==", "bodyText": "Why not use max?", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470276492", "createdAt": "2020-08-13T22:09:40Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);\n+\n+    PhysType inputPhysType = result.physType;\n+    final Pair<Expression, Expression> pair =\n+        inputPhysType.generateCollationKey(this.collation.getFieldCollations());\n+\n+    Expression fetchVal;\n+    if (this.fetch == null) {\n+      fetchVal = Expressions.constant(Integer.valueOf(Integer.MAX_VALUE));\n+    } else {\n+      fetchVal = getExpression(this.fetch);\n+    }\n+\n+    Expression offsetVal = this.offset == null ? Expressions.constant(Integer.valueOf(0))\n+        : getExpression(this.offset);\n+\n+    builder.add(\n+        Expressions.return_(\n+            null, Expressions.call(\n+                BuiltInMethod.ORDER_BY_WITH_FETCH_AND_OFFSET.method, Expressions.list(\n+                    childExp,\n+                    builder.append(\"keySelector\", pair.left))\n+                    .appendIfNotNull(builder.appendIfNotNull(\"comparator\", pair.right))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"offset\",\n+                            Expressions.constant(offsetVal)))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"fetch\",\n+                            Expressions.constant(fetchVal)))\n+            )));\n+    return implementor.result(physType, builder.toBlock());\n+  }\n+\n+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+    final double rowCount = mq.getRowCount(this.input).doubleValue();\n+    double toSort = this.fetch == null ? rowCount : RexLiteral.intValue(this.fetch);\n+    if (this.offset != null) {\n+      toSort += RexLiteral.intValue(this.offset);\n+    }\n+    toSort = Math.min(rowCount, toSort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72"}, "originalPosition": 135}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a777643adb49dcaf3c31066ec40e08a55e529c72", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/a777643adb49dcaf3c31066ec40e08a55e529c72", "committedDate": "2020-08-13T10:21:05Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "acc1b44c9e466d4e2603b98389a89120818797c2", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/acc1b44c9e466d4e2603b98389a89120818797c2", "committedDate": "2020-08-18T10:48:42Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acc1b44c9e466d4e2603b98389a89120818797c2", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/acc1b44c9e466d4e2603b98389a89120818797c2", "committedDate": "2020-08-18T10:48:42Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "d92beec74a043aad5807c154bef5062bab1074ca", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/d92beec74a043aad5807c154bef5062bab1074ca", "committedDate": "2020-08-18T10:49:29Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d92beec74a043aad5807c154bef5062bab1074ca", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/d92beec74a043aad5807c154bef5062bab1074ca", "committedDate": "2020-08-18T10:49:29Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "de5200dd34f0e9997a4440b63ca1c0d25af97b18", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/de5200dd34f0e9997a4440b63ca1c0d25af97b18", "committedDate": "2020-08-19T08:34:38Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de5200dd34f0e9997a4440b63ca1c0d25af97b18", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/de5200dd34f0e9997a4440b63ca1c0d25af97b18", "committedDate": "2020-08-19T08:34:38Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "committedDate": "2020-09-02T09:53:44Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "committedDate": "2020-09-02T09:53:44Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "a809ca073b14443b643c39002155a9802bb1fe19", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/a809ca073b14443b643c39002155a9802bb1fe19", "committedDate": "2020-09-02T10:32:05Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNzM0NDUx", "url": "https://github.com/apache/calcite/pull/2109#pullrequestreview-480734451", "createdAt": "2020-09-02T11:39:43Z", "commit": {"oid": "a809ca073b14443b643c39002155a9802bb1fe19"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a809ca073b14443b643c39002155a9802bb1fe19", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/a809ca073b14443b643c39002155a9802bb1fe19", "committedDate": "2020-09-02T10:32:05Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "2507ea29b223eaaa59663774a151c445510d683f", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/2507ea29b223eaaa59663774a151c445510d683f", "committedDate": "2020-09-02T11:58:56Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01b38c4545ba272329ec3565c961cc28484e6494", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/01b38c4545ba272329ec3565c961cc28484e6494", "committedDate": "2020-09-02T12:30:36Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT (Thomas Rebele)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2507ea29b223eaaa59663774a151c445510d683f", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/2507ea29b223eaaa59663774a151c445510d683f", "committedDate": "2020-09-02T11:58:56Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT"}, "afterCommit": {"oid": "01b38c4545ba272329ec3565c961cc28484e6494", "author": {"user": null}, "url": "https://github.com/apache/calcite/commit/01b38c4545ba272329ec3565c961cc28484e6494", "committedDate": "2020-09-02T12:30:36Z", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT (Thomas Rebele)"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3225, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}