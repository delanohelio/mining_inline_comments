{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MTkzMDM5", "number": 1937, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoyMjoxOFrOD0rjqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNzo1NzoxOFrOD4T6wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTY2MTg2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoyMjoxOFrOGJu9gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoyMjoxOFrOGJu9gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1OTc3OA==", "bodyText": "Not sure if there is a way to express String.CASE_INSENSITIVE_ORDER as an Expression... (for the moment using \"\".CASE_INSENSITIVE_ORDER as workaround)", "url": "https://github.com/apache/calcite/pull/1937#discussion_r412859778", "createdAt": "2020-04-22T10:22:18Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java", "diffHunk": "@@ -258,6 +264,85 @@\n         .returnsUnordered(\"empid=100\\nempid=110\\nempid=150\\nempid=200\");\n   }\n \n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df564c0ed2780784b61c25c81f567e18c14577b5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTMwMDA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoyNDoxMlrOGMW7lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToxODoyMlrOGM4ICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ==", "bodyText": "Having a linq4j.tree.Expression in this level seems a bit weird. I don't remember any other class in the sql package having dependencies to linq4j. Moreover, for those projects that do not rely on Enumerable this method is a bit useless.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415611799", "createdAt": "2020-04-27T08:24:12Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return Comparator expression to be used, or null if no special comparator is required.\n+   */\n+  public Expression getComparatorExpression() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyMTM1Ng==", "bodyText": "I agree. I guess a cleaner solution would be having an EnumerableSqlCollation extends SqlCollation and having this method in there?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415721356", "createdAt": "2020-04-27T11:09:49Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return Comparator expression to be used, or null if no special comparator is required.\n+   */\n+  public Expression getComparatorExpression() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NTY1Nw==", "bodyText": "@zabetak I removed the Expression dependency and created an auxiliary method in EnumUtils to generate the expression for a certain SqlCollation's collator", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416155657", "createdAt": "2020-04-27T21:18:22Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return Comparator expression to be used, or null if no special comparator is required.\n+   */\n+  public Expression getComparatorExpression() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTMxNTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoyNzoxOFrOGMXERw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToxODo1NVrOGM4JUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxNDAyMw==", "bodyText": "Is it better to return a Comparator or Collator? If we need to generate collation keys in other places then maybe the second option is preferable.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415614023", "createdAt": "2020-04-27T08:27:18Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NTk4NQ==", "bodyText": "Collator will give us more possibilities. Changed into Collator.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416155985", "createdAt": "2020-04-27T21:18:55Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxNDAyMw=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTM1MDI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODozNDo1NFrOGMXYXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowMTo1N1rOGOkW8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng==", "bodyText": "The newly added method indicate that projects should rely on inheritance to define a new collation but the documentation doesn't say so. Moreover, I get the feeling that this information is not an extension but really part of this class.\nUsing inheritance brings up questions like what happens with equals and hashCode? Should the comparator be part of it?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415619166", "createdAt": "2020-04-27T08:34:54Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NjYyMg==", "bodyText": "Refactored, inheritance no longer needed.\nCollator is now extracted from Locale and strength (so it implicitly becomes part of the equals / hashCode)", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416156622", "createdAt": "2020-04-27T21:20:11Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODk0Ng==", "bodyText": "Re-refactored, and back to inheritance (JavaCollation extends SqlCollation), but equals/hashCode should work fine in that case too.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928946", "createdAt": "2020-04-30T11:01:57Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTM5NTk1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo0NDo1M1rOGMXzgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowMDozNFrOGOkUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjExMg==", "bodyText": "This test is similar to the logic of SqlOperatorBaseTest. Could we move things there? Are there things that we could reuse?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415626112", "createdAt": "2020-04-27T08:44:53Z", "author": {"login": "zabetak"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.sql.SqlCollation;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Test cases for\n+ * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3951\">[CALCITE-3951]\n+ * Support different string comparison based on SqlCollation</a>.\n+ */\n+class EnumerableStringComparisonTest {\n+\n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator<String> getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),\n+              \"CASE_INSENSITIVE_ORDER\");\n+        }\n+  };\n+\n+  private RelDataType createRecordVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().builder()\n+        .add(\n+            \"name\",\n+            builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+                builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+                builder.getTypeFactory().getDefaultCharset(),\n+                NO_CASE))\n+        .build();\n+  }\n+\n+  private RelDataType createVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+        builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+        builder.getTypeFactory().getDefaultCharset(),\n+        NO_CASE);\n+  }\n+\n+  @Test void testSortNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withRel(builder -> builder\n+            .values(\n+                createRecordVarcharNoCase(builder),\n+                \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\")\n+            .sort(\n+                builder.field(1, 0, \"name\"))\n+            .build())\n+        .explainHookMatches(\"\"\n+            + \"EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"  EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\")\n+        .returnsOrdered(\"name=Administration\\n\"\n+            + \"name=hr\\n\"\n+            + \"name=Legal\\n\"\n+            + \"name=MARKETING\\n\"\n+            + \"name=presales\");\n+  }\n+\n+  @Test void testMergeJoinOnStringNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {\n+          planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n+          planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n+        })\n+        .withRel(builder -> builder\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\").as(\"v1\")\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Marketing\", \"bureaucracy\", \"Sales\", \"HR\").as(\"v2\")\n+              .join(JoinRelType.INNER,\n+                  builder.equals(\n+                      builder.field(2, 0, \"name\"),\n+                      builder.field(2, 1, \"name\")))\n+              .project(\n+                  builder.field(\"v1\", \"name\"),\n+                  builder.field(\"v2\", \"name\"))\n+              .build())\n+        .explainHookMatches(\"\" // It is important that we have MergeJoin in the plan\n+            + \"EnumerableMergeJoin(condition=[=($0, $1)], joinType=[inner])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Marketing' }, { 'bureaucracy' }, { 'Sales' }, { 'HR' }]])\\n\")\n+        .returnsOrdered(\"name=hr; name0=HR\\n\"\n+            + \"name=MARKETING; name0=Marketing\");\n+  }\n+\n+  @Test void testStringComparison() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODIxOA==", "bodyText": "SqlOperatorBaseTest is based on Sql strings, this tests requires RelBuilder (since JavaCollation cannot be extracted from sql string), so for the moment it cannot be moved there.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928218", "createdAt": "2020-04-30T11:00:34Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.sql.SqlCollation;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Test cases for\n+ * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3951\">[CALCITE-3951]\n+ * Support different string comparison based on SqlCollation</a>.\n+ */\n+class EnumerableStringComparisonTest {\n+\n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator<String> getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),\n+              \"CASE_INSENSITIVE_ORDER\");\n+        }\n+  };\n+\n+  private RelDataType createRecordVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().builder()\n+        .add(\n+            \"name\",\n+            builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+                builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+                builder.getTypeFactory().getDefaultCharset(),\n+                NO_CASE))\n+        .build();\n+  }\n+\n+  private RelDataType createVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+        builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+        builder.getTypeFactory().getDefaultCharset(),\n+        NO_CASE);\n+  }\n+\n+  @Test void testSortNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withRel(builder -> builder\n+            .values(\n+                createRecordVarcharNoCase(builder),\n+                \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\")\n+            .sort(\n+                builder.field(1, 0, \"name\"))\n+            .build())\n+        .explainHookMatches(\"\"\n+            + \"EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"  EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\")\n+        .returnsOrdered(\"name=Administration\\n\"\n+            + \"name=hr\\n\"\n+            + \"name=Legal\\n\"\n+            + \"name=MARKETING\\n\"\n+            + \"name=presales\");\n+  }\n+\n+  @Test void testMergeJoinOnStringNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {\n+          planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n+          planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n+        })\n+        .withRel(builder -> builder\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\").as(\"v1\")\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Marketing\", \"bureaucracy\", \"Sales\", \"HR\").as(\"v2\")\n+              .join(JoinRelType.INNER,\n+                  builder.equals(\n+                      builder.field(2, 0, \"name\"),\n+                      builder.field(2, 1, \"name\")))\n+              .project(\n+                  builder.field(\"v1\", \"name\"),\n+                  builder.field(\"v2\", \"name\"))\n+              .build())\n+        .explainHookMatches(\"\" // It is important that we have MergeJoin in the plan\n+            + \"EnumerableMergeJoin(condition=[=($0, $1)], joinType=[inner])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Marketing' }, { 'bureaucracy' }, { 'Sales' }, { 'HR' }]])\\n\")\n+        .returnsOrdered(\"name=hr; name0=HR\\n\"\n+            + \"name=MARKETING; name0=Marketing\");\n+  }\n+\n+  @Test void testStringComparison() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjExMg=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTQzMDI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo1MjowNlrOGMYHcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyMTozNVrOGM4PIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTIxNg==", "bodyText": "Collations are compared with equals but is the Comparator part of the equals? Should it be?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415631216", "createdAt": "2020-04-27T08:52:06Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/rex/RexBuilder.java", "diffHunk": "@@ -919,9 +919,12 @@ protected RexLiteral makeLiteral(\n       // from the type if necessary.\n       assert o instanceof NlsString;\n       NlsString nlsString = (NlsString) o;\n-      if ((nlsString.getCollation() == null)\n-          || (nlsString.getCharset() == null)) {\n-        assert type.getSqlTypeName() == SqlTypeName.CHAR;\n+      if (nlsString.getCollation() == null\n+          || nlsString.getCharset() == null\n+          || !nlsString.getCharset().equals(type.getCharset())\n+          || !nlsString.getCollation().equals(type.getCollation())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NzQ3NA==", "bodyText": "Collator is now extracted from SqlCollation's Locale and strength (so it implicitly becomes part of the equals / hashCode)", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416157474", "createdAt": "2020-04-27T21:21:35Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rex/RexBuilder.java", "diffHunk": "@@ -919,9 +919,12 @@ protected RexLiteral makeLiteral(\n       // from the type if necessary.\n       assert o instanceof NlsString;\n       NlsString nlsString = (NlsString) o;\n-      if ((nlsString.getCollation() == null)\n-          || (nlsString.getCharset() == null)) {\n-        assert type.getSqlTypeName() == SqlTypeName.CHAR;\n+      if (nlsString.getCollation() == null\n+          || nlsString.getCharset() == null\n+          || !nlsString.getCharset().equals(type.getCharset())\n+          || !nlsString.getCollation().equals(type.getCollation())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTIxNg=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTQ4NDkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwOTowMzoyMVrOGMYnAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowMDo1OFrOGOkU3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTI5OA==", "bodyText": "Possibly we could deprecate/remove the old methods (e.g., le(String b0, String b1) and always use the new alternatives with the Comparator. When we don't have one we could use String::compareTo or Comparator.naturalOrder to have the same behavior as before.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415639298", "createdAt": "2020-04-27T09:03:21Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -730,6 +743,11 @@ public static boolean le(String b0, String b1) {\n     return b0.compareTo(b1) <= 0;\n   }\n \n+  /** SQL <code>&le;</code> operator applied to String values. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODQxNA==", "bodyText": "I prefer to leave them for backwards compatibility", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928414", "createdAt": "2020-04-30T11:00:58Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -730,6 +743,11 @@ public static boolean le(String b0, String b1) {\n     return b0.compareTo(b1) <= 0;\n   }\n \n+  /** SQL <code>&le;</code> operator applied to String values. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTI5OA=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTQ5MTgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwOTowNDo1MFrOGMYrEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyMDo1OFrOGM4NhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MDMzOQ==", "bodyText": "Normally we should call this method only with parameters of type String. Why do we need Object?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415640339", "createdAt": "2020-04-27T09:04:50Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -638,6 +639,13 @@ public static boolean eq(Object b0, Object b1) {\n     return b0.equals(b1);\n   }\n \n+  /** SQL <code>=</code> operator applied to Object values (including String;\n+   * neither side may be null). */\n+  public static boolean eq(Object b0, Object b1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NzA2MA==", "bodyText": "Parameters modified.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416157060", "createdAt": "2020-04-27T21:20:58Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -638,6 +639,13 @@ public static boolean eq(Object b0, Object b1) {\n     return b0.equals(b1);\n   }\n \n+  /** SQL <code>=</code> operator applied to Object values (including String;\n+   * neither side may be null). */\n+  public static boolean eq(Object b0, Object b1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MDMzOQ=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTU3NDU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/runtime/Utilities.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwOToyMjo1MVrOGMZbIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNTowMVrOGM4XBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MjY0MA==", "bodyText": "Do we need all this new variants? Note that there are also the standard java methods Comparator.nullsFirst and Comparator.nullsLast.\nIf we have a Comparator at hand then we could directly generate the code:\nComparator nfc = Comparator.nullsFirst(comparator);\nnfc.compare(v0, v1);\n\nI don't see clearly why we need to use the Utilties redirection in this case.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415652640", "createdAt": "2020-04-27T09:22:51Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/Utilities.java", "diffHunk": "@@ -212,6 +213,27 @@ public static int compareNullsLast(Comparable v0, Comparable v1) {\n                 : v0.compareTo(v1);\n   }\n \n+  public static int compare(Comparable v0, Comparable v1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTQ5NQ==", "bodyText": "These methods help us to have a compact and homogeneous code in PhysTypeImpl.java, where \"complex\" comparator expressions can be generated, combining e.g. numeric keys (without comparator), with String keys (with comparator).", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416159495", "createdAt": "2020-04-27T21:25:01Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/runtime/Utilities.java", "diffHunk": "@@ -212,6 +213,27 @@ public static int compareNullsLast(Comparable v0, Comparable v1) {\n                 : v0.compareTo(v1);\n   }\n \n+  public static int compare(Comparable v0, Comparable v1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MjY0MA=="}, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMzczMTg0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNzo1NzoxOFrOGPEWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxODozMTozOVrOGPR6XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzA2OA==", "bodyText": "The description here needs some modifications.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r418453068", "createdAt": "2020-05-01T07:57:18Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -356,8 +302,9 @@ public final Locale getLocale() {\n \n   /**\n    * @return Collator to be used for comparison, or null if no specific collator is defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6858b37421c9fa6502fb11b7f75303bc86ccd605"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY3NTI5Mg==", "bodyText": "Thanks for your feedback @XuQianJin-Stars , you are right.\nI have re-worked the javadoc, let me know what you think.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r418675292", "createdAt": "2020-05-01T18:31:39Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -356,8 +302,9 @@ public final Locale getLocale() {\n \n   /**\n    * @return Collator to be used for comparison, or null if no specific collator is defined", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzA2OA=="}, "originalCommit": {"oid": "6858b37421c9fa6502fb11b7f75303bc86ccd605"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 265, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}