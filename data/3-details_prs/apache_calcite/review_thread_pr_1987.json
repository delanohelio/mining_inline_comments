{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNjgwMTQ2", "number": 1987, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozNzoyMVrOD_gS4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzowNDoxOFrOEFYCHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE2MDAxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozNzoyMVrOGaM7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMzoxODo1MlrOGaNcFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODAzOQ==", "bodyText": "What's the difference between testCalcFieldTrimmer0  and testCalcFieldTrimmer1?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r430128039", "createdAt": "2020-05-26T02:37:21Z", "author": {"login": "chunweilei"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -183,4 +190,96 @@\n     assertThat(trimmed, hasTree(expected));\n   }\n \n+  @Test public void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzNjM0MQ==", "bodyText": "testCalcFieldTrimmer0 is used for check Project operator.\ntestCalcFieldTrimmer1 is used for check Filter operator.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r430136341", "createdAt": "2020-05-26T03:18:52Z", "author": {"login": "xy2953396112"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -183,4 +190,96 @@\n     assertThat(trimmed, hasTree(expected));\n   }\n \n+  @Test public void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODAzOQ=="}, "originalCommit": {"oid": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNjM4OTQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozNjozMFrOGi6Ipw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwOTo1NToxOVrOGjWxTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ==", "bodyText": "Hints need to be transferred from the original Calc to the new Calc (see CALCITE-4055).\nAlso, IMHO this piece of code could be refactored, to avoid duplicating instructions at the end of the \"if\" and \"else\" block, something like:\nRexNode newConditionExpr = null;\nif (rexProgram.getCondition() != null) {\n  ...\n  newConditionExpr = conditionExpr.accept(shuttle);\n}\nfinal RexProgram newRexProgram = ...\nfinal LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\nlogicalCalc.withHints(calc.getHints()); // transfer hints\nreturn result(logicalCalc, mapping);", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439257255", "createdAt": "2020-06-12T07:36:30Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+          rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+\n+      final RexNode newConditionExpr =\n+          conditionExpr.accept(shuttle);\n+      final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+          newProjects, newConditionExpr, newRowType.getFieldNames(),\n+          newInputRelNode.getCluster().getRexBuilder());\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+\n+      return result(logicalCalc, mapping);\n+    } else {\n+      final RexProgram newRexProgram = RexProgram\n+          .create(newInputRelNode.getRowType(), newProjects, null,\n+              newRowType.getFieldNames(), newInputRelNode.getCluster().getRexBuilder());\n+\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+      return result(logicalCalc, mapping);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDE3Mw==", "bodyText": "There is still duplicated code in the if + else block, I think the refactoring I proposed in my comment above would make the code cleaner.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439724173", "createdAt": "2020-06-13T09:19:08Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+          rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+\n+      final RexNode newConditionExpr =\n+          conditionExpr.accept(shuttle);\n+      final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+          newProjects, newConditionExpr, newRowType.getFieldNames(),\n+          newInputRelNode.getCluster().getRexBuilder());\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+\n+      return result(logicalCalc, mapping);\n+    } else {\n+      final RexProgram newRexProgram = RexProgram\n+          .create(newInputRelNode.getRowType(), newProjects, null,\n+              newRowType.getFieldNames(), newInputRelNode.getCluster().getRexBuilder());\n+\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+      return result(logicalCalc, mapping);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ=="}, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNjQxNA==", "bodyText": "Thanks, clean up the code.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439726414", "createdAt": "2020-06-13T09:55:19Z", "author": {"login": "xy2953396112"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+          rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+\n+      final RexNode newConditionExpr =\n+          conditionExpr.accept(shuttle);\n+      final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+          newProjects, newConditionExpr, newRowType.getFieldNames(),\n+          newInputRelNode.getCluster().getRexBuilder());\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+\n+      return result(logicalCalc, mapping);\n+    } else {\n+      final RexProgram newRexProgram = RexProgram\n+          .create(newInputRelNode.getRowType(), newProjects, null,\n+              newRowType.getFieldNames(), newInputRelNode.getCluster().getRexBuilder());\n+\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+      return result(logicalCalc, mapping);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ=="}, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNjM5NDkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozODo0NVrOGi6MOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwNzozODo0NVrOGi6MOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1ODE2OQ==", "bodyText": "I am not sure if, in this situation, the hints from the original Calc must / can be transferred into the new \"dummy Project\". What do you think @danny0405 ?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439258169", "createdAt": "2020-06-12T07:38:45Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTMzMDg2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwOToyMDo0OVrOGjWpCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwOTo1Nzo1NVrOGjWx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDI5OQ==", "bodyText": "minor: I think in this test it would also make sense to verify that the original Calc (relNode.getInput(0).getInput(0)) contains the hints.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439724299", "createdAt": "2020-06-13T09:20:49Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -306,4 +314,139 @@\n     assertTrue(project.getHints().contains(projectHint));\n   }\n \n+  @Test void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder().\n+        addRuleInstance(ProjectToCalcRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer1() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..2=[{inputs}], expr#3=[100], expr#4=[>($t0, $t3)], proj#0.\"\n+        + \".2=[{exprs}], $condition=[$t4])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..2=[{inputs}], proj#0..2=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1], DEPTNO=[$7])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer2() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .addRuleInstance(CalcMergeRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], expr#2=[100], expr#3=[>($t0, $t2)], proj#0.\"\n+        + \".1=[{exprs}], $condition=[$t3])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcWithHints() {\n+    final RelHint calcHint = RelHint.builder(\"resource\").build();\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    builder.getCluster().setHintStrategies(\n+        HintStrategyTable.builder().hintStrategy(\"resource\", HintPredicates.CALC).build());\n+    final RelNode original =\n+        builder.scan(\"EMP\")\n+            .project(\n+                builder.field(\"EMPNO\"),\n+                builder.field(\"ENAME\"),\n+                builder.field(\"DEPTNO\")\n+            ).hints(calcHint)\n+            .sort(builder.field(\"EMPNO\"))\n+            .project(builder.field(\"EMPNO\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .build();\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(original);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"  LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n+        + \"    LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+\n+    assertTrue(original.getInput(0).getInput(0) instanceof Project);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNjU2NA==", "bodyText": "Thanks, Add the verification logic of the original Calc contains the hints.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439726564", "createdAt": "2020-06-13T09:57:55Z", "author": {"login": "xy2953396112"}, "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -306,4 +314,139 @@\n     assertTrue(project.getHints().contains(projectHint));\n   }\n \n+  @Test void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder().\n+        addRuleInstance(ProjectToCalcRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer1() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..2=[{inputs}], expr#3=[100], expr#4=[>($t0, $t3)], proj#0.\"\n+        + \".2=[{exprs}], $condition=[$t4])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..2=[{inputs}], proj#0..2=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1], DEPTNO=[$7])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer2() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .addRuleInstance(CalcMergeRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], expr#2=[100], expr#3=[>($t0, $t2)], proj#0.\"\n+        + \".1=[{exprs}], $condition=[$t3])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcWithHints() {\n+    final RelHint calcHint = RelHint.builder(\"resource\").build();\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    builder.getCluster().setHintStrategies(\n+        HintStrategyTable.builder().hintStrategy(\"resource\", HintPredicates.CALC).build());\n+    final RelNode original =\n+        builder.scan(\"EMP\")\n+            .project(\n+                builder.field(\"EMPNO\"),\n+                builder.field(\"ENAME\"),\n+                builder.field(\"DEPTNO\")\n+            ).hints(calcHint)\n+            .sort(builder.field(\"EMPNO\"))\n+            .project(builder.field(\"EMPNO\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .build();\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(original);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"  LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n+        + \"    LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+\n+    assertTrue(original.getInput(0).getInput(0) instanceof Project);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDI5OQ=="}, "originalCommit": {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDcxMDA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMjo1NzowMVrOGjhzNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNjozMToyNFrOGjkwrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzEyNw==", "bodyText": "Do we have to use LinkedHashSet ? Looks like HashSet is enough.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439907127", "createdAt": "2020-06-15T02:57:01Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1NTYyOA==", "bodyText": "ok", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439955628", "createdAt": "2020-06-15T06:31:24Z", "author": {"login": "xy2953396112"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzEyNw=="}, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDcyMDk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMzowNDoxOFrOGjh5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNjozMTo0NFrOGjkxEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODY5Nw==", "bodyText": "Should we use Calc#copy to generate new Calc?", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439908697", "createdAt": "2020-06-15T03:04:18Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    RexNode newConditionExpr = null;\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+              rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+      newConditionExpr = conditionExpr.accept(shuttle);\n+    }\n+    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+        newProjects, newConditionExpr, newRowType.getFieldNames(),\n+        newInputRelNode.getCluster().getRexBuilder());\n+    final LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+    // transfer hints\n+    return result(logicalCalc.withHints(calc.getHints()), mapping);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1NTczMQ==", "bodyText": "Calc#copy is better.", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439955731", "createdAt": "2020-06-15T06:31:44Z", "author": {"login": "xy2953396112"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    RexNode newConditionExpr = null;\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+              rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+      newConditionExpr = conditionExpr.accept(shuttle);\n+    }\n+    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+        newProjects, newConditionExpr, newRowType.getFieldNames(),\n+        newInputRelNode.getCluster().getRexBuilder());\n+    final LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+    // transfer hints\n+    return result(logicalCalc.withHints(calc.getHints()), mapping);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODY5Nw=="}, "originalCommit": {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 156, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}