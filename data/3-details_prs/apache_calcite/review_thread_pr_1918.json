{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzODkwMDgw", "number": 1918, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo0OVrODyLmEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxNDowOFrOD39b4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ1MzYyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "isResolved": false, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo0OVrOGGFFlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODozNDozNlrOGIJWJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA==", "bodyText": "Not only sort, but all the operators can have the same issue.\nWe should update emptyValues to have the same traits with single. Just collation is not enough, should be all the traits.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409027990", "createdAt": "2020-04-15T17:54:49Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzNzA1NQ==", "bodyText": "Maybe we should put the trait logic in RelBuilder#empty ?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409037055", "createdAt": "2020-04-15T18:10:30Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NDI2Mg==", "bodyText": "we can try. But if only empty() considers the trait logic, the other methods don't, that might look odd.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409044262", "createdAt": "2020-04-15T18:23:04Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA3MDA0NQ==", "bodyText": "Agree with @hsyuan . This trait replacement is a one-off thing just for PruneEmptyRule. I am not convinced it should be available in RelBuilder.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409070045", "createdAt": "2020-04-15T19:06:19Z", "author": {"login": "xndai"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1Mzg1Ng==", "bodyText": "Done. Trait propagation applied to all RemoveEmptySingleRule instances (AGGREGATE, FILTER, PROJECT, SORT) + SORT_FETCH_ZERO_INSTANCE.\nWhat about the rest of PruneEmptyRules (MINUS, UNION, INTERSECT, JOIN_LEFT, JOIN_RIGHT)?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409353856", "createdAt": "2020-04-16T07:54:07Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzUwMA==", "bodyText": "Propagating all traits does not seem a good solution. Right now there are some tests failing because of the following scenario: we have an enumerable single rel + logical empty values, so we replace the whole thing with an empty values (which in our case is a LogicalValues, as returned by RelBuilder#empty). If we try to propagate all traits it will fail, because we would be trying to propagate the EnumerableConvention towards a LogicalValues. So what should be our strategy here? Should we propagate all traits except the convention? Am I missing something in the trait propagation process?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410053500", "createdAt": "2020-04-17T07:53:34Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0Ng==", "bodyText": "Moreover, what happens with e.g. Distribution? If we replace a SingleRel + EmptyValues = EmptyValues. Should the resulting EmptyValues have a values' distribution, or the SingleRel's distribution? What makes more sense?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410073646", "createdAt": "2020-04-17T08:31:53Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDExMzMyNQ==", "bodyText": "I'm confused, EmptyValues has no data, so what's the meaning of collation and distribution on it ?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410113325", "createdAt": "2020-04-17T09:44:04Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDEyOTU0Mw==", "bodyText": "Collation is required in order to solve this bug, since we are removing the Sort:\nSort + EmptyValues => EmptyValues\nif the resulting empty values does not have the sort's collation, we get a CannotPlanException. See https://issues.apache.org/jira/browse/CALCITE-3926 for more details.\nTherefore, in order to fix this problem it seems clear that we need to propagate the collation into the EmptyValues. Another discussion would be what about other traits, like distribution....", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410129543", "createdAt": "2020-04-17T10:15:23Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU0NTc5OA==", "bodyText": "Therefore, in order to fix this problem it seems clear that we need to propagate the collation into the EmptyValues.\n\nNot really from my side, to me, it seems that the traits check should be tweaked for EmptyValues, it should satisfy all the required traits, the EmptyValues itself does nothing wrong.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410545798", "createdAt": "2020-04-18T01:45:43Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY3NjEyNQ==", "bodyText": "Thanks an interesting approach @danny0405 . I guess we could tweak EmptyValues to satisfy any collation... will work on that", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410676125", "createdAt": "2020-04-18T09:48:46Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NDkxNg==", "bodyText": "Unfortunately, I cannot find a clean way of tweaking EmptyValues' collation to satisfy any collation. Since propagating all traits into EmptyValues did not work either, I am going back to the original solution of propagating just collation into EmptyValues if we are removing a Sort from the plan.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r411194916", "createdAt": "2020-04-20T08:34:36Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -400,7 +401,13 @@ private static boolean isEmpty(RelNode node) {\n \n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n-      call.transformTo(call.builder().push(single).empty().build());\n+      RelNode emptyValues = call.builder().push(single).empty().build();\n+      if (single instanceof Sort) {\n+        emptyValues = emptyValues.copy(\n+            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n+            Collections.emptyList());\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNzk5MA=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ1NjE5OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NTozMFrOGGFHPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzo1OTowOVrOGGZLVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw==", "bodyText": "Can you also compare the plan?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409028413", "createdAt": "2020-04-15T17:55:30Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3426,4 +3426,24 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n             builder.literal(5));\n     assertThat(call.toStringRaw(), is(\"BETWEEN ASYMMETRIC($0, 1, 5)\"));\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3926\">[CALCITE-3926]\n+   * CannotPlanException when an empty LogicalValues requires a certain collation</a>. */\n+  @Test void testEmptyValuesWithCollation() throws Exception {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder\n+            .scan(\"DEPT\")\n+            .filter(builder.literal(false))\n+            .sort(\n+                builder.field(\"DNAME\"),\n+                builder.field(\"DEPTNO\"))\n+            .build();\n+    try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n+      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String result = \"\";\n+      assertThat(s, is(result));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MDEyNw==", "bodyText": "Done", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409350127", "createdAt": "2020-04-16T07:48:11Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3426,4 +3426,24 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n             builder.literal(5));\n     assertThat(call.toStringRaw(), is(\"BETWEEN ASYMMETRIC($0, 1, 5)\"));\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3926\">[CALCITE-3926]\n+   * CannotPlanException when an empty LogicalValues requires a certain collation</a>. */\n+  @Test void testEmptyValuesWithCollation() throws Exception {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder\n+            .scan(\"DEPT\")\n+            .filter(builder.literal(false))\n+            .sort(\n+                builder.field(\"DNAME\"),\n+                builder.field(\"DEPTNO\"))\n+            .build();\n+    try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n+      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String result = \"\";\n+      assertThat(s, is(result));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NzE0MA==", "bodyText": "I mean the final plan generated by planner, not by the RelBuilder.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409357140", "createdAt": "2020-04-16T07:59:09Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3426,4 +3426,24 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n             builder.literal(5));\n     assertThat(call.toStringRaw(), is(\"BETWEEN ASYMMETRIC($0, 1, 5)\"));\n   }\n+\n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3926\">[CALCITE-3926]\n+   * CannotPlanException when an empty LogicalValues requires a certain collation</a>. */\n+  @Test void testEmptyValuesWithCollation() throws Exception {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder\n+            .scan(\"DEPT\")\n+            .filter(builder.literal(false))\n+            .sort(\n+                builder.field(\"DNAME\"),\n+                builder.field(\"DEPTNO\"))\n+            .build();\n+    try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n+      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String result = \"\";\n+      assertThat(s, is(result));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODQxMw=="}, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTYxNzIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODo0MDoyNFrOGGGtYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODo0MDoyNFrOGGGtYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA1NDU2Mg==", "bodyText": "Instead of doing this, can we just modify copy(traitset, inputs) method to just return new EnumerableValues(getCluster(), rowType, tuples, traitSet);?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409054562", "createdAt": "2020-04-15T18:40:24Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -65,6 +65,19 @@ public static EnumerableValues create(RelOptCluster cluster,\n     return new EnumerableValues(cluster, rowType, tuples, traitSet);\n   }\n \n+  /** Creates an EnumerableValues. */\n+  public static EnumerableValues create(Values input) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final ImmutableList<ImmutableList<RexLiteral>> tuples = input.getTuples();\n+    final RelDataType rowType = input.getRowType();\n+    final RelTraitSet traitSet =\n+        input.getTraitSet()\n+            .replace(EnumerableConvention.INSTANCE)\n+            .replaceIf(RelDistributionTraitDef.INSTANCE,\n+                () -> RelMdDistribution.values(rowType, tuples));\n+    return new EnumerableValues(cluster, rowType, tuples, traitSet);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a3b7da738bc63daac9eea38241e1ae72e0538b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTU0NjYxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzo1MDo0MVrOGGY1_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo0MDoyMlrOGHDR7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA==", "bodyText": "This is not expected. That means the rule or something else doesn't work.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409351678", "createdAt": "2020-04-16T07:50:41Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1NTI2Mw==", "bodyText": "I mean the expected plan should not have sort operator.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409355263", "createdAt": "2020-04-16T07:56:15Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM4ODA4Mg==", "bodyText": "This is the expected plan built by the RelBuilder, before any PruneEmptyRules is applied.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409388082", "createdAt": "2020-04-16T08:48:30Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgwODI3NQ==", "bodyText": "I guess we only care about plan generated by planner, not the builder.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409808275", "createdAt": "2020-04-16T19:48:42Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg3NDI1OQ==", "bodyText": "OK, I found that it is not able to compare the final plan here.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409874259", "createdAt": "2020-04-16T22:01:50Z", "author": {"login": "hsyuan"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA0Njk1Nw==", "bodyText": "I added another test in RelOptRulesTest to check the plan before and after the rule is applied", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410046957", "createdAt": "2020-04-17T07:40:22Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelBuilderTest.java", "diffHunk": "@@ -3440,10 +3440,14 @@ private void checkExpandTable(RelBuilder builder, Matcher<RelNode> matcher) {\n                 builder.field(\"DNAME\"),\n                 builder.field(\"DEPTNO\"))\n             .build();\n+    final String expectedTree = \"\"\n+        + \"LogicalSort(sort0=[$1], sort1=[$0], dir0=[ASC], dir1=[ASC])\\n\"\n+        + \"  LogicalValues(tuples=[[]])\\n\";\n+    assertThat(root, hasTree(expectedTree));\n     try (PreparedStatement preparedStatement = RelRunners.run(root)) {\n-      final String s = CalciteAssert.toString(preparedStatement.executeQuery());\n-      final String result = \"\";\n-      assertThat(s, is(result));\n+      final String result = CalciteAssert.toString(preparedStatement.executeQuery());\n+      final String expectedResult = \"\";\n+      assertThat(result, is(expectedResult));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MTY3OA=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTU1MTkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzo1MjowM1rOGGY5RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxOTo1MjoxNlrOGG01cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg==", "bodyText": "If you change PruneEmptyRule's autoPruneOld to false, you might be able to see another error.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409352516", "createdAt": "2020-04-16T07:52:03Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -402,12 +404,8 @@ private static boolean isEmpty(RelNode node) {\n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n       RelNode emptyValues = call.builder().push(single).empty().build();\n-      if (single instanceof Sort) {\n-        emptyValues = emptyValues.copy(\n-            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n-            Collections.emptyList());\n-      }\n-      call.transformTo(emptyValues);\n+      RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM3MDQ0Ng==", "bodyText": "That's rigth, in that case I get:\njava.lang.AssertionError\n\tat org.apache.calcite.rel.logical.LogicalValues.copy(LogicalValues.java:95)\n\nWhich refers to the following line:\n@Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {\n    assert traitSet.containsIfApplicable(Convention.NONE);  // <--\n    ...", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409370446", "createdAt": "2020-04-16T08:21:09Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -402,12 +404,8 @@ private static boolean isEmpty(RelNode node) {\n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n       RelNode emptyValues = call.builder().push(single).empty().build();\n-      if (single instanceof Sort) {\n-        emptyValues = emptyValues.copy(\n-            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n-            Collections.emptyList());\n-      }\n-      call.transformTo(emptyValues);\n+      RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMzYzNg==", "bodyText": "Actually, we can solve the problem with a different approach, and it would take just one line of code, which is returning false in PruneEmptyRule's autoPruneOld (or just remove the method to not override the default SubstitutionRule's behavior):\n  protected abstract static class PruneEmptyRule extends RelOptRule\n      implements SubstitutionRule {\n    ...\n    @Override public boolean autoPruneOld() {\n      return false; // this solves the problem!\n    }\n  }", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409413636", "createdAt": "2020-04-16T09:27:41Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -402,12 +404,8 @@ private static boolean isEmpty(RelNode node) {\n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n       RelNode emptyValues = call.builder().push(single).empty().build();\n-      if (single instanceof Sort) {\n-        emptyValues = emptyValues.copy(\n-            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n-            Collections.emptyList());\n-      }\n-      call.transformTo(emptyValues);\n+      RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgxMDI4OQ==", "bodyText": "It will just hide the issue of the rule. We still get a sort in the plan.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r409810289", "createdAt": "2020-04-16T19:52:16Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -402,12 +404,8 @@ private static boolean isEmpty(RelNode node) {\n     public void onMatch(RelOptRuleCall call) {\n       SingleRel single = call.rel(0);\n       RelNode emptyValues = call.builder().push(single).empty().build();\n-      if (single instanceof Sort) {\n-        emptyValues = emptyValues.copy(\n-            emptyValues.getTraitSet().replace(((Sort) single).getCollation()),\n-            Collections.emptyList());\n-      }\n-      call.transformTo(emptyValues);\n+      RelNode result = emptyValues.copy(single.getTraitSet(), Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM1MjUxNg=="}, "originalCommit": {"oid": "468911f1df6a960a8498115bda6d17a797aa99e1"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTk2NTU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzo1MzozMlrOGHDrcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwODozMzozOVrOGHE91Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA==", "bodyText": "Always use create instead of new directly.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410053488", "createdAt": "2020-04-17T07:53:32Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -46,7 +46,7 @@\n  * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}. */\n public class EnumerableValues extends Values implements EnumerableRel {\n   /** Creates an EnumerableValues. */\n-  private EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n+  EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n       ImmutableList<ImmutableList<RexLiteral>> tuples, RelTraitSet traitSet) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52fcec7eb089e34dca2332b74fa31ecdf3a95800"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1NTc4MQ==", "bodyText": "Agree, calling directly the constructor is generally an anti-pattern. The problem here is that, in order to solve this bug, we need to propagate the traitSet from the LogicalValues to the EnumerableValues, at right now this is not possible via create method. I could define a new overloaded create method (I had done it previously in this PR and then removed it).", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410055781", "createdAt": "2020-04-17T07:57:54Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -46,7 +46,7 @@\n  * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}. */\n public class EnumerableValues extends Values implements EnumerableRel {\n   /** Creates an EnumerableValues. */\n-  private EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n+  EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n       ImmutableList<ImmutableList<RexLiteral>> tuples, RelTraitSet traitSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA=="}, "originalCommit": {"oid": "52fcec7eb089e34dca2332b74fa31ecdf3a95800"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDU4MQ==", "bodyText": "Changed back: constructor is private again.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r410074581", "createdAt": "2020-04-17T08:33:39Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -46,7 +46,7 @@\n  * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}. */\n public class EnumerableValues extends Values implements EnumerableRel {\n   /** Creates an EnumerableValues. */\n-  private EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n+  EnumerableValues(RelOptCluster cluster, RelDataType rowType,\n       ImmutableList<ImmutableList<RexLiteral>> tuples, RelTraitSet traitSet) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA1MzQ4OA=="}, "originalCommit": {"oid": "52fcec7eb089e34dca2332b74fa31ecdf3a95800"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDAzNjQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxMDo1N1rOGOgn9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOTozMTo0OVrOGOhXaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2Nzc2NQ==", "bodyText": "How about we modify the other create to support an explicit traitSet param ?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417867765", "createdAt": "2020-04-30T09:10:57Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -65,9 +65,20 @@ public static EnumerableValues create(RelOptCluster cluster,\n     return new EnumerableValues(cluster, rowType, tuples, traitSet);\n   }\n \n+  /** Creates an EnumerableValues. */\n+  public static EnumerableValues create(Values input) {\n+    final RelOptCluster cluster = input.getCluster();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3OTkxMg==", "bodyText": "I think the copy method should be handling that scenario", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417879912", "createdAt": "2020-04-30T09:31:49Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableValues.java", "diffHunk": "@@ -65,9 +65,20 @@ public static EnumerableValues create(RelOptCluster cluster,\n     return new EnumerableValues(cluster, rowType, tuples, traitSet);\n   }\n \n+  /** Creates an EnumerableValues. */\n+  public static EnumerableValues create(Values input) {\n+    final RelOptCluster cluster = input.getCluster();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2Nzc2NQ=="}, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDA0ODM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwOToxNDowOFrOGOgvPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDoxODoxOVrOGOi8_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ==", "bodyText": "Why only copy the Collation trait ?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417869631", "createdAt": "2020-04-30T09:14:08Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -277,7 +278,11 @@ private static boolean isEmpty(RelNode node) {\n           if (sort.fetch != null\n               && !(sort.fetch instanceof RexDynamicParam)\n               && RexLiteral.intValue(sort.fetch) == 0) {\n-            call.transformTo(call.builder().push(sort).empty().build());\n+            RelNode emptyValues = call.builder().push(sort).empty().build();\n+            emptyValues = emptyValues.copy(\n+                emptyValues.getTraitSet().replace(sort.getCollation()),\n+                Collections.emptyList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg3NzQyNw==", "bodyText": "The (non propagation of) Collation trait is the root cause of this issue. So propagating just the Collation seems the easiest way to fix this bug (but arguably maybe not the \"most correct\" one).\nPreviously, I tried to propagate other traits as well, but it did not work as expected:\nPropagating all traits does not seem a good solution. [...] there are some tests failing because of the following scenario: we have an enumerable single rel + logical empty values, so we replace the whole thing with an empty values (which in our case is a LogicalValues, as returned by RelBuilder#empty). If we try to propagate all traits it will fail, because we would be trying to propagate the EnumerableConvention towards a LogicalValues. So what should be our strategy here? Should we propagate all traits except the convention? Am I missing something in the trait propagation process?", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417877427", "createdAt": "2020-04-30T09:27:28Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -277,7 +278,11 @@ private static boolean isEmpty(RelNode node) {\n           if (sort.fetch != null\n               && !(sort.fetch instanceof RexDynamicParam)\n               && RexLiteral.intValue(sort.fetch) == 0) {\n-            call.transformTo(call.builder().push(sort).empty().build());\n+            RelNode emptyValues = call.builder().push(sort).empty().build();\n+            emptyValues = emptyValues.copy(\n+                emptyValues.getTraitSet().replace(sort.getCollation()),\n+                Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg5NDMyNA==", "bodyText": "Thanks @rubenada , i have gave a fix in [1] based on your code, hope it helps ~\n[1] https://github.com/danny0405/calcite/tree/rubenada-CALCITE-3926", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417894324", "createdAt": "2020-04-30T09:57:08Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -277,7 +278,11 @@ private static boolean isEmpty(RelNode node) {\n           if (sort.fetch != null\n               && !(sort.fetch instanceof RexDynamicParam)\n               && RexLiteral.intValue(sort.fetch) == 0) {\n-            call.transformTo(call.builder().push(sort).empty().build());\n+            RelNode emptyValues = call.builder().push(sort).empty().build();\n+            emptyValues = emptyValues.copy(\n+                emptyValues.getTraitSet().replace(sort.getCollation()),\n+                Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkwNTkxOA==", "bodyText": "Thanks @danny0405 , I have added a comment in there.", "url": "https://github.com/apache/calcite/pull/1918#discussion_r417905918", "createdAt": "2020-04-30T10:18:19Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/rules/PruneEmptyRules.java", "diffHunk": "@@ -277,7 +278,11 @@ private static boolean isEmpty(RelNode node) {\n           if (sort.fetch != null\n               && !(sort.fetch instanceof RexDynamicParam)\n               && RexLiteral.intValue(sort.fetch) == 0) {\n-            call.transformTo(call.builder().push(sort).empty().build());\n+            RelNode emptyValues = call.builder().push(sort).empty().build();\n+            emptyValues = emptyValues.copy(\n+                emptyValues.getTraitSet().replace(sort.getCollation()),\n+                Collections.emptyList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg2OTYzMQ=="}, "originalCommit": {"oid": "826af564c8160bc1b5558a6518eeb64a374215c3"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 254, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}