{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTc5MzM2", "number": 1761, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDozNVrODYF5uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTo0ODo0NlrOD0DkVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTg5MTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDozNVrOFdwKOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMDo1MToxMVrOFgqijQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw==", "bodyText": "extra line?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366742073", "createdAt": "2020-01-15T08:20:35Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -20,17 +20,16 @@\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n-import org.apache.calcite.sql.type.SqlOperandCountRanges;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n import org.apache.calcite.sql.type.SqlTypeName;\n-import org.apache.calcite.sql.type.SqlTypeUtil;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.calcite.util.Static.RESOURCE;\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTc5MA==", "bodyText": "thanks! I will hold the change a bit until receive enough comments (and will address all style like comments at a time).", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367085790", "createdAt": "2020-01-15T20:16:48Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -20,17 +20,16 @@\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n-import org.apache.calcite.sql.type.SqlOperandCountRanges;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n import org.apache.calcite.sql.type.SqlTypeName;\n-import org.apache.calcite.sql.type.SqlTypeUtil;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.calcite.util.Static.RESOURCE;\n \n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw=="}, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5NTcyNQ==", "bodyText": "fixed!", "url": "https://github.com/apache/calcite/pull/1761#discussion_r369795725", "createdAt": "2020-01-22T20:51:11Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -20,17 +20,16 @@\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n-import org.apache.calcite.sql.type.SqlOperandCountRanges;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n import org.apache.calcite.sql.type.SqlTypeName;\n-import org.apache.calcite.sql.type.SqlTypeUtil;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.calcite.util.Static.RESOURCE;\n \n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw=="}, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTkxMTcxOnYy", "diffSide": "LEFT", "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyODo1NFrOFdwWOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxMzoxMFrOFeFCnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NTE0NA==", "bodyText": "Why we remove these methods? Each window table function has its own implementation?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366745144", "createdAt": "2020-01-15T08:28:54Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -44,28 +43,21 @@ public SqlWindowTableFunction(String name) {\n         SqlFunctionCategory.SYSTEM);\n   }\n \n-  @Override public SqlOperandCountRange getOperandCountRange() {\n-    return SqlOperandCountRanges.of(3);\n-  }\n-\n-  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NDE4OA==", "bodyText": "Yes. Each windowing table-valued function shall check their own operands. The check of DESCRIPTOR names are also left for each function (which makes sense as each function has its own interpretation of names).", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367084188", "createdAt": "2020-01-15T20:13:10Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -44,28 +43,21 @@ public SqlWindowTableFunction(String name) {\n         SqlFunctionCategory.SYSTEM);\n   }\n \n-  @Override public SqlOperandCountRange getOperandCountRange() {\n-    return SqlOperandCountRanges.of(3);\n-  }\n-\n-  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NTE0NA=="}, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODA2MjI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxNTozN1rOFeFGzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxNTozN1rOFeFGzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTI2MQ==", "bodyText": "extra line", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367085261", "createdAt": "2020-01-15T20:15:37Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2ODQ3MzA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo1NjoyN1rOFeJH9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo1NjoyN1rOFeJH9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MTA5Mg==", "bodyText": "will fix bases as a typo.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367151092", "createdAt": "2020-01-15T22:56:27Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -744,9 +748,9 @@ static Expression generatePredicate(\n     return Expressions.lambda(Predicate2.class, builder.toBlock(), left_, right_);\n   }\n \n-  /** Generates a window selector which appends attribute of the window based on\n+  /** Generates a window selector which appends attribute of the window bases on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjIwMjMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1MjowN1rOFes2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1MjowN1rOFes2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjQxNQ==", "bodyText": "Here we can use Math.toIntExact.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367736415", "createdAt": "2020-01-17T01:52:07Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+\n+    }\n+\n+    public boolean moveNext() {\n+      if (list.size() > 0) {\n+        return true;\n+      }\n+      return inputEnumerator.moveNext();\n+    }\n+\n+    public void reset() {\n+      inputEnumerator.reset();\n+      list.clear();\n+    }\n+\n+    public void close() {\n+    }\n+\n+    private Object[] takeOne() {\n+      return list.pollFirst();\n+    }\n+  }\n+\n+  private static List<Pair> hopWindows(long tsMillis, long periodMillis, long sizeMillis) {\n+    ArrayList<Pair> ret = new ArrayList<>((int) (sizeMillis / periodMillis));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjIwODAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1NzowOFrOFes57Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1NzowOFrOFes57Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNzMyNQ==", "bodyText": "809L-811L The indentation format seems a bit problematic.\nThere are several more functions with indentation format below.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367737325", "createdAt": "2020-01-17T01:57:08Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjg0ODM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NTo0OVrOF32OOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NTo0OVrOF32OOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDM3OA==", "bodyText": "Just of curious, is the \"TVF\" a commonly-used abbreviation?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104378", "createdAt": "2020-03-18T04:45:49Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2273,8 +2275,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjg0OTkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NzoxMFrOF32PTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwMjoyMTo0MVrOF51Mhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw==", "bodyText": "Why we need to change the function name here?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104653", "createdAt": "2020-03-18T04:47:10Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2312,7 +2320,7 @@ public void unparse(\n \n   /** The {@code HOP} group function. */\n   public static final SqlGroupedWindowFunction HOP =\n-      new SqlGroupedWindowFunction(SqlKind.HOP.name(), SqlKind.HOP, null,\n+      new SqlGroupedWindowFunction(\"$HOP\", SqlKind.HOP, null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NTkyMQ==", "bodyText": "Here is the context about this change: https://github.com/apache/calcite/blob/master/core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java#L2304", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396145921", "createdAt": "2020-03-22T21:58:23Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2312,7 +2320,7 @@ public void unparse(\n \n   /** The {@code HOP} group function. */\n   public static final SqlGroupedWindowFunction HOP =\n-      new SqlGroupedWindowFunction(SqlKind.HOP.name(), SqlKind.HOP, null,\n+      new SqlGroupedWindowFunction(\"$HOP\", SqlKind.HOP, null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NDcxMA==", "bodyText": "I see, thanks for explanation.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396184710", "createdAt": "2020-03-23T02:21:41Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2312,7 +2320,7 @@ public void unparse(\n \n   /** The {@code HOP} group function. */\n   public static final SqlGroupedWindowFunction HOP =\n-      new SqlGroupedWindowFunction(SqlKind.HOP.name(), SqlKind.HOP, null,\n+      new SqlGroupedWindowFunction(\"$HOP\", SqlKind.HOP, null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjg1MjY2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0OToxNFrOF32RBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDowNjowN1rOF7BFUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA==", "bodyText": "Any special reasons to implement tumbling and hopping&sessionize in different places?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394105094", "createdAt": "2020-03-18T04:49:14Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NjA0MA==", "bodyText": "I see. No special reason. Would you suggest I put it in the same class? If so, which class is better?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396146040", "createdAt": "2020-03-22T21:59:45Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTMxMQ==", "bodyText": "Current now, I personally suggest to put them in EnumUtils. It is a little strange in Linq4j. But if we will add more streaming functions later, I think we can create a separate class for them. It's more clear.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396185311", "createdAt": "2020-03-23T02:25:27Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyODA1MQ==", "bodyText": "Done!", "url": "https://github.com/apache/calcite/pull/1761#discussion_r397428051", "createdAt": "2020-03-24T20:06:07Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0Mjg2OTA1OnYy", "diffSide": "RIGHT", "path": "site/_docs/reference.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNTowMTo0MFrOF32bkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDowODozMFrOF7BKJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNzc5Mg==", "bodyText": "Some comments:\n\nIs it necessary to deprecate the manner of using them as grouped window function?\nUpdate \"Table-valued functions.\" to \"Table functions\".\nCould you add doc the streaming page? I think we can do this work in this PR or after finishing the umbrella JIRA.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394107792", "createdAt": "2020-03-18T05:01:40Z", "author": {"login": "DonnyZone"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1871,14 +1872,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n \n Here is an example:\n `SELECT * FROM TABLE(TUMBLE(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '1' MINUTE))`,\n will apply tumbling with 1 minute window size on rows from table orders. rowtime is the\n watermarked column of table orders that tells data completeness.\n \n+#### HOP\n+In streaming queries, HOP assigns windows that cover rows within the interval of *size*, shifting every *slide*, \n+and optionally aligned at *time* based on a timestamp column. Windows assigned could have overlapping so hopping \n+sometime is named as \"sliding windowing\".  \n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| HOP(table, DESCRIPTOR(datetime), slide, size, [, time ]) | Indicates a hopping window for *datetime*, covering rows within the interval of *size*, shifting every *slide*, and optionally aligned at *time*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(HOP(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '2' MINUTE, INTERVAL '5' MINUTE))`,\n+will apply hopping with 5-minute interval size on rows from table orders, shifting every 2 minutes. rowtime is the\n+watermarked column of table orders that tells data completeness.\n+\n+#### SESSION\n+In streaming queries, SESSION assigns windows that cover rows based on *datetime*. Within a session window, distances \n+of rows are less than *interval*. Session window is applied per *key*.\n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| session(table, DESCRIPTOR(datetime), DESCRIPTOR(key), interval [, time ]) | Indicates a session window of *interval* for *datetime*, optionally aligned at *time*. Session window is applied per *key*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(SESSION(TABLE orders, DESCRIPTOR(rowtime), DESCRIPTOR(product), INTERVAL '20' MINUTE))`,\n+will apply session with 20-minute inactive gap on rows from table orders. rowtime is the\n+watermarked column of table orders that tells data completeness. Session is applied per product.\n+\n ### Grouped window functions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NjY2Ng==", "bodyText": "Re: 1. Yes. First of all, table function style streaming can cover what grouped window function provides. Then grouped window function has drawbacks:\n\nmagic *_start, * _end function to get window_start, window_end\nenforce to use a GROUP BY. E.g. if users only want to do windowing streaming join without aggregation, they shouldn't be bothered to use a GROUP BY.\nerror prone syntax. E.g. why users cannot do GROUP BY TUMBLE(), HOP()? The syntax is correct for SQL.\nSo I think (and probably Julian also agreed) grouped window function can be deprecated.\n\nI will send an email to discuss the deprecation with Calcite community. So grouped window functions won't disappear silently.\nRe 2 and 3: nice suggestions. I will add a commit for the change.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396146666", "createdAt": "2020-03-22T22:06:29Z", "author": {"login": "amaliujia"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1871,14 +1872,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n \n Here is an example:\n `SELECT * FROM TABLE(TUMBLE(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '1' MINUTE))`,\n will apply tumbling with 1 minute window size on rows from table orders. rowtime is the\n watermarked column of table orders that tells data completeness.\n \n+#### HOP\n+In streaming queries, HOP assigns windows that cover rows within the interval of *size*, shifting every *slide*, \n+and optionally aligned at *time* based on a timestamp column. Windows assigned could have overlapping so hopping \n+sometime is named as \"sliding windowing\".  \n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| HOP(table, DESCRIPTOR(datetime), slide, size, [, time ]) | Indicates a hopping window for *datetime*, covering rows within the interval of *size*, shifting every *slide*, and optionally aligned at *time*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(HOP(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '2' MINUTE, INTERVAL '5' MINUTE))`,\n+will apply hopping with 5-minute interval size on rows from table orders, shifting every 2 minutes. rowtime is the\n+watermarked column of table orders that tells data completeness.\n+\n+#### SESSION\n+In streaming queries, SESSION assigns windows that cover rows based on *datetime*. Within a session window, distances \n+of rows are less than *interval*. Session window is applied per *key*.\n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| session(table, DESCRIPTOR(datetime), DESCRIPTOR(key), interval [, time ]) | Indicates a session window of *interval* for *datetime*, optionally aligned at *time*. Session window is applied per *key*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(SESSION(TABLE orders, DESCRIPTOR(rowtime), DESCRIPTOR(product), INTERVAL '20' MINUTE))`,\n+will apply session with 20-minute inactive gap on rows from table orders. rowtime is the\n+watermarked column of table orders that tells data completeness. Session is applied per product.\n+\n ### Grouped window functions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNzc5Mg=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyOTI4NA==", "bodyText": "I have addressed 2.\nRegarding 3, I would like to do it after this PR. I would prefer to have a discussion about deprecating grouped window functions in mailing list first, which will give a much better idea how streaming page be updated (e.g. keep both style or just keep the new one)", "url": "https://github.com/apache/calcite/pull/1761#discussion_r397429284", "createdAt": "2020-03-24T20:08:30Z", "author": {"login": "amaliujia"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1871,14 +1872,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n \n Here is an example:\n `SELECT * FROM TABLE(TUMBLE(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '1' MINUTE))`,\n will apply tumbling with 1 minute window size on rows from table orders. rowtime is the\n watermarked column of table orders that tells data completeness.\n \n+#### HOP\n+In streaming queries, HOP assigns windows that cover rows within the interval of *size*, shifting every *slide*, \n+and optionally aligned at *time* based on a timestamp column. Windows assigned could have overlapping so hopping \n+sometime is named as \"sliding windowing\".  \n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| HOP(table, DESCRIPTOR(datetime), slide, size, [, time ]) | Indicates a hopping window for *datetime*, covering rows within the interval of *size*, shifting every *slide*, and optionally aligned at *time*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(HOP(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '2' MINUTE, INTERVAL '5' MINUTE))`,\n+will apply hopping with 5-minute interval size on rows from table orders, shifting every 2 minutes. rowtime is the\n+watermarked column of table orders that tells data completeness.\n+\n+#### SESSION\n+In streaming queries, SESSION assigns windows that cover rows based on *datetime*. Within a session window, distances \n+of rows are less than *interval*. Session window is applied per *key*.\n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| session(table, DESCRIPTOR(datetime), DESCRIPTOR(key), interval [, time ]) | Indicates a session window of *interval* for *datetime*, optionally aligned at *time*. Session window is applied per *key*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(SESSION(TABLE orders, DESCRIPTOR(rowtime), DESCRIPTOR(product), INTERVAL '20' MINUTE))`,\n+will apply session with 20-minute inactive gap on rows from table orders. rowtime is the\n+watermarked column of table orders that tells data completeness. Session is applied per product.\n+\n ### Grouped window functions", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNzc5Mg=="}, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODczMDQ4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo1NjowMlrOGEee6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDo0OTo1NFrOGE0zpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0NjkyMw==", "bodyText": "nitpicking: indent", "url": "https://github.com/apache/calcite/pull/1761#discussion_r407346923", "createdAt": "2020-04-13T06:56:02Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+                                             boolean throwOnFailure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94446e35592b69b3eee805919257f6072099e85"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMjY3Ng==", "bodyText": "oops. Fixed", "url": "https://github.com/apache/calcite/pull/1761#discussion_r407712676", "createdAt": "2020-04-13T20:49:54Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+                                             boolean throwOnFailure) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0NjkyMw=="}, "originalCommit": {"oid": "a94446e35592b69b3eee805919257f6072099e85"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTM5NjQxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyMjozNVrOGHkM8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNToyOToxNlrOGIDtgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjM1Mw==", "bodyText": "Give doc for these parameters. Same for other codes.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586353", "createdAt": "2020-04-18T03:22:35Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjU5NQ==", "bodyText": "Done.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102595", "createdAt": "2020-04-20T05:29:16Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjM1Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTM5NzQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyMjo1MlrOGHkNhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNToyOToxMVrOGIDtZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjUwMA==", "bodyText": "Create -> Creates, same for other codes.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586500", "createdAt": "2020-04-18T03:22:52Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjU2NQ==", "bodyText": "Done.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102565", "createdAt": "2020-04-20T05:29:11Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjUwMA=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQwNDQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyNDozN1rOGHkQiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMDoxNTowOVrOGKJqgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw==", "bodyText": "Is this true ? Shouldn't we rely on the watermark and gap to decide if a session is expired ? What about the late arrive data ?\nThis implementation should not be blocking.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410587273", "createdAt": "2020-04-18T03:24:37Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTI3Mg==", "bodyText": "It is true because this is batch only implementation.\nFor streaming cases, it needs to rely on watermark to know when it's ready to emit data. For batch cases, technically watermark always advances to the positive infinite at the beginning to mark all data has arrived (because it is bounded, or pre-known input data set). So this implementation is correct for batch case, because \"watermark = positive infinity\" means all data need to be processed.\nI do have a plan to introduce watermark into calcite, and along with it, there should also be a test unbounded/streaming input source be built. By doing so we should be able to migrate current batch only implementation to batch-streaming unified implementation, which depends on watermark. However it will take some time to reach that point (with the support of community).", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411089272", "createdAt": "2020-04-20T04:44:18Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTMwMw==", "bodyText": "I hear your concerns, but the operator did have a param named watermark.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411855303", "createdAt": "2020-04-21T04:14:35Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MTc3Ng==", "bodyText": "Sorry I might have missed something. What's the param that is named watermark? You mean the watermarked column, e.g. timestamp column specified by descriptor?\nTo clarify, that column is not named watermark. It is just a timestamp column which we say \"watermark is built upon\". For SQL, watermark is not visible to users. Users cannot tell a \"watermark\" from the query, and watermark is not a part of algebra.\nWatermark is supposed to be implemented by SQL engine, which usually is tied with sources. For example, in Apache Beam, we have two interfaces for sources: bounded source 1 and unbounded source 2. For bounded source, there is no watermark since it is the batch case, but windowing still applies: just applying windowing based on a timestamp column without considering late data. Calcite's Enumerable interface is like bounded source in Beam.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411861776", "createdAt": "2020-04-21T04:35:00Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyNzMzMw==", "bodyText": "Then why there are param named indexOfWatermarkedColumn  ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411927333", "createdAt": "2020-04-21T07:08:50Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4ODUyNw==", "bodyText": "Watermark is a concept that is used to indicate the completeness of data, and it is not necessary an implementation.\nThe naming of \"WatermarkedColumn\" really means two things:\n\nThis is the column that provide event timestamp, which has the \"event timestamp\" semantic. (You can find \"Event time vs. processing time\" section in https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/ to know more about this semantic)\nBecause it has \"event timestamp\" semantic, we reply on \"watermark\" to know the data completeness and define late data.\n\nAnd windowing implemented by these series of PRs are coupled with \"event timestamp\" semantic, or we can just call it \"event timestamp windowing\" semantic.\nWhat does it mean for batch and streaming sources? Say \"hey,  this is the watermarked column, which gives the event timestamp. Let's apply windowing on this column. Wait a minute, how do I know the data is complete, thus I can close a window?\"\nFor streaming source: \"Hey it is streaming case, and we have watermark! If the watermark passes the end of window, you can mark the window is closed and all future data falls into that window is late\".\nFor batch source: \"Hey it is batch case, all data is known and there is no late data. Just close the window when all data are processed. And watermark also applies because when you ask the watermark, it always tell you that you can close the window\". In this case we can either implement watermark, which explicitly tell all window can be closed, or we just close them because this is batch. After all, it is just an implementation choice,\nI think it is really a high-level argument and depends on if you accept this statement: batch is a special case of streaming. If you do accept this statement, using \"watermark\" is not wrong. Batch case can use all streaming terms (note that I am not saying using the same implementation). Also in the future, after streaming sources are built, either we change code here, or not, the behavior of what is build in this PR won't change cause it matches with \"event timestamp windowing\" semantic. So it is backward compatible.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412488527", "createdAt": "2020-04-21T21:01:26Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwODY4MQ==", "bodyText": "I do understand what a watermark is, no need to explain more, what i have concern upon is that the implementation has no relationship with a \"watermark\" definition but in the function doc, we represent it everywhere, which i think is not in consistent.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412608681", "createdAt": "2020-04-22T01:47:07Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNTIzNQ==", "bodyText": "Ok what's the recommendation then? Do you want \"watermark\" as a word removed?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412615235", "createdAt": "2020-04-22T02:05:58Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxOTc5Nw==", "bodyText": "How about we add some notes in the function document that we only implements batch group window.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412619797", "createdAt": "2020-04-22T02:19:55Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NzI4MQ==", "bodyText": "Sure. Added a note for each windowing implementation to say they work for batch only.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r413297281", "createdAt": "2020-04-22T20:15:09Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQxMDk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyNjoyOFrOGHkTYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTozMTowNlrOGIDv4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA==", "bodyText": "indexOfWatermarkedColumn  -> wmIndex ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588000", "createdAt": "2020-04-18T03:26:28Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {\n+        elements.add(inputEnumerator.current());\n+      }\n+\n+      Map<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> sessionKeyMap = new HashMap<>();\n+      for (Object[] element : elements) {\n+        sessionKeyMap.putIfAbsent(element[indexOfKeyColumn], new SortedMultiMap<>());\n+        Pair initWindow = computeInitWindow(\n+            SqlFunctions.toLong(element[indexOfWatermarkedColumn]), gap);\n+        sessionKeyMap.get(element[indexOfKeyColumn]).putMulti(initWindow, element);\n+      }\n+\n+      // merge per key session windows if there is any overlap between windows.\n+      for (Map.Entry<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> perKeyEntry\n+          : sessionKeyMap.entrySet()) {\n+        Map<Pair<Long, Long>, List<Object[]>> finalWindowElementsMap = new HashMap<>();\n+        Pair<Long, Long> currentWindow = null;\n+        List<Object[]> tempElementList = new ArrayList<>();\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> sessionEntry\n+            : perKeyEntry.getValue().entrySet()) {\n+          // check the next window can be merged.\n+          if (currentWindow == null || !isOverlapped(currentWindow, sessionEntry.getKey())) {\n+            // cannot merge window as there is no overlap\n+            if (currentWindow != null) {\n+              finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+            }\n+\n+            currentWindow = sessionEntry.getKey();\n+            tempElementList.clear();\n+            tempElementList.addAll(sessionEntry.getValue());\n+          } else {\n+            // merge windows.\n+            currentWindow = mergeWindows(currentWindow, sessionEntry.getKey());\n+            // merge elements in windows.\n+            tempElementList.addAll(sessionEntry.getValue());\n+          }\n+        }\n+\n+        if (!tempElementList.isEmpty()) {\n+          finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+        }\n+\n+        // construct final results from finalWindowElementsMap.\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> finalWindowElementsEntry\n+            : finalWindowElementsMap.entrySet()) {\n+          for (Object[] element : finalWindowElementsEntry.getValue()) {\n+            Object[] curWithWindow = new Object[element.length + 2];\n+            System.arraycopy(element, 0, curWithWindow, 0, element.length);\n+            curWithWindow[element.length] = finalWindowElementsEntry.getKey().left;\n+            curWithWindow[element.length + 1] = finalWindowElementsEntry.getKey().right;\n+            list.offer(curWithWindow);\n+          }\n+        }\n+      }\n+    }\n+\n+    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return !(b.left >= a.right);\n+    }\n+\n+    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);\n+    }\n+\n+    private Pair<Long, Long> computeInitWindow(long ts, long gap) {\n+      return new Pair<>(ts, ts + gap);\n+    }\n+  }\n+\n+  /**\n+   * Create enumerable implementation that applies hopping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hopping(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4NzQ4OA==", "bodyText": "I prefer to keep \"watermark\". This is the relatively new concept for Calcite, so abbreviation could make people confused.\nActually I have observed it on \"TVF\" (table-valued function or table function). Seems like people are already confused on such abbreviation.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411087488", "createdAt": "2020-04-20T04:37:55Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {\n+        elements.add(inputEnumerator.current());\n+      }\n+\n+      Map<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> sessionKeyMap = new HashMap<>();\n+      for (Object[] element : elements) {\n+        sessionKeyMap.putIfAbsent(element[indexOfKeyColumn], new SortedMultiMap<>());\n+        Pair initWindow = computeInitWindow(\n+            SqlFunctions.toLong(element[indexOfWatermarkedColumn]), gap);\n+        sessionKeyMap.get(element[indexOfKeyColumn]).putMulti(initWindow, element);\n+      }\n+\n+      // merge per key session windows if there is any overlap between windows.\n+      for (Map.Entry<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> perKeyEntry\n+          : sessionKeyMap.entrySet()) {\n+        Map<Pair<Long, Long>, List<Object[]>> finalWindowElementsMap = new HashMap<>();\n+        Pair<Long, Long> currentWindow = null;\n+        List<Object[]> tempElementList = new ArrayList<>();\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> sessionEntry\n+            : perKeyEntry.getValue().entrySet()) {\n+          // check the next window can be merged.\n+          if (currentWindow == null || !isOverlapped(currentWindow, sessionEntry.getKey())) {\n+            // cannot merge window as there is no overlap\n+            if (currentWindow != null) {\n+              finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+            }\n+\n+            currentWindow = sessionEntry.getKey();\n+            tempElementList.clear();\n+            tempElementList.addAll(sessionEntry.getValue());\n+          } else {\n+            // merge windows.\n+            currentWindow = mergeWindows(currentWindow, sessionEntry.getKey());\n+            // merge elements in windows.\n+            tempElementList.addAll(sessionEntry.getValue());\n+          }\n+        }\n+\n+        if (!tempElementList.isEmpty()) {\n+          finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+        }\n+\n+        // construct final results from finalWindowElementsMap.\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> finalWindowElementsEntry\n+            : finalWindowElementsMap.entrySet()) {\n+          for (Object[] element : finalWindowElementsEntry.getValue()) {\n+            Object[] curWithWindow = new Object[element.length + 2];\n+            System.arraycopy(element, 0, curWithWindow, 0, element.length);\n+            curWithWindow[element.length] = finalWindowElementsEntry.getKey().left;\n+            curWithWindow[element.length + 1] = finalWindowElementsEntry.getKey().right;\n+            list.offer(curWithWindow);\n+          }\n+        }\n+      }\n+    }\n+\n+    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return !(b.left >= a.right);\n+    }\n+\n+    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);\n+    }\n+\n+    private Pair<Long, Long> computeInitWindow(long ts, long gap) {\n+      return new Pair<>(ts, ts + gap);\n+    }\n+  }\n+\n+  /**\n+   * Create enumerable implementation that applies hopping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hopping(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzIwMw==", "bodyText": "Use \"table function\" sounds better, i don't really know what a \"table-valued function\" means.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411103203", "createdAt": "2020-04-20T05:31:06Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {\n+        elements.add(inputEnumerator.current());\n+      }\n+\n+      Map<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> sessionKeyMap = new HashMap<>();\n+      for (Object[] element : elements) {\n+        sessionKeyMap.putIfAbsent(element[indexOfKeyColumn], new SortedMultiMap<>());\n+        Pair initWindow = computeInitWindow(\n+            SqlFunctions.toLong(element[indexOfWatermarkedColumn]), gap);\n+        sessionKeyMap.get(element[indexOfKeyColumn]).putMulti(initWindow, element);\n+      }\n+\n+      // merge per key session windows if there is any overlap between windows.\n+      for (Map.Entry<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> perKeyEntry\n+          : sessionKeyMap.entrySet()) {\n+        Map<Pair<Long, Long>, List<Object[]>> finalWindowElementsMap = new HashMap<>();\n+        Pair<Long, Long> currentWindow = null;\n+        List<Object[]> tempElementList = new ArrayList<>();\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> sessionEntry\n+            : perKeyEntry.getValue().entrySet()) {\n+          // check the next window can be merged.\n+          if (currentWindow == null || !isOverlapped(currentWindow, sessionEntry.getKey())) {\n+            // cannot merge window as there is no overlap\n+            if (currentWindow != null) {\n+              finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+            }\n+\n+            currentWindow = sessionEntry.getKey();\n+            tempElementList.clear();\n+            tempElementList.addAll(sessionEntry.getValue());\n+          } else {\n+            // merge windows.\n+            currentWindow = mergeWindows(currentWindow, sessionEntry.getKey());\n+            // merge elements in windows.\n+            tempElementList.addAll(sessionEntry.getValue());\n+          }\n+        }\n+\n+        if (!tempElementList.isEmpty()) {\n+          finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+        }\n+\n+        // construct final results from finalWindowElementsMap.\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> finalWindowElementsEntry\n+            : finalWindowElementsMap.entrySet()) {\n+          for (Object[] element : finalWindowElementsEntry.getValue()) {\n+            Object[] curWithWindow = new Object[element.length + 2];\n+            System.arraycopy(element, 0, curWithWindow, 0, element.length);\n+            curWithWindow[element.length] = finalWindowElementsEntry.getKey().left;\n+            curWithWindow[element.length + 1] = finalWindowElementsEntry.getKey().right;\n+            list.offer(curWithWindow);\n+          }\n+        }\n+      }\n+    }\n+\n+    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return !(b.left >= a.right);\n+    }\n+\n+    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);\n+    }\n+\n+    private Pair<Long, Long> computeInitWindow(long ts, long gap) {\n+      return new Pair<>(ts, ts + gap);\n+    }\n+  }\n+\n+  /**\n+   * Create enumerable implementation that applies hopping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hopping(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQxNDA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyNzoyM1rOGHkUog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTozMDozMlrOGIDvTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODMyMg==", "bodyText": "Also remove the values keyword from the commit message.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588322", "createdAt": "2020-04-18T03:27:23Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -966,8 +970,8 @@ public MatchImplementor get(final SqlMatchFunction function) {\n     }\n   }\n \n-  public TableValuedFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n-    final Supplier<? extends TableValuedFunctionCallImplementor> supplier =\n+  public TableFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n+    final Supplier<? extends TableFunctionCallImplementor> supplier =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA1Mg==", "bodyText": "Done.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411103052", "createdAt": "2020-04-20T05:30:32Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -966,8 +970,8 @@ public MatchImplementor get(final SqlMatchFunction function) {\n     }\n   }\n \n-  public TableValuedFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n-    final Supplier<? extends TableValuedFunctionCallImplementor> supplier =\n+  public TableFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n+    final Supplier<? extends TableFunctionCallImplementor> supplier =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODMyMg=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQxOTA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyODoyOVrOGHkWxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNToyOTowMFrOGIDtKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODg3MQ==", "bodyText": "Give these intervalExpression  more meaningful name. e.g. windowSize and slidingInterval ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588871", "createdAt": "2020-04-18T03:28:29Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -3143,11 +3147,62 @@ private Expression normalize(SqlTypeName typeName, Expression e) {\n       return Expressions.call(\n           BuiltInMethod.TUMBLING.method,\n           inputEnumerable,\n-          EnumUtils.windowSelector(\n+          EnumUtils.tumblingWindowSelector(\n               inputPhysType,\n               outputPhysType,\n               translatedOperands.get(0),\n               translatedOperands.get(1)));\n     }\n   }\n+\n+  /** Implements hopping. */\n+  private static class HopImplementor implements TableFunctionCallImplementor {\n+    @Override public Expression implement(RexToLixTranslator translator,\n+        Expression inputEnumerable, RexCall call, PhysType inputPhysType, PhysType outputPhysType) {\n+      Expression intervalExpression = translator.translate(call.getOperands().get(2));\n+      Expression intervalExpression2 = translator.translate(call.getOperands().get(3));\n+      RexCall descriptor = (RexCall) call.getOperands().get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjUwNQ==", "bodyText": "Done.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102505", "createdAt": "2020-04-20T05:29:00Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -3143,11 +3147,62 @@ private Expression normalize(SqlTypeName typeName, Expression e) {\n       return Expressions.call(\n           BuiltInMethod.TUMBLING.method,\n           inputEnumerable,\n-          EnumUtils.windowSelector(\n+          EnumUtils.tumblingWindowSelector(\n               inputPhysType,\n               outputPhysType,\n               translatedOperands.get(0),\n               translatedOperands.get(1)));\n     }\n   }\n+\n+  /** Implements hopping. */\n+  private static class HopImplementor implements TableFunctionCallImplementor {\n+    @Override public Expression implement(RexToLixTranslator translator,\n+        Expression inputEnumerable, RexCall call, PhysType inputPhysType, PhysType outputPhysType) {\n+      Expression intervalExpression = translator.translate(call.getOperands().get(2));\n+      Expression intervalExpression2 = translator.translate(call.getOperands().get(3));\n+      RexCall descriptor = (RexCall) call.getOperands().get(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODg3MQ=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQyMzUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyOTo0MVrOGHkYvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwMTozNzoxMlrOGMNUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw==", "bodyText": "What does the TVF mean ? How about just name it HOP_FUN", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589373", "createdAt": "2020-04-18T03:29:41Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MDIyMA==", "bodyText": "TVF is the abbrev for \"table-valued function\".  To clarify, \"table-valued function\" is the term used in SQL standard. But seems like people in Calcite community like the short version: table function.\nI can rename it, but it will be better to use, e.g. HOP_TABLE_FUNCTION. What do you think?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411090220", "createdAt": "2020-04-20T04:47:47Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNDUxOA==", "bodyText": "I would prefer to name it directly \"HOP\" and rename the old one to \"_HOP\", after all, we already rename the group window with prefix \"$\".", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411104518", "createdAt": "2020-04-20T05:35:11Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDUyNQ==", "bodyText": "I am using e.g. \"SESSION_TABLE_FUNCTION\" right now.\nRegarding old one to \"_HOP\" and use \"HOP\" for the new, how about put this rename in a deprecation process? Directly renaming is not backward compatible. I plan to send a discussion email to community to discuss the deprecation of group window functions. We can decide how to rename it based on the discussion (e.g. if people don't want to deprecate group window functions, it probably means that they want keep HOP for hopping by group windowing function).", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411604525", "createdAt": "2020-04-20T18:39:51Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDg3NA==", "bodyText": "My personal idea is to fully deprecate group window function. HOP,TUMBLE and SESSION will be reserved for table function windowing only.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411604874", "createdAt": "2020-04-20T18:40:26Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTY3NA==", "bodyText": "Go ahead and send the mail ~", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411855674", "createdAt": "2020-04-21T04:15:53Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0NDUyNw==", "bodyText": "After a second thought, I think I will just make the change about \"HOP\" and \"_HOP\" for old and new in this PR, because as you have said, I have already used \"$\" in the name.\nThe email discussion I want is about a bigger discussion on if we should fully deprecate group window function. I will do it later and that discussion is not relevant to this PR.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412344527", "createdAt": "2020-04-21T17:20:13Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NTc0OA==", "bodyText": "There is a naming constraint:\nName '_TUMBLE' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'.\nSo the realistic naming is TUMBLE_. Do you think it is a good idea to rename all group window function operator with \"_\" as suffix?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r413295748", "createdAt": "2020-04-22T20:12:46Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MDM1OQ==", "bodyText": "I'm fine with that.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414240359", "createdAt": "2020-04-24T02:06:54Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1NDI0Mw==", "bodyText": "Used , for example, TUMBLE_OLD as the naming for grouped window functions (check style does not allow _ as the last character)", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415454243", "createdAt": "2020-04-27T01:37:12Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQyNTQyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzozMDoxOVrOGHkZjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNToyODo1NFrOGIDtEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTU4MA==", "bodyText": "Also add tests for SESSION and HOP.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589580", "createdAt": "2020-04-18T03:30:19Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java", "diffHunk": "@@ -1778,15 +1778,16 @@ public final Sql sql(String sql) {\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumble() {\n+\n+  @Test public void testTableFunctionTumble() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble(table Shipments, descriptor(rowtime), INTERVAL '1' MINUTE))\";\n     sql(sql).ok();\n   }\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumbleWithSubQueryParam() {\n+  @Test public void testTableFunctionTumbleWithSubQueryParam() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble((select * from Shipments), descriptor(rowtime), INTERVAL '1' MINUTE))\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjQ4Mw==", "bodyText": "Done", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102483", "createdAt": "2020-04-20T05:28:54Z", "author": {"login": "amaliujia"}, "path": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java", "diffHunk": "@@ -1778,15 +1778,16 @@ public final Sql sql(String sql) {\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumble() {\n+\n+  @Test public void testTableFunctionTumble() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble(table Shipments, descriptor(rowtime), INTERVAL '1' MINUTE))\";\n     sql(sql).ok();\n   }\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumbleWithSubQueryParam() {\n+  @Test public void testTableFunctionTumbleWithSubQueryParam() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble((select * from Shipments), descriptor(rowtime), INTERVAL '1' MINUTE))\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTU4MA=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0OTQzMDc2OnYy", "diffSide": "RIGHT", "path": "site/_docs/reference.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzozMTo0OVrOGHkb0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0Njo0MFrOGIimrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MDE2MQ==", "bodyText": "Do we really support [, time ] ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410590161", "createdAt": "2020-04-18T03:31:49Z", "author": {"login": "danny0405"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1875,14 +1876,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MDYxNw==", "bodyText": "yes you are right. We don't support it so far.\nDo you prefer me to support it in this PR, or a future PR (I can modify documentation accordingly)?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411090617", "createdAt": "2020-04-20T04:48:58Z", "author": {"login": "amaliujia"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1875,14 +1876,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MDE2MQ=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNDc3NQ==", "bodyText": "Either is fine, we should keep our document correct and exact.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411104775", "createdAt": "2020-04-20T05:36:04Z", "author": {"login": "danny0405"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1875,14 +1876,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MDE2MQ=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwODc0OA==", "bodyText": "Done! Remove [, time] and relevant bits from the documentation.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411608748", "createdAt": "2020-04-20T18:46:40Z", "author": {"login": "amaliujia"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1875,14 +1876,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MDE2MQ=="}, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1OTAwMzIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/codegen/templates/Parser.jj", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTowODozNFrOGIyuXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwMTo1NjoxMlrOGMNnmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA==", "bodyText": "We can combine these\nargs = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n        }\nUse another variable to keep the operator and move the common parse logic to the java code block.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411872860", "createdAt": "2020-04-21T05:08:34Z", "author": {"login": "danny0405"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NzM1Nw==", "bodyText": "Done.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r413297357", "createdAt": "2020-04-22T20:15:16Z", "author": {"login": "amaliujia"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4NTMwNQ==", "bodyText": "span() can also be promoted.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415185305", "createdAt": "2020-04-26T01:31:21Z", "author": {"login": "danny0405"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1NTg4NA==", "bodyText": "I tried to change to this way\n(\n        <TUMBLE>\n        {\n            op = SqlStdOperatorTable.TUMBLE_OLD;\n        }\n    |\n        <HOP>\n        {\n            op = SqlStdOperatorTable.HOP_OLD;\n        }\n    |\n        <SESSION>\n        {\n            op = SqlStdOperatorTable.SESSION_OLD;\n        }\n    )\n    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n        s = span();\n        return op.createCall(s.end(this), args);\n    }\n\nBut the parser didn't work as expected.\nAny thing I have missed?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415455884", "createdAt": "2020-04-27T01:43:16Z", "author": {"login": "amaliujia"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1OTIyNQ==", "bodyText": "No worries, i would promote that when i merged the PR.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415459225", "createdAt": "2020-04-27T01:56:12Z", "author": {"login": "danny0405"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1OTEwOTk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "isResolved": false, "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTo0ODo0NlrOGIznlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMjo0Mjo0OFrOGOXzSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA==", "bodyText": "Why we must have 2 DESCRIPTOR here ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411887508", "createdAt": "2020-04-21T05:48:46Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyMDE4OA==", "bodyText": "For session, usually common usage is per key. E.g. per user session. That's what the second descriptor used for: offer a session key.\nThe group window function does not have this problem because that style of windowing happens at GROUP BY, where users can put separate GROUP BY key as session key.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411920188", "createdAt": "2020-04-21T06:55:59Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyODM4OQ==", "bodyText": "I mean why couldn't we have one DESCRIPTOR with 2 columns ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411928389", "createdAt": "2020-04-21T07:10:35Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0OTM4OQ==", "bodyText": "Because descriptor only provide column names so far. If there is only one descriptor in which there are two column names, it will have a problem to know which one is the timestamp column that apply windowing upon and which one is the session key(note that session could be timestamp type as well). Of course a workaround is to define, say: the first column name is for windowing, and the second column is for session key. But this is error-prone, both from user usage and documentation perspectives: users have to use the right column name on the right position and documentation needs to explain the meaning of each position.\nTwo descriptors is better as each one has its clear semantic and require one column only.\nSo I think it's a good API design than single descriptor.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412349389", "createdAt": "2020-04-21T17:27:05Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNzY4Mw==", "bodyText": "I don't think so, use two descriptors also has such concerns, people would also ask \"which column is timestamp column\"", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412607683", "createdAt": "2020-04-22T01:44:24Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNTY0Ng==", "bodyText": "It's ok that you don't think that benefit holds. Even if so, then seems to me that there is no difference between one descriptor and two descriptors, in terms of benefits. What do you think?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412615646", "createdAt": "2020-04-22T02:07:11Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MDk4Mg==", "bodyText": "The descriptor keyword itself is too verbose, why we must have that ? Couldn't we just put a column name there directly ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414240982", "createdAt": "2020-04-24T02:09:11Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1MDY2OA==", "bodyText": "In fact, DESCRIPTOR is a part of  SQL standard 2016: Polymorphic table functions (https://issues.apache.org/jira/browse/CALCITE-2270). DESCRIPTOR is designed to specify columns explicitly in table functions. That was one of the purpose  it was created for.\nYou can find a free copy of SQL standard 2016:  Polymorphic table functions in this link: https://modern-sql.com/standard", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414350668", "createdAt": "2020-04-24T07:17:36Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MzI1NQ==", "bodyText": "Thanks for the explanations, personally i think one DESCRIPTOR is more concise, i'm wondering what other people think ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414393255", "createdAt": "2020-04-24T08:29:12Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4NTQ4OQ==", "bodyText": "Can the session key be multiple keys ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415185489", "createdAt": "2020-04-26T01:32:34Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0OTY3Nw==", "bodyText": "This is a good point. In my implementation, it is single key only (cause that is the typical usage). But compound key is feasible and valid use case.\nIf there is a need to support compound key, then I think two descriptors will be better.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415449677", "createdAt": "2020-04-27T01:19:51Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1MTc3MQ==", "bodyText": "Yes, two descriptor is more feasible to support multiple session keys, we better add a test in  SqlToRelConverterTest to support multiple session keys.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415451771", "createdAt": "2020-04-27T01:27:21Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ2MDA3NA==", "bodyText": "Added a testTableFunctionSessionCompoundSessionKey in SqlToRelConverterTest for verifying that generated plan is correct when there are multiple session key.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415460074", "createdAt": "2020-04-27T01:59:25Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MzM5OQ==", "bodyText": "Another reason why we use descriptor than just a column name: https://issues.apache.org/jira/browse/CALCITE-3964\nBasically there is a missing feature of DESCRIPTOR: an optional data type, which can be used to do type validation. It's useful for event timestamp windowing because such windowing should be apply on TIMESTAMP column. DESCRIPTOR will be handy to validate if user query applies windowing on a right column.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r417663399", "createdAt": "2020-04-29T23:06:39Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcyMzIwOQ==", "bodyText": "From the paper, the DESCRIPTOR only appears in the function definition, that is, it is in the DDL, here we are not creating a function, but use it directly, i'm not sure if we should use the descriptor, as for the first argument, i would fix it as a cursor.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r417723209", "createdAt": "2020-04-30T02:42:48Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 273, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}