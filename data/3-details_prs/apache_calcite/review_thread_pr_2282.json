{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4Mzg2NjI3", "number": 2282, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDowNzowMVrOE-JkNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMzo1Mzo0NlrOGPKPoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNjAzODkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDowNzowMVrOH7MpRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNDo0OTo0N1rOH7r2tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgzNTIwNQ==", "bodyText": "It might not be true. Sometimes users may want it to throw an exception.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r531835205", "createdAt": "2020-11-28T04:07:01Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -329,6 +336,93 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    // if any operand is null, the result will be null\n+    if (RexUtil.isNullLiteral(e.operands.get(0), true)\n+        || RexUtil.isNullLiteral(e.operands.get(1), true)) {\n+      return rexBuilder.makeNullLiteral(e.type);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16333305cc14637b854ad38cbb111ce7445ec1e2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0NjU0OQ==", "bodyText": "Thanks for your feedback. It makes sense. This logic is removed.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r532346549", "createdAt": "2020-11-30T04:49:47Z", "author": {"login": "liyafan82"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -329,6 +336,93 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    // if any operand is null, the result will be null\n+    if (RexUtil.isNullLiteral(e.operands.get(0), true)\n+        || RexUtil.isNullLiteral(e.operands.get(1), true)) {\n+      return rexBuilder.makeNullLiteral(e.type);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgzNTIwNQ=="}, "originalCommit": {"oid": "16333305cc14637b854ad38cbb111ce7445ec1e2"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNjA0NDY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQwNDowODozM1rOH7MtTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwNDo1MTo0NFrOH7r4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgzNjIzOQ==", "bodyText": "Can a - a be simplified to 0 if a is not nullable?", "url": "https://github.com/apache/calcite/pull/2282#discussion_r531836239", "createdAt": "2020-11-28T04:08:33Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -329,6 +336,93 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    // if any operand is null, the result will be null\n+    if (RexUtil.isNullLiteral(e.operands.get(0), true)\n+        || RexUtil.isNullLiteral(e.operands.get(1), true)) {\n+      return rexBuilder.makeNullLiteral(e.type);\n+    }\n+\n+    switch (e.getKind()) {\n+    case PLUS:\n+      return simplifyPlus(e);\n+    case MINUS:\n+      return simplifyMinus(e);\n+    case TIMES:\n+      return simplifyMultiply(e);\n+    case DIVIDE:\n+      return simplifyDivide(e);\n+    default:\n+      throw new IllegalArgumentException(\"Unsupported arithmeitc operation \" + e.getKind());\n+    }\n+  }\n+\n+  private RexNode simplifyPlus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex >= 0) {\n+      // return the other operand\n+      RexNode other = e.getOperands().get((zeroIndex + 1) % 2);\n+      return other.getType().equals(e.getType())\n+          ? other : rexBuilder.makeCast(e.getType(), other);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMinus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex == 1) {\n+      RexNode leftOperand = e.getOperands().get(0);\n+      return leftOperand.getType().equals(e.getType())\n+          ? leftOperand : rexBuilder.makeCast(e.getType(), leftOperand);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16333305cc14637b854ad38cbb111ce7445ec1e2"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjM0NjkzNA==", "bodyText": "Thanks for the suggestion.\nThere are some special cases for which this is not true. For example,\nNaN - NaN = NaN\nInf - Inf = NaN", "url": "https://github.com/apache/calcite/pull/2282#discussion_r532346934", "createdAt": "2020-11-30T04:51:44Z", "author": {"login": "liyafan82"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -329,6 +336,93 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    // if any operand is null, the result will be null\n+    if (RexUtil.isNullLiteral(e.operands.get(0), true)\n+        || RexUtil.isNullLiteral(e.operands.get(1), true)) {\n+      return rexBuilder.makeNullLiteral(e.type);\n+    }\n+\n+    switch (e.getKind()) {\n+    case PLUS:\n+      return simplifyPlus(e);\n+    case MINUS:\n+      return simplifyMinus(e);\n+    case TIMES:\n+      return simplifyMultiply(e);\n+    case DIVIDE:\n+      return simplifyDivide(e);\n+    default:\n+      throw new IllegalArgumentException(\"Unsupported arithmeitc operation \" + e.getKind());\n+    }\n+  }\n+\n+  private RexNode simplifyPlus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex >= 0) {\n+      // return the other operand\n+      RexNode other = e.getOperands().get((zeroIndex + 1) % 2);\n+      return other.getType().equals(e.getType())\n+          ? other : rexBuilder.makeCast(e.getType(), other);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMinus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex == 1) {\n+      RexNode leftOperand = e.getOperands().get(0);\n+      return leftOperand.getType().equals(e.getType())\n+          ? leftOperand : rexBuilder.makeCast(e.getType(), leftOperand);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgzNjIzOQ=="}, "originalCommit": {"oid": "16333305cc14637b854ad38cbb111ce7445ec1e2"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAxMDMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMDoxNVrOH8UXHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNjoyMzo0OFrOH8ZvoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMDIwNA==", "bodyText": "Make it final since it's our convention.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533010204", "createdAt": "2020-12-01T01:20:15Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    switch (e.getKind()) {\n+    case PLUS:\n+      return simplifyPlus(e);\n+    case MINUS:\n+      return simplifyMinus(e);\n+    case TIMES:\n+      return simplifyMultiply(e);\n+    case DIVIDE:\n+      return simplifyDivide(e);\n+    default:\n+      throw new IllegalArgumentException(\"Unsupported arithmeitc operation \" + e.getKind());\n+    }\n+  }\n+\n+  private RexNode simplifyPlus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex >= 0) {\n+      // return the other operand\n+      RexNode other = e.getOperands().get((zeroIndex + 1) % 2);\n+      return other.getType().equals(e.getType())\n+          ? other : rexBuilder.makeCast(e.getType(), other);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMinus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex == 1) {\n+      RexNode leftOperand = e.getOperands().get(0);\n+      return leftOperand.getType().equals(e.getType())\n+          ? leftOperand : rexBuilder.makeCast(e.getType(), leftOperand);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMultiply(RexCall e) {\n+    int oneIndex = findLiteralIndex(e.operands, 1L);\n+    if (oneIndex >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5ODQwMA==", "bodyText": "Revised. Thanks for the good suggestion.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533098400", "createdAt": "2020-12-01T06:23:48Z", "author": {"login": "liyafan82"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);\n+    }\n+\n+    assert e.getOperands().size() == 2;\n+\n+    switch (e.getKind()) {\n+    case PLUS:\n+      return simplifyPlus(e);\n+    case MINUS:\n+      return simplifyMinus(e);\n+    case TIMES:\n+      return simplifyMultiply(e);\n+    case DIVIDE:\n+      return simplifyDivide(e);\n+    default:\n+      throw new IllegalArgumentException(\"Unsupported arithmeitc operation \" + e.getKind());\n+    }\n+  }\n+\n+  private RexNode simplifyPlus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex >= 0) {\n+      // return the other operand\n+      RexNode other = e.getOperands().get((zeroIndex + 1) % 2);\n+      return other.getType().equals(e.getType())\n+          ? other : rexBuilder.makeCast(e.getType(), other);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMinus(RexCall e) {\n+    int zeroIndex = findLiteralIndex(e.operands, 0L);\n+    if (zeroIndex == 1) {\n+      RexNode leftOperand = e.getOperands().get(0);\n+      return leftOperand.getType().equals(e.getType())\n+          ? leftOperand : rexBuilder.makeCast(e.getType(), leftOperand);\n+    }\n+    return simplifyGenericNode(e);\n+  }\n+\n+  private RexNode simplifyMultiply(RexCall e) {\n+    int oneIndex = findLiteralIndex(e.operands, 1L);\n+    if (oneIndex >= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMDIwNA=="}, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAxNTA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMjoyMlrOH8UZyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNjoyNDowMFrOH8Zv1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMDg5MQ==", "bodyText": "Add . to the end of the sentence.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533010891", "createdAt": "2020-12-01T01:22:22Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5ODQ1Mg==", "bodyText": "Done. Thanks.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533098452", "createdAt": "2020-12-01T06:24:00Z", "author": {"login": "liyafan82"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private RexNode simplifyArithmetic(RexCall e) {\n+    if (e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC\n+        || e.getOperands().stream()\n+        .anyMatch(o -> e.getType().getSqlTypeName().getFamily() != SqlTypeFamily.NUMERIC)) {\n+      // we only support simplifying numeric types\n+      return simplifyGenericNode(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMDg5MQ=="}, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDAxNzMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMToyMzozOVrOH8UbMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNjoyNDoyMVrOH8ZwTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMTI1MQ==", "bodyText": "Could you mark it that it only supports numeric type?", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533011251", "createdAt": "2020-12-01T01:23:39Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA5ODU3NA==", "bodyText": "Sure. I've made it explicit in the JavaDoc.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r533098574", "createdAt": "2020-12-01T06:24:21Z", "author": {"login": "liyafan82"}, "path": "core/src/main/java/org/apache/calcite/rex/RexSimplify.java", "diffHunk": "@@ -332,6 +339,87 @@ private RexNode simplifyGenericNode(RexCall e) {\n     return rexBuilder.makeCall(e.getType(), e.getOperator(), operands);\n   }\n \n+  /**\n+   * Try to find a literal with the given value in the input list.\n+   */\n+  private int findLiteralIndex(List<RexNode> operands, long value) {\n+    for (int i = 0; i < operands.size(); i++) {\n+      if (operands.get(i).isA(SqlKind.LITERAL)) {\n+        Comparable comparable = ((RexLiteral) operands.get(i)).getValue();\n+        if (comparable instanceof BigDecimal && ((BigDecimal) comparable).longValue() == value) {\n+          return i;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxMTI1MQ=="}, "originalCommit": {"oid": "68f497f4f08cde35f47c3777e90a21d4259ac1c3"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE4NTQ5NjY1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexProgramTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMzo1Mzo0NlrOJ0jdaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOFQwNDo0MzozNVrOJ07Hqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA4NjY5Nw==", "bodyText": "Could you please add a test like add(zero, sub(vInt(0), vInt(0)))?\nThe expression should evaluate to null in case vInt(0) is null.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r659086697", "createdAt": "2021-06-25T23:53:46Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexProgramTest.java", "diffHunk": "@@ -3224,4 +3224,25 @@ private SqlSpecialOperatorWithPolicy(String name, SqlKind kind, int prec, boolea\n   @Test void testSimplifyVarbinary() {\n     checkSimplifyUnchanged(cast(cast(vInt(), tVarchar(true, 100)), tVarbinary(true)));\n   }\n+\n+  @Test void testSimplifySimpleArithmetic() {\n+    RexNode a = vIntNotNull(1);\n+    RexNode zero = literal(0);\n+    RexNode one = literal(1);\n+\n+    RexNode b = vDecimalNotNull(2);\n+    RexNode half = literal(new BigDecimal(0.5), b.getType());\n+\n+    checkSimplify(add(a, zero), \"?0.notNullInt1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11add5bf0fa6b861f4b826f418bc6ea7a18565f6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTQ3NDM0Nw==", "bodyText": "Good point. Thanks. @vlsi\nI have added some test cases concerning null. Please check.", "url": "https://github.com/apache/calcite/pull/2282#discussion_r659474347", "createdAt": "2021-06-28T04:43:35Z", "author": {"login": "liyafan82"}, "path": "core/src/test/java/org/apache/calcite/rex/RexProgramTest.java", "diffHunk": "@@ -3224,4 +3224,25 @@ private SqlSpecialOperatorWithPolicy(String name, SqlKind kind, int prec, boolea\n   @Test void testSimplifyVarbinary() {\n     checkSimplifyUnchanged(cast(cast(vInt(), tVarchar(true, 100)), tVarbinary(true)));\n   }\n+\n+  @Test void testSimplifySimpleArithmetic() {\n+    RexNode a = vIntNotNull(1);\n+    RexNode zero = literal(0);\n+    RexNode one = literal(1);\n+\n+    RexNode b = vDecimalNotNull(2);\n+    RexNode half = literal(new BigDecimal(0.5), b.getType());\n+\n+    checkSimplify(add(a, zero), \"?0.notNullInt1\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA4NjY5Nw=="}, "originalCommit": {"oid": "11add5bf0fa6b861f4b826f418bc6ea7a18565f6"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 10, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}