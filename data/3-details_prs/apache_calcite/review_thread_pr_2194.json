{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MzY0OTc3", "number": 2194, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoxNTo1NFrOErQXsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNzo1NzowMFrOErS0vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzkyNDMzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoxNTo1NFrOHd7L3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1NDo1N1rOHeSQkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQ0Nw==", "bodyText": "this is the NPE fix", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501140447", "createdAt": "2020-10-07T16:15:54Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java", "diffHunk": "@@ -872,23 +872,36 @@ public static boolean checkInputForCollationAndLimit(RelMetadataQuery mq,\n       RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n     // Check if the input is already sorted\n     boolean alreadySorted = collation.getFieldCollations().isEmpty();\n-    for (RelCollation inputCollation : mq.collations(input)) {\n-      if (inputCollation.satisfies(collation)) {\n-        alreadySorted = true;\n-        break;\n+    if (!alreadySorted) {\n+      final ImmutableList<RelCollation> collations = mq.collations(input);\n+      if (collations != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0ODIwMw==", "bodyText": "Should it be like if (collations == null) { return false; } ?", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501148203", "createdAt": "2020-10-07T16:27:15Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java", "diffHunk": "@@ -872,23 +872,36 @@ public static boolean checkInputForCollationAndLimit(RelMetadataQuery mq,\n       RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n     // Check if the input is already sorted\n     boolean alreadySorted = collation.getFieldCollations().isEmpty();\n-    for (RelCollation inputCollation : mq.collations(input)) {\n-      if (inputCollation.satisfies(collation)) {\n-        alreadySorted = true;\n-        break;\n+    if (!alreadySorted) {\n+      final ImmutableList<RelCollation> collations = mq.collations(input);\n+      if (collations != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQ0Nw=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNTMyMQ==", "bodyText": "Yes, totally. I'll change it", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501505321", "createdAt": "2020-10-08T07:31:23Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java", "diffHunk": "@@ -872,23 +872,36 @@ public static boolean checkInputForCollationAndLimit(RelMetadataQuery mq,\n       RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n     // Check if the input is already sorted\n     boolean alreadySorted = collation.getFieldCollations().isEmpty();\n-    for (RelCollation inputCollation : mq.collations(input)) {\n-      if (inputCollation.satisfies(collation)) {\n-        alreadySorted = true;\n-        break;\n+    if (!alreadySorted) {\n+      final ImmutableList<RelCollation> collations = mq.collations(input);\n+      if (collations != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQ0Nw=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxODQ4Mw==", "bodyText": "Changed", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501518483", "createdAt": "2020-10-08T07:54:57Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/metadata/RelMdUtil.java", "diffHunk": "@@ -872,23 +872,36 @@ public static boolean checkInputForCollationAndLimit(RelMetadataQuery mq,\n       RelNode input, RelCollation collation, RexNode offset, RexNode fetch) {\n     // Check if the input is already sorted\n     boolean alreadySorted = collation.getFieldCollations().isEmpty();\n-    for (RelCollation inputCollation : mq.collations(input)) {\n-      if (inputCollation.satisfies(collation)) {\n-        alreadySorted = true;\n-        break;\n+    if (!alreadySorted) {\n+      final ImmutableList<RelCollation> collations = mq.collations(input);\n+      if (collations != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQ0Nw=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzODMyNjM4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNzo1NzowMFrOHd_Fng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNDoyODowNFrOHehX6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM4Mg==", "bodyText": "Could you add a clarification why true is expected here?\nFrankly speaking, it would be hard to maintain the test if it fails with \"expected true got false\" :-/", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501204382", "createdAt": "2020-10-07T17:57:00Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "diffHunk": "@@ -3132,6 +3133,35 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n         is(\"=($0, $1)\"));\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-4315\">[CALCITE-4315]\n+   * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */\n+  @Test void testCheckInputForCollationAndLimit() {\n+    final Project rel = (Project) convertSql(\"select * from emp, dept\");\n+    final Join join = (Join) rel.getInput();\n+    final RelOptTable empTable = join.getInput(0).getTable();\n+    final RelOptTable deptTable = join.getInput(1).getTable();\n+    Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {\n+      checkInputForCollationAndLimit(cluster, empTable, deptTable);\n+      return null;\n+    });\n+  }\n+\n+  private void checkInputForCollationAndLimit(RelOptCluster cluster, RelOptTable empTable,\n+      RelOptTable deptTable) {\n+    final RexBuilder rexBuilder = cluster.getRexBuilder();\n+    final RelMetadataQuery mq = cluster.getMetadataQuery();\n+    final List<RelHint> hints = ImmutableList.of();\n+    final LogicalTableScan empScan = LogicalTableScan.create(cluster, empTable, hints);\n+    final LogicalTableScan deptScan = LogicalTableScan.create(cluster, deptTable, hints);\n+    final LogicalJoin join =\n+        LogicalJoin.create(empScan, deptScan, ImmutableList.of(),\n+            rexBuilder.makeLiteral(true), ImmutableSet.of(), JoinRelType.INNER);\n+    assertTrue(\n+        RelMdUtil.checkInputForCollationAndLimit(mq, join, join.getTraitSet().getCollation(),\n+            null, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNjkyMA==", "bodyText": "true is expected because we are checking the join against its own collation (so of course it is already sorted by that collation) and no limit (fetch parameter is null). In any case, checking the result of the method is not really relevant, the original problem was a NPE inside checkInputForCollationAndLimit, so for this test I can perfectly remove the assertTrue(...), and just the call checkInputForCollationAndLimit.", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501506920", "createdAt": "2020-10-08T07:34:28Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "diffHunk": "@@ -3132,6 +3133,35 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n         is(\"=($0, $1)\"));\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-4315\">[CALCITE-4315]\n+   * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */\n+  @Test void testCheckInputForCollationAndLimit() {\n+    final Project rel = (Project) convertSql(\"select * from emp, dept\");\n+    final Join join = (Join) rel.getInput();\n+    final RelOptTable empTable = join.getInput(0).getTable();\n+    final RelOptTable deptTable = join.getInput(1).getTable();\n+    Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {\n+      checkInputForCollationAndLimit(cluster, empTable, deptTable);\n+      return null;\n+    });\n+  }\n+\n+  private void checkInputForCollationAndLimit(RelOptCluster cluster, RelOptTable empTable,\n+      RelOptTable deptTable) {\n+    final RexBuilder rexBuilder = cluster.getRexBuilder();\n+    final RelMetadataQuery mq = cluster.getMetadataQuery();\n+    final List<RelHint> hints = ImmutableList.of();\n+    final LogicalTableScan empScan = LogicalTableScan.create(cluster, empTable, hints);\n+    final LogicalTableScan deptScan = LogicalTableScan.create(cluster, deptTable, hints);\n+    final LogicalJoin join =\n+        LogicalJoin.create(empScan, deptScan, ImmutableList.of(),\n+            rexBuilder.makeLiteral(true), ImmutableSet.of(), JoinRelType.INNER);\n+    assertTrue(\n+        RelMdUtil.checkInputForCollationAndLimit(mq, join, join.getTraitSet().getCollation(),\n+            null, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM4Mg=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNDQwMg==", "bodyText": "It might be fine if you copy your explanation to the assert message: () -> \"we are checking the join against its own collation, fetch=null, offset=null => checkInputForCollationAndLimit must be true. join=\" + join)\nWDYT?\n\nfor this test I can perfectly remove the assertTrue(...), and just the call checkInputForCollationAndLimit.\n\nIf you remove all the asserts, then the test does not add much value. The code won't compile, and it would force the developer to handle null.", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501514402", "createdAt": "2020-10-08T07:47:56Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "diffHunk": "@@ -3132,6 +3133,35 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n         is(\"=($0, $1)\"));\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-4315\">[CALCITE-4315]\n+   * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */\n+  @Test void testCheckInputForCollationAndLimit() {\n+    final Project rel = (Project) convertSql(\"select * from emp, dept\");\n+    final Join join = (Join) rel.getInput();\n+    final RelOptTable empTable = join.getInput(0).getTable();\n+    final RelOptTable deptTable = join.getInput(1).getTable();\n+    Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {\n+      checkInputForCollationAndLimit(cluster, empTable, deptTable);\n+      return null;\n+    });\n+  }\n+\n+  private void checkInputForCollationAndLimit(RelOptCluster cluster, RelOptTable empTable,\n+      RelOptTable deptTable) {\n+    final RexBuilder rexBuilder = cluster.getRexBuilder();\n+    final RelMetadataQuery mq = cluster.getMetadataQuery();\n+    final List<RelHint> hints = ImmutableList.of();\n+    final LogicalTableScan empScan = LogicalTableScan.create(cluster, empTable, hints);\n+    final LogicalTableScan deptScan = LogicalTableScan.create(cluster, deptTable, hints);\n+    final LogicalJoin join =\n+        LogicalJoin.create(empScan, deptScan, ImmutableList.of(),\n+            rexBuilder.makeLiteral(true), ImmutableSet.of(), JoinRelType.INNER);\n+    assertTrue(\n+        RelMdUtil.checkInputForCollationAndLimit(mq, join, join.getTraitSet().getCollation(),\n+            null, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM4Mg=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMDgwMg==", "bodyText": "The test without assert runs fine (I have just pushed a version in that way). It just executes a method that previously used to failed with a NPE, and now with the fix it runs successfully.\nBut I am ok with both (with or without assert). If you prefer, I can re-apply the assert with an explanation in the assert message.", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501520802", "createdAt": "2020-10-08T07:58:38Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "diffHunk": "@@ -3132,6 +3133,35 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n         is(\"=($0, $1)\"));\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-4315\">[CALCITE-4315]\n+   * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */\n+  @Test void testCheckInputForCollationAndLimit() {\n+    final Project rel = (Project) convertSql(\"select * from emp, dept\");\n+    final Join join = (Join) rel.getInput();\n+    final RelOptTable empTable = join.getInput(0).getTable();\n+    final RelOptTable deptTable = join.getInput(1).getTable();\n+    Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {\n+      checkInputForCollationAndLimit(cluster, empTable, deptTable);\n+      return null;\n+    });\n+  }\n+\n+  private void checkInputForCollationAndLimit(RelOptCluster cluster, RelOptTable empTable,\n+      RelOptTable deptTable) {\n+    final RexBuilder rexBuilder = cluster.getRexBuilder();\n+    final RelMetadataQuery mq = cluster.getMetadataQuery();\n+    final List<RelHint> hints = ImmutableList.of();\n+    final LogicalTableScan empScan = LogicalTableScan.create(cluster, empTable, hints);\n+    final LogicalTableScan deptScan = LogicalTableScan.create(cluster, deptTable, hints);\n+    final LogicalJoin join =\n+        LogicalJoin.create(empScan, deptScan, ImmutableList.of(),\n+            rexBuilder.makeLiteral(true), ImmutableSet.of(), JoinRelType.INNER);\n+    assertTrue(\n+        RelMdUtil.checkInputForCollationAndLimit(mq, join, join.getTraitSet().getCollation(),\n+            null, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM4Mg=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2NjEyMg==", "bodyText": "re-added assert, with message", "url": "https://github.com/apache/calcite/pull/2194#discussion_r501766122", "createdAt": "2020-10-08T14:28:04Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/RelMetadataTest.java", "diffHunk": "@@ -3132,6 +3133,35 @@ private void checkNodeTypeCount(String sql, Map<Class<? extends RelNode>, Intege\n         is(\"=($0, $1)\"));\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-4315\">[CALCITE-4315]\n+   * NPE in RelMdUtil#checkInputForCollationAndLimit</a>. */\n+  @Test void testCheckInputForCollationAndLimit() {\n+    final Project rel = (Project) convertSql(\"select * from emp, dept\");\n+    final Join join = (Join) rel.getInput();\n+    final RelOptTable empTable = join.getInput(0).getTable();\n+    final RelOptTable deptTable = join.getInput(1).getTable();\n+    Frameworks.withPlanner((cluster, relOptSchema, rootSchema) -> {\n+      checkInputForCollationAndLimit(cluster, empTable, deptTable);\n+      return null;\n+    });\n+  }\n+\n+  private void checkInputForCollationAndLimit(RelOptCluster cluster, RelOptTable empTable,\n+      RelOptTable deptTable) {\n+    final RexBuilder rexBuilder = cluster.getRexBuilder();\n+    final RelMetadataQuery mq = cluster.getMetadataQuery();\n+    final List<RelHint> hints = ImmutableList.of();\n+    final LogicalTableScan empScan = LogicalTableScan.create(cluster, empTable, hints);\n+    final LogicalTableScan deptScan = LogicalTableScan.create(cluster, deptTable, hints);\n+    final LogicalJoin join =\n+        LogicalJoin.create(empScan, deptScan, ImmutableList.of(),\n+            rexBuilder.makeLiteral(true), ImmutableSet.of(), JoinRelType.INNER);\n+    assertTrue(\n+        RelMdUtil.checkInputForCollationAndLimit(mq, join, join.getTraitSet().getCollation(),\n+            null, null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwNDM4Mg=="}, "originalCommit": {"oid": "24f37a6d3eaa04c18e42e290adc47bbee1fe06d4"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 43, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}