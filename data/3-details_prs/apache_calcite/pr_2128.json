{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2OTM1Mzgy", "number": 2128, "title": "[CALCITE-4197] Provide utility to visualize RelNode plans", "bodyText": "From time to time, we want to visualize the plan generated the optimizer as a DAG (Directed Acyclic Graph). This gives us an overview of the plan, and helps us to find problems with the plan quickly.\nA common way to visualize a DAG is to dump it in the dot format, and then display the DAG through GraphViz. Currently, we already have a utility to dump the Volcano planner in dot format. In this issue, we want to dump a RelNode plan (a RelNode DAG) in the dot format, which will help users to see their plans more clearly.\nThe utility should have some options that allow users to specify the visuzalization details, for example:\n\nthe max length of a node description.\nwhether RelSubset/HepRelVertex should be displayed.\nNodes that should be highlighted.", "createdAt": "2020-09-01T09:06:24Z", "url": "https://github.com/apache/calcite/pull/2128", "merged": true, "mergeCommit": {"oid": "99c0fefeca7caf638de875133f8c836472e8b28c"}, "closed": true, "closedAt": "2020-09-14T02:04:02Z", "author": {"login": "liyafan82"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEjuh9AFqTQ3OTU0NTMxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHwujmABqjM3NTQ4ODI4MjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NTQ1MzE1", "url": "https://github.com/apache/calcite/pull/2128#pullrequestreview-479545315", "createdAt": "2020-09-01T09:10:26Z", "commit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNDAwOTE0", "url": "https://github.com/apache/calcite/pull/2128#pullrequestreview-480400914", "createdAt": "2020-09-02T02:46:52Z", "commit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMjo0Njo1MlrOHLRKBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMjo1MzowMFrOHLRZQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3NzQ3Nw==", "bodyText": "Minor: it is time to dump the plan -> it is time to dump the plan.", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481577477", "createdAt": "2020-09-02T02:46:52Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.externalize;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.sql.SqlExplainLevel;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.Util;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to dump a rel node plan in dot format.\n+ */\n+public class RelDotWriter extends RelWriterImpl {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  /**\n+   * Adjacent list of the plan graph.\n+   */\n+  private final Map<RelNode, List<RelNode>> outArcTable = new LinkedHashMap<>();\n+\n+  private Map<RelNode, String> nodeLabels = new HashMap<>();\n+\n+  private Multimap<RelNode, String> nodeStyles = HashMultimap.create();\n+\n+  private final WriteOption option;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix) {\n+    this(pw, detailLevel, withIdPrefix, new WriteOption());\n+  }\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix, WriteOption option) {\n+    super(pw, detailLevel, withIdPrefix);\n+    this.option = option;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void explain_(RelNode rel,\n+                          List<Pair<String, Object>> values) {\n+    // get inputs\n+    List<RelNode> inputs = getInputs(rel);\n+    outArcTable.put(rel, inputs);\n+\n+    // generate node label\n+    StringBuilder relDesc = new StringBuilder();\n+    populateRelNodeLabel(rel, values, relDesc);\n+    nodeLabels.put(rel, option.formatNodeLabel(relDesc.toString()));\n+\n+    if (option.highlightNode(rel)) {\n+      nodeStyles.put(rel, \"bold\");\n+    }\n+\n+    explainInputs(inputs);\n+  }\n+\n+  private List<RelNode> getInputs(RelNode parent) {\n+    return parent.getInputs().stream().map(child -> {\n+      if (child instanceof HepRelVertex) {\n+        return ((HepRelVertex) child).getCurrentRel();\n+      } else if (child instanceof RelSubset) {\n+        RelSubset subset = (RelSubset) child;\n+        return Util.first(subset.getBest(), subset.getOriginal());\n+      } else {\n+        return child;\n+      }\n+    }).collect(Collectors.toList());\n+  }\n+\n+  private void explainInputs(List<RelNode> inputs) {\n+    for (RelNode input : inputs) {\n+      if (input == null || nodeLabels.containsKey(input)) {\n+        continue;\n+      }\n+      input.explain(this);\n+    }\n+  }\n+\n+  public RelWriter done(RelNode node) {\n+    int numOfVisitedNodes = nodeLabels.size();\n+    super.done(node);\n+    if (numOfVisitedNodes == 0) {\n+      // When we enter this method call, no node\n+      // has been visited. So the current node must be the root of the plan.\n+      // Now we are exiting the method, all nodes in the plan\n+      // have been visited, so it is time to dump the plan\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4MTM3OA==", "bodyText": "Text such as LogicalAggregate(gro\\\\nup=[{0}] and LogicalTableScan(tab\\\\nle= is a little weird. Maybe we can change it to LogicalAggregate\\n(group=[{0}]. What do you think?", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481581378", "createdAt": "2020-09-02T02:53:00Z", "author": {"login": "chunweilei"}, "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -658,14 +658,25 @@\n     final RelJsonWriter jsonWriter = new RelJsonWriter();\n     rel.explain(jsonWriter);\n     final String relJson = jsonWriter.asString();\n-    String s = deserializeAndDumpToTextFormat(getSchema(rel), relJson);\n-    final String expected = \"\"\n+    String s = deserializeAndDumpToTextFormat(getSchema(rel), relJson, format);\n+    assertThat(s, isLinux(expected));\n+  }\n+\n+  @Test void testAggregateWithAlias() {\n+    testAggregateWithAlias0(SqlExplainFormat.TEXT, \"\"\n         + \"LogicalProject(max_sal=[$1])\\n\"\n         + \"  LogicalAggregate(group=[{0}], max_sal=[MAX($1)])\\n\"\n         + \"    LogicalProject(JOB=[$2], SAL=[$5])\\n\"\n-        + \"      LogicalTableScan(table=[[scott, EMP]])\\n\";\n+        + \"      LogicalTableScan(table=[[scott, EMP]])\\n\");\n \n-    assertThat(s, isLinux(expected));\n+    testAggregateWithAlias0(SqlExplainFormat.DOT, \"digraph {\\n\"\n+        + \"\\\"LogicalProject(max_s\\\\nal=[$1])\\\" -> \\\"LogicalAggregate(gro\\\\nup=[{0}], \"\n+        + \"max_sal=[M\\\\nAX($1)])\\\" [label=\\\"0\\\"]\\n\"\n+        + \"\\\"LogicalAggregate(gro\\\\nup=[{0}], max_sal=[M\\\\nAX($1)])\\\" -> \\\"LogicalProject\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNDY5OTMy", "url": "https://github.com/apache/calcite/pull/2128#pullrequestreview-480469932", "createdAt": "2020-09-02T04:11:59Z", "commit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNDoxMTo1OVrOHLVcCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNDoxMTo1OVrOHLVcCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0NzYyNw==", "bodyText": "This function should be called as deserializeAndDumpToFormat?", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481647627", "createdAt": "2020-09-02T04:11:59Z", "author": {"login": "amaliujia"}, "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -883,7 +917,8 @@ private RelOptSchema getSchema(RelNode rel) {\n    * Deserialize a relnode from the json string by {@link RelJsonReader},\n    * and dump it to text format.\n    */\n-  private String deserializeAndDumpToTextFormat(RelOptSchema schema, String relJson) {\n+  private String deserializeAndDumpToTextFormat(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNTAwNjE2", "url": "https://github.com/apache/calcite/pull/2128#pullrequestreview-480500616", "createdAt": "2020-09-02T05:49:28Z", "commit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo0OToyOFrOHLbSVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNTo1MToyMlrOHLbaQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0MzQ0NQ==", "bodyText": "Did you try the Config as an ImmutableBeans ?", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481743445", "createdAt": "2020-09-02T05:49:28Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.externalize;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.sql.SqlExplainLevel;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.Util;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to dump a rel node plan in dot format.\n+ */\n+public class RelDotWriter extends RelWriterImpl {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  /**\n+   * Adjacent list of the plan graph.\n+   */\n+  private final Map<RelNode, List<RelNode>> outArcTable = new LinkedHashMap<>();\n+\n+  private Map<RelNode, String> nodeLabels = new HashMap<>();\n+\n+  private Multimap<RelNode, String> nodeStyles = HashMultimap.create();\n+\n+  private final WriteOption option;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix) {\n+    this(pw, detailLevel, withIdPrefix, new WriteOption());\n+  }\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix, WriteOption option) {\n+    super(pw, detailLevel, withIdPrefix);\n+    this.option = option;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void explain_(RelNode rel,\n+                          List<Pair<String, Object>> values) {\n+    // get inputs\n+    List<RelNode> inputs = getInputs(rel);\n+    outArcTable.put(rel, inputs);\n+\n+    // generate node label\n+    StringBuilder relDesc = new StringBuilder();\n+    populateRelNodeLabel(rel, values, relDesc);\n+    nodeLabels.put(rel, option.formatNodeLabel(relDesc.toString()));\n+\n+    if (option.highlightNode(rel)) {\n+      nodeStyles.put(rel, \"bold\");\n+    }\n+\n+    explainInputs(inputs);\n+  }\n+\n+  private List<RelNode> getInputs(RelNode parent) {\n+    return parent.getInputs().stream().map(child -> {\n+      if (child instanceof HepRelVertex) {\n+        return ((HepRelVertex) child).getCurrentRel();\n+      } else if (child instanceof RelSubset) {\n+        RelSubset subset = (RelSubset) child;\n+        return Util.first(subset.getBest(), subset.getOriginal());\n+      } else {\n+        return child;\n+      }\n+    }).collect(Collectors.toList());\n+  }\n+\n+  private void explainInputs(List<RelNode> inputs) {\n+    for (RelNode input : inputs) {\n+      if (input == null || nodeLabels.containsKey(input)) {\n+        continue;\n+      }\n+      input.explain(this);\n+    }\n+  }\n+\n+  public RelWriter done(RelNode node) {\n+    int numOfVisitedNodes = nodeLabels.size();\n+    super.done(node);\n+    if (numOfVisitedNodes == 0) {\n+      // When we enter this method call, no node\n+      // has been visited. So the current node must be the root of the plan.\n+      // Now we are exiting the method, all nodes in the plan\n+      // have been visited, so it is time to dump the plan\n+\n+      pw.println(\"digraph {\");\n+\n+      // print nodes with styles\n+      for (RelNode rel : nodeStyles.keySet()) {\n+        String style = String.join(\",\", nodeStyles.get(rel));\n+        pw.println(nodeLabels.get(rel) + \" [style=\\\"\" + style + \"\\\"]\");\n+      }\n+\n+      // ordinary arcs\n+      for (Map.Entry<RelNode, List<RelNode>> entry : outArcTable.entrySet()) {\n+        RelNode src = entry.getKey();\n+        String srcDesc = nodeLabels.get(src);\n+        for (int i = 0; i < entry.getValue().size(); i++) {\n+          RelNode dst = entry.getValue().get(i);\n+\n+          // label is the ordinal of the arc\n+          pw.println(srcDesc + \" -> \" + nodeLabels.get(dst) + \" [label=\\\"\" + i + \"\\\"]\");\n+        }\n+      }\n+      pw.println(\"}\");\n+      pw.flush();\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Options for displaying the rel node plan in dot format.\n+   */\n+  public static class WriteOption {\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NTQ3Mg==", "bodyText": "Can we make RelWriterTest parameterized instead of modifying and abstract common test base ?", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481745472", "createdAt": "2020-09-02T05:51:22Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -839,12 +863,22 @@\n         .build();\n     final String relJson = RelOptUtil.dumpPlan(\"\", rel,\n         SqlExplainFormat.JSON, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n-    final String result = deserializeAndDumpToTextFormat(getSchema(rel), relJson);\n-    final String expected = \"\"\n+    final String result = deserializeAndDumpToTextFormat(getSchema(rel), relJson, format);\n+    assertThat(result, isLinux(expected));\n+  }\n+\n+  @Test void testUDAF() {\n+    testUDAF0(SqlExplainFormat.TEXT, \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ecc6ff958cb3ddd125667c74148b69d00461a9"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NTM1Mzcy", "url": "https://github.com/apache/calcite/pull/2128#pullrequestreview-486535372", "createdAt": "2020-09-11T07:23:41Z", "commit": {"oid": "d6adef2a98520ba1ce93a45e5b684f0cca79ee01"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ab8187fc6c497ea9179399f08f5635c2e215a6", "author": {"user": {"login": "liyafan82", "name": null}}, "url": "https://github.com/apache/calcite/commit/94ab8187fc6c497ea9179399f08f5635c2e215a6", "committedDate": "2020-09-11T08:00:24Z", "message": "[CALCITE-4197] Provide utility to visualize RelNode plans"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6adef2a98520ba1ce93a45e5b684f0cca79ee01", "author": {"user": {"login": "liyafan82", "name": null}}, "url": "https://github.com/apache/calcite/commit/d6adef2a98520ba1ce93a45e5b684f0cca79ee01", "committedDate": "2020-09-03T09:31:49Z", "message": "[CALCITE-4197] Resolve more comments about node labels"}, "afterCommit": {"oid": "94ab8187fc6c497ea9179399f08f5635c2e215a6", "author": {"user": {"login": "liyafan82", "name": null}}, "url": "https://github.com/apache/calcite/commit/94ab8187fc6c497ea9179399f08f5635c2e215a6", "committedDate": "2020-09-11T08:00:24Z", "message": "[CALCITE-4197] Provide utility to visualize RelNode plans"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3281, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}