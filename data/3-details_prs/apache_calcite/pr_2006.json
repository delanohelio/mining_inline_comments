{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5ODg2MjA2", "number": 2006, "title": "[CALCITE-4015] Pass through parent collation request on subset or sup\u2026", "bodyText": "\u2026erset of join keys for EnumerableMergeJoin.\nsee: https://issues.apache.org/jira/browse/CALCITE-4015", "createdAt": "2020-06-07T09:01:36Z", "url": "https://github.com/apache/calcite/pull/2006", "merged": true, "mergeCommit": {"oid": "88d18185e6177c9df587bdd23dd4049f59adc2e4"}, "closed": true, "closedAt": "2020-09-01T08:13:37Z", "author": {"login": "amaliujia"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABco_l1kAFqTQyNTgzOTk5NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCKIUKgBqjM2ODc0MjE4MjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODM5OTk0", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-425839994", "createdAt": "2020-06-07T17:48:24Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNzo0ODoyNFrOGgK5uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNzo0ODoyNFrOGgK5uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ==", "bodyText": "I will probably add more comments to these new methods to explain what they are doing.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r436386235", "createdAt": "2020-06-07T17:48:24Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Njk4MzIy", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-426698322", "createdAt": "2020-06-08T23:54:16Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1NDoxNlrOGg0MyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzo1NDoxNlrOGg0MyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2Mjg1Ng==", "bodyText": "See RelCollations.containsOrderless, you can make the private one public is necessary.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062856", "createdAt": "2020-06-08T23:54:16Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n+    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n+    for (int i : intList) {\n+      arrayList.add(i + offset);\n+    }\n+    return arrayList;\n+  }\n+\n+  private boolean isSubset(List<Integer> a, List<Integer> b) {\n+    if (a.size() > b.size()) {\n+      return false;\n+    }\n+    Set<Integer> set = new HashSet<>(b);\n+    for (int i = 0; i < a.size(); i++) {\n+      if (!set.contains(a.get(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYyMTg0", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-426762184", "createdAt": "2020-06-09T03:21:06Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyMTowNlrOGg3bqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyMTowNlrOGg3bqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTgxOA==", "bodyText": "nice catch. in case the keys are 1,1,2,2. IMHO, we shouldn't see duplicate join keys in physical merge/hash join operators. They should be optimized away, because that means the predicate is not pushed down at all.\nlike foo.a = bar.b and foo.a=bar.c. The predicate bar.b=bar.c should be pushed down for table bar.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437115818", "createdAt": "2020-06-09T03:21:06Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYzMDk5", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-426763099", "createdAt": "2020-06-09T03:24:13Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNDoxM1rOGg3egg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNDoxM1rOGg3egg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng==", "bodyText": "why do you want to sort it?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437116546", "createdAt": "2020-06-09T03:24:13Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYzNjc0", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-426763674", "createdAt": "2020-06-09T03:26:14Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNjoxNFrOGg3gVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzoyNjoxNFrOGg3gVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ==", "bodyText": "You can use RelCollations.containsOrderless", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437117015", "createdAt": "2020-06-09T03:26:14Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDk3NTg2", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-427497586", "createdAt": "2020-06-09T20:01:41Z", "commit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowMTo0MVrOGhaJjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDowNDoxNFrOGhaOZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NDYyMA==", "bodyText": "let's use a var to store left.getRowType().getFieldCount().", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437684620", "createdAt": "2020-06-09T20:01:41Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+      // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n+      // (order not matter), also sort keys are all from right join input.\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw==", "bodyText": "can we use reqKeys.stream().allMatch()?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437685863", "createdAt": "2020-06-09T20:04:14Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386"}, "originalPosition": 86}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "995031ec5b29a425abb1f09ad5bb33c767334386", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/995031ec5b29a425abb1f09ad5bb33c767334386", "committedDate": "2020-06-07T09:00:39Z", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin."}, "afterCommit": {"oid": "5c09c3695883b67f056179caa06441100360ac5e", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/5c09c3695883b67f056179caa06441100360ac5e", "committedDate": "2020-06-10T06:28:30Z", "message": "fixup! address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTgwMjY0", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-430180264", "createdAt": "2020-06-14T01:19:04Z", "commit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwMToxOTowNFrOGjaLgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwMToyMzozM1rOGjaMIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA==", "bodyText": "Why toIntegerList?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782274", "createdAt": "2020-06-14T01:19:04Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ==", "bodyText": "It is not obvious to get the meaning from method name. An example and comment will help.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782315", "createdAt": "2020-06-14T01:20:02Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA==", "bodyText": "Do we need to keep the keys order?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782434", "createdAt": "2020-06-14T01:23:33Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTg2MjE5", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-430186219", "createdAt": "2020-06-14T04:19:53Z", "commit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwNDoxOTo1M1rOGjap8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQwNDoyNDoxOFrOGjaqnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA==", "bodyText": "How can it be true if sort keys are subset of left join keys?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790064", "createdAt": "2020-06-14T04:19:53Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDIzNg==", "bodyText": "Why not just use bitset.except to compute the diff keys?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790236", "createdAt": "2020-06-14T04:24:18Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, "originalCommit": {"oid": "fee95d236a1042baa7672bf74b764e82f8465717"}, "originalPosition": 133}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ccb5a70d591ea7b1be112bcf0c33f2da90b73654", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/ccb5a70d591ea7b1be112bcf0c33f2da90b73654", "committedDate": "2020-06-15T04:47:21Z", "message": "fixup! address comments."}, "afterCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/003479ad81f463ff120a987c349ccc6c2e9396e9", "committedDate": "2020-06-20T20:17:08Z", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMjQ2OTYx", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-470246961", "createdAt": "2020-08-19T08:42:38Z", "commit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0MjozOFrOHC9USQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0MjozOFrOHC9USQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw==", "bodyText": "I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472863817", "createdAt": "2020-08-19T08:42:38Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMjQ4Nzgw", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-470248780", "createdAt": "2020-08-19T08:44:54Z", "commit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0NDo1NFrOHC9Z3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwODo0NDo1NFrOHC9Z3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2NTI0NQ==", "bodyText": "minor: typo in 'defiend'", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472865245", "createdAt": "2020-08-19T08:44:54Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,48 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMzQ0NjI3", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-470344627", "createdAt": "2020-08-19T10:55:25Z", "commit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMDo1NToyNVrOHDCCew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMDo1NToyNVrOHDCCew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0MTE3OQ==", "bodyText": "Given that containsOrderless already does a Util.distinctList(keys), we could skip it here.\nThe same applies to collationsContainKeysOrderless", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472941179", "createdAt": "2020-08-19T10:55:25Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -227,6 +247,21 @@ public static boolean containsOrderless(List<RelCollation> collations,\n     return false;\n   }\n \n+  /**\n+   * Returns whether one of a list of collations is contained by the given list of keys\n+   * regardless the order.\n+   */\n+  public static boolean keysContainCollationsOrderless(\n+      List<Integer> keys,  List<RelCollation> collations) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNDE5Nzg1", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-470419785", "createdAt": "2020-08-19T12:46:29Z", "commit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMjo0NjoyOVrOHDFsLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMjo0NjoyOVrOHDFsLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ==", "bodyText": "I think it would be helpful to describe the general logic and all the different cases in a javadoc on passThroughTraits", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473001005", "createdAt": "2020-08-19T12:46:29Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNDcxNDMz", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-470471433", "createdAt": "2020-08-19T13:44:22Z", "commit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo0NDoyMlrOHDIFNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxMzo0NDoyMlrOHDIFNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA0MDE4Mg==", "bodyText": "Warning: the current implementation of EnumerableMergeJoin only supports keys sorted in ascending order nulls last, this will be a limitation if we ever want to actually run a plan like this one.", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473040182", "createdAt": "2020-08-19T13:44:22Z", "author": {"login": "rubenada"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -491,6 +491,81 @@ EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n ]]>\n     </Resource>\n   </TestCase>\n+    <TestCase name=\"testSortMergeJoinSubsetKey\">\n+        <Resource name=\"sql\">\n+            <![CDATA[select * from\n+        sales.emp r join sales.bonus s on r.ename=s.ename and r.job=s.job\n+        order by r.job desc nulls last]]>\n+        </Resource>\n+        <Resource name=\"planBefore\">\n+            <![CDATA[\n+LogicalSort(sort0=[$2], dir0=[DESC-nulls-last])\n+  LogicalProject(EMPNO=[$0], ENAME=[$1], JOB=[$2], MGR=[$3], HIREDATE=[$4], SAL=[$5], COMM=[$6], DEPTNO=[$7], SLACKER=[$8], ENAME0=[$9], JOB0=[$10], SAL0=[$11], COMM0=[$12])\n+    LogicalJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+      LogicalTableScan(table=[[CATALOG, SALES, EMP]])\n+      LogicalTableScan(table=[[CATALOG, SALES, BONUS]])\n+]]>\n+        </Resource>\n+        <Resource name=\"planAfter\">\n+            <![CDATA[\n+EnumerableMergeJoin(condition=[AND(=($1, $9), =($2, $10))], joinType=[inner])\n+  EnumerableSort(sort0=[$2], sort1=[$1], dir0=[DESC-nulls-last], dir1=[ASC])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/003479ad81f463ff120a987c349ccc6c2e9396e9", "committedDate": "2020-06-20T20:17:08Z", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side."}, "afterCommit": {"oid": "b3af0bb59afb080641b10455804ef65847e09800", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/b3af0bb59afb080641b10455804ef65847e09800", "committedDate": "2020-08-19T21:27:06Z", "message": "fixup! address comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjU1MTEz", "url": "https://github.com/apache/calcite/pull/2006#pullrequestreview-473255113", "createdAt": "2020-08-24T09:08:52Z", "commit": {"oid": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowODo1M1rOHFbGaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowODo1M1rOHFbGaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw==", "bodyText": "maybe we could also add some unit tests for the new method keysContainCollationsOrderless?", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475448937", "createdAt": "2020-08-24T09:08:53Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "diffHunk": "@@ -84,18 +84,36 @@\n         is(true));\n   }\n \n-  /** Unit test for {@link RelCollations#containsOrderless(List, List)}. */\n+  /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "committedDate": "2020-08-24T22:12:44Z", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e654552e9efd9423cb1c7edc74e11a7fe7a04d27", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/e654552e9efd9423cb1c7edc74e11a7fe7a04d27", "committedDate": "2020-08-24T17:25:57Z", "message": "fixup! address comments."}, "afterCommit": {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "committedDate": "2020-08-24T22:12:44Z", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3567, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}