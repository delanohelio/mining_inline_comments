{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NzY5OTgx", "number": 1896, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzoyODo0M1rODuMfIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzozMzowNVrODuPYIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzY1NjY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMzoyODo0M1rOGAD6Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjo0Nzo1MFrOGAdsbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNzIxOQ==", "bodyText": "Do we also need to prevent merging projects in RelBuilder when converting SqlNode to RelNode?\nLogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY $1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])\n  JdbcTableScan(table=[[foodmart, product]])", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402717219", "createdAt": "2020-04-03T03:28:43Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java", "diffHunk": "@@ -1439,6 +1439,14 @@ private boolean needNewSubQuery(RelNode rel, Clause[] clauses) {\n         return true;\n       }\n \n+      if (rel instanceof Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d22d59326c4a2a188cf5d852f576617b854cf71a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzOTY5NQ==", "bodyText": "Yes, but that's covered in https://issues.apache.org/jira/browse/CALCITE-3079.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403139695", "createdAt": "2020-04-03T16:47:50Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java", "diffHunk": "@@ -1439,6 +1439,14 @@ private boolean needNewSubQuery(RelNode rel, Clause[] clauses) {\n         return true;\n       }\n \n+      if (rel instanceof Project", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNzIxOQ=="}, "originalCommit": {"oid": "d22d59326c4a2a188cf5d852f576617b854cf71a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5Nzc4ODQyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNDo1NjoxNVrOGAFGUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMTowOTo0OFrOGAtvsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczNjcyMg==", "bodyText": "What about we do not have any options for OVER , there would then has no reference for underlying inputs.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402736722", "createdAt": "2020-04-03T04:56:15Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java", "diffHunk": "@@ -2749,6 +2749,28 @@ private void checkLiteral2(String expression, String expected) {\n     sql(query).ok(expected);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3876\">[CALCITE-3876]\n+   * RelToSqlConverter should not combine Projects when top Project contains\n+   * window function referencing window function from bottom Project</a>. */\n+  @Test public void testWindowOnWindowDoesNotCombineProjects() {\n+    final String query = \"SELECT ROW_NUMBER() OVER (ORDER BY rn)\\n\"\n+        + \"FROM (SELECT *,\\n\"\n+        + \"  ROW_NUMBER() OVER (ORDER BY \\\"product_id\\\") as rn\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6d62e6286d27803295959993ebe569e265cf5a5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjY3Mw==", "bodyText": "I think ROW_NUMBER must have ORDER BY in its window, and if so, this concern is moot.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402673", "createdAt": "2020-04-04T01:09:48Z", "author": {"login": "julianhyde"}, "path": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java", "diffHunk": "@@ -2749,6 +2749,28 @@ private void checkLiteral2(String expression, String expected) {\n     sql(query).ok(expected);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3876\">[CALCITE-3876]\n+   * RelToSqlConverter should not combine Projects when top Project contains\n+   * window function referencing window function from bottom Project</a>. */\n+  @Test public void testWindowOnWindowDoesNotCombineProjects() {\n+    final String query = \"SELECT ROW_NUMBER() OVER (ORDER BY rn)\\n\"\n+        + \"FROM (SELECT *,\\n\"\n+        + \"  ROW_NUMBER() OVER (ORDER BY \\\"product_id\\\") as rn\\n\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczNjcyMg=="}, "originalCommit": {"oid": "e6d62e6286d27803295959993ebe569e265cf5a5"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzgxOTUwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToxNjozMlrOGAFY1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMzo1MTo1MFrOGAuz3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw==", "bodyText": "This block seems not necessary.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402741463", "createdAt": "2020-04-03T05:16:32Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzYyNQ==", "bodyText": "It is necessary - without it, there are failures in SqlToRelConverterTest.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403403625", "createdAt": "2020-04-04T01:17:02Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMDEyNw==", "bodyText": "Yeah, you are right, it is not equivalent with the following block.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403420127", "createdAt": "2020-04-04T03:51:50Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzgyNjU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToyMDo0M1rOGAFcxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQyMDo1MjoyNlrOGBDRqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ==", "bodyText": "Is this true ? From the MS-SQL syntax, the ORDER BY has no relationship with <ROW or RANGE clause>, they can both exist separately. [1]\nhttps://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402742471", "createdAt": "2020-04-03T05:20:43Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0MTQ3MQ==", "bodyText": "How can you say '5 ROWS PRECEDING' if you don't provide an ORDER BY clause to say by which criteria they are preceding?\nIf rows/range are present and there is no ORDER BY the validator doesn't throw (maybe it should) but we treat all rows as equal.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403141471", "createdAt": "2020-04-03T16:51:06Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMDk0Ng==", "bodyText": "I checked these for MS-SQL 2017\ncreate table t(\n  a int,\n  b int\n);\n\nselect max(a) over( rows 2 PRECEDING ) from t; -- syntax error throws\nselect max(a) over( order by b rows 2 PRECEDING ) from t; -- this works\n\nselect max(a) over(ROWS between UNBOUNDED PRECEDING and CURRENT ROW) from t; -- syntax error throws\nselect max(a) over(order by b ROWS between UNBOUNDED PRECEDING and CURRENT ROW) from t; -- this works", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403420946", "createdAt": "2020-04-04T04:01:21Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTg1Mg==", "bodyText": "Show we throw for non-order by query ?", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403421852", "createdAt": "2020-04-04T04:10:10Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1NTQzMg==", "bodyText": "I have logged https://issues.apache.org/jira/browse/CALCITE-3897. We should decide whether we want to fix it.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403755432", "createdAt": "2020-04-05T20:52:26Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NzgzNTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToyNjoyOFrOGAFiOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwODo1OTo1NFrOGAwXsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw==", "bodyText": "Why this change ?", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402743867", "createdAt": "2020-04-03T05:26:28Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3NjY4NA==", "bodyText": "I have the same question. If ImmutableList.of() is bad, then we should forbid its use, and move to Collections.emptyList().", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402776684", "createdAt": "2020-04-03T07:07:47Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0MjQ5NA==", "bodyText": "See the commit comment. That parameter to scan is mutable, always has been. The implementation calls List.removeIf on it. As of guava-28.2-jre, removeIf throws even if the list is empty. So, these calls were incorrect to pass an immutable list.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403142494", "createdAt": "2020-04-03T16:52:56Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzA2Nw==", "bodyText": "@julianhyde , Collection.emptyList() supports removeIf just fine.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403197067", "createdAt": "2020-04-03T17:56:16Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjEyMQ==", "bodyText": "But it's not mutable. The contract calls to a mutable list.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402121", "createdAt": "2020-04-04T01:06:43Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0NTY4Mg==", "bodyText": "If you think the contract is to treat the list as fully mutable, then, adjust the Javadoc, and adjust the implementation so it handles the mutations of the list.\nIn other words, for now you pass an ArrayList and expect it to be mutated. However, you seem to ignore the mutated value of the ArrayList, so the new code might result in invalid data being returned.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403445682", "createdAt": "2020-04-04T08:59:54Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODA3NzI1OnYy", "diffSide": "RIGHT", "path": "site/_docs/history.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoxNTozNlrOGAHwgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjo1MzozMFrOGAd4eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDI4OA==", "bodyText": "Please remove 9, 10, 11, 12, 13 from the list. We test only LTS (8, 11) and EA (14) JDK versions.\nI'm not sure we test with Oracle JDK.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402780288", "createdAt": "2020-04-03T07:15:36Z", "author": {"login": "vlsi"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0Mjc3Nw==", "bodyText": "I test on all of those JDKs.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403142777", "createdAt": "2020-04-03T16:53:30Z", "author": {"login": "julianhyde"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDI4OA=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODA3ODM3OnYy", "diffSide": "RIGHT", "path": "site/_docs/history.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoxNjowOVrOGAHxSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwOTowNDowMlrOGAwZAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDQ4OQ==", "bodyText": "19.0 to 28.2-jre;\n\nAre you sure all the versions in-between are really tested? Where's the CI?", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402780489", "createdAt": "2020-04-03T07:16:09Z", "author": {"login": "vlsi"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;\n+Guava versions 19.0 to 28.2-jre; Apache Flink 1.10.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NTE1Ng==", "bodyText": "Not sure where 'Apache Flink' came from. There used to be 'Apache Druid', because we have a Druid adapter, and we tested against a particular version of Druid. We don't depend on any Druid maven artifacts - because we speak to Druid using REST - so the version is not apparent by simply looking at our maven dependencies.\nFlink doesn't belong on this list because we don't test against Flink. Flink tests against us.\n@danny0405 Can you comment?", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403145156", "createdAt": "2020-04-03T16:56:48Z", "author": {"login": "julianhyde"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;\n+Guava versions 19.0 to 28.2-jre; Apache Flink 1.10.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDQ4OQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNzI2Mg==", "bodyText": "I test Flink manually when upgrade Calcite for Flink and prepare for Calcite release. And i put it in the release note.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403407262", "createdAt": "2020-04-04T01:46:33Z", "author": {"login": "danny0405"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;\n+Guava versions 19.0 to 28.2-jre; Apache Flink 1.10.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDQ4OQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0NjAxOA==", "bodyText": "Calcite does not rely on Flink, so I guess we should remove Flink from the list here because it might confuse the reader.\nJDK releases do not put words like \"this JDK release was tested with Calcite 1.22\"", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403446018", "createdAt": "2020-04-04T09:04:02Z", "author": {"login": "vlsi"}, "path": "site/_docs/history.md", "diffHunk": "@@ -31,6 +31,11 @@ Downloads are available on the\n ## <a href=\"https://github.com/apache/calcite/releases/tag/calcite-1.23.0\">1.23.0</a> / under development\n {: #v1-23-0}\n \n+Compatibility: This release is tested on Linux, macOS, Microsoft Windows;\n+using Oracle JDK 8, 9, 10, 11, 12, 13, 14 and OpenJDK 8, 9, 10, 11, 12, 13, 14;\n+Guava versions 19.0 to 28.2-jre; Apache Flink 1.10.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDQ4OQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODA3OTkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoxNjo0NlrOGAHyUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNzowNzoyMFrOGAvxkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return table.scan(root, new ArrayList<>());\n          \n          \n            \n                return table.scan(root, Collections.emptyList());", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402780755", "createdAt": "2020-04-03T07:16:46Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NTcwNQ==", "bodyText": "No. We need a mutable list. Try running with -Pguava.version=28.2-jre and you will see.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403145705", "createdAt": "2020-04-03T16:57:28Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTQxOQ==", "bodyText": "Why do you think mutable list is required here?\nIt was working with ImmutableList.of(), so it means it should be perfectly fine to pass Collections.emptyList().", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403195419", "createdAt": "2020-04-03T17:54:28Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMTQyMg==", "bodyText": "The javadoc says \"the list of filters is mutable\".", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403401422", "createdAt": "2020-04-04T01:03:00Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTkyMw==", "bodyText": "javadoc does not say the implementation can add new filters to the list. So Collections.emptyList() is fine.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403435923", "createdAt": "2020-04-04T07:07:20Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, "originalCommit": {"oid": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODA5ODg2OnYy", "diffSide": "RIGHT", "path": "babel/src/test/resources/sql/redshift.iq", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoyMzowNlrOGAH-Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMTowNjoxM1rOGAttLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mzc5OQ==", "bodyText": "What does dense_rank without ORDER BY mean?\nI guess it should be an error.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402783799", "createdAt": "2020-04-03T07:23:06Z", "author": {"login": "vlsi"}, "path": "babel/src/test/resources/sql/redshift.iq", "diffHunk": "@@ -603,11 +603,11 @@ EMPNO, EXPR$1\n select dense_rank() over () from emp where deptno = 30;\n EXPR$0\n 6\n-6\n-6\n-6\n-6\n-6\n+1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NjIzNg==", "bodyText": "It is an error in Calcite (I checked), but not in Redshift.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403146236", "createdAt": "2020-04-03T16:58:02Z", "author": {"login": "julianhyde"}, "path": "babel/src/test/resources/sql/redshift.iq", "diffHunk": "@@ -603,11 +603,11 @@ EMPNO, EXPR$1\n select dense_rank() over () from emp where deptno = 30;\n EXPR$0\n 6\n-6\n-6\n-6\n-6\n-6\n+1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mzc5OQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMjcxNA==", "bodyText": "Is Redshift different from PostgreSQL?\nselect dense_rank() over() from (select * from generate_series(1,5)) y\nreturns 1,1,1,1,1;\nIt is really strange to see 1,2,3,4,5 from dense_rank()", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403202714", "createdAt": "2020-04-03T18:02:40Z", "author": {"login": "vlsi"}, "path": "babel/src/test/resources/sql/redshift.iq", "diffHunk": "@@ -603,11 +603,11 @@ EMPNO, EXPR$1\n select dense_rank() over () from emp where deptno = 30;\n EXPR$0\n 6\n-6\n-6\n-6\n-6\n-6\n+1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mzc5OQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjAyOA==", "bodyText": "I don't know. Since this is babel, the main point of the test is parsing & validation, not execution. I don't much care if the results are wrong.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402028", "createdAt": "2020-04-04T01:06:13Z", "author": {"login": "julianhyde"}, "path": "babel/src/test/resources/sql/redshift.iq", "diffHunk": "@@ -603,11 +603,11 @@ EMPNO, EXPR$1\n select dense_rank() over () from emp where deptno = 30;\n EXPR$0\n 6\n-6\n-6\n-6\n-6\n-6\n+1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mzc5OQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODEzMDI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzozMzowNVrOGAIRtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMToxMDoxMlrOGAtv5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4ODc4OQ==", "bodyText": "This is invalid because it does not verify if rows vs range is in its default value.\nFor instance,\ncount(x) over (order by x RANGE between unbounded preceding and current row) returns different values depending on RANGE vs ROW", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402788789", "createdAt": "2020-04-03T07:33:05Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "diffHunk": "@@ -246,26 +244,38 @@ public String toString() {\n     }\n \n     private String computeString() {\n-      final StringBuilder buf = new StringBuilder();\n-      buf.append(\"window(partition \");\n-      buf.append(keys);\n-      buf.append(\" order by \");\n-      buf.append(orderKeys);\n-      buf.append(isRows ? \" rows \" : \" range \");\n-      if (lowerBound != null) {\n-        if (upperBound != null) {\n-          buf.append(\"between \");\n-          buf.append(lowerBound);\n-          buf.append(\" and \");\n-          buf.append(upperBound);\n-        } else {\n-          buf.append(lowerBound);\n-        }\n-      } else if (upperBound != null) {\n+      final StringBuilder buf = new StringBuilder(\"window(\");\n+      final int i = buf.length();\n+      if (!keys.isEmpty()) {\n+        buf.append(\"partition \");\n+        buf.append(keys);\n+      }\n+      if (!orderKeys.getFieldCollations().isEmpty()) {\n+        buf.append(buf.length() == i ? \"order by \" : \" order by \");\n+        buf.append(orderKeys);\n+      }\n+      if (orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isUnbounded()\n+          && upperBound.isFollowing()) {\n+        // skip bracket if no ORDER BY, and if bracket is the default\n+      } else if (!orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isCurrentRow()) {\n+        // skip bracket if there is ORDER BY, and if bracket is the default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjcyNA==", "bodyText": "Good point. I've fixed in 75ee3ec.", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402724", "createdAt": "2020-04-04T01:10:12Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "diffHunk": "@@ -246,26 +244,38 @@ public String toString() {\n     }\n \n     private String computeString() {\n-      final StringBuilder buf = new StringBuilder();\n-      buf.append(\"window(partition \");\n-      buf.append(keys);\n-      buf.append(\" order by \");\n-      buf.append(orderKeys);\n-      buf.append(isRows ? \" rows \" : \" range \");\n-      if (lowerBound != null) {\n-        if (upperBound != null) {\n-          buf.append(\"between \");\n-          buf.append(lowerBound);\n-          buf.append(\" and \");\n-          buf.append(upperBound);\n-        } else {\n-          buf.append(lowerBound);\n-        }\n-      } else if (upperBound != null) {\n+      final StringBuilder buf = new StringBuilder(\"window(\");\n+      final int i = buf.length();\n+      if (!keys.isEmpty()) {\n+        buf.append(\"partition \");\n+        buf.append(keys);\n+      }\n+      if (!orderKeys.getFieldCollations().isEmpty()) {\n+        buf.append(buf.length() == i ? \"order by \" : \" order by \");\n+        buf.append(orderKeys);\n+      }\n+      if (orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isUnbounded()\n+          && upperBound.isFollowing()) {\n+        // skip bracket if no ORDER BY, and if bracket is the default\n+      } else if (!orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isCurrentRow()) {\n+        // skip bracket if there is ORDER BY, and if bracket is the default", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4ODc4OQ=="}, "originalCommit": {"oid": "2ece8a122ff1fcd778a5849cb3c0899776e33e53"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 238, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}