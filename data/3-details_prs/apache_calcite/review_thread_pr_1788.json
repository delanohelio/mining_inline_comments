{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxOTA5MjIz", "number": 1788, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo1ODoxNVrODoPSwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjoxMTo0N1rODoscIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTIwMTk0OnYy", "diffSide": "RIGHT", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo1ODoxNVrOF2qqRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMToxNzoyOVrOF3XxRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw==", "bodyText": "How is this different from a filter on top of Linq4j.product?\nIf it is not different, then please remove manual for-for.\nIf it is different please add a clarification comment.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392866373", "createdAt": "2020-03-16T08:58:15Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MTc0Mw==", "bodyText": "At the current state (only INNER join supported), we could have a filter on top of the product. However, we have other join types in the backlog that can / will be supported by EnumerableMergeJoin (SEMI-join, see CALCITE-3833; and ANTI-join, see  CALCITE-3834). For those join types (which do not project the right-hand-side of the join), we cannot use the strategy of applying a filter on top of the product, so I am just preparing the ground here with an homogeneous strategy that can work on other join types.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392871743", "createdAt": "2020-03-16T09:09:17Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkwOTk5OA==", "bodyText": "Implementation-wise it looks the same.\nI see no reason why do you use for-for-if here.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392909998", "createdAt": "2020-03-16T10:18:31Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxNDg3NQ==", "bodyText": "The next step will be implementing SEMI join type with Enumerable Merge Join. In order to do so, we would just a need a break inside the if (to avoid 'left' duplicates, which SEMI join must not have). So this algorithm works for INNER join and can be easily adapted for other types, like SEMI.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392914875", "createdAt": "2020-03-16T10:27:57Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1MTU5OQ==", "bodyText": "Is it different from the existing org.apache.calcite.linq4j.EnumerableDefaults#semiJoin and #antiJoin methods?\nWhy do you reimplement the same thing?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393051599", "createdAt": "2020-03-16T14:13:50Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA1ODYxMw==", "bodyText": "org.apache.calcite.linq4j.EnumerableDefaults#semiJoin and #antiJoin methods implement hashSemiJoin and hashAntiJoin, they are used by EnumerableHashJoin, the idea is to provide another alternative implementation of semiJoin/antiJoin via MergeJoin algorithm (as they exist for NestedLoopJoin, CorrelateJoin or CorrelateBatchJoin)", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393058613", "createdAt": "2020-03-16T14:20:32Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2ODg4MA==", "bodyText": "Let me rephrase it differently:\n\nYou calculate lefts and rights using merge join algorithm on equal predicates\nThen you have lefts and rights, and there's nothing from merge join left that you can do about it. The rest could be exactly the same as in hash semi-join.\n\nfor-for-if logic performs exactly the same actions as the existing semiJoin and antoJoin methods. Why duplicate code (bugs)?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393068880", "createdAt": "2020-03-16T14:31:07Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA4NTg3Nw==", "bodyText": "Ok, I think I understand your point. We should re-use existing code instead of the for-for-if. However, I don't think hashJoin code is the appropriate module here, since there is no need to create the hash structure to find matching keys (because we already have them with the merge join algorithm). Instead, we should use the nestedLoopJoin(lefts, rights, extraPredicateWithNonEquiClauses) which performs precisely this for-for-if process.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393085877", "createdAt": "2020-03-16T14:54:59Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5MzE1Nw==", "bodyText": "I don't think hashJoin code is the appropriate module here, since there is no need to create the hash structure to find matching keys\n\nWell, my point is the code seems to duplicate the existing code, so it looks like a bug.\nOf course, the only predicates left are non-equality, so there's nothing to hash.\nHowever, the key point here is to avoid code duplication.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393093157", "createdAt": "2020-03-16T15:04:55Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwNTQ0Nw==", "bodyText": "Refactored to re-use nested loop join", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393605447", "createdAt": "2020-03-17T11:17:29Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3911,9 +3936,33 @@ private boolean advance() {\n         }\n         rights.add(right);\n       }\n-      cartesians = Linq4j.product(\n-          ImmutableList.of(Linq4j.enumerator(lefts),\n-              Linq4j.enumerator(rights)));\n+\n+      if (extraPredicate == null) {\n+        cartesians = Linq4j.product(\n+            ImmutableList.of(Linq4j.enumerator(lefts),\n+                Linq4j.enumerator(rights)));\n+      } else {\n+        // we must verify the non equi-join predicate\n+        final List<List<Object>> results = new ArrayList<>();\n+        for (TSource currentLeft : lefts) {\n+          for (TInner currentRight : rights) {\n+            if (extraPredicate.apply(currentLeft, currentRight)) {\n+              final List<Object> result = new ArrayList<>(2);\n+              result.add(currentLeft);\n+              result.add(currentRight);\n+              results.add(result);\n+            }\n+          }\n+        }\n+        if (results.isEmpty()) {\n+          if (done) {\n+            return false;\n+          }\n+          return advance();\n+        } else {\n+          cartesians = Linq4j.enumerator(results);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NjM3Mw=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTIwNTUwOnYy", "diffSide": "RIGHT", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODo1OToyMVrOF2qsfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMTozNzoxMVrOF4BEng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Njk0MQ==", "bodyText": "Please add the relevant documentation that clarifies why this extraPredicate is needed and how it is different from a predicate on top of join results.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392866941", "createdAt": "2020-03-16T08:59:21Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental\n+  public static <TSource, TInner, TKey extends Comparable<TKey>, TResult> Enumerable<TResult>\n+      mergeJoin(final Enumerable<TSource> outer,\n+      final Enumerable<TInner> inner,\n+      final Function1<TSource, TKey> outerKeySelector,\n+      final Function1<TInner, TKey> innerKeySelector,\n+      final Predicate2<TSource, TInner> extraPredicate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NTAxMg==", "bodyText": "You're right, I'll document that we use a predicate rather that a filter on top of join results in order to support other join types in the (near) future.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392875012", "createdAt": "2020-03-16T09:15:18Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental\n+  public static <TSource, TInner, TKey extends Comparable<TKey>, TResult> Enumerable<TResult>\n+      mergeJoin(final Enumerable<TSource> outer,\n+      final Enumerable<TInner> inner,\n+      final Function1<TSource, TKey> outerKeySelector,\n+      final Function1<TInner, TKey> innerKeySelector,\n+      final Predicate2<TSource, TInner> extraPredicate,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Njk0MQ=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwNTYxMQ==", "bodyText": "documentation updated", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393605611", "createdAt": "2020-03-17T11:17:53Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental\n+  public static <TSource, TInner, TKey extends Comparable<TKey>, TResult> Enumerable<TResult>\n+      mergeJoin(final Enumerable<TSource> outer,\n+      final Enumerable<TInner> inner,\n+      final Function1<TSource, TKey> outerKeySelector,\n+      final Function1<TInner, TKey> innerKeySelector,\n+      final Predicate2<TSource, TInner> extraPredicate,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Njk0MQ=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI2NTMyNw==", "bodyText": "Thanks. However, can you please add @param extraPredicate that would clarify the meaning of extraPredicate in a couple of words?\nThe documentation does not need to clarfy all the implementation details, however, the naming of Predicate2<TSource, TInner> extraPredicate provides absolutely no clue one meaning of the predicate.\nWell, I do see it is a predicate. I can judge that by class name. As a user of that API I want to know what is expected to be passed there. I want to know if nulls are allowed or not and so on.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r394265327", "createdAt": "2020-03-18T11:04:48Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental\n+  public static <TSource, TInner, TKey extends Comparable<TKey>, TResult> Enumerable<TResult>\n+      mergeJoin(final Enumerable<TSource> outer,\n+      final Enumerable<TInner> inner,\n+      final Function1<TSource, TKey> outerKeySelector,\n+      final Function1<TInner, TKey> innerKeySelector,\n+      final Predicate2<TSource, TInner> extraPredicate,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Njk0MQ=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MjE0Mg==", "bodyText": "javadoc updated: added @param extraPredicate", "url": "https://github.com/apache/calcite/pull/1788#discussion_r394282142", "createdAt": "2020-03-18T11:37:11Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental\n+  public static <TSource, TInner, TKey extends Comparable<TKey>, TResult> Enumerable<TResult>\n+      mergeJoin(final Enumerable<TSource> outer,\n+      final Enumerable<TInner> inner,\n+      final Function1<TSource, TKey> outerKeySelector,\n+      final Function1<TInner, TKey> innerKeySelector,\n+      final Predicate2<TSource, TInner> extraPredicate,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2Njk0MQ=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTIyMTE0OnYy", "diffSide": "RIGHT", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTowNDozMVrOF2q2Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMToxNzo0MFrOF3XxjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2OTQ3MA==", "bodyText": "I would suggest @API(...)", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392869470", "createdAt": "2020-03-16T09:04:31Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY5NQ==", "bodyText": "Ok, I'll change it.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392881695", "createdAt": "2020-03-16T09:27:24Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2OTQ3MA=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxMjIzNg==", "bodyText": "Unfortunately, when I try to import org.apiguardian.api.API; and use  @API(since = \"1.23\", status = API.Status.EXPERIMENTAL) in EnumerableDefaults (which belongs to linq4j), I get a compilation error. Is it possible to use that library there? Do I need to change gradle config files to do so?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r392912236", "createdAt": "2020-03-16T10:22:51Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2OTQ3MA=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA2NTQ3MA==", "bodyText": "It comes from apiguardian, so you need to add the relevant dependency to linq4j: \n  \n    \n      calcite/core/build.gradle.kts\n    \n    \n         Line 44\n      in\n      d234626\n    \n    \n    \n    \n\n        \n          \n           api(\"org.apiguardian:apiguardian-api\")", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393065470", "createdAt": "2020-03-16T14:26:43Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2OTQ3MA=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYwNTUxNg==", "bodyText": "added apiguardian", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393605516", "createdAt": "2020-03-17T11:17:40Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -1971,6 +1972,26 @@ private void closeInner() {\n       final Function2<TSource, TInner, TResult> resultSelector,\n       boolean generateNullsOnLeft,\n       boolean generateNullsOnRight) {\n+    return mergeJoin(outer, inner, outerKeySelector, innerKeySelector, null,\n+        resultSelector, generateNullsOnLeft, generateNullsOnRight);\n+  }\n+\n+  /**\n+   * Joins two inputs that are sorted on the key, with an extra predicate for non equi-join\n+   * conditions (in case of equi-join, it will be null).\n+   * Inputs must sorted in ascending order, nulls last.\n+   * NOTE: The current API is experimental and subject to change without notice.\n+   */\n+  @Experimental", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2OTQ3MA=="}, "originalCommit": {"oid": "88edc40afd6dc8716a1b40d78d0a3890bb7fcfa2"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTk3MDk5OnYy", "diffSide": "RIGHT", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjowOTo1NFrOF3Zbdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjo0NzowM1rOF3apjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMjYzMA==", "bodyText": "What is the purpose of Arrays.asList and .clone() here?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393632630", "createdAt": "2020-03-17T12:09:54Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {\n+      super(ImmutableList.of(outer, inner));\n+      this.resultSelector = resultSelector;\n+    }\n+\n+    @Override public TResult current() {\n+      final List<Object> list = Arrays.asList(elements.clone());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNjQ5OA==", "bodyText": "Transforming elements array into list. Just applying the same approach as Linq4j#CartesianProductListEnumerator", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393636498", "createdAt": "2020-03-17T12:17:35Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {\n+      super(ImmutableList.of(outer, inner));\n+      this.resultSelector = resultSelector;\n+    }\n+\n+    @Override public TResult current() {\n+      final List<Object> list = Arrays.asList(elements.clone());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMjYzMA=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzOTQ2OA==", "bodyText": "Note: list never escapes this method, so there's no need to copy it.\nThere's no need to create list as well.", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393639468", "createdAt": "2020-03-17T12:23:14Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {\n+      super(ImmutableList.of(outer, inner));\n+      this.resultSelector = resultSelector;\n+    }\n+\n+    @Override public TResult current() {\n+      final List<Object> list = Arrays.asList(elements.clone());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMjYzMA=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0MDcyMQ==", "bodyText": "you're right, I'll change it", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393640721", "createdAt": "2020-03-17T12:25:38Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {\n+      super(ImmutableList.of(outer, inner));\n+      this.resultSelector = resultSelector;\n+    }\n+\n+    @Override public TResult current() {\n+      final List<Object> list = Arrays.asList(elements.clone());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMjYzMA=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY1MjYyMg==", "bodyText": "modified: list no longer generated", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393652622", "createdAt": "2020-03-17T12:47:03Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {\n+      super(ImmutableList.of(outer, inner));\n+      this.resultSelector = resultSelector;\n+    }\n+\n+    @Override public TResult current() {\n+      final List<Object> list = Arrays.asList(elements.clone());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMjYzMA=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTk3NzI4OnYy", "diffSide": "RIGHT", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjoxMTo0OFrOF3ZfSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjo0NjozMFrOF3aoUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMzYxMQ==", "bodyText": "Should it be typed like Enumerator<TOuter>?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393633611", "createdAt": "2020-03-17T12:11:48Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNzI5MQ==", "bodyText": "Not possible if we want to extend CartesianProductEnumerator:\n/**\n * Enumerator over the cartesian product of enumerators.\n * @param <T> Input element type\n * @param <E> Element type\n */\npublic abstract class CartesianProductEnumerator<T, E> implements Enumerator<E> {...}", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393637291", "createdAt": "2020-03-17T12:19:09Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMzYxMQ=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzODkxMA==", "bodyText": "Well, can you cast when calling the super constructor?", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393638910", "createdAt": "2020-03-17T12:22:04Z", "author": {"login": "vlsi"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMzYxMQ=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY1MjMwNg==", "bodyText": "Modified: cast in constructor", "url": "https://github.com/apache/calcite/pull/1788#discussion_r393652306", "createdAt": "2020-03-17T12:46:30Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -3951,6 +3982,24 @@ public void close() {\n     }\n   }\n \n+  private static class CartesianProductJoinEnumerator<TResult, TOuter, TInner>\n+      extends CartesianProductEnumerator<Object, TResult> {\n+    private final Function2<TOuter, TInner, TResult> resultSelector;\n+\n+    CartesianProductJoinEnumerator(Function2<TOuter, TInner, TResult> resultSelector,\n+                                   Enumerator<Object> outer, Enumerator<Object> inner) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzMzYxMQ=="}, "originalCommit": {"oid": "10caf1edfdb95d5887d6ab61e7e6a1f82342bb24"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 282, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}