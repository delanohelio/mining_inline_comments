{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTc5MzM2", "number": 1761, "title": "[CALCITE-3737][CALCITE-3780] Implement HOP and SESSION table functions", "bodyText": "see:\nhttps://issues.apache.org/jira/browse/CALCITE-3737\nhttps://issues.apache.org/jira/browse/CALCITE-3780\nSome highlights on this PR:\n\nsupport HOP as a table function.\nsupport SESSION as a table function.\nrename \"table-valued function\" to \"table function\" to improve naming.", "createdAt": "2020-01-15T06:34:16Z", "url": "https://github.com/apache/calcite/pull/1761", "merged": true, "mergeCommit": {"oid": "890eb61efcccc486e2192110cefe4cac5aa6f150"}, "closed": true, "closedAt": "2020-05-09T12:23:48Z", "author": {"login": "amaliujia"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6hKPDgFqTM0MzA0NjUyNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcef71EgFqTQwNjI4MTEzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDQ2NTI2", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-343046526", "createdAt": "2020-01-15T08:20:35Z", "commit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDozNVrOFdwKOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyMDozNVrOFdwKOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw==", "bodyText": "extra line?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366742073", "createdAt": "2020-01-15T08:20:35Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -20,17 +20,16 @@\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n-import org.apache.calcite.sql.type.SqlOperandCountRanges;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n import org.apache.calcite.sql.type.SqlTypeName;\n-import org.apache.calcite.sql.type.SqlTypeUtil;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.calcite.util.Static.RESOURCE;\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDUwNDk3", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-343050497", "createdAt": "2020-01-15T08:28:54Z", "commit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyODo1NFrOFdwWOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODoyODo1NFrOFdwWOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NTE0NA==", "bodyText": "Why we remove these methods? Each window table function has its own implementation?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366745144", "createdAt": "2020-01-15T08:28:54Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -44,28 +43,21 @@ public SqlWindowTableFunction(String name) {\n         SqlFunctionCategory.SYSTEM);\n   }\n \n-  @Override public SqlOperandCountRange getOperandCountRange() {\n-    return SqlOperandCountRanges.of(3);\n-  }\n-\n-  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNDkyOTA1", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-343492905", "createdAt": "2020-01-15T20:15:37Z", "commit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxNTozN1rOFeFGzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoxNTozN1rOFeFGzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTI2MQ==", "bodyText": "extra line", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367085261", "createdAt": "2020-01-15T20:15:37Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTc4Mjk2", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-343578296", "createdAt": "2020-01-15T22:56:26Z", "commit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo1NjoyN1rOFeJH9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo1NjoyN1rOFeJH9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MTA5Mg==", "bodyText": "will fix bases as a typo.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367151092", "createdAt": "2020-01-15T22:56:27Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -744,9 +748,9 @@ static Expression generatePredicate(\n     return Expressions.lambda(Predicate2.class, builder.toBlock(), left_, right_);\n   }\n \n-  /** Generates a window selector which appends attribute of the window based on\n+  /** Generates a window selector which appends attribute of the window bases on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MzI0OTU4", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-344324958", "createdAt": "2020-01-17T01:52:06Z", "commit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1MjowN1rOFes2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMTo1NzowOFrOFes57Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjQxNQ==", "bodyText": "Here we can use Math.toIntExact.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367736415", "createdAt": "2020-01-17T01:52:07Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+\n+    }\n+\n+    public boolean moveNext() {\n+      if (list.size() > 0) {\n+        return true;\n+      }\n+      return inputEnumerator.moveNext();\n+    }\n+\n+    public void reset() {\n+      inputEnumerator.reset();\n+      list.clear();\n+    }\n+\n+    public void close() {\n+    }\n+\n+    private Object[] takeOne() {\n+      return list.pollFirst();\n+    }\n+  }\n+\n+  private static List<Pair> hopWindows(long tsMillis, long periodMillis, long sizeMillis) {\n+    ArrayList<Pair> ret = new ArrayList<>((int) (sizeMillis / periodMillis));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNzMyNQ==", "bodyText": "809L-811L The indentation format seems a bit problematic.\nThere are several more functions with indentation format below.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367737325", "createdAt": "2020-01-17T01:57:08Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698"}, "originalPosition": 40}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "865bc1a9e74e41f3f6fe50f8dbb40bc2e8cc3a90", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/865bc1a9e74e41f3f6fe50f8dbb40bc2e8cc3a90", "committedDate": "2020-01-22T20:55:50Z", "message": "fixup! fix HOP signature message"}, "afterCommit": {"oid": "7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "committedDate": "2020-01-23T21:39:21Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "committedDate": "2020-01-23T21:39:21Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}, "afterCommit": {"oid": "a3510f94f9a72b58895e8bcddd101a8d4487f74e", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a3510f94f9a72b58895e8bcddd101a8d4487f74e", "committedDate": "2020-01-23T21:51:22Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3510f94f9a72b58895e8bcddd101a8d4487f74e", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a3510f94f9a72b58895e8bcddd101a8d4487f74e", "committedDate": "2020-01-23T21:51:22Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}, "afterCommit": {"oid": "949ab21f76773211c25a84f9dc8fb16807c4d1f5", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/949ab21f76773211c25a84f9dc8fb16807c4d1f5", "committedDate": "2020-01-23T22:35:31Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "949ab21f76773211c25a84f9dc8fb16807c4d1f5", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/949ab21f76773211c25a84f9dc8fb16807c4d1f5", "committedDate": "2020-01-23T22:35:31Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}, "afterCommit": {"oid": "e446488a1865bbeeededce9a8c0923e6fd3597fb", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/e446488a1865bbeeededce9a8c0923e6fd3597fb", "committedDate": "2020-02-02T06:52:20Z", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1176a1856e7d0223636b11ea9b673c32b3e8823", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/b1176a1856e7d0223636b11ea9b673c32b3e8823", "committedDate": "2020-02-09T06:35:35Z", "message": "[CALCITE-3780] SESSION table-valued function (Rui Wang)"}, "afterCommit": {"oid": "4b70c23fc071064d0a3f51b4c6d825acfede8774", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/4b70c23fc071064d0a3f51b4c6d825acfede8774", "committedDate": "2020-02-12T21:59:22Z", "message": "fixup! fix reference.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTYxNTkx", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-376561591", "createdAt": "2020-03-18T04:45:49Z", "commit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NTo0OVrOF32OOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NTo0OVrOF32OOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDM3OA==", "bodyText": "Just of curious, is the \"TVF\" a commonly-used abbreviation?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104378", "createdAt": "2020-03-18T04:45:49Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2273,8 +2275,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTYxOTE5", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-376561919", "createdAt": "2020-03-18T04:47:10Z", "commit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NzoxMFrOF32PTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0NzoxMFrOF32PTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw==", "bodyText": "Why we need to change the function name here?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104653", "createdAt": "2020-03-18T04:47:10Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2312,7 +2320,7 @@ public void unparse(\n \n   /** The {@code HOP} group function. */\n   public static final SqlGroupedWindowFunction HOP =\n-      new SqlGroupedWindowFunction(SqlKind.HOP.name(), SqlKind.HOP, null,\n+      new SqlGroupedWindowFunction(\"$HOP\", SqlKind.HOP, null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTYyNDM2", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-376562436", "createdAt": "2020-03-18T04:49:14Z", "commit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0OToxNFrOF32RBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNDo0OToxNFrOF32RBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA==", "bodyText": "Any special reasons to implement tumbling and hopping&sessionize in different places?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394105094", "createdAt": "2020-03-18T04:49:14Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTY1NzQ1", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-376565745", "createdAt": "2020-03-18T05:01:40Z", "commit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNTowMTo0MFrOF32bkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNTowMTo0MFrOF32bkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNzc5Mg==", "bodyText": "Some comments:\n\nIs it necessary to deprecate the manner of using them as grouped window function?\nUpdate \"Table-valued functions.\" to \"Table functions\".\nCould you add doc the streaming page? I think we can do this work in this PR or after finishing the umbrella JIRA.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394107792", "createdAt": "2020-03-18T05:01:40Z", "author": {"login": "DonnyZone"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1871,14 +1872,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n \n Here is an example:\n `SELECT * FROM TABLE(TUMBLE(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '1' MINUTE))`,\n will apply tumbling with 1 minute window size on rows from table orders. rowtime is the\n watermarked column of table orders that tells data completeness.\n \n+#### HOP\n+In streaming queries, HOP assigns windows that cover rows within the interval of *size*, shifting every *slide*, \n+and optionally aligned at *time* based on a timestamp column. Windows assigned could have overlapping so hopping \n+sometime is named as \"sliding windowing\".  \n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| HOP(table, DESCRIPTOR(datetime), slide, size, [, time ]) | Indicates a hopping window for *datetime*, covering rows within the interval of *size*, shifting every *slide*, and optionally aligned at *time*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(HOP(TABLE orders, DESCRIPTOR(rowtime), INTERVAL '2' MINUTE, INTERVAL '5' MINUTE))`,\n+will apply hopping with 5-minute interval size on rows from table orders, shifting every 2 minutes. rowtime is the\n+watermarked column of table orders that tells data completeness.\n+\n+#### SESSION\n+In streaming queries, SESSION assigns windows that cover rows based on *datetime*. Within a session window, distances \n+of rows are less than *interval*. Session window is applied per *key*.\n+\n+\n+| Operator syntax      | Description\n+|:-------------------- |:-----------\n+| session(table, DESCRIPTOR(datetime), DESCRIPTOR(key), interval [, time ]) | Indicates a session window of *interval* for *datetime*, optionally aligned at *time*. Session window is applied per *key*.\n+\n+Here is an example:\n+`SELECT * FROM TABLE(SESSION(TABLE orders, DESCRIPTOR(rowtime), DESCRIPTOR(product), INTERVAL '20' MINUTE))`,\n+will apply session with 20-minute inactive gap on rows from table orders. rowtime is the\n+watermarked column of table orders that tells data completeness. Session is applied per product.\n+\n ### Grouped window functions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0929d9ef379ef5da0d566fc28326f2e44e57ae02", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/0929d9ef379ef5da0d566fc28326f2e44e57ae02", "committedDate": "2020-03-24T20:06:53Z", "message": "fixup! address comments"}, "afterCommit": {"oid": "a94446e35592b69b3eee805919257f6072099e85", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a94446e35592b69b3eee805919257f6072099e85", "committedDate": "2020-04-07T22:12:47Z", "message": "fixup! address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxOTg4NDkz", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-391988493", "createdAt": "2020-04-13T06:56:02Z", "commit": {"oid": "a94446e35592b69b3eee805919257f6072099e85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo1NjowMlrOGEee6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo1NjowMlrOGEee6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0NjkyMw==", "bodyText": "nitpicking: indent", "url": "https://github.com/apache/calcite/pull/1761#discussion_r407346923", "createdAt": "2020-04-13T06:56:02Z", "author": {"login": "DonnyZone"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+                                             boolean throwOnFailure) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a94446e35592b69b3eee805919257f6072099e85"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a94446e35592b69b3eee805919257f6072099e85", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/a94446e35592b69b3eee805919257f6072099e85", "committedDate": "2020-04-07T22:12:47Z", "message": "fixup! address comments"}, "afterCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/14a165a47cb329720c1cbf649b976573ab1b11b1", "committedDate": "2020-04-13T20:51:21Z", "message": "[CALCITE-3780] SESSION table-valued function (Rui Wang)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODc2NzAy", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-395876702", "createdAt": "2020-04-18T03:22:35Z", "commit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzoyMjozNVrOGHkM8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMzozMTo0OVrOGHkb0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjM1Mw==", "bodyText": "Give doc for these parameters. Same for other codes.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586353", "createdAt": "2020-04-18T03:22:35Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjUwMA==", "bodyText": "Create -> Creates, same for other codes.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586500", "createdAt": "2020-04-18T03:22:52Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw==", "bodyText": "Is this true ? Shouldn't we rely on the watermark and gap to decide if a session is expired ? What about the late arrive data ?\nThis implementation should not be blocking.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410587273", "createdAt": "2020-04-18T03:24:37Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA==", "bodyText": "indexOfWatermarkedColumn  -> wmIndex ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588000", "createdAt": "2020-04-18T03:26:28Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {\n+        elements.add(inputEnumerator.current());\n+      }\n+\n+      Map<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> sessionKeyMap = new HashMap<>();\n+      for (Object[] element : elements) {\n+        sessionKeyMap.putIfAbsent(element[indexOfKeyColumn], new SortedMultiMap<>());\n+        Pair initWindow = computeInitWindow(\n+            SqlFunctions.toLong(element[indexOfWatermarkedColumn]), gap);\n+        sessionKeyMap.get(element[indexOfKeyColumn]).putMulti(initWindow, element);\n+      }\n+\n+      // merge per key session windows if there is any overlap between windows.\n+      for (Map.Entry<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> perKeyEntry\n+          : sessionKeyMap.entrySet()) {\n+        Map<Pair<Long, Long>, List<Object[]>> finalWindowElementsMap = new HashMap<>();\n+        Pair<Long, Long> currentWindow = null;\n+        List<Object[]> tempElementList = new ArrayList<>();\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> sessionEntry\n+            : perKeyEntry.getValue().entrySet()) {\n+          // check the next window can be merged.\n+          if (currentWindow == null || !isOverlapped(currentWindow, sessionEntry.getKey())) {\n+            // cannot merge window as there is no overlap\n+            if (currentWindow != null) {\n+              finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+            }\n+\n+            currentWindow = sessionEntry.getKey();\n+            tempElementList.clear();\n+            tempElementList.addAll(sessionEntry.getValue());\n+          } else {\n+            // merge windows.\n+            currentWindow = mergeWindows(currentWindow, sessionEntry.getKey());\n+            // merge elements in windows.\n+            tempElementList.addAll(sessionEntry.getValue());\n+          }\n+        }\n+\n+        if (!tempElementList.isEmpty()) {\n+          finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+        }\n+\n+        // construct final results from finalWindowElementsMap.\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> finalWindowElementsEntry\n+            : finalWindowElementsMap.entrySet()) {\n+          for (Object[] element : finalWindowElementsEntry.getValue()) {\n+            Object[] curWithWindow = new Object[element.length + 2];\n+            System.arraycopy(element, 0, curWithWindow, 0, element.length);\n+            curWithWindow[element.length] = finalWindowElementsEntry.getKey().left;\n+            curWithWindow[element.length + 1] = finalWindowElementsEntry.getKey().right;\n+            list.offer(curWithWindow);\n+          }\n+        }\n+      }\n+    }\n+\n+    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return !(b.left >= a.right);\n+    }\n+\n+    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);\n+    }\n+\n+    private Pair<Long, Long> computeInitWindow(long ts, long gap) {\n+      return new Pair<>(ts, ts + gap);\n+    }\n+  }\n+\n+  /**\n+   * Create enumerable implementation that applies hopping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hopping(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODMyMg==", "bodyText": "Also remove the values keyword from the commit message.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588322", "createdAt": "2020-04-18T03:27:23Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -966,8 +970,8 @@ public MatchImplementor get(final SqlMatchFunction function) {\n     }\n   }\n \n-  public TableValuedFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n-    final Supplier<? extends TableValuedFunctionCallImplementor> supplier =\n+  public TableFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n+    final Supplier<? extends TableFunctionCallImplementor> supplier =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODg3MQ==", "bodyText": "Give these intervalExpression  more meaningful name. e.g. windowSize and slidingInterval ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588871", "createdAt": "2020-04-18T03:28:29Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -3143,11 +3147,62 @@ private Expression normalize(SqlTypeName typeName, Expression e) {\n       return Expressions.call(\n           BuiltInMethod.TUMBLING.method,\n           inputEnumerable,\n-          EnumUtils.windowSelector(\n+          EnumUtils.tumblingWindowSelector(\n               inputPhysType,\n               outputPhysType,\n               translatedOperands.get(0),\n               translatedOperands.get(1)));\n     }\n   }\n+\n+  /** Implements hopping. */\n+  private static class HopImplementor implements TableFunctionCallImplementor {\n+    @Override public Expression implement(RexToLixTranslator translator,\n+        Expression inputEnumerable, RexCall call, PhysType inputPhysType, PhysType outputPhysType) {\n+      Expression intervalExpression = translator.translate(call.getOperands().get(2));\n+      Expression intervalExpression2 = translator.translate(call.getOperands().get(3));\n+      RexCall descriptor = (RexCall) call.getOperands().get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw==", "bodyText": "What does the TVF mean ? How about just name it HOP_FUN", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589373", "createdAt": "2020-04-18T03:29:41Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTU4MA==", "bodyText": "Also add tests for SESSION and HOP.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589580", "createdAt": "2020-04-18T03:30:19Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java", "diffHunk": "@@ -1778,15 +1778,16 @@ public final Sql sql(String sql) {\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumble() {\n+\n+  @Test public void testTableFunctionTumble() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble(table Shipments, descriptor(rowtime), INTERVAL '1' MINUTE))\";\n     sql(sql).ok();\n   }\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumbleWithSubQueryParam() {\n+  @Test public void testTableFunctionTumbleWithSubQueryParam() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble((select * from Shipments), descriptor(rowtime), INTERVAL '1' MINUTE))\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5MDE2MQ==", "bodyText": "Do we really support [, time ] ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410590161", "createdAt": "2020-04-18T03:31:49Z", "author": {"login": "danny0405"}, "path": "site/_docs/reference.md", "diffHunk": "@@ -1875,14 +1876,44 @@ is named as \"fixed windowing\".\n \n | Operator syntax      | Description\n |:-------------------- |:-----------\n-| TUMBLE(table, DESCRIPTOR(column_name), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*. Tumbling is applied on table in which there is a watermarked column specified by descriptor.\n+| TUMBLE(table, DESCRIPTOR(datetime), interval [, time ]) | Indicates a tumbling window of *interval* for *datetime*, optionally aligned at *time*.\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d4966f90f64a6b37a108cfdee8d036763ba788e7", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/d4966f90f64a6b37a108cfdee8d036763ba788e7", "committedDate": "2020-04-20T05:30:39Z", "message": "fixup! address comments!"}, "afterCommit": {"oid": "c92f9f544271c0a0cf27f1206d7e1595daefe68f", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/c92f9f544271c0a0cf27f1206d7e1595daefe68f", "committedDate": "2020-04-20T05:32:02Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c92f9f544271c0a0cf27f1206d7e1595daefe68f", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/c92f9f544271c0a0cf27f1206d7e1595daefe68f", "committedDate": "2020-04-20T05:32:02Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}, "afterCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/2283f49381cfb958a1b36e475887aa1f0198ec28", "committedDate": "2020-04-20T18:48:05Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTkwMzMw", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-396990330", "createdAt": "2020-04-21T05:08:34Z", "commit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTowODozNFrOGIyuXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTowODozNFrOGIyuXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Mjg2MA==", "bodyText": "We can combine these\nargs = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n        }\nUse another variable to keep the operator and move the common parse logic to the java code block.", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411872860", "createdAt": "2020-04-21T05:08:34Z", "author": {"login": "danny0405"}, "path": "core/src/main/codegen/templates/Parser.jj", "diffHunk": "@@ -6065,10 +6065,22 @@ SqlCall GroupByWindowingCall():\n     final List<SqlNode> args;\n }\n {\n-    <TUMBLE> { s = span(); }\n-    args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n-        return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n-    }\n+    (\n+        <TUMBLE> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.TUMBLE.createCall(s.end(this), args);\n+        }\n+    |\n+        <HOP> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.HOP.createCall(s.end(this), args);\n+        }\n+    |\n+        <SESSION> { s = span(); }\n+        args = UnquantifiedFunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {\n+            return SqlStdOperatorTable.SESSION.createCall(s.end(this), args);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MDA0MTAz", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-397004103", "createdAt": "2020-04-21T05:48:46Z", "commit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTo0ODo0NlrOGIznlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwNTo0ODo0NlrOGIznlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA==", "bodyText": "Why we must have 2 DESCRIPTOR here ?", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411887508", "createdAt": "2020-04-21T05:48:46Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/2283f49381cfb958a1b36e475887aa1f0198ec28", "committedDate": "2020-04-20T18:48:05Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}, "afterCommit": {"oid": "3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "committedDate": "2020-04-22T20:14:15Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "committedDate": "2020-04-22T20:14:15Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}, "afterCommit": {"oid": "aba2e4fded2e3164b012b25f7e272945ace25b41", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/aba2e4fded2e3164b012b25f7e272945ace25b41", "committedDate": "2020-04-27T01:45:43Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea320ed3bf1ddc59d1dbd5473b6f9812d3734098", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/ea320ed3bf1ddc59d1dbd5473b6f9812d3734098", "committedDate": "2020-04-27T01:59:41Z", "message": "[CALCITE-3737] HOP Table Function (Rui Wang)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf089edf925b13db01bf08c5c928e1727928f676", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/cf089edf925b13db01bf08c5c928e1727928f676", "committedDate": "2020-04-27T01:59:42Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aba2e4fded2e3164b012b25f7e272945ace25b41", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/aba2e4fded2e3164b012b25f7e272945ace25b41", "committedDate": "2020-04-27T01:45:43Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}, "afterCommit": {"oid": "cf089edf925b13db01bf08c5c928e1727928f676", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/cf089edf925b13db01bf08c5c928e1727928f676", "committedDate": "2020-04-27T01:59:42Z", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MjgxMTM5", "url": "https://github.com/apache/calcite/pull/1761#pullrequestreview-406281139", "createdAt": "2020-05-06T03:16:13Z", "commit": {"oid": "cf089edf925b13db01bf08c5c928e1727928f676"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4185, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}