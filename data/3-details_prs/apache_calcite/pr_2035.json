{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NjgyNzA0", "number": 2035, "title": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregat\u2026", "bodyText": "\u2026e (Rui Wang).\nSee: https://jira.apache.org/jira/browse/CALCITE-4008", "createdAt": "2020-06-18T18:11:00Z", "url": "https://github.com/apache/calcite/pull/2035", "merged": true, "mergeCommit": {"oid": "bf9ff001db743bcba35943daf7fec5fe8b8b207e"}, "closed": true, "closedAt": "2020-06-29T08:36:01Z", "author": {"login": "amaliujia"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsioQ1AFqTQzMzUzNTc3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcv8CDQABqjM0OTE2NjE4Nzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTM1Nzc3", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-433535777", "createdAt": "2020-06-18T18:19:29Z", "commit": {"oid": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOToyOVrOGl6-cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOToyOVrOGl6-cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjc1Mg==", "bodyText": "I will need to double check and probably revise this part to make KeySelector match with KeyComparator.", "url": "https://github.com/apache/calcite/pull/2035#discussion_r442416752", "createdAt": "2020-06-18T18:19:29Z", "author": {"login": "amaliujia"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java", "diffHunk": "@@ -90,6 +101,133 @@ public EnumerableSortedAggregate(\n   }\n \n   public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n-    throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    if (getGroupType() != Group.SIMPLE\n+        || aggCalls.isEmpty()) {\n+      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    }\n+\n+    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    Expression childExp =\n+        builder.append(\n+            \"child\",\n+            result.block);\n+\n+    final PhysType physType =\n+        PhysTypeImpl.of(\n+            typeFactory, getRowType(), pref.preferCustom());\n+\n+    final PhysType inputPhysType = result.physType;\n+\n+    ParameterExpression parameter =\n+        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n+\n+    final PhysType keyPhysType =\n+        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n+            JavaRowFormat.LIST);\n+    final int groupCount = getGroupCount();\n+\n+    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n+    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n+      aggs.add(new AggImpState(call.i, call.e, false));\n+    }\n+\n+    // Function0<Object[]> accumulatorInitializer =\n+    //     new Function0<Object[]>() {\n+    //         public Object[] apply() {\n+    //             return new Object[] {0, 0};\n+    //         }\n+    //     };\n+    final List<Expression> initExpressions = new ArrayList<>();\n+    final BlockBuilder initBlock = new BlockBuilder();\n+\n+    final List<Type> aggStateTypes = createAggStateTypes(\n+        initExpressions, initBlock, aggs, typeFactory);\n+\n+    final PhysType accPhysType =\n+        PhysTypeImpl.of(typeFactory,\n+            typeFactory.createSyntheticType(aggStateTypes));\n+\n+    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n+\n+    final Expression accumulatorInitializer =\n+        builder.append(\"accumulatorInitializer\",\n+            Expressions.lambda(\n+                Function0.class,\n+                initBlock.toBlock()));\n+\n+    // Function2<Object[], Employee, Object[]> accumulatorAdder =\n+    //     new Function2<Object[], Employee, Object[]>() {\n+    //         public Object[] apply(Object[] acc, Employee in) {\n+    //              acc[0] = ((Integer) acc[0]) + 1;\n+    //              acc[1] = ((Integer) acc[1]) + in.salary;\n+    //             return acc;\n+    //         }\n+    //     };\n+    final ParameterExpression inParameter =\n+        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n+    final ParameterExpression acc_ =\n+        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n+\n+    createAccumulatorAdders(\n+        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n+\n+    final ParameterExpression lambdaFactory =\n+        Expressions.parameter(AggregateLambdaFactory.class,\n+            builder.newName(\"lambdaFactory\"));\n+\n+    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n+        false, lambdaFactory);\n+\n+    final BlockBuilder resultBlock = new BlockBuilder();\n+    final List<Expression> results = Expressions.list();\n+    final ParameterExpression key_;\n+    final Type keyType = keyPhysType.getJavaRowType();\n+    key_ = Expressions.parameter(keyType, \"key\");\n+    for (int j = 0; j < groupCount; j++) {\n+      final Expression ref = keyPhysType.fieldReference(key_, j);\n+      results.add(ref);\n+    }\n+\n+    for (final AggImpState agg : aggs) {\n+      results.add(\n+          agg.implementor.implementResult(agg.context,\n+              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n+                  keyPhysType)));\n+    }\n+    resultBlock.add(physType.record(results));\n+\n+    final Expression keySelector_ =\n+        builder.append(\"keySelector\",\n+            inputPhysType.generateSelector(parameter,\n+                groupSet.asList(),\n+                keyPhysType.getFormat()));\n+    // Generate the appropriate key Comparator.\n+    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTM2MzAw", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-433536300", "createdAt": "2020-06-18T18:20:14Z", "commit": {"oid": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMDoxNFrOGl6_9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoyMDoxNFrOGl6_9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNzE0MA==", "bodyText": "@hsyuan any suggestion that what extra tests are useful for EnumerableSortedAggregate?", "url": "https://github.com/apache/calcite/pull/2035#discussion_r442417140", "createdAt": "2020-06-18T18:20:14Z", "author": {"login": "amaliujia"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableSortedAggregateTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Consumer;\n+\n+public class EnumerableSortedAggregateTest {\n+  @Test void sortedAgg() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NzIxMDYx", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-434721061", "createdAt": "2020-06-22T08:45:11Z", "commit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo0NToxMVrOGm3Xag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwODo0NToxMVrOGm3Xag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwNjE4Ng==", "bodyText": "Would it be possible to extract these conditions as an auxiliary method isSupported ?\nBy doing this, we could make EnumerableSortedAggregateRule to check it, and in case of not supported, do not generate the EnumerableSortedAggregate (otherwise the rule would generate an operator that will fail when trying to implement).", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443406186", "createdAt": "2020-06-22T08:45:11Z", "author": {"login": "rubenada"}, "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java", "diffHunk": "@@ -90,6 +101,133 @@ public EnumerableSortedAggregate(\n   }\n \n   public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n-    throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    if (getGroupType() != Group.SIMPLE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NzczNTE3", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-434773517", "createdAt": "2020-06-22T09:54:43Z", "commit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NDo0NFrOGm5zMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwOTo1NDo0NFrOGm5zMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ==", "bodyText": "Would it be possible for a key to be null? Do we need to add a check for that?", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443446065", "createdAt": "2020-06-22T09:54:44Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+      TResult result = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NzgwNjgw", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-434780680", "createdAt": "2020-06-22T10:04:17Z", "commit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDowNDoxN1rOGm6IbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDowNDoxN1rOGm6IbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA==", "bodyText": "I think this implementation of current does not respect this part of the contract:\nThis method does not move the position of the enumerator, and\nconsecutive calls to {@code current} return the same object until either\n{@code moveNext} or {@code reset} is called.\n\nI have the impression that consecutive calls to current will return different results. I think the logic that we have here should be transferred as part of moveNext, and the \"current object\" should be somehow saved; finally current should do no processing, just returning the \"current object\" saved by the moveNext process, or something like that.", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443451500", "createdAt": "2020-06-22T10:04:17Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0ODI2NTQ1", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-434826545", "createdAt": "2020-06-22T11:15:06Z", "commit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNTowNlrOGm8RrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxNTowNlrOGm8RrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjYzNw==", "bodyText": "Maybe we should put curAccumulator = null; as part of the reset", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443486637", "createdAt": "2020-06-22T11:15:06Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+      TResult result = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);\n+        if (comparator.compare(prevKey, curKey) != 0) {\n+          // current key is different from previous key, get accumulated results and re-create\n+          // accumulator for current key.\n+          result = resultSelector.apply(prevKey, curAccumulator);\n+          curAccumulator = accumulatorInitializer.apply();\n+          break;\n+        } else {\n+          curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+        }\n+        prevKey = curKey;\n+      }\n+\n+      if (result == null) {\n+        // current key is the last key.\n+        result = resultSelector.apply(prevKey, curAccumulator);\n+        // no need to keep accumulator for the last key.\n+        curAccumulator = null;\n+      }\n+\n+      return result;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        return enumerator.moveNext();\n+      } else {\n+        return curAccumulator != null;\n+      }\n+    }\n+\n+    @Override public void reset() {\n+      enumerator.reset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71991f7985112f9cff2aaced0aa95cfc99e93971"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MjI0OTQ5", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-437224949", "createdAt": "2020-06-25T07:14:25Z", "commit": {"oid": "a25d8a03be0a67677d7c3492ac707430b83052ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzoxNDoyNVrOGouJiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzoxNDoyNVrOGouJiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MjMyOA==", "bodyText": "I think we can remove the else, because there is a break at the end of the if block. IMO that would meake the code clearer.", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445352328", "createdAt": "2020-06-25T07:14:25Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,132 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private boolean isLastMoveNextFalse;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+    private TResult curResult;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+      curResult = null;\n+      isLastMoveNextFalse = false;\n+    }\n+\n+    @Override public TResult current() {\n+      if (isLastMoveNextFalse) {\n+        throw new NoSuchElementException();\n+      }\n+      return curResult;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        // input is empty\n+        if (!enumerator.moveNext()) {\n+          isLastMoveNextFalse = true;\n+          return false;\n+        }\n+      } else if (isInitialized && curAccumulator == null) {\n+        // input has been exhausted.\n+        isLastMoveNextFalse = true;\n+        return false;\n+      }\n+\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+\n+      // reset result because now it can move to next aggregated result.\n+      curResult = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);\n+        if (comparator.compare(prevKey, curKey) != 0) {\n+          // current key is different from previous key, get accumulated results and re-create\n+          // accumulator for current key.\n+          curResult = resultSelector.apply(prevKey, curAccumulator);\n+          curAccumulator = accumulatorInitializer.apply();\n+          break;\n+        } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25d8a03be0a67677d7c3492ac707430b83052ec"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MjI2MDQ5", "url": "https://github.com/apache/calcite/pull/2035#pullrequestreview-437226049", "createdAt": "2020-06-25T07:16:14Z", "commit": {"oid": "a25d8a03be0a67677d7c3492ac707430b83052ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzoxNjoxNVrOGouNXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwNzoxNjoxNVrOGouNXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MzMxMQ==", "bodyText": "I think checking isInitialized in this line is redundant. At this point isInitialized will always be true (otherwise we would have went into the first if block).", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445353311", "createdAt": "2020-06-25T07:16:15Z", "author": {"login": "rubenada"}, "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,132 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private boolean isLastMoveNextFalse;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+    private TResult curResult;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+      curResult = null;\n+      isLastMoveNextFalse = false;\n+    }\n+\n+    @Override public TResult current() {\n+      if (isLastMoveNextFalse) {\n+        throw new NoSuchElementException();\n+      }\n+      return curResult;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        // input is empty\n+        if (!enumerator.moveNext()) {\n+          isLastMoveNextFalse = true;\n+          return false;\n+        }\n+      } else if (isInitialized && curAccumulator == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25d8a03be0a67677d7c3492ac707430b83052ec"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55f335df7ac8b8ae31647cf0f16736aadff0b772", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/55f335df7ac8b8ae31647cf0f16736aadff0b772", "committedDate": "2020-06-29T07:35:14Z", "message": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregate (Rui Wang)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "117abf79117ba188fe2eadec0e7f1354d9d6215c", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/117abf79117ba188fe2eadec0e7f1354d9d6215c", "committedDate": "2020-06-25T19:17:03Z", "message": "fixup! add unit tests."}, "afterCommit": {"oid": "55f335df7ac8b8ae31647cf0f16736aadff0b772", "author": {"user": {"login": "amaliujia", "name": "Rui Wang"}}, "url": "https://github.com/apache/calcite/commit/55f335df7ac8b8ae31647cf0f16736aadff0b772", "committedDate": "2020-06-29T07:35:14Z", "message": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregate (Rui Wang)."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3763, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}