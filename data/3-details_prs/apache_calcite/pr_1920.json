{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MTEzMzI4", "number": 1920, "title": "[CALCITE-3894] The Union operation between DATE with TIMESTAMP return\u2026", "bodyText": "\u2026s a wrong result\nThe RelDataTypeFactory#leastRestrictive finds the common type for IN,\nCASE and SET operations. For common type with DATE and TIMESTAMP, it\nreturns DATE. The root cause is that rules in SqlTypeAssignmentRule\ndecide that DATE is assignable from TIMESTAMP, which is actually wrong.\nAlthough in Java, this assignment makes sense but that\ndoes not mean it's true in SQL, because DATE and TIMESTAMP have\ndifferent time unit.\nFix the rules in SqlTypeAssignmentRule and let the implicit type\ncoercion rule get involved.", "createdAt": "2020-04-16T04:40:23Z", "url": "https://github.com/apache/calcite/pull/1920", "merged": true, "mergeCommit": {"oid": "2798d90a8082adb294c3aadbad6d22d9228abf3e"}, "closed": true, "closedAt": "2020-04-17T01:28:03Z", "author": {"login": "danny0405"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYG-6qgFqTM5NDM0MTE2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYII4EABqjMyMzg2OTcxODE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzQxMTY1", "url": "https://github.com/apache/calcite/pull/1920#pullrequestreview-394341165", "createdAt": "2020-04-16T06:48:18Z", "commit": {"oid": "a047f60053b695789d0ba74152aef1073c332c35"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjo0ODoxOFrOGGW35A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjo0ODoxOFrOGGW35A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxOTM5Ng==", "bodyText": "between DATE with TIMESTAMP -> between DATE and TIMESTAMP ?", "url": "https://github.com/apache/calcite/pull/1920#discussion_r409319396", "createdAt": "2020-04-16T06:48:18Z", "author": {"login": "chunweilei"}, "path": "core/src/test/java/org/apache/calcite/test/JdbcTest.java", "diffHunk": "@@ -7401,6 +7401,20 @@ private void checkGetTimestamp(Connection con) throws SQLException {\n         .runs();\n   }\n \n+  /**\n+   * Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3894\">[CALCITE-3894]\n+   * The Union operation between DATE with TIMESTAMP returns a wrong result</a>.\n+   */\n+  @Test public void testUnionDateTime() {\n+    CalciteAssert.AssertThat assertThat = CalciteAssert.that();\n+    String query = \"select * from (\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a047f60053b695789d0ba74152aef1073c332c35"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd8b96888cf625a0c0ceeb826021f86e49ae9f57", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/bd8b96888cf625a0c0ceeb826021f86e49ae9f57", "committedDate": "2020-04-16T08:08:53Z", "message": "[CALCITE-3894] SET operation between DATE and TIMESTAMP returns a wrong result\n\nThe RelDataTypeFactory#leastRestrictive finds the common type for IN,\nCASE and SET operations. For common type with DATE and TIMESTAMP, it\nreturns DATE. The root cause is that rules in SqlTypeAssignmentRule\ndecide that DATE is assignable from TIMESTAMP, which is actually wrong.\nAlthough in Java, this assignment makes sense but that\ndoes not mean it's true in SQL, because DATE and TIMESTAMP have\ndifferent time unit.\n\nFix the rules in SqlTypeAssignmentRule and let the implicit type\ncoercion rule get involved."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a047f60053b695789d0ba74152aef1073c332c35", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/a047f60053b695789d0ba74152aef1073c332c35", "committedDate": "2020-04-16T04:34:45Z", "message": "[CALCITE-3894] The Union operation between DATE with TIMESTAMP returns a wrong result\n\nThe RelDataTypeFactory#leastRestrictive finds the common type for IN,\nCASE and SET operations. For common type with DATE and TIMESTAMP, it\nreturns DATE. The root cause is that rules in SqlTypeAssignmentRule\ndecide that DATE is assignable from TIMESTAMP, which is actually wrong.\nAlthough in Java, this assignment makes sense but that\ndoes not mean it's true in SQL, because DATE and TIMESTAMP have\ndifferent time unit.\n\nFix the rules in SqlTypeAssignmentRule and let the implicit type\ncoercion rule get involved."}, "afterCommit": {"oid": "bd8b96888cf625a0c0ceeb826021f86e49ae9f57", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/bd8b96888cf625a0c0ceeb826021f86e49ae9f57", "committedDate": "2020-04-16T08:08:53Z", "message": "[CALCITE-3894] SET operation between DATE and TIMESTAMP returns a wrong result\n\nThe RelDataTypeFactory#leastRestrictive finds the common type for IN,\nCASE and SET operations. For common type with DATE and TIMESTAMP, it\nreturns DATE. The root cause is that rules in SqlTypeAssignmentRule\ndecide that DATE is assignable from TIMESTAMP, which is actually wrong.\nAlthough in Java, this assignment makes sense but that\ndoes not mean it's true in SQL, because DATE and TIMESTAMP have\ndifferent time unit.\n\nFix the rules in SqlTypeAssignmentRule and let the implicit type\ncoercion rule get involved."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4094, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}