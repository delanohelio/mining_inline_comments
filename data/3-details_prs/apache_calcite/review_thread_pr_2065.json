{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NzA3Mzg1", "number": 2065, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyODoyNlrOEOPG6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMzo0NzoxNVrOEPIzpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzYzMDUxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjoyODoyNlrOGxRcTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjozMzozOFrOGxRonw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxOTE4Mw==", "bodyText": "Please refactor this assertThat(node2.equals(node3), is(true)); into a helper method, so the failure message contains the proper context information (e.g. nodes that are compared with each other)", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454319183", "createdAt": "2020-07-14T12:28:26Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(\n+        or(input(tBool(), 1), input(tBool(), 0)),\n+        input(tBool(), 0));\n+    final RexNode node1 = and(\n+        input(tBool(), 0),\n+        or(input(tBool(), 0), input(tBool(), 1)));\n+    assertThat(node0.equals(node1), is(true));\n+\n+    final RexNode node2 = eq(input(tVarchar(), 0), literal(\"0123456789012345\"));\n+    final RexNode node3 = eq(literal(\"0123456789012345\"), input(tVarchar(), 0));\n+    assertThat(node2.equals(node3), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e2059c889686d7e10d7ecb6f4a4551236703e7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMjMzNQ==", "bodyText": "Okey.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454322335", "createdAt": "2020-07-14T12:33:38Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(\n+        or(input(tBool(), 1), input(tBool(), 0)),\n+        input(tBool(), 0));\n+    final RexNode node1 = and(\n+        input(tBool(), 0),\n+        or(input(tBool(), 0), input(tBool(), 1)));\n+    assertThat(node0.equals(node1), is(true));\n+\n+    final RexNode node2 = eq(input(tVarchar(), 0), literal(\"0123456789012345\"));\n+    final RexNode node3 = eq(literal(\"0123456789012345\"), input(tVarchar(), 0));\n+    assertThat(node2.equals(node3), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxOTE4Mw=="}, "originalCommit": {"oid": "e0e2059c889686d7e10d7ecb6f4a4551236703e7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMzY0MzkxOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjozMTozMVrOGxRj3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMjozMzowN1rOGxRnZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMTExOQ==", "bodyText": "Can you please use vBool(1) instead of input(tBool(), 1)?", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454321119", "createdAt": "2020-07-14T12:31:31Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(\n+        or(input(tBool(), 1), input(tBool(), 0)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0e2059c889686d7e10d7ecb6f4a4551236703e7"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMjAyMA==", "bodyText": "I can, let me fix it.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454322020", "createdAt": "2020-07-14T12:33:07Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(\n+        or(input(tBool(), 1), input(tBool(), 0)),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMTExOQ=="}, "originalCommit": {"oid": "e0e2059c889686d7e10d7ecb6f4a4551236703e7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzU1ODU3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0ODoyMFrOGx2sHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo1MjoxNFrOGx21Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQzNg==", "bodyText": "@danny0405 , the reason must include the original node representations.\nThe error message like The two rex nodes expect to be equal, expected: true got: false does not really help to understand the nature of the failure.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454929436", "createdAt": "2020-07-15T09:48:20Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(or(vBool(1), vBool(0)), vBool(0));\n+    final RexNode node1 = and(vBool(0), or(vBool(0), vBool(1)));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = eq(vVarchar(0), literal(\"0123456789012345\"));\n+    final RexNode node3 = eq(literal(\"0123456789012345\"), vVarchar(0));\n+    assertNodeEquals(node2, node3, true);\n+\n+    final RexNode node4 = eq(vVarchar(0), literal(\"01\"));\n+    final RexNode node5 = eq(literal(\"01\"), vVarchar(0));\n+    assertNodeEquals(node4, node5, true);\n+  }\n+\n+  @Test void reversibleNormalizedToLess() {\n+    // Same type operands.\n+    final RexNode node0 = lt(vBool(0), vBool(0));\n+    final RexNode node1 = gt(vBool(0), vBool(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = le(vBool(0), vBool(0));\n+    final RexNode node3 = ge(vBool(0), vBool(0));\n+    assertNodeEquals(node2, node3, true);\n+\n+    // Different type operands.\n+    final RexNode node4 = lt(vSmallInt(0), vInt(1));\n+    final RexNode node5 = gt(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node4, node5, true);\n+\n+    final RexNode node6 = le(vSmallInt(0), vInt(1));\n+    final RexNode node7 = ge(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node6, node7, true);\n+  }\n+\n+  @Test void reversibleDifferentArgTypesShouldNotBeShuffled() {\n+    final RexNode node0 = plus(vSmallInt(1), vInt(0));\n+    final RexNode node1 = plus(vInt(0), vSmallInt(1));\n+    assertNodeEquals(node0, node1, false);\n+\n+    final RexNode node2 = mul(vSmallInt(0), vInt(1));\n+    final RexNode node3 = mul(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node2, node3, false);\n+  }\n+\n+  @Test void reversibleDifferentNullabilityArgsAreNormalized() {\n+    final RexNode node0 = plus(vIntNotNull(0), vInt(1));\n+    final RexNode node1 = plus(vInt(1), vIntNotNull(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = mul(vIntNotNull(1), vInt(0));\n+    final RexNode node3 = mul(vInt(0), vIntNotNull(1));\n+    assertNodeEquals(node2, node3, true);\n+  }\n+\n+  @Test void symmetricalDifferentArgOps() {\n+    final RexNode node0 = eq(vBool(0), vBool(1));\n+    final RexNode node1 = eq(vBool(1), vBool(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = ne(vBool(0), vBool(1));\n+    final RexNode node3 = ne(vBool(1), vBool(0));\n+    assertNodeEquals(node2, node3, true);\n+  }\n+\n+  @Test void reversibleDifferentArgOps() {\n+    final RexNode node0 = lt(vBool(0), vBool(1));\n+    final RexNode node1 = lt(vBool(1), vBool(0));\n+    assertNodeEquals(node0, node1, false);\n+\n+    final RexNode node2 = le(vBool(0), vBool(1));\n+    final RexNode node3 = le(vBool(1), vBool(0));\n+    assertNodeEquals(node2, node3, false);\n+\n+    final RexNode node4 = gt(vBool(0), vBool(1));\n+    final RexNode node5 = gt(vBool(1), vBool(0));\n+    assertNodeEquals(node4, node5, false);\n+\n+    final RexNode node6 = ge(vBool(0), vBool(1));\n+    final RexNode node7 = ge(vBool(1), vBool(0));\n+    assertNodeEquals(node6, node7, false);\n+  }\n+\n+  /** Assert whether two rex nodes are equal. */\n+  private static void assertNodeEquals(RexNode node1, RexNode node2, boolean equal) {\n+    StringBuilder reason = new StringBuilder(\"The two rex nodes expect to be \");\n+    if (!equal) {\n+      reason.append(\"not \");\n+    }\n+    reason.append(\"equal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1046a5519320e5a29763774b2a94749899835"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMTc3MQ==", "bodyText": "Well, let me fix it.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454931771", "createdAt": "2020-07-15T09:52:14Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(or(vBool(1), vBool(0)), vBool(0));\n+    final RexNode node1 = and(vBool(0), or(vBool(0), vBool(1)));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = eq(vVarchar(0), literal(\"0123456789012345\"));\n+    final RexNode node3 = eq(literal(\"0123456789012345\"), vVarchar(0));\n+    assertNodeEquals(node2, node3, true);\n+\n+    final RexNode node4 = eq(vVarchar(0), literal(\"01\"));\n+    final RexNode node5 = eq(literal(\"01\"), vVarchar(0));\n+    assertNodeEquals(node4, node5, true);\n+  }\n+\n+  @Test void reversibleNormalizedToLess() {\n+    // Same type operands.\n+    final RexNode node0 = lt(vBool(0), vBool(0));\n+    final RexNode node1 = gt(vBool(0), vBool(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = le(vBool(0), vBool(0));\n+    final RexNode node3 = ge(vBool(0), vBool(0));\n+    assertNodeEquals(node2, node3, true);\n+\n+    // Different type operands.\n+    final RexNode node4 = lt(vSmallInt(0), vInt(1));\n+    final RexNode node5 = gt(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node4, node5, true);\n+\n+    final RexNode node6 = le(vSmallInt(0), vInt(1));\n+    final RexNode node7 = ge(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node6, node7, true);\n+  }\n+\n+  @Test void reversibleDifferentArgTypesShouldNotBeShuffled() {\n+    final RexNode node0 = plus(vSmallInt(1), vInt(0));\n+    final RexNode node1 = plus(vInt(0), vSmallInt(1));\n+    assertNodeEquals(node0, node1, false);\n+\n+    final RexNode node2 = mul(vSmallInt(0), vInt(1));\n+    final RexNode node3 = mul(vInt(1), vSmallInt(0));\n+    assertNodeEquals(node2, node3, false);\n+  }\n+\n+  @Test void reversibleDifferentNullabilityArgsAreNormalized() {\n+    final RexNode node0 = plus(vIntNotNull(0), vInt(1));\n+    final RexNode node1 = plus(vInt(1), vIntNotNull(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = mul(vIntNotNull(1), vInt(0));\n+    final RexNode node3 = mul(vInt(0), vIntNotNull(1));\n+    assertNodeEquals(node2, node3, true);\n+  }\n+\n+  @Test void symmetricalDifferentArgOps() {\n+    final RexNode node0 = eq(vBool(0), vBool(1));\n+    final RexNode node1 = eq(vBool(1), vBool(0));\n+    assertNodeEquals(node0, node1, true);\n+\n+    final RexNode node2 = ne(vBool(0), vBool(1));\n+    final RexNode node3 = ne(vBool(1), vBool(0));\n+    assertNodeEquals(node2, node3, true);\n+  }\n+\n+  @Test void reversibleDifferentArgOps() {\n+    final RexNode node0 = lt(vBool(0), vBool(1));\n+    final RexNode node1 = lt(vBool(1), vBool(0));\n+    assertNodeEquals(node0, node1, false);\n+\n+    final RexNode node2 = le(vBool(0), vBool(1));\n+    final RexNode node3 = le(vBool(1), vBool(0));\n+    assertNodeEquals(node2, node3, false);\n+\n+    final RexNode node4 = gt(vBool(0), vBool(1));\n+    final RexNode node5 = gt(vBool(1), vBool(0));\n+    assertNodeEquals(node4, node5, false);\n+\n+    final RexNode node6 = ge(vBool(0), vBool(1));\n+    final RexNode node7 = ge(vBool(1), vBool(0));\n+    assertNodeEquals(node6, node7, false);\n+  }\n+\n+  /** Assert whether two rex nodes are equal. */\n+  private static void assertNodeEquals(RexNode node1, RexNode node2, boolean equal) {\n+    StringBuilder reason = new StringBuilder(\"The two rex nodes expect to be \");\n+    if (!equal) {\n+      reason.append(\"not \");\n+    }\n+    reason.append(\"equal\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyOTQzNg=="}, "originalCommit": {"oid": "24d1046a5519320e5a29763774b2a94749899835"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzU5NTIwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo1ODowN1rOGx3CTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxMDo1MlrOGx3etg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNTExNg==", "bodyText": "It looks like the nodes are used only once, so I would suggest to inline node0, node1 and similar variables.\nFor instance:\nassertNodeEquals( // or assertNodeNotEqual\n    and(or(vBool(1), vBool(0)), vBool(0)),\n    and(vBool(0), or(vBool(0), vBool(1)))\n);", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454935116", "createdAt": "2020-07-15T09:58:07Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(or(vBool(1), vBool(0)), vBool(0));\n+    final RexNode node1 = and(vBool(0), or(vBool(0), vBool(1)));\n+    assertNodeEquals(node0, node1, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24d1046a5519320e5a29763774b2a94749899835"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNTcyOA==", "bodyText": "An alternative option is to use Parameterized tests.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454935728", "createdAt": "2020-07-15T09:59:08Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(or(vBool(1), vBool(0)), vBool(0));\n+    final RexNode node1 = and(vBool(0), or(vBool(0), vBool(1)));\n+    assertNodeEquals(node0, node1, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNTExNg=="}, "originalCommit": {"oid": "24d1046a5519320e5a29763774b2a94749899835"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MjM5MA==", "bodyText": "Will change to inline, thanks ~", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454942390", "createdAt": "2020-07-15T10:10:52Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    final RexNode node0 = and(or(vBool(1), vBool(0)), vBool(0));\n+    final RexNode node1 = and(vBool(0), or(vBool(0), vBool(1)));\n+    assertNodeEquals(node0, node1, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNTExNg=="}, "originalCommit": {"oid": "24d1046a5519320e5a29763774b2a94749899835"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzYwNzAwOnYy", "diffSide": "RIGHT", "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowMDo0OFrOGx3JFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDowOTo0MlrOGx3cKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNjg1Mg==", "bodyText": "This change looks odd. Is there a reason why $5 is placed before $1?", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454936852", "createdAt": "2020-07-15T10:00:48Z", "author": {"login": "vlsi"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -606,7 +606,7 @@ on r.job=s.job and r.ename=s.ename]]>\n     <Resource name=\"planBefore\">\n       <![CDATA[\n LogicalProject(ENAME=[$0], JOB=[$1], SAL=[$2], COMM=[$3], ENAME0=[$4], JOB0=[$5], MGR=[$6], EXPR$3=[$7])\n-  LogicalJoin(condition=[AND(=($1, $5), =($0, $4))], joinType=[inner])\n+  LogicalJoin(condition=[AND(=($5, $1), =($4, $0))], joinType=[inner])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "724549a62c3b052daa0676fc16f68749a9296725"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0MTczNw==", "bodyText": "This is just the original plan, without any operands reordering, it is changed in CALCITE-3786 and revert back in this PR.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r454941737", "createdAt": "2020-07-15T10:09:42Z", "author": {"login": "danny0405"}, "path": "core/src/test/resources/org/apache/calcite/test/TopDownOptTest.xml", "diffHunk": "@@ -606,7 +606,7 @@ on r.job=s.job and r.ename=s.ename]]>\n     <Resource name=\"planBefore\">\n       <![CDATA[\n LogicalProject(ENAME=[$0], JOB=[$1], SAL=[$2], COMM=[$3], ENAME0=[$4], JOB0=[$5], MGR=[$6], EXPR$3=[$7])\n-  LogicalJoin(condition=[AND(=($1, $5), =($0, $4))], joinType=[inner])\n+  LogicalJoin(condition=[AND(=($5, $1), =($4, $0))], joinType=[inner])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNjg1Mg=="}, "originalCommit": {"oid": "724549a62c3b052daa0676fc16f68749a9296725"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTQ4NDYzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjo0NDo0MVrOGycQ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QwMTo1MTo1N1rOGzCplg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng==", "bodyText": "Could you please inline the seed into the method?\nI don't think we would need to change it often, so having less unknowns in the API helps.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455545086", "createdAt": "2020-07-16T06:44:41Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NjQzOQ==", "bodyText": "By the way, I don't think unorderedHash helps here.\nWe still need to be able to implement equals, and I don't think there's an easy way to compute equals without normalization.\nThen, I think we could normalize and cache the normalized value, then we can use a regular hash functions rather than unordered ones.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455546439", "createdAt": "2020-07-16T06:47:23Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0Nzc3Ng==", "bodyText": "Agree, would cache the normalized value instead.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455547776", "createdAt": "2020-07-16T06:50:23Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgwNjM5Mg==", "bodyText": "The thing is it is quite possible that you don't even get chance to call equals at all, in which case, it is wasteful to normalize it in computing hashcode.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455806392", "createdAt": "2020-07-16T13:57:53Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxNTYxMg==", "bodyText": "That makes sense!\nIn other words, use unorderedHash in hashCode, and compute/store the normalization only for equals.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455815612", "createdAt": "2020-07-16T14:09:57Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3Mzk3NA==", "bodyText": "I'm fine to keep the unorderedHash, one drawback with it is that the logic to decide whether operands need reordering must be strictly same with the #normalize, which i don't like because it is error-prone.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456173974", "createdAt": "2020-07-17T01:51:57Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();\n+  }\n+\n+  /** Computes the hashcode of a rex call, we ignore the operands sequence when\n+   * the call is symmetrical. */\n+  public static int hashCode(SqlOperator operator, List<RexNode> operands) {\n+    if (!allowsNormalize()) {\n+      return Objects.hash(operator, operands);\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return Objects.hash(operator, operands);\n+    }\n+    if (isSymmetricalCall(operator, operands.get(0), operands.get(1))) {\n+      return Objects.hash(operator, unorderedHash(operands, 17));\n+    }\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final int x = kind.reverse().compareTo(kind);\n+    if (x < 0) {\n+      // Note that Objects.hash([obj1, obj2]) is different from\n+      // Objects.hash(obj1, obj2)\n+      return Objects.hash(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operands.get(1), operands.get(0)));\n+    } else {\n+      return Objects.hash(operator, operands);\n+    }\n+  }\n+\n+  /** Returns whether a call is symmetrical. **/\n+  private static boolean isSymmetricalCall(\n+      SqlOperator operator,\n+      RexNode operand0,\n+      RexNode operand1) {\n+    return operator.isSymmetrical()\n+        || SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(operator.getKind())\n+            && SqlTypeUtil.equalSansNullability(operand0.getType(), operand1.getType());\n+  }\n+\n+  /**\n+   * The digest of {@code RexNode} is normalized by default.\n+   *\n+   * @return true if the digest needs to be normalized\n+   */\n+  private static boolean allowsNormalize() {\n+    return CalciteSystemProperty.ENABLE_REX_DIGEST_NORMALIZE.value();\n+  }\n+\n+  /** Compute a hash that is symmetric in its arguments - that is a hash\n+   *  where the order of appearance of elements does not matter.\n+   *  This is useful for hashing symmetric rex calls, for example.\n+   */\n+  private static int unorderedHash(List<?> xs, int seed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0NTA4Ng=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTUxNDE3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjo1NDoyN1rOGyciuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzoxMDo1M1rOGydByQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0OTYyNQ==", "bodyText": "Can you please add a test case like\n    assertNodeEquals(\n        and(or(vBool(1), vBool(0)), vBool(0)),\n        and(or(vBool(0), vBool(1)), vBool(0))\n    );\n\n?\nDoes it pass?", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455549625", "createdAt": "2020-07-16T06:54:27Z", "author": {"login": "vlsi"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    assertNodeEquals(\n+        and(or(vBool(1), vBool(0)), vBool(0)),\n+        and(vBool(0), or(vBool(0), vBool(1))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzU3Nw==", "bodyText": "Added and passed.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455557577", "createdAt": "2020-07-16T07:10:53Z", "author": {"login": "danny0405"}, "path": "core/src/test/java/org/apache/calcite/rex/RexNormalizeTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/** Test cases for {@link RexNormalize}. */\n+class RexNormalizeTest extends RexProgramTestBase {\n+\n+  @Test void digestIsNormalized() {\n+    assertNodeEquals(\n+        and(or(vBool(1), vBool(0)), vBool(0)),\n+        and(vBool(0), or(vBool(0), vBool(1))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0OTYyNQ=="}, "originalCommit": {"oid": "7137ea7ee47ca9e06ad6798c5556047290f80392"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MjQ4OTY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMTowMzo0M1rOGymBjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMToxOTozNVrOGymfUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNDk3NQ==", "bodyText": "Please use Integer#compare", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455704975", "createdAt": "2020-07-16T11:03:43Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcxMjU5Mg==", "bodyText": "Oh, i missed it, what's the difference.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455712592", "createdAt": "2020-07-16T11:19:35Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/rex/RexNormalize.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rex;\n+\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.util.Pair;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.List;\n+\n+/**\n+ * Context required to normalize a row-expression.\n+ *\n+ * <p>Currently, only simple normalization is supported, such as:\n+ *\n+ * <ul>\n+ *   <li>$2 = $1 &rarr; $1 = $2</li>\n+ *   <li>$2 &gt; $1 &rarr; $1 &lt; $2</li>\n+ *   <li>1.23 = $1 &rarr; $1 = 1.23</li>\n+ *   <li>OR(OR(udf($1), $2), $3) &rarr; OR($3, OR($2, udf($1)))</li>\n+ * </ul>\n+ *\n+ * <p>In the future, this component may extend to support more normalization cases\n+ * for general promotion. e.g. the strategy to decide which operand is more complex\n+ * should be more smart.\n+ *\n+ * <p>There is no one normalization strategy that works for all cases, and no consensus about what\n+ * the desired strategies should be. So by default, the normalization is disabled. We do force\n+ * normalization when computing the digest of {@link RexCall}s during planner planning.\n+ */\n+public class RexNormalize {\n+\n+  private RexNormalize() {}\n+\n+  /**\n+   * Normalizes the variables of a rex call.\n+   *\n+   * @param operator The operator\n+   * @param operands The operands\n+   *\n+   * @return normalized variables of the call or the original\n+   * if there is no need to normalize\n+   */\n+  @API(since = \"1.24\", status = API.Status.EXPERIMENTAL)\n+  public static Pair<SqlOperator, List<RexNode>> normalize(\n+      SqlOperator operator,\n+      List<RexNode> operands) {\n+    final Pair<SqlOperator, List<RexNode>> original = Pair.of(operator, operands);\n+    if (!allowsNormalize()) {\n+      return original;\n+    }\n+    // Quick check.\n+    if (operands.size() != 2) {\n+      return original;\n+    }\n+\n+    final RexNode operand0 = operands.get(0);\n+    final RexNode operand1 = operands.get(1);\n+\n+    // If arguments are the same, then we normalize < vs >\n+    // '<' == 60, '>' == 62, so we prefer <.\n+    final SqlKind kind = operator.getKind();\n+    final SqlKind reversedKind = kind.reverse();\n+    final int x = reversedKind.compareTo(kind);\n+    if (x < 0) {\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    if (x > 0) {\n+      return original;\n+    }\n+\n+    if (!isSymmetricalCall(operator, operand0, operand1)) {\n+      return original;\n+    }\n+\n+    if (reorderOperands(operand0, operand1) < 0) {\n+      // $0=$1 is the same as $1=$0, so we make sure the digest is the same for them.\n+\n+      // When $1 > $0 is normalized, the operation needs to be flipped\n+      // so we sort arguments first, then flip the sign.\n+      return Pair.of(\n+          SqlStdOperatorTable.reverse(operator),\n+          ImmutableList.of(operand1, operand0));\n+    }\n+    return original;\n+  }\n+\n+  /**\n+   * Compares two operands to see which one should be normalized to be in front of the other.\n+   *\n+   * <p>We can always use the #hashCode to reorder the operands, do it as a fallback to keep\n+   * good readability.\n+   *\n+   * @param operand0  First operand\n+   * @param operand1  Second operand\n+   *\n+   * @return non-negative (>=0) if {@code operand0} should be in the front,\n+   * negative if {@code operand1} should be in the front\n+   */\n+  private static int reorderOperands(RexNode operand0, RexNode operand1) {\n+    // Reorder the operands based on the SqlKind enumeration sequence,\n+    // smaller is in the behind, e.g. the literal is behind of input ref and AND, OR.\n+    int x = operand0.getKind().compareTo(operand1.getKind());\n+    // If the operands are same kind, use the hashcode to reorder.\n+    // Note: the RexInputRef's hash code is its index.\n+    return x != 0 ? x : operand1.hashCode() - operand0.hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwNDk3NQ=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzA4Mzg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMzo0NzoxNVrOGyruqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTozNzo1MlrOGzh17g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA==", "bodyText": "The word SYMMETRICAL is very misleading, especially for public method isSymmetrical. It doesn't mean order insensitive.\nhttps://www.thefreedictionary.com/Symetrical", "url": "https://github.com/apache/calcite/pull/2065#discussion_r455798440", "createdAt": "2020-07-16T13:47:15Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE0MzQ5Mg==", "bodyText": "Not that misleading, i found the MurmurHash3#unorderedHash also use the word symmetric to describe the similar semantic.\n[1] https://github.com/scala/scala/blob/2.11.x/src/library/scala/util/hashing/MurmurHash3.scala#L88", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456143492", "createdAt": "2020-07-17T00:00:41Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3MDQ1MA==", "bodyText": "So would you rather believe that Scala guys are always right, even when the dictionary clearly says otherwise?\nI do believe you have the common sense of what symmetric encryption algorithm is.\nFYI, the original method name of MurmurHash3#unorderedHash was symmetricHash, it was later renamed to unorderedHash, but the author forgot to update the comment.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456170450", "createdAt": "2020-07-17T01:38:34Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3MjQ1OQ==", "bodyText": "We might need to discuss on the mail thread about the name, personally i have no strong objections on the name, i did prefer symmetrical than inputNonSensitive, the latter is not even a terminology.\nThe SqlKind.SYMMETRICAL was first added in 1.22 by @vlsi , maybe he would give better explanation.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456172459", "createdAt": "2020-07-17T01:46:07Z", "author": {"login": "danny0405"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3MzM3NA==", "bodyText": "Sure, you can send out to the mailing list.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456173374", "createdAt": "2020-07-17T01:49:43Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMTgyNw==", "bodyText": "I'm siding with @danny0405 on this one. His use conforms to the mathematical concept of a symmetric function.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456231827", "createdAt": "2020-07-17T05:49:50Z", "author": {"login": "julianhyde"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NTAzOA==", "bodyText": "Well, if you think the meaning the method name isSymmetrical conveys is crystal clear and without any ambiguity...\nIt has several meanings:\n\nThe one you mentioned above, input order insensitive (forgive my ignorance)\nhttps://www.thefreedictionary.com/Symetrical or https://en.wikipedia.org/wiki/Symmetry_(geometry)\nSymmetric encryption uses it to denote encryption and decryption use the same key\n\nI do believe there is a reason Scala renamed symmetricHash to unorderedHash, Cockroachdb call the method isOrderingSensitive instead of others.\nFor those who lacks of mathematical background, I don't think it is a good naming public API, which is not self explanatory.", "url": "https://github.com/apache/calcite/pull/2065#discussion_r456685038", "createdAt": "2020-07-17T21:37:52Z", "author": {"login": "hsyuan"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlOperator.java", "diffHunk": "@@ -929,6 +929,17 @@ public boolean isDeterministic() {\n     return true;\n   }\n \n+  /**\n+   * Returns whether a call to this operator is not sensitive to the operands input order.\n+   * An operator is symmetrical if the call returns the same result when\n+   * the operands are shuffled.\n+   *\n+   * <p>By default, returns true for {@link SqlKind#SYMMETRICAL}.\n+   */\n+  public boolean isSymmetrical() {\n+    return SqlKind.SYMMETRICAL.contains(kind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5ODQ0MA=="}, "originalCommit": {"oid": "80c34d4bbc9d26d0d37e920de4c820f84ded1efc"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 92, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}