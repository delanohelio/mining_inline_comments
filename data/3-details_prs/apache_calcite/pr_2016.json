{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNzg5NzQ1", "number": 2016, "title": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equa\u2026", "bodyText": "\u2026ls) for RexNode and RelNode\n\nAdd class Digest used to identify the node;\nThere is a pre-computed hashcode to speedup #hashCode and #equals;\nWe still use the string digest comparison for RexNode, which can be\npromoted as reused objects later", "createdAt": "2020-06-09T13:21:55Z", "url": "https://github.com/apache/calcite/pull/2016", "merged": true, "mergeCommit": {"oid": "69f25863f5f4197c17927a39a82cbf1cffd12b80"}, "closed": true, "closedAt": "2020-06-16T03:11:14Z", "author": {"login": "danny0405"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcplKWPAFqTQyNzE1MTA4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsqXYVAFqTQzMzc3NzQxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTUxMDgz", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-427151083", "createdAt": "2020-06-09T13:34:45Z", "commit": {"oid": "2039685a7280cf647f194fca9784ae9879560d19"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozNDo0NlrOGhKDEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzozNDo0NlrOGhKDEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw==", "bodyText": "This seems to be resource-consuming. Should the result is not cached in the constructor?", "url": "https://github.com/apache/calcite/pull/2016#discussion_r437420817", "createdAt": "2020-06-09T13:34:46Z", "author": {"login": "vlsi"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents));\n+  }\n+\n+  private static Object[] collect(RelNode rel, List<Pair<String, Object>> contents) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2039685a7280cf647f194fca9784ae9879560d19"}, "originalPosition": 94}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99f55001923eb1618268cfb9d0d645a86eb2ceff", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/99f55001923eb1618268cfb9d0d645a86eb2ceff", "committedDate": "2020-06-11T11:48:32Z", "message": "Change RexCall to use object#equals instead of pure string digest compare"}, "afterCommit": {"oid": "828435697ce7679736aff2824d7e6f184903e3b7", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/828435697ce7679736aff2824d7e6f184903e3b7", "committedDate": "2020-06-12T04:12:03Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "828435697ce7679736aff2824d7e6f184903e3b7", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/828435697ce7679736aff2824d7e6f184903e3b7", "committedDate": "2020-06-12T04:12:03Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}, "afterCommit": {"oid": "a51dc0709518d8626d48dede830589f5254dfcd3", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/a51dc0709518d8626d48dede830589f5254dfcd3", "committedDate": "2020-06-12T05:39:14Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a51dc0709518d8626d48dede830589f5254dfcd3", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/a51dc0709518d8626d48dede830589f5254dfcd3", "committedDate": "2020-06-12T05:39:14Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}, "afterCommit": {"oid": "02eebf905cc0689f684fad3a3bab8ec6da040abe", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/02eebf905cc0689f684fad3a3bab8ec6da040abe", "committedDate": "2020-06-12T07:41:16Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02eebf905cc0689f684fad3a3bab8ec6da040abe", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/02eebf905cc0689f684fad3a3bab8ec6da040abe", "committedDate": "2020-06-12T07:41:16Z", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;"}, "afterCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/545743d9db35eaeb45e8310ae050d3891c8602de", "committedDate": "2020-06-12T08:22:39Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODU3MTM5", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-429857139", "createdAt": "2020-06-12T15:57:40Z", "commit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNTo1Nzo0MFrOGjJOLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNjowOTo1NFrOGjJmxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA==", "bodyText": "This breaks the contract that if 2 objects are equal, then the method should return 0.", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439504428", "createdAt": "2020-06-12T15:57:40Z", "author": {"login": "laurentgo"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg==", "bodyText": "The whole check + loop could be replaced with Arrays.equals(Object[], Object[])", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439506332", "createdAt": "2020-06-12T16:01:17Z", "author": {"login": "laurentgo"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ==", "bodyText": "should Arrays.deepEquals be used if thisItems[i] is an array?", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439507991", "createdAt": "2020-06-12T16:04:32Z", "author": {"login": "laurentgo"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {\n+      return false;\n+    }\n+    for (int i = 0; i < thisItems.length; i++) {\n+      if (!Objects.equals(thisItems[i], thatItems[i])) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg==", "bodyText": "Why not let the rel node itself handle how to create the digest vs having a non-extendable/overridable method using different behaviors based on the type of rel to do it? This looks like an anti design pattern.", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439510726", "createdAt": "2020-06-12T16:09:54Z", "author": {"login": "laurentgo"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de"}, "originalPosition": 169}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/545743d9db35eaeb45e8310ae050d3891c8602de", "committedDate": "2020-06-12T08:22:39Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}, "afterCommit": {"oid": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/ef321d8643a8b449ec5da33952e9f661273d7a8f", "committedDate": "2020-06-15T03:08:31Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/ef321d8643a8b449ec5da33952e9f661273d7a8f", "committedDate": "2020-06-15T03:08:31Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}, "afterCommit": {"oid": "36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "committedDate": "2020-06-15T03:43:05Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "committedDate": "2020-06-15T03:43:05Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}, "afterCommit": {"oid": "09bd6945f49b5d199a1488c70a511763d947efbc", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/09bd6945f49b5d199a1488c70a511763d947efbc", "committedDate": "2020-06-15T03:56:17Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09bd6945f49b5d199a1488c70a511763d947efbc", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/09bd6945f49b5d199a1488c70a511763d947efbc", "committedDate": "2020-06-15T03:56:17Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}, "afterCommit": {"oid": "ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "committedDate": "2020-06-16T02:29:28Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/380cc446c24dd0d50198508a626f80b306d9b9b5", "committedDate": "2020-06-16T02:33:49Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "committedDate": "2020-06-16T02:29:28Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}, "afterCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5", "author": {"user": {"login": "danny0405", "name": "Danny Chan"}}, "url": "https://github.com/apache/calcite/commit/380cc446c24dd0d50198508a626f80b306d9b9b5", "committedDate": "2020-06-16T02:33:49Z", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzYzNjQ4", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-433763648", "createdAt": "2020-06-19T02:29:02Z", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyOTowMlrOGmGC_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjoyOTowMlrOGmGC_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODE0MQ==", "bodyText": "Why do you use getRelTypeName() rather than \"HepRelVertex\"?", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442598141", "createdAt": "2020-06-19T02:29:02Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/plan/hep/HepRelVertex.java", "diffHunk": "@@ -75,8 +76,8 @@\n     return currentRel.getRowType();\n   }\n \n-  @Override protected String computeDigest() {\n-    return \"HepRelVertex(\" + currentRel + \")\";\n+  @Override protected Digest computeDigest() {\n+    return Digest.create(this, getRelTypeName() + '#' + getCurrentRel().getId());\n   }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzY3MTc0", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-433767174", "createdAt": "2020-06-19T02:41:43Z", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo0MTo0M1rOGmGO8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMjo0MTo0M1rOGmGO8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMw==", "bodyText": "It's weird to add PALN= just for the two cases. It's better to have the same format for all the cases.", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442601203", "createdAt": "2020-06-19T02:41:43Z", "author": {"login": "chunweilei"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java", "diffHunk": "@@ -96,11 +96,11 @@\n           planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n         })\n         .explainContains(\"\"\n-            + \"EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\\n\"\n+            + \"PLAN=EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\\n\"\n             + \"  EnumerableCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0}])\\n\"\n             + \"    EnumerableAggregate(group=[{0}])\\n\"\n             + \"      EnumerableTableScan(table=[[s, depts]])\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzcyNTg1", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-433772585", "createdAt": "2020-06-19T03:01:24Z", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowMToyNFrOGmGhBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowMToyNFrOGmGhBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTgyOQ==", "bodyText": "What's the difference between Digest#create and Digest#initial ? Their results seem the same.", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442605829", "createdAt": "2020-06-19T03:01:24Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  private final int hashCode;\n+  private final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>Currently, returns composition of class name and id.\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    return rel.getRelTypeName() + '#' + rel.getId();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(@Nonnull Digest other) {\n+    return this.equals(other) ? 0 : this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {\n+      return false;\n+    }\n+    for (int i = 0; i < thisItems.length; i++) {\n+      if (!Objects.equals(thisItems[i], thatItems[i])) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override public int hashCode() {\n+    return hashCode;\n+  }\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   */\n+  public static Digest create(RelNode rel, List<Pair<String, Object>> contents) {\n+    return new Digest(rel, contents);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel.\n+   */\n+  public static Digest create(RelNode rel) {\n+    return new Digest(rel);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel and string format digest\n+   */\n+  public static Digest create(RelNode rel, String digest) {\n+    return new Digest(rel, digest);\n+  }\n+\n+  /**\n+   * Instantiates a digest with solid string format digest, this digest should only\n+   * be used as a initial.\n+   */\n+  public static Digest initial(RelNode rel) {\n+    return new Digest(rel, simpleRelDigest(rel));\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "originalPosition": 256}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzc0Nzc4", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-433774778", "createdAt": "2020-06-19T03:09:59Z", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowOTo1OVrOGmGoeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowOTo1OVrOGmGoeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNzczNg==", "bodyText": "As you said \"List<Pair<String, Object>> items are the properties, e.g. the inputs, the type, the traits and so on\", why should we still have to append trait?", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442607736", "createdAt": "2020-06-19T03:09:59Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  private final int hashCode;\n+  private final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>Currently, returns composition of class name and id.\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    return rel.getRelTypeName() + '#' + rel.getId();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzc3NDE2", "url": "https://github.com/apache/calcite/pull/2016#pullrequestreview-433777416", "createdAt": "2020-06-19T03:20:17Z", "commit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzoyMDoxN1rOGmGxPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzoyMDoxN1rOGmGxPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwOTk4MA==", "bodyText": "Nice catch.", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442609980", "createdAt": "2020-06-19T03:20:17Z", "author": {"login": "chunweilei"}, "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "diffHunk": "@@ -394,16 +394,24 @@ public RexWinAggCall(\n       this.ignoreNulls = ignoreNulls;\n     }\n \n-    /** {@inheritDoc}\n-     *\n-     * <p>Override {@link RexCall}, defining equality based on identity.\n-     */\n-    @Override public boolean equals(Object obj) {\n-      return this == obj;\n+    @Override public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      if (!super.equals(o)) {\n+        return false;\n+      }\n+      RexWinAggCall that = (RexWinAggCall) o;\n+      return ordinal == that.ordinal\n+          && distinct == that.distinct\n+          && ignoreNulls == that.ignoreNulls;\n     }\n \n     @Override public int hashCode() {\n-      return Objects.hash(digest, ordinal, distinct);\n+      return Objects.hash(super.hashCode(), ordinal, distinct, ignoreNulls);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3638, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}