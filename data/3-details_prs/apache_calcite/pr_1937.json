{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3MTkzMDM5", "number": 1937, "title": "[CALCITE-3951] Support different string comparison based on SqlCollation", "bodyText": "Currently SqlCollation defines concepts like Coercibility, Charset, Locale, etc. However, we cannot specify on a certain collation that e.g. a string field should use case insensitive comparison. The goal of this ticket is to evolve SqlCollation to support that, and adapt the corresponding classes to use that (optional) \"non-standard\" comparison.", "createdAt": "2020-04-22T10:20:07Z", "url": "https://github.com/apache/calcite/pull/1937", "merged": true, "mergeCommit": {"oid": "fa8349069d141d3c75bafa06d5fb8800711ec8d6"}, "closed": true, "closedAt": "2020-06-18T16:07:17Z", "author": {"login": "rubenada"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaFo45AFqTM5ODA1MDQwNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsfLBpgFqTQzMzMzMDExMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDUwNDA1", "url": "https://github.com/apache/calcite/pull/1937#pullrequestreview-398050405", "createdAt": "2020-04-22T10:22:18Z", "commit": {"oid": "df564c0ed2780784b61c25c81f567e18c14577b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoyMjoxOFrOGJu9gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMDoyMjoxOFrOGJu9gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1OTc3OA==", "bodyText": "Not sure if there is a way to express String.CASE_INSENSITIVE_ORDER as an Expression... (for the moment using \"\".CASE_INSENSITIVE_ORDER as workaround)", "url": "https://github.com/apache/calcite/pull/1937#discussion_r412859778", "createdAt": "2020-04-22T10:22:18Z", "author": {"login": "rubenada"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java", "diffHunk": "@@ -258,6 +264,85 @@\n         .returnsUnordered(\"empid=100\\nempid=110\\nempid=150\\nempid=200\");\n   }\n \n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df564c0ed2780784b61c25c81f567e18c14577b5"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwNzMwMTM3", "url": "https://github.com/apache/calcite/pull/1937#pullrequestreview-400730137", "createdAt": "2020-04-27T08:24:11Z", "commit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODoyNDoxMlrOGMW7lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwOToyMjo1MVrOGMZbIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ==", "bodyText": "Having a linq4j.tree.Expression in this level seems a bit weird. I don't remember any other class in the sql package having dependencies to linq4j. Moreover, for those projects that do not rely on Enumerable this method is a bit useless.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415611799", "createdAt": "2020-04-27T08:24:12Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return Comparator expression to be used, or null if no special comparator is required.\n+   */\n+  public Expression getComparatorExpression() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxNDAyMw==", "bodyText": "Is it better to return a Comparator or Collator? If we need to generate collation keys in other places then maybe the second option is preferable.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415614023", "createdAt": "2020-04-27T08:27:18Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng==", "bodyText": "The newly added method indicate that projects should rely on inheritance to define a new collation but the documentation doesn't say so. Moreover, I get the feeling that this information is not an extension but really part of this class.\nUsing inheritance brings up questions like what happens with equals and hashCode? Should the comparator be part of it?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415619166", "createdAt": "2020-04-27T08:34:54Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjExMg==", "bodyText": "This test is similar to the logic of SqlOperatorBaseTest. Could we move things there? Are there things that we could reuse?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415626112", "createdAt": "2020-04-27T08:44:53Z", "author": {"login": "zabetak"}, "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.sql.SqlCollation;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Test cases for\n+ * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3951\">[CALCITE-3951]\n+ * Support different string comparison based on SqlCollation</a>.\n+ */\n+class EnumerableStringComparisonTest {\n+\n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator<String> getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),\n+              \"CASE_INSENSITIVE_ORDER\");\n+        }\n+  };\n+\n+  private RelDataType createRecordVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().builder()\n+        .add(\n+            \"name\",\n+            builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+                builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+                builder.getTypeFactory().getDefaultCharset(),\n+                NO_CASE))\n+        .build();\n+  }\n+\n+  private RelDataType createVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+        builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+        builder.getTypeFactory().getDefaultCharset(),\n+        NO_CASE);\n+  }\n+\n+  @Test void testSortNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withRel(builder -> builder\n+            .values(\n+                createRecordVarcharNoCase(builder),\n+                \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\")\n+            .sort(\n+                builder.field(1, 0, \"name\"))\n+            .build())\n+        .explainHookMatches(\"\"\n+            + \"EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"  EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\")\n+        .returnsOrdered(\"name=Administration\\n\"\n+            + \"name=hr\\n\"\n+            + \"name=Legal\\n\"\n+            + \"name=MARKETING\\n\"\n+            + \"name=presales\");\n+  }\n+\n+  @Test void testMergeJoinOnStringNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {\n+          planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n+          planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n+        })\n+        .withRel(builder -> builder\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\").as(\"v1\")\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Marketing\", \"bureaucracy\", \"Sales\", \"HR\").as(\"v2\")\n+              .join(JoinRelType.INNER,\n+                  builder.equals(\n+                      builder.field(2, 0, \"name\"),\n+                      builder.field(2, 1, \"name\")))\n+              .project(\n+                  builder.field(\"v1\", \"name\"),\n+                  builder.field(\"v2\", \"name\"))\n+              .build())\n+        .explainHookMatches(\"\" // It is important that we have MergeJoin in the plan\n+            + \"EnumerableMergeJoin(condition=[=($0, $1)], joinType=[inner])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Marketing' }, { 'bureaucracy' }, { 'Sales' }, { 'HR' }]])\\n\")\n+        .returnsOrdered(\"name=hr; name0=HR\\n\"\n+            + \"name=MARKETING; name0=Marketing\");\n+  }\n+\n+  @Test void testStringComparison() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTIxNg==", "bodyText": "Collations are compared with equals but is the Comparator part of the equals? Should it be?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415631216", "createdAt": "2020-04-27T08:52:06Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/rex/RexBuilder.java", "diffHunk": "@@ -919,9 +919,12 @@ protected RexLiteral makeLiteral(\n       // from the type if necessary.\n       assert o instanceof NlsString;\n       NlsString nlsString = (NlsString) o;\n-      if ((nlsString.getCollation() == null)\n-          || (nlsString.getCharset() == null)) {\n-        assert type.getSqlTypeName() == SqlTypeName.CHAR;\n+      if (nlsString.getCollation() == null\n+          || nlsString.getCharset() == null\n+          || !nlsString.getCharset().equals(type.getCharset())\n+          || !nlsString.getCollation().equals(type.getCollation())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTI5OA==", "bodyText": "Possibly we could deprecate/remove the old methods (e.g., le(String b0, String b1) and always use the new alternatives with the Comparator. When we don't have one we could use String::compareTo or Comparator.naturalOrder to have the same behavior as before.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415639298", "createdAt": "2020-04-27T09:03:21Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -730,6 +743,11 @@ public static boolean le(String b0, String b1) {\n     return b0.compareTo(b1) <= 0;\n   }\n \n+  /** SQL <code>&le;</code> operator applied to String values. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MDMzOQ==", "bodyText": "Normally we should call this method only with parameters of type String. Why do we need Object?", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415640339", "createdAt": "2020-04-27T09:04:50Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -638,6 +639,13 @@ public static boolean eq(Object b0, Object b1) {\n     return b0.equals(b1);\n   }\n \n+  /** SQL <code>=</code> operator applied to Object values (including String;\n+   * neither side may be null). */\n+  public static boolean eq(Object b0, Object b1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MjY0MA==", "bodyText": "Do we need all this new variants? Note that there are also the standard java methods Comparator.nullsFirst and Comparator.nullsLast.\nIf we have a Comparator at hand then we could directly generate the code:\nComparator nfc = Comparator.nullsFirst(comparator);\nnfc.compare(v0, v1);\n\nI don't see clearly why we need to use the Utilties redirection in this case.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415652640", "createdAt": "2020-04-27T09:22:51Z", "author": {"login": "zabetak"}, "path": "core/src/main/java/org/apache/calcite/runtime/Utilities.java", "diffHunk": "@@ -212,6 +213,27 @@ public static int compareNullsLast(Comparable v0, Comparable v1) {\n                 : v0.compareTo(v1);\n   }\n \n+  public static int compare(Comparable v0, Comparable v1, Comparator comparator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d76a623a142ce92366bcf345c4e39c7097ba4d8"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MDU4Nzcw", "url": "https://github.com/apache/calcite/pull/1937#pullrequestreview-404058770", "createdAt": "2020-05-01T07:57:17Z", "commit": {"oid": "6858b37421c9fa6502fb11b7f75303bc86ccd605"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNzo1NzoxOFrOGPEWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQwNzo1NzoxOFrOGPEWTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzA2OA==", "bodyText": "The description here needs some modifications.", "url": "https://github.com/apache/calcite/pull/1937#discussion_r418453068", "createdAt": "2020-05-01T07:57:18Z", "author": {"login": "XuQianJin-Stars"}, "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -356,8 +302,9 @@ public final Locale getLocale() {\n \n   /**\n    * @return Collator to be used for comparison, or null if no specific collator is defined", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6858b37421c9fa6502fb11b7f75303bc86ccd605"}, "originalPosition": 111}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0453c95dbd58be36ef3bbe6efc769283aa6ed771", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/0453c95dbd58be36ef3bbe6efc769283aa6ed771", "committedDate": "2020-05-01T18:29:43Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}, "afterCommit": {"oid": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/9c1943c5403b2c2d29390e6a29036166208f9ca6", "committedDate": "2020-05-11T11:09:58Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/9c1943c5403b2c2d29390e6a29036166208f9ca6", "committedDate": "2020-05-11T11:09:58Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}, "afterCommit": {"oid": "d1968a0753fe8dfbf12b695799df22b07d957337", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/d1968a0753fe8dfbf12b695799df22b07d957337", "committedDate": "2020-06-02T15:09:22Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f79a6bf801a17b8517f845230426f84014c992d", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/5f79a6bf801a17b8517f845230426f84014c992d", "committedDate": "2020-06-03T07:46:44Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d1968a0753fe8dfbf12b695799df22b07d957337", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/d1968a0753fe8dfbf12b695799df22b07d957337", "committedDate": "2020-06-02T15:09:22Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}, "afterCommit": {"oid": "5f79a6bf801a17b8517f845230426f84014c992d", "author": {"user": {"login": "rubenada", "name": null}}, "url": "https://github.com/apache/calcite/commit/5f79a6bf801a17b8517f845230426f84014c992d", "committedDate": "2020-06-03T07:46:44Z", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzMwMTEz", "url": "https://github.com/apache/calcite/pull/1937#pullrequestreview-433330113", "createdAt": "2020-06-18T14:17:51Z", "commit": {"oid": "5f79a6bf801a17b8517f845230426f84014c992d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4143, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}