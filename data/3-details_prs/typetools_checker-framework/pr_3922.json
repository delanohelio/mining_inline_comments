{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1Nzc1NzU4", "number": 3922, "title": "Implement capture conversion.", "bodyText": "Merge with plume-lib/plume-util#157.\nThis pull request implements capture conversion.  This required several related changes:\n\nRe-implementing isContainedBy in DefaultTypeHierarchy.\nRemoving various workarounds.\n\nTo understand capture conversion, you need to understand the following sections of the JLS:\n\n5.1.10.\n4.5.1 containment\n4.10 subtyping (and note that \"|T|\" means \"the erasure of T\")\n\nReviewing order:\n\nCapture conversion: AnnotatedTypeFactory#applyCaptureConversion(AnnotatedTypeMirror)\nContainment: DefaultTypeHierarchy#isContainedBy\nAll other changes. (Note some of these are removing work arounds for not having capture conversion.)\n\nFixes #3013, fixes #3754, fixes #3791, fixes #3845, fixes #3970, and fixes #4523.", "createdAt": "2020-11-23T14:38:14Z", "url": "https://github.com/typetools/checker-framework/pull/3922", "merged": true, "mergeCommit": {"oid": "8475fd7ef0c21c6ace0a0c37e99a828b2a3e83b5"}, "closed": true, "closedAt": "2021-07-13T01:02:08Z", "author": {"login": "smillst"}, "timelineItems": {"totalCount": 263, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABelQGRVgH2gAyNTI1Nzc1NzU4OjNiZjAyMTRmYjVhNDA4ODEzYTI0ZDVmM2MyODFiOThmZmE0MDYwYzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABepz0CkgH2gAyNTI1Nzc1NzU4OjhmZjk4NzBkMGQ5MjVmZTZmNWE5ZDg1M2Y1MzgyZDNlMjljYWE3MGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3bf0214fb5a408813a24d5f3c281b98ffa4060c5", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3bf0214fb5a408813a24d5f3c281b98ffa4060c5", "committedDate": "2021-06-28T19:08:55Z", "message": "Add comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "768bb35256b5f86097fad58fd06617a3ea66038d", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/768bb35256b5f86097fad58fd06617a3ea66038d", "committedDate": "2021-06-28T19:09:01Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57dbcde57bc35d87a5a4431ce5a728859eda5e51", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/57dbcde57bc35d87a5a4431ce5a728859eda5e51", "committedDate": "2021-06-29T17:19:18Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8d2e1d98be7e04c8cae2d2da14bc6029af7ab759", "committedDate": "2021-06-30T16:10:54Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ecd6d25c064af4beee36dcd8a2337c06bd133695", "committedDate": "2021-06-30T16:39:44Z", "message": "Code review changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk2MzY2NjUw", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-696366650", "createdAt": "2021-06-30T16:13:01Z", "commit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxMzowMVrOJ2-R_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjo0Mjo1MlrOJ2_qnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyMzI5NQ==", "bodyText": "What is the relationship between these types?  Are their erased/raw types the same?  Or is there a subtyping relationship?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661623295", "createdAt": "2021-06-30T16:13:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyMzg4NQ==", "bodyText": "I usually expect to see a check of a cache at the beginning of the routine.  Should it be moved there, or is there a reason that it needs to appear after other logic?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661623885", "createdAt": "2021-06-30T16:13:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNDg1Mg==", "bodyText": "Would a better name for this routine be isContainedByBoundedWildcard?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661624852", "createdAt": "2021-06-30T16:15:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNTc1MQ==", "bodyText": "\"they should be equal\":  I'm not sure whether this is describing an application invariant that is true whenever control reaches this line, or it is describing a test that will be performed later in the routine.  Could you rewrite to resolve the ambiguity?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661625751", "createdAt": "2021-06-30T16:16:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(\n+              inside,\n+              outsideWildcard.getSuperBound(),\n+              outsideWildcard.getExtendsBound(),\n+              canBeCovariant);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n+    } else if ((TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+        && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+      // TODO: This branch should be removed after #979 is fixed.\n+      // If both outside and inside are captured type variables, they should be equal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMDc0OA==", "bodyText": "\"Checks that\" could mean that the method throws an exception or reports an error.\nOr, \"checks that\" could indicate the method's return value.\nCould you resolve the ambiguity?\nI think that all the visit methods are returning a boolean value indicating whether the method's arguments are in a subtyping relationship.  It would be good to document that in the class Javadoc.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661630748", "createdAt": "2021-06-30T16:22:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -482,12 +502,18 @@ public Boolean visitDeclared_Declared(\n   }\n \n   /**\n-   * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n-   * to customize the handling of type arguments. This method provides a convenient extension point.\n+   * Checks that the type arguments in {@code supertype} contain the type arguments in {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMTE3OA==", "bodyText": "Please make this comment more descriptive.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661631178", "createdAt": "2021-06-30T16:22:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -482,12 +502,18 @@ public Boolean visitDeclared_Declared(\n   }\n \n   /**\n-   * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n-   * to customize the handling of type arguments. This method provides a convenient extension point.\n+   * Checks that the type arguments in {@code supertype} contain the type arguments in {@code\n+   * subtype}. See {@link #isContainedBy} for an explanation of containment.\n+   *\n+   * @param subtype a possible subtype (its underlying type is a subtype of {@code supertype})\n+   * @param supertype a possible supertype (its underlying type is a supertype of {@code subtype})\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMjA2OA==", "bodyText": "Why does this case not indicate a bug that should be raised as an exception?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661632068", "createdAt": "2021-06-30T16:23:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -503,6 +529,7 @@ protected boolean visitTypeArgs(\n     if (subtypeTypeArgs.size() != supertypeTypeArgs.size()) {\n       return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMzQwOQ==", "bodyText": "I think this is only handling the 3rd bullet point of that paragraph.  Does it actually handle more?\nNit: I would change \"JLS\" to \"JLS 11\" in case later editions rewrite the section.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661633409", "createdAt": "2021-06-30T16:25:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzNDM3MQ==", "bodyText": "I am a bit confused by this code.  The 5th paragraph says that -- after capture conversion -- one should do a regular subtyping test.  Is this an optimization, because the subtyping test would boil down to isContainedMany?  Or is there another reason we need to diverge from the JLS text?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661634371", "createdAt": "2021-06-30T16:26:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph\n+    if (isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes)) {\n+      return true;\n+    }\n+    // 5th paragraph\n+    AnnotatedDeclaredType capturedSubtype =\n+        (AnnotatedDeclaredType) subtype.atypeFactory.applyCaptureConversion(subtype);\n+    return isContainedMany(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTA2Nw==", "bodyText": "Nit: the ordering of tests in this cascaded if is:\nsub && super\n!sub && !super && X\nsub && !super\nsuper && !sub\n!sub && !super && Y\nIt's a bit weird to see the two cases that include \"!sub && !super\" separated rather than appearing together (probably at the end).\nAlso, it might be helpful for documentation (and won't hurt performance) to make the omitted parts of the tests explicit, as I did above.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639067", "createdAt": "2021-06-30T16:33:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTcxOA==", "bodyText": "The cascaded if statement is not exhaustive:  control can fall through.  Why is that?  It might be clearer to make the handling of the final case when haveSameDeclaration is true explicit, unless it needs all the following logic in the method.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639718", "createdAt": "2021-06-30T16:34:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {\n+        Set<AnnotationMirror> superLBs =\n+            AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, supertype);\n+        AnnotationMirror superLB =\n+            qualifierHierarchy.findAnnotationInHierarchy(superLBs, currentTop);\n+        return qualifierHierarchy.isSubtype(subtype.getAnnotationInHierarchy(currentTop), superLB);\n+      } else if (supertypeHasAnno) {\n+        return qualifierHierarchy.isSubtype(\n+            subtype.getEffectiveAnnotationInHierarchy(currentTop),\n+            supertype.getAnnotationInHierarchy(currentTop));\n \n       } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTc1OA==", "bodyText": "Three lines below, a comment says \"one use of the type has an annotation and the other does not\", but I don't think that is possible because the previous two cases handled whenever one use has an annotation and one does not.  Can you double-check?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639758", "createdAt": "2021-06-30T16:34:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {\n+        Set<AnnotationMirror> superLBs =\n+            AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, supertype);\n+        AnnotationMirror superLB =\n+            qualifierHierarchy.findAnnotationInHierarchy(superLBs, currentTop);\n+        return qualifierHierarchy.isSubtype(subtype.getAnnotationInHierarchy(currentTop), superLB);\n+      } else if (supertypeHasAnno) {\n+        return qualifierHierarchy.isSubtype(\n+            subtype.getEffectiveAnnotationInHierarchy(currentTop),\n+            supertype.getAnnotationInHierarchy(currentTop));\n \n       } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n         // This case happens when a type has an intersection bound.  e.g.,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0MDI4Mw==", "bodyText": "Are these necessarily the same captured type variable, or might they be different ones?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661640283", "createdAt": "2021-06-30T16:34:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -845,6 +922,16 @@ public Boolean visitTypevar_Typevar(\n       }\n     }\n \n+    if (TypesUtils.isCapturedTypeVariable(subtype.getUnderlyingType())\n+        && TypesUtils.isCapturedTypeVariable(supertype.getUnderlyingType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0MDczNQ==", "bodyText": "Can you expand on this comment?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661640735", "createdAt": "2021-06-30T16:35:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -845,6 +922,16 @@ public Boolean visitTypevar_Typevar(\n       }\n     }\n \n+    if (TypesUtils.isCapturedTypeVariable(subtype.getUnderlyingType())\n+        && TypesUtils.isCapturedTypeVariable(supertype.getUnderlyingType())) {\n+      // TODO: Can this be removed?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0NDkyNw==", "bodyText": "The naming of visitTypevarSupertype and visitTypevarSubtype feels inconsistent with the rest of the class.  Usually a visit method name contains the types of its two arguments, so I expected these to be something like visitType_TypeVariable and visitTypeVariable_Type.  Can you explain the reason for the naming, or make it more consistent?  (I realize these are not overloads, but more consistency is still desirable if their names start with visit rather than, say, isSubtype.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661644927", "createdAt": "2021-06-30T16:41:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -988,46 +1075,57 @@ protected boolean visitTypevarSupertype(\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitTypevarSupertype will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n   protected boolean visitTypevarSubtype(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0NTk4MA==", "bodyText": "This code appears identically above (but for a variable name).  I think the method will be easier to read and understand  if you abstract out this logic into a method of its own.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661645980", "createdAt": "2021-06-30T16:42:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -988,46 +1075,57 @@ protected boolean visitTypevarSupertype(\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitTypevarSupertype will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n   protected boolean visitTypevarSubtype(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n+      // Make sure the upper bound is no wildcard or type variable.\n+      while (subtypeUpperBound.getKind() == TypeKind.TYPEVAR\n+          || subtypeUpperBound.getKind() == TypeKind.WILDCARD) {\n+        if (subtypeUpperBound.getKind() == TypeKind.TYPEVAR) {\n+          subtypeUpperBound = ((AnnotatedTypeVariable) subtypeUpperBound).getUpperBound();\n         }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n+        if (subtypeUpperBound.getKind() == TypeKind.WILDCARD) {\n+          subtypeUpperBound = ((AnnotatedWildcardType) subtypeUpperBound).getExtendsBound();\n         }\n       }\n       // If the supertype is an interface, only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of\n       // the type variable must not implement the interface.\n-      if (upperBound.getKind() == TypeKind.INTERSECTION) {\n+      if (subtypeUpperBound.getKind() == TypeKind.INTERSECTION) {\n         Types types = checker.getTypeUtils();\n-        for (AnnotatedTypeMirror ub : ((AnnotatedIntersectionType) upperBound).getBounds()) {\n+        for (AnnotatedTypeMirror bound :\n+            ((AnnotatedIntersectionType) subtypeUpperBound).getBounds()) {\n+          // Make sure the upper bound is no wildcard or type variable.\n+          while (bound.getKind() == TypeKind.TYPEVAR || bound.getKind() == TypeKind.WILDCARD) {\n+            if (bound.getKind() == TypeKind.TYPEVAR) {\n+              bound = ((AnnotatedTypeVariable) bound).getUpperBound();\n+            }\n+            if (bound.getKind() == TypeKind.WILDCARD) {\n+              bound = ((AnnotatedWildcardType) bound).getExtendsBound();\n+            }\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695"}, "originalPosition": 463}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ad2c1f03edf022de44d5b05c302c17d0a346ed6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5ad2c1f03edf022de44d5b05c302c17d0a346ed6", "committedDate": "2021-06-30T18:05:20Z", "message": "Some code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28c00e7b5796957e9cbee2855db687d12ed5709a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/28c00e7b5796957e9cbee2855db687d12ed5709a", "committedDate": "2021-06-30T19:10:58Z", "message": "Rename methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5aefe8c5a5e9c33372e683e53a6ebf1bd280c5b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e5aefe8c5a5e9c33372e683e53a6ebf1bd280c5b", "committedDate": "2021-06-30T19:22:56Z", "message": "Merge branch 'default-hierarchy-method-renames' into capture-conversion\n\n# Conflicts:\n#\tframework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88d5d7130e5dfa277f5acaf7abcb08a0107bb842", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/88d5d7130e5dfa277f5acaf7abcb08a0107bb842", "committedDate": "2021-06-30T20:08:18Z", "message": "Use new method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb57b605decef08f3d70750a933ab780d2e773e6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/eb57b605decef08f3d70750a933ab780d2e773e6", "committedDate": "2021-06-30T20:20:20Z", "message": "Add comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce49ceceba8ef87e2b29cf4ee318b5df65e32826", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ce49ceceba8ef87e2b29cf4ee318b5df65e32826", "committedDate": "2021-06-30T20:44:25Z", "message": "Fix the logic in visitTypevar_Typevar."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d8b23869e43705b89be8eb6a310cbd545db3b46", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8d8b23869e43705b89be8eb6a310cbd545db3b46", "committedDate": "2021-06-30T21:33:37Z", "message": "Correct javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6899b4ef6381ed0b2b940aa67d0c619a4bee47a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b6899b4ef6381ed0b2b940aa67d0c619a4bee47a", "committedDate": "2021-06-30T21:41:38Z", "message": "Comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a5ba28401ca7fe578711452c8a351b4e6028252", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6a5ba28401ca7fe578711452c8a351b4e6028252", "committedDate": "2021-06-30T21:44:28Z", "message": "Add comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92865d4ad71c44f8237e5709632584854a27317b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/92865d4ad71c44f8237e5709632584854a27317b", "committedDate": "2021-07-01T20:06:10Z", "message": "Fix guava crash."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b65aa451658473e7222de8cd6cdda1934e68af64", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b65aa451658473e7222de8cd6cdda1934e68af64", "committedDate": "2021-07-01T20:06:52Z", "message": "Merge branch 'guava-crash' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7948e931a8b0d09bfe249f19c13d87dc7e46ce4", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b7948e931a8b0d09bfe249f19c13d87dc7e46ce4", "committedDate": "2021-07-02T16:11:14Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion\n\n# Conflicts:\n#\tframework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0642850ddca3bab4eaddcdfe204605b0dd05b0a8", "committedDate": "2021-07-02T16:13:31Z", "message": "Rename method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2de7a95d3a4f0ca73753a02307993fa038f0de2e", "committedDate": "2021-07-06T21:07:03Z", "message": "Comment tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c4792794b1c3b18ed3ea470e1068ea45a6c224e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7c4792794b1c3b18ed3ea470e1068ea45a6c224e", "committedDate": "2021-07-06T21:14:19Z", "message": "Comment changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwMzc3Nzk4", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-700377798", "createdAt": "2021-07-06T21:00:14Z", "commit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMDoxNFrOJ6EvkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMToxMDozOVrOJ6FFnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NDg5Ng==", "bodyText": "I don't understand this @param.  Could you clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664874896", "createdAt": "2021-07-06T21:00:14Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -516,25 +548,48 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS 11: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph, bullet 2\n+    if (isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes)) {\n+      return true;\n+    }\n+    // 5th paragraph:\n+    // Instead of calling isSubtype with the captured type, just check for containment.\n+    AnnotatedDeclaredType capturedSubtype =\n+        (AnnotatedDeclaredType) subtype.atypeFactory.applyCaptureConversion(subtype);\n+    return isContainedMany(\n+        capturedSubtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes);\n+  }\n \n-      if (!result) {\n+  /**\n+   * Calls {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} on the two\n+   * lists of type arguments. Returns true if every type argument in {@code supertypeTypeArgs}\n+   * contains the type argument at the same index in {@code subtypeTypeArgs}.\n+   *\n+   * @param subtypeTypeArgs subtype arguments\n+   * @param supertypeTypeArgs supertype arguments\n+   * @param covariantArgIndexes with the type argument is covariant", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NTc5Nw==", "bodyText": "Above, line 815/888 says \"// subtype and supertype are uses of the same type parameter\".  If that is true, why cannot this line be just return true;?  Maybe a comment would help to clarify.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664875797", "createdAt": "2021-07-06T21:01:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -821,19 +894,21 @@ public Boolean visitTypevar_Typevar(\n         // as the bounds are the same.\n         return isPrimarySubtype(subtype, supertype);\n \n-      } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n+      } else if (!subtypeHasAnno && !supertypeHasAnno) {\n         // two unannotated uses of the same type parameter are of the same type\n-        return true;\n-\n-      } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-        // This case happens when a type has an intersection bound.  e.g.,\n-        // T extends A & B\n-        //\n-        // And one use of the type has an annotation and the other does not. e.g.,\n-        // @X T xt = ...;  T t = ..;\n-        // xt = t;\n-        //\n-        return visit(subtype.getUpperBound(), supertype.getLowerBound(), null);\n+        return areEqualInHierarchy(subtype, supertype);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 499}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NzQ1OA==", "bodyText": "I don't understand what \"will combine to isValid\" means.  Could you reword?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664877458", "createdAt": "2021-07-06T21:05:04Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1068,76 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 640}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3Nzg4NA==", "bodyText": "It's surprising to see supertype used here when the assignment is all about subtypes.  Can you use subtype here instead of superttype?  If not, why?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664877884", "createdAt": "2021-07-06T21:05:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1068,76 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 653}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3OTg3NQ==", "bodyText": "I'm not sure how this related no the code below, which is conditional.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664879875", "createdAt": "2021-07-06T21:09:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 674}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDAzNg==", "bodyText": "Is \"the actual type argument\" the same as subtype?  (I think not, but I'm not sure what it is.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664880036", "createdAt": "2021-07-06T21:09:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDU0MA==", "bodyText": "What is \"the type variable\"?  Is it subtype?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664880540", "createdAt": "2021-07-06T21:10:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of\n       // the type variable must not implement the interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 676}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "945b776c62f6dd5df5f6d7fa01c713882f746054", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/945b776c62f6dd5df5f6d7fa01c713882f746054", "committedDate": "2021-07-06T22:44:48Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6e5dbef0e13b69431ee5ab6e427e2d1338c920d", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c6e5dbef0e13b69431ee5ab6e427e2d1338c920d", "committedDate": "2021-07-06T22:47:24Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a6ed70557e0da60a5a4f92cf13374349a3907f19", "committedDate": "2021-07-06T22:48:38Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5811c8b5df8c9596912529834a758786ce0463e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e5811c8b5df8c9596912529834a758786ce0463e", "committedDate": "2021-07-06T22:55:18Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/63259e90bd1fdb1281d5749efd43fc679c18bf48", "committedDate": "2021-07-06T23:23:58Z", "message": "Tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2f8c3aaac4c37cca593eb32492564507bc875782", "committedDate": "2021-07-06T23:37:45Z", "message": "Undo string concatenation (due to bad merge?)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9da048e59720eea14f2b6b0facb92d43c76f5ef", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b9da048e59720eea14f2b6b0facb92d43c76f5ef", "committedDate": "2021-07-07T02:20:08Z", "message": "Improve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62a7d9c63bfa18e5c215350c9c53ada015dec15c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/62a7d9c63bfa18e5c215350c9c53ada015dec15c", "committedDate": "2021-07-07T02:20:20Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c69ca148b235f3c052f7f168fb547e3a99144943", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c69ca148b235f3c052f7f168fb547e3a99144943", "committedDate": "2021-07-07T02:22:56Z", "message": "Simplify a comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aefddea73160ccd452666f40f76b110e62ec5c71", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/aefddea73160ccd452666f40f76b110e62ec5c71", "committedDate": "2021-07-07T02:31:32Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25caabc965466cad5269b0c9c0a194a5337952bd", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/25caabc965466cad5269b0c9c0a194a5337952bd", "committedDate": "2021-07-07T02:47:04Z", "message": "Fix capitalization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5330fed2fd9a5231eba915dec4203978894d6e53", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5330fed2fd9a5231eba915dec4203978894d6e53", "committedDate": "2021-07-07T02:47:19Z", "message": "Renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6ea793ca42404487c25e812ccc57b1d4f3804f9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a6ea793ca42404487c25e812ccc57b1d4f3804f9", "committedDate": "2021-07-07T02:55:29Z", "message": "Tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDUwMzQz", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-700450343", "createdAt": "2021-07-06T23:13:25Z", "commit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxMzoyNVrOJ6ITrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMjozNDo1OFrOJ6MOiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzMzI5Mw==", "bodyText": "It looks like there is a typo on this line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664933293", "createdAt": "2021-07-06T23:13:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzMzY2Ng==", "bodyText": "These variable names are confusingly similar, given that one is from getTypeArguments and the other is from getTypeParameters.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664933666", "createdAt": "2021-07-06T23:14:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNDI5Nw==", "bodyText": "This is actually a type variable.  That is a type, but the comment could be more specific, and perhaps the variable name too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664934297", "createdAt": "2021-07-06T23:16:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds\n+   *\n+   * @param typeParameter type of {@code typeParameterTree}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNTI5Nw==", "bodyText": "I think that here and in the method above, this is only used as a location for error reporting.  If so, that might be helpful to state.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664935297", "createdAt": "2021-07-06T23:19:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds\n+   *\n+   * @param typeParameter type of {@code typeParameterTree}\n+   * @param typeParameterTree a type parameter tree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNzMzNQ==", "bodyText": "Does this test the tree (as the comment states), or does it just use the tree for error reporting?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664937335", "createdAt": "2021-07-06T23:25:09Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -4490,7 +4475,7 @@ public boolean validateTypeOf(Tree tree) {\n \n   /**\n    * Tests whether the type and corresponding type tree is a valid type, and emits an error if that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNzg2Mg==", "bodyText": "For efficiency, could break; after this statement, since the inner loop is now done.\nOr, to make this code clearer at the cost of a helper method, define a method to find the type corresponding to tree im.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664937862", "createdAt": "2021-07-06T23:26:56Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -525,13 +525,22 @@ public void processClassTree(ClassTree classTree) {\n \n     Tree ext = classTree.getExtendsClause();\n     if (ext != null) {\n-      validateTypeOf(ext);\n+      for (AnnotatedDeclaredType superType : classType.directSupertypes()) {\n+        if (superType.getUnderlyingType().asElement().getKind().isClass()) {\n+          validateType(ext, superType);\n+        }\n+      }\n     }\n \n     List<? extends Tree> impls = classTree.getImplementsClause();\n     if (impls != null) {\n       for (Tree im : impls) {\n-        validateTypeOf(im);\n+        for (AnnotatedDeclaredType superType : classType.directSupertypes()) {\n+          if (superType.getUnderlyingType().asElement().getKind().isInterface()\n+              && types.isSameType(superType.getUnderlyingType(), TreeUtils.typeOf(im))) {\n+            validateType(im, superType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzODYzOA==", "bodyText": "What situation is this testing for?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664938638", "createdAt": "2021-07-06T23:29:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -1378,21 +1387,17 @@ protected void checkConditionalPostcondition(\n \n   @Override\n   public Void visitTypeParameter(TypeParameterTree node, Void p) {\n-    validateTypeOf(node);\n-    // Check the bounds here and not with every TypeParameterTree.\n-    // For the latter, we only need to check annotations on the type variable itself.\n-    // Why isn't this covered by the super call?\n-    for (Tree tpb : node.getBounds()) {\n-      validateTypeOf(tpb);\n-    }\n-\n     if (node.getBounds().size() > 1) {\n       // The upper bound of the type parameter is an intersection\n       AnnotatedTypeVariable type =\n           (AnnotatedTypeVariable) atypeFactory.getAnnotatedTypeFromTypeTree(node);\n       AnnotatedIntersectionType intersection = (AnnotatedIntersectionType) type.getUpperBound();\n       checkExplicitAnnotationsOnIntersectionBounds(intersection, node.getBounds());\n     }\n+    if (TreeUtils.isClassTree(getCurrentPath().getParentPath().getLeaf())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzODkzNQ==", "bodyText": "Could you clarify \"made within\"?  I think I know what you mean, but I had to think about this phrase when I encountered it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664938935", "createdAt": "2021-07-06T23:29:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -3056,20 +3061,16 @@ protected void checkTypeArguments(\n       AnnotatedTypeParameterBounds bounds = paramBounds.get(i);\n       AnnotatedTypeMirror typeArg = typeargs.get(i);\n \n-      if (isIgnoredUninferredWildcard(bounds.getUpperBound())\n-          || isIgnoredUninferredWildcard(typeArg)) {\n+      if (typeArg.getKind() == TypeKind.WILDCARD) {\n+        // Even if the wildcard is outside the bound, it is made within the bound during", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk3NzMzMw==", "bodyText": "I don't understand the \"If\" here.  Is this a fact that is true, or will it be tested, or does something else depend on it?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664977333", "createdAt": "2021-07-07T01:35:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "diffHunk": "@@ -920,9 +922,32 @@ public AnnotatedDeclaredType asUse() {\n       }\n       AnnotatedDeclaredType result = this.shallowCopy(true);\n       result.declaration = false;\n+      if (this.enclosingType != null) {\n+        result.enclosingType = this.enclosingType.asUse();\n+      }\n       // setTypeArguments calls asUse on all the new type arguments.\n       result.setTypeArguments(typeArgs);\n \n+      // If \"this\" is a type declaration with a type variable that references itself, i.e. MyClass<T", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk3NzczNg==", "bodyText": "Please fill the paragraph, or add line breaks where appropriate.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664977736", "createdAt": "2021-07-07T01:36:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "diffHunk": "@@ -920,9 +922,32 @@ public AnnotatedDeclaredType asUse() {\n       }\n       AnnotatedDeclaredType result = this.shallowCopy(true);\n       result.declaration = false;\n+      if (this.enclosingType != null) {\n+        result.enclosingType = this.enclosingType.asUse();\n+      }\n       // setTypeArguments calls asUse on all the new type arguments.\n       result.setTypeArguments(typeArgs);\n \n+      // If \"this\" is a type declaration with a type variable that references itself, i.e. MyClass<T\n+      // extends List<T>>.\n+      // The type variable is a declaration, i.e. the first T, but the reference to the type\n+      // variable is a use, i.e the second T.  When", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk4MTM3MA==", "bodyText": "I'm confused by the formal parameter names wildcard and parent.  The fact that wildcard is a wildcard is not used by this method.  I'm also not clear why the type is named parent; what is it a parent of, or what is that trying to convey?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664981370", "createdAt": "2021-07-07T01:48:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/typeannotator/PropagationTypeAnnotator.java", "diffHunk": "@@ -207,26 +207,16 @@ private void applyAnnosFromBound(\n    */\n   private Element getTypeParamFromEnclosingClass(\n       final @FindDistinct AnnotatedWildcardType wildcard, final AnnotatedDeclaredType parent) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5MDgzNA==", "bodyText": "I suggest making these assertions (here and 2 lines down) into if (...) throw new BugInCF(), so we get earlier notification of problems.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664990834", "createdAt": "2021-07-07T02:14:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,103 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the glb of two annotated types.\n+   *\n+   * @param atypeFactory AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror greatestLowerBound(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#greatestLowerBound: unexpected java type: %s. type1: %s, type2: %s\",\n+          glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> setA =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> setB =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(setA, setB);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type1, bound);\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type2, bound);\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the\n+   * underlying java types are in a subtyping relationship.\n+   *\n+   * @param qualifierHierarchy QualifierHierarchy\n+   * @param subtype annotated types whose underlying type is a subtype of {@code supertype}\n+   * @param supertype annotated types whose underlying type is a supertype of {@code subtype}\n+   * @return the annotated greatest lower bound of {@code subtype} and {@code supertype}\n+   */\n+  private static AnnotatedTypeMirror glbSubtype(\n+      QualifierHierarchy qualifierHierarchy,\n+      AnnotatedTypeMirror subtype,\n+      AnnotatedTypeMirror supertype) {\n+    AnnotatedTypeMirror glb = subtype.deepCopy();\n+    glb.clearAnnotations();\n+\n+    for (AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\n+      AnnotationMirror subAnno = subtype.getAnnotationInHierarchy(top);\n+      AnnotationMirror superAnno = supertype.getAnnotationInHierarchy(top);\n+      if (subAnno != null && superAnno != null) {\n+        glb.addAnnotation(qualifierHierarchy.greatestLowerBound(subAnno, superAnno));\n+      } else if (subAnno == null && superAnno == null) {\n+        assert subtype.getKind() == TypeKind.TYPEVAR && supertype.getKind() == TypeKind.TYPEVAR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzUxMg==", "bodyText": "This method only manipulates the primary annotations.  The result might not be a subtype of the argument supertype (because of annotations other than primary annotations).  (This seems possible at the third and fourth call sites.)  Is this a bug or intended behavior?  Or is it impossible?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664997512", "createdAt": "2021-07-07T02:34:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,103 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the glb of two annotated types.\n+   *\n+   * @param atypeFactory the AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror greatestLowerBound(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#greatestLowerBound: unexpected java type: %s. type1: %s, type2: %s\",\n+          glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> setA =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> setB =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(setA, setB);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type1, bound);\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type2, bound);\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefddea73160ccd452666f40f76b110e62ec5c71"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc134ea336abff3de61cb40740332c841717dbcd", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/fc134ea336abff3de61cb40740332c841717dbcd", "committedDate": "2021-07-07T04:44:08Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3efa5cfcb10120cac11f9009a15a0481a7c5e07f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3efa5cfcb10120cac11f9009a15a0481a7c5e07f", "committedDate": "2021-07-07T14:20:54Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e5d0ba1521447499aecb2f7921d18a47ca5300a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8e5d0ba1521447499aecb2f7921d18a47ca5300a", "committedDate": "2021-07-07T15:28:14Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d7033004703fcd9eeaa4cdc912c45481f611f2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b4d7033004703fcd9eeaa4cdc912c45481f611f2", "committedDate": "2021-07-07T15:34:09Z", "message": "Code isn't needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9edb07e185d003a1671fc8120b55a84d8027597f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/9edb07e185d003a1671fc8120b55a84d8027597f", "committedDate": "2021-07-07T15:53:25Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f91f177b6b5b5659643f20240df35b0dc79dd94", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/4f91f177b6b5b5659643f20240df35b0dc79dd94", "committedDate": "2021-07-07T20:13:31Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93d8fd003f3284d04145f30c9a738416ad0d54c8", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/93d8fd003f3284d04145f30c9a738416ad0d54c8", "committedDate": "2021-07-07T20:13:46Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "930c6f13a51f5eadac44b66c5a7af9de84de62e9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/930c6f13a51f5eadac44b66c5a7af9de84de62e9", "committedDate": "2021-07-07T20:14:20Z", "message": "Use new method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fccd7a1d93230de84ad7d0f0d14f0ea9e8abb5c", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5fccd7a1d93230de84ad7d0f0d14f0ea9e8abb5c", "committedDate": "2021-07-07T22:41:47Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "354a05da8b2ee5e485c9a21ca69918b1b9bdde37", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/354a05da8b2ee5e485c9a21ca69918b1b9bdde37", "committedDate": "2021-07-07T22:46:51Z", "message": "Fix testcase."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef727b2946a7e1332fba1934d0d940765dedc0ef", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ef727b2946a7e1332fba1934d0d940765dedc0ef", "committedDate": "2021-07-07T22:57:50Z", "message": "Expand comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e84f8a22eb2572cfc7f683c903d375a043db2a53", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e84f8a22eb2572cfc7f683c903d375a043db2a53", "committedDate": "2021-07-08T17:12:49Z", "message": "Tweak comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e21f05edbb13efdee7c8fb4d61674b9635c808a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0e21f05edbb13efdee7c8fb4d61674b9635c808a", "committedDate": "2021-07-08T17:17:43Z", "message": "Tweak comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fd725a59d2491a1b1558a5dd7a43c084d017299", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0fd725a59d2491a1b1558a5dd7a43c084d017299", "committedDate": "2021-07-08T17:18:37Z", "message": "Tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "327d76588cee832a7d48c42c46fb416ad7f00be3", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/327d76588cee832a7d48c42c46fb416ad7f00be3", "committedDate": "2021-07-08T20:12:51Z", "message": "Tweak comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8d385a4d463566b1287a519f9e9885b90b57e49", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b8d385a4d463566b1287a519f9e9885b90b57e49", "committedDate": "2021-07-08T21:14:48Z", "message": "Add missing error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d31e5407bccfde5e35c7874c96cb1335b41f1688", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d31e5407bccfde5e35c7874c96cb1335b41f1688", "committedDate": "2021-07-08T21:15:48Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9944488e5b971d2506b4a20ce0a28f4061016ccf", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/9944488e5b971d2506b4a20ce0a28f4061016ccf", "committedDate": "2021-07-09T17:10:33Z", "message": "Correct bounds."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98935531e12113a831bde8ad729f4b0a36ecb66b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/98935531e12113a831bde8ad729f4b0a36ecb66b", "committedDate": "2021-07-09T17:10:57Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea3e31bab54f21fa22247e50874f52906eb745a3", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ea3e31bab54f21fa22247e50874f52906eb745a3", "committedDate": "2021-07-09T17:35:01Z", "message": "Delete comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69cd42bb4aff1fd33942310be0aaa98ed11fad22", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/69cd42bb4aff1fd33942310be0aaa98ed11fad22", "committedDate": "2021-07-09T19:11:04Z", "message": "Fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "770c0ff0edb4b0366a66a80b57ce3b065fe36edd", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/770c0ff0edb4b0366a66a80b57ce3b065fe36edd", "committedDate": "2021-07-09T22:28:08Z", "message": "Suppress warning."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fa4e1bd08d6a3793c1f2e792684abbbb5f0eb8e", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/1fa4e1bd08d6a3793c1f2e792684abbbb5f0eb8e", "committedDate": "2021-07-09T22:28:34Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00908c37706abe8c53b8c624e999c2dd5bd31dd4", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/00908c37706abe8c53b8c624e999c2dd5bd31dd4", "committedDate": "2021-07-12T20:01:11Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dfab48650e736a433e393ac77b6985a5552a41c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0dfab48650e736a433e393ac77b6985a5552a41c", "committedDate": "2021-07-12T21:18:32Z", "message": "Tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0NTUzNzk0", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-704553794", "createdAt": "2021-07-12T21:20:05Z", "commit": {"oid": "0dfab48650e736a433e393ac77b6985a5552a41c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQyMToyMDowNVrOJ9TouA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQyMToyMDowNVrOJ9TouA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODI2NDYzMg==", "bodyText": "I think this handles cases 1, 2, and 3: anytime the two types have a subtyping relationship.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r668264632", "createdAt": "2021-07-12T21:20:05Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,138 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the \"annotated greatest lower bound\" of {@code type1} and {@code type2}.\n+   *\n+   * <p>Suppose that there is an expression e with annotated type T. The underlying type of T must\n+   * be the same as javac's type for e. (This is a requirement of the Checker Framework.) As a\n+   * corollary, when computing a glb of atype1 and atype2, it is required that\n+   * underlyingType(cfGLB(atype1, atype2) == glb(javacGLB(underlyingType(atype1),\n+   * underlyingType(atype2)). Because of this requirement, the return value of this method (the\n+   * \"annotated GLB\") may not be a subtype of one of the types.\n+   *\n+   * <p>The \"annotated greatest lower bound\" is defined as follows:\n+   *\n+   * <ol>\n+   *   <li>If the underlying type of {@code type1} and {@code type2} are the same, then return a\n+   *       copy of {@code type1} whose primary annotations are the greatest lower bound of the\n+   *       primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} is a subtype of the underlying type of {@code\n+   *       type2}, then return a copy of {@code type1} whose primary annotations are the greatest\n+   *       lower bound of the primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} is a supertype of the underlying type of {@code\n+   *       type2}, then return a copy of {@code type2} whose primary annotations are the greatest\n+   *       lower bound of the primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} and {@code type2} are not in a subtyping\n+   *       relationship, then return an annotated intersection type whose bounds are {@code type1}\n+   *       and {@code type2}.\n+   * </ol>\n+   *\n+   * @param atypeFactory the AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the annotated glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror annotatedGLB(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#annotatedGLB: expected intersection, got [%s] %s. \"\n+              + \"type1: %s, type2: %s\",\n+          glbJava.getKind(), glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> set1 =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> set2 =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(set1, set2);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    List<AnnotatedTypeMirror> newBounds = new ArrayList<>(2);\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        newBounds.add(type1.deepCopy());\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        newBounds.add(type2.deepCopy());\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.setBounds(newBounds);\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the\n+   * underlying Java types are in a subtyping relationship.\n+   *\n+   * <p>This handles cases 2 and 3 mentioned in the Javadoc of {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dfab48650e736a433e393ac77b6985a5552a41c"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff9870d0d925fe6f5a9d853f5382d3e29caa70f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8ff9870d0d925fe6f5a9d853f5382d3e29caa70f", "committedDate": "2021-07-12T23:01:17Z", "message": "Tweak."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55dee59990b9013b382bb7f4e37b1726299da98f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/55dee59990b9013b382bb7f4e37b1726299da98f", "committedDate": "2021-04-14T22:41:44Z", "message": "Copy the enclosing type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77f7f9a1ae24815853e105ae92b948585a9def57", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/77f7f9a1ae24815853e105ae92b948585a9def57", "committedDate": "2021-04-14T22:49:22Z", "message": "Check for null."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae766a8277775a4243f9e5084c96f4c5bcaf9772", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ae766a8277775a4243f9e5084c96f4c5bcaf9772", "committedDate": "2021-04-16T16:38:01Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d32649a74c5b4aaf752985eed25d5814d98fd6e7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d32649a74c5b4aaf752985eed25d5814d98fd6e7", "committedDate": "2021-04-16T18:00:16Z", "message": "Add expected error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8494ec810bdd9edbe3f0d2fdc9a43f244d9dbf44", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8494ec810bdd9edbe3f0d2fdc9a43f244d9dbf44", "committedDate": "2021-04-16T19:12:31Z", "message": "Checkpoint."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75a417e00b8f497129308b7a71994d73ef89c8cd", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/75a417e00b8f497129308b7a71994d73ef89c8cd", "committedDate": "2021-04-16T21:52:02Z", "message": "Checkpoint."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3df470bc263077c051b195f0be5d781703787e55", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3df470bc263077c051b195f0be5d781703787e55", "committedDate": "2021-04-19T19:33:27Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e5b570f3fae540865d70aed5a75a3ddc5ac2e4a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/1e5b570f3fae540865d70aed5a75a3ddc5ac2e4a", "committedDate": "2021-04-21T20:59:21Z", "message": "Final fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34d289421b9d4012d4e0bbe396be7726ebfe04b1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/34d289421b9d4012d4e0bbe396be7726ebfe04b1", "committedDate": "2021-04-21T21:01:41Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa90c859d0dc050fdd4b9114ea8122c0fd4bcc65", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/fa90c859d0dc050fdd4b9114ea8122c0fd4bcc65", "committedDate": "2021-04-21T21:17:19Z", "message": "Javadoc tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f7643fb78b045b2461d963ae17d83e0cfd9b6ad", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5f7643fb78b045b2461d963ae17d83e0cfd9b6ad", "committedDate": "2021-04-21T21:40:00Z", "message": "Remove BoundType."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27f87f7df1ee3f07ea63d6ab17f00e4cc6d4e8a9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/27f87f7df1ee3f07ea63d6ab17f00e4cc6d4e8a9", "committedDate": "2021-04-21T22:29:11Z", "message": "Add todo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f7d1e90f6cecacce57b11b34fe020d7fe07798e", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0f7d1e90f6cecacce57b11b34fe020d7fe07798e", "committedDate": "2021-04-22T16:34:49Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6465836633267f6ef58248d52ef031597e4f398b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6465836633267f6ef58248d52ef031597e4f398b", "committedDate": "2021-04-26T19:28:26Z", "message": "Make type variable reference itself."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13feec024a5717ef4d81d54126b29a1db6bb04e9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/13feec024a5717ef4d81d54126b29a1db6bb04e9", "committedDate": "2021-04-26T19:50:08Z", "message": "Update test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d790c82d55571232b307006fd95efc9f65dd6403", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d790c82d55571232b307006fd95efc9f65dd6403", "committedDate": "2021-04-26T20:14:05Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad741c476594d4b15e75cd9a04a869c8a9b15f56", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ad741c476594d4b15e75cd9a04a869c8a9b15f56", "committedDate": "2021-05-03T16:02:23Z", "message": "Checkpoint."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edfe3f6241a95a0d2823f8c07b68286e77eccd36", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/edfe3f6241a95a0d2823f8c07b68286e77eccd36", "committedDate": "2021-05-24T16:38:09Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion\n\n# Conflicts:\n#\tchecker/tests/guieffect/ThrowCatchTest.java\n#\tchecker/tests/nullness/Issue2048.java\n#\tchecker/tests/nullness/generics/WildcardOverride.java\n#\tchecker/tests/nullness/generics/WildcardSubtyping.java\n#\tchecker/tests/nullness/java8/methodref/GroundTargetTypeLub.java\n#\tframework/tests/defaulting/lowerbound/LowerBoundDefaulting.java\n#\tframework/tests/defaulting/upperbound/UpperBoundDefaulting.java\n#\tframework/tests/h1h2checker/InferTypeArgsPolyChecker.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe7924ddae7e21c1d0c6afeb4aafb67f21e5f99b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/fe7924ddae7e21c1d0c6afeb4aafb67f21e5f99b", "committedDate": "2021-05-28T16:16:21Z", "message": "No crashes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "954ba19d0c653c80028ee70881890e3d5356c2a1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/954ba19d0c653c80028ee70881890e3d5356c2a1", "committedDate": "2021-06-01T18:04:30Z", "message": "Add comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6771ef0c7271eec6cff1160a74278bd17b2be080", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6771ef0c7271eec6cff1160a74278bd17b2be080", "committedDate": "2021-06-02T16:40:23Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfc1177cee98c7b4445ab8467d876215d957e9d7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/bfc1177cee98c7b4445ab8467d876215d957e9d7", "committedDate": "2021-06-02T20:19:13Z", "message": "Rewrite order."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ebd4d2693a266724453945002225a87d496c7a8", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6ebd4d2693a266724453945002225a87d496c7a8", "committedDate": "2021-06-02T20:26:44Z", "message": "Fix error messages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4335b9ba31b5102d125afa476b9f8aa140437d5e", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/4335b9ba31b5102d125afa476b9f8aa140437d5e", "committedDate": "2021-06-02T21:46:33Z", "message": "Fix error message."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf822de6a4ad12133fb20bf5768ff0a4e380f3f1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/cf822de6a4ad12133fb20bf5768ff0a4e380f3f1", "committedDate": "2021-06-03T16:42:40Z", "message": "Fix crash."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b5b61bc52284ffb21020f7c1795a41f2b709705", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7b5b61bc52284ffb21020f7c1795a41f2b709705", "committedDate": "2021-06-03T17:37:29Z", "message": "Fix error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96b96bc6093a345b371dd4df9e2a15db8cacec78", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/96b96bc6093a345b371dd4df9e2a15db8cacec78", "committedDate": "2021-06-03T18:12:29Z", "message": "Fix crash."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7adb787d50bfdfb32049ff69b5df950e3f71d69d", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7adb787d50bfdfb32049ff69b5df950e3f71d69d", "committedDate": "2021-06-03T19:47:03Z", "message": "Put back a workaround that is still needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f37c4d90d27c6d1864969d11a92424f78993376", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2f37c4d90d27c6d1864969d11a92424f78993376", "committedDate": "2021-06-04T22:56:51Z", "message": "Add some debugging."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f702f6c1295d0cd07b54d92b072f273330542dd", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2f702f6c1295d0cd07b54d92b072f273330542dd", "committedDate": "2021-06-07T16:03:35Z", "message": "Revert \"Add some debugging.\"\n\nThis reverts commit 2f37c4d90d27c6d1864969d11a92424f78993376."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b60219ea61dc6e7717beb1f2f8a4145fa620b92", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8b60219ea61dc6e7717beb1f2f8a4145fa620b92", "committedDate": "2021-06-07T16:28:21Z", "message": "asUse on enclosing type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0aa2a62789537234b7287e7415dfc578649aa3f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d0aa2a62789537234b7287e7415dfc578649aa3f", "committedDate": "2021-06-07T16:34:57Z", "message": "Add test case for last fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85403e63b40fc50c6abd6be093b61853b60e9cb1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/85403e63b40fc50c6abd6be093b61853b60e9cb1", "committedDate": "2021-06-07T20:40:37Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f22dcfb3c3e55bc60a19b6a1bca9dbccce37a823", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f22dcfb3c3e55bc60a19b6a1bca9dbccce37a823", "committedDate": "2021-06-07T21:10:07Z", "message": "Move to named class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fe4c5de0ac90475eddc1b2facb283a2bf3f4057", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0fe4c5de0ac90475eddc1b2facb283a2bf3f4057", "committedDate": "2021-06-07T21:41:31Z", "message": "Simplify."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a30a04d7691095624e0d47807ecbd6da88db3d9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0a30a04d7691095624e0d47807ecbd6da88db3d9", "committedDate": "2021-06-07T21:46:56Z", "message": "Add a warning suppression."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b01969c344fd61f2b67ce76992ca10036a9e681d", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b01969c344fd61f2b67ce76992ca10036a9e681d", "committedDate": "2021-06-07T22:18:22Z", "message": "Add comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92bbaa12a582d8da2f756d6a2c9928e4d28ba9d2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/92bbaa12a582d8da2f756d6a2c9928e4d28ba9d2", "committedDate": "2021-06-07T22:48:34Z", "message": "Add javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77a24ee479a2ee4efd4291b7a67f7fb7f6c54f30", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/77a24ee479a2ee4efd4291b7a67f7fb7f6c54f30", "committedDate": "2021-06-07T23:17:52Z", "message": "Add Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f22973f340c8f87ca5588683d9793bc58d165094", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f22973f340c8f87ca5588683d9793bc58d165094", "committedDate": "2021-06-08T16:17:24Z", "message": "Add Javdoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d07bac9d20f5f54f5ab16ec7e6297c7917d6003", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7d07bac9d20f5f54f5ab16ec7e6297c7917d6003", "committedDate": "2021-06-08T16:28:58Z", "message": "Always use version 1.7 of Google Java Format."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6465db3099c8e8ebc679f1f33f8e65d2dfe06cce", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6465db3099c8e8ebc679f1f33f8e65d2dfe06cce", "committedDate": "2021-06-08T16:43:44Z", "message": "Don't run formatting on Java 8."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8b3787b84f00dd700233f87f6dff9279eba9b0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5b8b3787b84f00dd700233f87f6dff9279eba9b0", "committedDate": "2021-06-08T16:49:00Z", "message": "Revert \"Always use version 1.7 of Google Java Format.\"\n\nThis reverts commit 7d07bac9d20f5f54f5ab16ec7e6297c7917d6003."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85796b6e96410f9acfc477507371ab9577ec2055", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/85796b6e96410f9acfc477507371ab9577ec2055", "committedDate": "2021-06-08T16:49:07Z", "message": "Merge branch 'gjf2' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b304a0e3248e654c853cef4a88358bea1e3a8f92", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b304a0e3248e654c853cef4a88358bea1e3a8f92", "committedDate": "2021-06-08T16:58:03Z", "message": "Reformat."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49fb276836839ca39c3f3045a6d4bd730598f5f0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/49fb276836839ca39c3f3045a6d4bd730598f5f0", "committedDate": "2021-06-08T17:17:21Z", "message": "Add comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76394047a9b919f44984bf0174ee6433130f5259", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/76394047a9b919f44984bf0174ee6433130f5259", "committedDate": "2021-06-08T18:26:23Z", "message": "Fix comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ca4ee2ef0194c22d9335f098a0a0ae2180a65b6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3ca4ee2ef0194c22d9335f098a0a0ae2180a65b6", "committedDate": "2021-06-08T19:18:22Z", "message": "Tweak comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425a9605ecc6c5f111ee512b6dea34e6e65759c9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/425a9605ecc6c5f111ee512b6dea34e6e65759c9", "committedDate": "2021-06-08T22:21:27Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion\n\n# Conflicts:\n#\tbuild.gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0eeeaa86486cb165bd78f9be1a342eae0e852ac", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a0eeeaa86486cb165bd78f9be1a342eae0e852ac", "committedDate": "2021-06-10T18:20:08Z", "message": "Use NullType for the type of default values."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b2cbc8a42d611d37772b09cd21ae04e70c4b57c", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8b2cbc8a42d611d37772b09cd21ae04e70c4b57c", "committedDate": "2021-06-10T18:24:52Z", "message": "Add test case."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d409f0898997f81df1eee9103af8a2ae2e4ec7b7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d409f0898997f81df1eee9103af8a2ae2e4ec7b7", "committedDate": "2021-06-10T19:54:45Z", "message": "Merge branch 'default-value' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0540668c191e38670c6c52a774da997594687c51", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0540668c191e38670c6c52a774da997594687c51", "committedDate": "2021-06-10T23:01:38Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNDU2ODc3", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-682456877", "createdAt": "2021-06-14T00:04:34Z", "commit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNDozNFrOJsdLng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNzoyMlrOJsda4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTIzMA==", "bodyText": "The @param Javadoc merely restate the type, which does not supply any information.  Please try to provide more information, such as what it represents or where it is from or other facts about it.  That will make the code easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595230", "createdAt": "2021-06-14T00:04:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNA==", "bodyText": "What change to the code will be made?  Will this method be eliminated, or is this comment about some part of the method body?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595434", "createdAt": "2021-06-14T00:06:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNg==", "bodyText": "Why is this a normal return?  That is, why does this situation not indicate a bug?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595436", "createdAt": "2021-06-14T00:06:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.\n+    // See Issue #979.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();\n+      if (originalTypeArg.containsUninferredTypeArguments()) {\n+        return typeVarMapping;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTgxNQ==", "bodyText": "These conditions are introduced without preamble or segue.  I first interpreted them as method preconditions, but after reading the implementation it seems more likely that they are laying out the method's algorithm.  (Neither can be correct, because for this line, violation of one of the conditions leads to return false but violation of the other leads to throw new BugInCF.)  Could you please clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595815", "createdAt": "2021-06-14T00:09:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjAxNA==", "bodyText": "Please state the relationship between type and typeMirror.  From examining calls, I think that typeMirror must correspond to type and must be a captured type (that is, those are preconditions of the method).", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596014", "createdAt": "2021-06-14T00:10:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjE3NA==", "bodyText": "The name capturedTypeMirror was unclear to me when first reading this.  On subsequent readings and after examining call sites, it makes more sense, but could you add documentation and/or renamings to clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596174", "createdAt": "2021-06-14T00:11:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw==", "bodyText": "The past tense name wasRaw is in conflict with the present tense documentation \"must not be a raw type\".  (I guess it must not have been written by the programmer as a raw type, even if the type as provided to this method is not raw.  Is that correct?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596703", "createdAt": "2021-06-14T00:16:14Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Njk3OQ==", "bodyText": "\"generic\" always refers to a type declaration, which has type variables, not type arguments.\nI think that \"generic\" here should be \"parameterized\".  The same comment applies to the other overload of this method.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596979", "createdAt": "2021-06-14T00:18:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzA0MA==", "bodyText": "This information would be useful in the documentation for shouldCapture.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597040", "createdAt": "2021-06-14T00:19:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzE5OA==", "bodyText": "The notion of uninferred wildcards is not in JLS 5.1.10.  Where is a description of the variant that this method computes?  Or are uninferred wildcards always replaced by inferred wildcards before this method terminates?  (In that case, the algorithm differs from 5.1.10 but the result does not.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597198", "createdAt": "2021-06-14T00:20:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzU0NQ==", "bodyText": "Maybe it would be more descriptive to name this copyNonWildcardTypeArgs or NonWildcardTypeArgCopier, which describes what it does rather than where it is used.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597545", "createdAt": "2021-06-14T00:23:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final CaptureTypeArgCopier captureTypeArgCopier = new CaptureTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they are refer to\n+   * the same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class CaptureTypeArgCopier extends AnnotatedTypeCopier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 474}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzY0MA==", "bodyText": "What is the relationship between uncapturedType.getUnderlyingType() on this line and local variable capturedTypeMirror?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597640", "createdAt": "2021-06-14T00:24:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 387}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Nzc5NA==", "bodyText": "Regarding \"the captured type\":  I think this method applyCaptureConversion is capturing a single type, which I would call \"the captured type\".  Is this a mapping for the type variables of that type, rather than a mapping from whole captured types?  I may be confused, but please clarify.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597794", "createdAt": "2021-06-14T00:26:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODY5Mg==", "bodyText": "The Javadoc of TypesUtils.isCaptured says \"Returns whether a TypeVariable represents a captured type.\" but I think it is actually whether the type variable comes from a wildcard.  The type variable is part of a captured type but is not itself a captured type.  Although javac's Type.java poorly uses the name isCaptured, I think that TypesUtils should use something more descriptive, such as isCapturedTypeVariable or isTypeVariableFromCaptureConversion or the like.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598692", "createdAt": "2021-06-14T00:33:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODk1OQ==", "bodyText": "Is this \"If\" something that is definitely true when control reaches this point (in which case \"If\" is not appropriate), or is it describing some conditional effect of the immediately following code (in which case I need a bit more guidance to understand it)?\nAlso, please don't use passive voice \"it is converted\".  Please state the actor, which will also make the comment easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598959", "createdAt": "2021-06-14T00:35:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODk5MA==", "bodyText": "I think \"captured type\" should be \"wildcard\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598990", "createdAt": "2021-06-14T00:36:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5OTEzNw==", "bodyText": "\"each captured type\":  This method only captures one type.  Are you talking about the type variables that were constructed to stand in for wildcards -- that is, any type argument that changed as a result of capture conversion?  Maybe we need terminology for them, but \"captured type\" seems wrong.  This naming choice may be related to my comment about isCaptured.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650599137", "createdAt": "2021-06-14T00:37:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 432}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f5f11367c9497616fac8be5eb2fccc72f34bba1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5f5f11367c9497616fac8be5eb2fccc72f34bba1", "committedDate": "2021-06-14T00:39:49Z", "message": "Comment edits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a234980fab80ef9f7d30f253891be67107b861dc", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a234980fab80ef9f7d30f253891be67107b861dc", "committedDate": "2021-06-14T00:39:57Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14e81d5caf4118ef38890a5461d4ac25f4b9eccc", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/14e81d5caf4118ef38890a5461d4ac25f4b9eccc", "committedDate": "2021-06-14T16:42:50Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "772369c58f1d17f0e4a106889b30221d53c3de03", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/772369c58f1d17f0e4a106889b30221d53c3de03", "committedDate": "2021-06-14T22:39:23Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb010e108f406beedb44d9cf2727e88e3a9f47d3", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/eb010e108f406beedb44d9cf2727e88e3a9f47d3", "committedDate": "2021-06-14T22:42:26Z", "message": "Rename isCaptured."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "165aefcbc0a5d72e90fb095a381e297baca4ab59", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/165aefcbc0a5d72e90fb095a381e297baca4ab59", "committedDate": "2021-06-14T22:42:46Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70e0b94dd5f63e7e131e74faf4348273956214c4", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/70e0b94dd5f63e7e131e74faf4348273956214c4", "committedDate": "2021-06-14T22:56:39Z", "message": "Use captured type variable."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b70b8247424d7e30b929ef6d73b311d9e21b387", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0b70b8247424d7e30b929ef6d73b311d9e21b387", "committedDate": "2021-06-14T23:02:16Z", "message": "Address one more comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78869d7905c464cade8091c0aef6b1ea5a1d894f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/78869d7905c464cade8091c0aef6b1ea5a1d894f", "committedDate": "2021-06-14T23:21:25Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e2d40c4714b402adccdc6e18b24309d1f62f3f03", "committedDate": "2021-06-15T16:14:12Z", "message": "Add Javadoc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg0MjE5MTQ0", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-684219144", "createdAt": "2021-06-15T16:16:49Z", "commit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoxNjo0OVrOJtvxqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozOToyNVrOJtw5vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk0ODQ1Nw==", "bodyText": "As a matter of style, I think a Map.Entry loop body is clearer when the getKey() invocation is on the first line and the getValue() invocation is on the second line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651948457", "createdAt": "2021-06-15T16:16:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,70 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding\n+   *     type argument at the method invocation\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping from type variable in the method declaration to its captured type argument.\n+   *     For a non-wildcard, Capture conversion is the identity. Its keys are the same as in {@code\n+   *     typeVarMapping}, and the values are their captures (capture conversion may be the\n+   *     identity).\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference and this method should be removed when\n+    // #979 is fixed.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    // `newTypeVarMapping` is the result of this method.\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1NDQ2MQ==", "bodyText": "Since the uncaptured type is the first formal parameter, I would swap the order of this assignment and the previous one.  I think that makes the code a bit more uniform and easier to read.  I made similar changes in a number of other places in the code.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651954461", "createdAt": "2021-06-15T16:23:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1NDg4Nw==", "bodyText": "The name may be fine after all (now that I understand it), but updating the documentation would still be useful.  Thanks.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651954887", "createdAt": "2021-06-15T16:24:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1ODIzMw==", "bodyText": "A variable named \"Mapping\" or \"Map\" reiterates the type and thus adds no new information.  I had to keep referring back to the comments to understand uses of these variables.  Can you give them more descriptive names?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651958233", "createdAt": "2021-06-15T16:27:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 393}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1OTI4NA==", "bodyText": "\"capturing the wildcard\" is funny terminology; consider rewording, per our earlier discussion.\nAlso, where does the \"capturing the wildcard\" occur?  It would be helpful for this comment to be more explicit.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651959284", "createdAt": "2021-06-15T16:29:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 407}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1OTk0MQ==", "bodyText": "These two lines are the same in the then clause.  Can this code be hoisted out of the if statement?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651959941", "createdAt": "2021-06-15T16:29:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MDY3MA==", "bodyText": "What is the relationship between typeVar.getUnderlyingType() and typeVarTypeMirror?  I'm unclear whether this is replacing a mapping or is adding a new mapping.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651960670", "createdAt": "2021-06-15T16:30:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MTk2MQ==", "bodyText": "List has a set method.  Is there a reason not to use it here?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651961961", "createdAt": "2021-06-15T16:32:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 451}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MjY4Nw==", "bodyText": "This is a confusing location for a comment.  If it refers to the line above, put it before that line.  If it refers to the line below, remove the separating whitespace and maybe add whitespace before the comment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651962687", "createdAt": "2021-06-15T16:33:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 455}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2Mzk0MQ==", "bodyText": "Here and below, why does the comment use @code instead of @link?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651963941", "createdAt": "2021-06-15T16:35:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NTQwMA==", "bodyText": "copyArg sounds like an action.  I would use copyOfArg or copiedArg or argCopy.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651965400", "createdAt": "2021-06-15T16:37:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NjE0NQ==", "bodyText": "Please put comments above the code that they refer to.  (That is the standard convention.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651966145", "createdAt": "2021-06-15T16:38:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);\n+          if (copyArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyArg).getUnderlyingType(), copyArg);\n+          }\n+          newTypeArgs[i] = copyArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap\n+      // created above.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          // Note: this if statement can't be replaced with if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 521}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NjkwOQ==", "bodyText": "I would change \"contain\" to \"lexically contain\" (if that is true!) to distinguish from the JLS notion of type containment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651966909", "createdAt": "2021-06-15T16:39:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);\n+          if (copyArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyArg).getUnderlyingType(), copyArg);\n+          }\n+          newTypeArgs[i] = copyArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap\n+      // created above.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          // Note: this if statement can't be replaced with if\n+          // (TypesUtils.isCapturedTypeVariable(capturedArg))\n+          // because if the bounds of the captured wildcard are equal, then instead of a captured\n+          // wildcard, the type of the bound is used.\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set captureType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that eachtype variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not contain any other type in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 561}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52c98ec422c556447241e115687b4799c122dbf9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/52c98ec422c556447241e115687b4799c122dbf9", "committedDate": "2021-06-15T17:05:13Z", "message": "Code review changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88743527d393837ba120765bd79685a743c442fa", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/88743527d393837ba120765bd79685a743c442fa", "committedDate": "2021-06-15T17:05:27Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "384a9e543c1efc9b84db5cac458897c8eccfc440", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/384a9e543c1efc9b84db5cac458897c8eccfc440", "committedDate": "2021-06-15T17:49:30Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676491b405a716fd1ce57f88945d9e93009fe968", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/676491b405a716fd1ce57f88945d9e93009fe968", "committedDate": "2021-06-15T17:49:39Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f64e79068ebc742db8e22281e27fe8b899e5a18f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f64e79068ebc742db8e22281e27fe8b899e5a18f", "committedDate": "2021-06-15T21:38:25Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95d6e36fc863289127ec490d0be8db5e3f249859", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/95d6e36fc863289127ec490d0be8db5e3f249859", "committedDate": "2021-06-16T16:06:55Z", "message": "More code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56d0efebe56a93f466dad80008f71fdbf41d46b8", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/56d0efebe56a93f466dad80008f71fdbf41d46b8", "committedDate": "2021-06-16T16:07:22Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19f99351ac319940f9a82b9c8a146e6d2b89a7f2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/19f99351ac319940f9a82b9c8a146e6d2b89a7f2", "committedDate": "2021-06-16T17:05:58Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8915d79c4c5b4538d797c0bf7f3f1e578c8c682", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a8915d79c4c5b4538d797c0bf7f3f1e578c8c682", "committedDate": "2021-06-16T17:13:18Z", "message": "Fix javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba975917939e092e254670f663520fd0b32df2df", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ba975917939e092e254670f663520fd0b32df2df", "committedDate": "2021-06-17T00:49:25Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/17181277aa647d378ebc27e30438023845eafe7a", "committedDate": "2021-06-17T15:34:27Z", "message": "Rename variables, tweak comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c24683b649f1295977246d51722df7626ed67fa9", "committedDate": "2021-06-17T16:18:02Z", "message": "Tweak logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbf7d05df7d953012f508ed42251466bf1463513", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/dbf7d05df7d953012f508ed42251466bf1463513", "committedDate": "2021-06-17T16:27:34Z", "message": "Comment tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb5d5dca3d399b793207d51f98eddc213ee6d3e4", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cb5d5dca3d399b793207d51f98eddc213ee6d3e4", "committedDate": "2021-06-17T16:30:04Z", "message": "Tweak formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg2NDY5NDEy", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-686469412", "createdAt": "2021-06-17T15:32:32Z", "commit": {"oid": "ba975917939e092e254670f663520fd0b32df2df"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozMjozMlrOJvZjtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyOToyM1rOJvcZmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4MTU4OQ==", "bodyText": "Variable names like typeVarMapping and newTypeVarMapping are not very informative.  (I realize that existing code in this class does use such names.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653681589", "createdAt": "2021-06-17T15:32:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,72 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba975917939e092e254670f663520fd0b32df2df"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4MTYyNg==", "bodyText": "Is this exactly the keys of typeVarMapping, but in order?  If so, please document that.  In that case, is this formal parameter needed?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653681626", "createdAt": "2021-06-17T15:32:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,72 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding\n+   *     type argument at the method invocation\n+   * @param declTypeVar list of type variable declarations in the method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba975917939e092e254670f663520fd0b32df2df"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDA2OQ==", "bodyText": "What is the reason for the requirement that the underlying type is not raw?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653684069", "createdAt": "2021-06-17T15:35:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDkyMA==", "bodyText": "I think it's the case that either:\n\nits underlying type is a wildcard, or\nit has a wildcard as a type argument.\n\nCould you document whichever of these (or some other fact) is true?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653684920", "createdAt": "2021-06-17T15:36:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMDcxNQ==", "bodyText": "I changed the logic slightly here.  Please double-check.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653720715", "createdAt": "2021-06-17T16:19:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMTIzNg==", "bodyText": "This comment says \"all wildcards\", but there is && after uncapturedTypeArg.getKind() == TypeKind.WILDCARD.  Which is right, and why?  (When does the second conjunct have an effect?  Or should it be an assertion?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653721236", "createdAt": "2021-06-17T16:20:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMjAwOQ==", "bodyText": "Is the key from the underlying type or from the captured type?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653722009", "createdAt": "2021-06-17T16:21:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMzEzNg==", "bodyText": "Could you document the relationship between typeVarTypeMirror and typeVar.getUnderlyingType(), and why two entries need to be added to typeVarToAnnotatedTypeArg?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653723136", "createdAt": "2021-06-17T16:22:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMzcwMg==", "bodyText": "What is the point of this variable?  It is only used once, on the next line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653723702", "createdAt": "2021-06-17T16:23:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 493}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNDA2NA==", "bodyText": "What does this map to?  I think it's an uncaptured type argument.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653724064", "createdAt": "2021-06-17T16:23:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNDk2Mw==", "bodyText": "This may set primary annotations as well as those on the bounds.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653724963", "createdAt": "2021-06-17T16:25:00Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 596}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNTg4NQ==", "bodyText": "There is extra logic in the initialization of typeVarUpperBound that is not present for lower bounds.  What is the reason for the difference?  (It just makes me a bit nervous to see a lack of symmetry.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653725885", "createdAt": "2021-06-17T16:26:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 621}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNjIzOQ==", "bodyText": "Should those in the intersection also be removed from the bounds where they are now redundant?  Or is it better to retain them?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653726239", "createdAt": "2021-06-17T16:26:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 626}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNzczNw==", "bodyText": "Which AnnotatedTypeVariable is mapped to?  That is, what is its relationship to the key?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653727737", "createdAt": "2021-06-17T16:28:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,448 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are added by\n+        // #annotateCapturedTypeVar, which is called at the end of this method.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // The name \"originalToCopy\" means a mapping from the original to the copy, not an original\n+      // that needs to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          newTypeArgs[i] = copyOfArg;\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: This `if` statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not lexically contain any other\n+   * type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.\n+    AnnotationMirrorSet p =\n+        new AnnotationMirrorSet(capturedTypeVar.getUpperBound().getAnnotations());\n+    p.retainAll(capturedTypeVar.getLowerBound().getAnnotations());\n+    capturedTypeVar.replaceAnnotations(p);\n+\n+    capturedTypeVarSubstitutor.substitute(capturedTypeVar, capturedTypeVarToAnnotatedTypeVar);\n+  }\n+\n+  /**\n+   * Substitutes references to captured type variables.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private final CapturedTypeVarSubstitutor capturedTypeVarSubstitutor =\n+      new CapturedTypeVarSubstitutor();\n+\n+  /**\n+   * Substitutes references to captured types in {@code type} using {@code\n+   * capturedTypeVarToAnnotatedTypeVar}.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private static class CapturedTypeVarSubstitutor extends AnnotatedTypeCopier {\n+\n+    /** A mapping from a captured type variable to an AnnotatedTypeVariable. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf7d05df7d953012f508ed42251466bf1463513"}, "originalPosition": 653}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyODE1NA==", "bodyText": "Are they already captured type variables, or does this method do the work to make them captured type variables?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653728154", "createdAt": "2021-06-17T16:29:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,448 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are added by\n+        // #annotateCapturedTypeVar, which is called at the end of this method.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // The name \"originalToCopy\" means a mapping from the original to the copy, not an original\n+      // that needs to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          newTypeArgs[i] = copyOfArg;\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: This `if` statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not lexically contain any other\n+   * type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.\n+    AnnotationMirrorSet p =\n+        new AnnotationMirrorSet(capturedTypeVar.getUpperBound().getAnnotations());\n+    p.retainAll(capturedTypeVar.getLowerBound().getAnnotations());\n+    capturedTypeVar.replaceAnnotations(p);\n+\n+    capturedTypeVarSubstitutor.substitute(capturedTypeVar, capturedTypeVarToAnnotatedTypeVar);\n+  }\n+\n+  /**\n+   * Substitutes references to captured type variables.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private final CapturedTypeVarSubstitutor capturedTypeVarSubstitutor =\n+      new CapturedTypeVarSubstitutor();\n+\n+  /**\n+   * Substitutes references to captured types in {@code type} using {@code\n+   * capturedTypeVarToAnnotatedTypeVar}.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private static class CapturedTypeVarSubstitutor extends AnnotatedTypeCopier {\n+\n+    /** A mapping from a captured type variable to an AnnotatedTypeVariable. */\n+    private Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar;\n+\n+    /**\n+     * Substitutes references to captured type variable in {@code type} using {@code\n+     * capturedTypeVarToAnnotatedTypeVar}.\n+     *\n+     * <p>Unlike {@link #typeVarSubstitutor}, this method does not copy the type.\n+     *\n+     * @param type AnnotatedTypeMirror whose captured type variables are substituted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf7d05df7d953012f508ed42251466bf1463513"}, "originalPosition": 662}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02ed559b3db491c9a96132957c1152f9a55faeff", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/02ed559b3db491c9a96132957c1152f9a55faeff", "committedDate": "2021-06-17T22:38:42Z", "message": "Rename mappings from type parameters to type arguments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dd92862bc87566cfc227cbeedb17b28dd170057", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0dd92862bc87566cfc227cbeedb17b28dd170057", "committedDate": "2021-06-18T20:48:23Z", "message": "Code Review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06bf5ced8dc146f9e3c321169e1147be27963cf9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/06bf5ced8dc146f9e3c321169e1147be27963cf9", "committedDate": "2021-06-18T21:21:38Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94609874142f708ee2d3a3962b523687c20f251c", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/94609874142f708ee2d3a3962b523687c20f251c", "committedDate": "2021-06-18T21:26:42Z", "message": "Make changes match those in capture-conversion."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "492973fdaf8ff34143a1653458ba9d15d6683123", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/492973fdaf8ff34143a1653458ba9d15d6683123", "committedDate": "2021-06-18T21:28:56Z", "message": "Merge branch 'typeParamToTypeArg' into capture-conversion\n\n# Conflicts:\n#\tframework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java\n#\tframework/src/main/java/org/checkerframework/framework/type/TypeVariableSubstitutor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d13f8cfd6b88892dc86c35f44880669887650fa", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/1d13f8cfd6b88892dc86c35f44880669887650fa", "committedDate": "2021-06-18T22:12:01Z", "message": "Renames."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22be43028d8f2bd759699fc737888d96865b00ae", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/22be43028d8f2bd759699fc737888d96865b00ae", "committedDate": "2021-06-18T23:08:12Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/83f6875c155b20abe3efd60c93a15327ed1399c0", "committedDate": "2021-06-23T00:39:58Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e82b310b506e8d7c2c87d2d533664f264dfaeff", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8e82b310b506e8d7c2c87d2d533664f264dfaeff", "committedDate": "2021-06-24T15:40:50Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkxOTg3MjY0", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-691987264", "createdAt": "2021-06-24T16:33:29Z", "commit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozMzoyOVrOJznzcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjo0MTozNlrOJzoJOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTI5OA==", "bodyText": "This second sentence is a reference to a different section of the JLS.  Please mention that: \"In JLS section XX, ...\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658109298", "createdAt": "2021-06-24T16:33:29Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTk5Mw==", "bodyText": "I find the name of this method a bit hard to read; it sounds more like an imperative or command than a predicate.  Consider changing to \"shouldIgnore...\" or \"isIgnored...\" or the like.\nAlso, the Javadoc of this method says that it returns true if the checker should not issue warnings, but here it seems to affect behavior too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658109993", "createdAt": "2021-06-24T16:34:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMDcyNA==", "bodyText": "I don't understand this line.  (I understand the one above, but I don't see why this part of the test is desirable/necessary.)  Maybe it doesn't matter because this is a hack to be removed later.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658110724", "createdAt": "2021-06-24T16:35:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMTgyNA==", "bodyText": "I am not sure why this block is here.  Is it for case 7 in the JLS description?  Is it a hack for #979 that will be removed later?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658111824", "createdAt": "2021-06-24T16:37:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMjg4NQ==", "bodyText": "There is no variable outside.  I think this comment should start with:\nLet outside be ? super outsideLower extends outsideUpper.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658112885", "createdAt": "2021-06-24T16:38:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMzYyMw==", "bodyText": "Can there be assert outsideUpper.getKind() != TypeKind.NULL; here?  If so, add it -- for documentation more than for error detection.  If not, please explain.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658113623", "createdAt": "2021-06-24T16:39:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExNDg3Mg==", "bodyText": "This looks suspicious to me.  Per the JLS algorithm, I think the first isSubtype call should be between outsideLower and the bound of inside, not inside itself.  (Likewise for the second isSubtype call.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658114872", "createdAt": "2021-06-24T16:41:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);\n+        }\n       }\n-      outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n-    }\n-\n-    if (!TypesUtils.isErasedSubtype(\n-        inside.getUnderlyingType(),\n-        outsideUpperBound.getUnderlyingType(),\n-        inside.atypeFactory.types)) {\n-      // TODO: subtype is a wildcard that should have been captured, so just check the primary\n-      // annotations.\n-      AnnotationMirror subAnno = inside.getEffectiveAnnotationInHierarchy(currentTop);\n-      AnnotationMirror superAnno = outsideUpperBound.getAnnotationInHierarchy(currentTop);\n-      return qualifierHierarchy.isSubtype(subAnno, superAnno);\n-    }\n-\n-    AnnotatedTypeMirror castedInside =\n-        AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-    if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-      return false;\n-    }\n-\n-    if (outside.getKind() == TypeKind.WILDCARD && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-      // tests/all-systems/Issue1991.java crashes without this.\n-      return true;\n+      return isSubtype(outsideLower, inside) && isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 188}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae", "committedDate": "2021-06-24T16:43:25Z", "message": "Comment tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkyMDczMTQ5", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-692073149", "createdAt": "2021-06-24T18:02:44Z", "commit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowMjo0NFrOJzrgHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowNDoyOFrOJzrnhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE2OTg4NA==", "bodyText": "Just below there is\n if (ignoreTypeArgs) {\n      return true;\n    }\nWhy is no test needed for the raw component?  What if this method were called with two arguments:  raw Class and raw List?  I suspect that subtype and supertype must have some specific relationship, such as that their raw types are the same or in some subtyping relationship.  Could you document that?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658169884", "createdAt": "2021-06-24T18:02:44Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MDc2Nw==", "bodyText": "Below there is also\n    if (subtypeTypeArgs.isEmpty()) {\n      return true;\n    }\nHow can that happen?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658170767", "createdAt": "2021-06-24T18:03:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MTc4Mg==", "bodyText": "The third paragraph is about comparisons between declarations (generic types).\nThe fourth paragraph is about comparisons between uses (parameterized types).\nShould this refer to the fourth paragraph rather than the third?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658171782", "createdAt": "2021-06-24T18:04:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +524,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 3th paragraph", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 244}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ed80413cbdf0b91d87a7597f80a66b88340f72b", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/4ed80413cbdf0b91d87a7597f80a66b88340f72b", "committedDate": "2021-06-24T21:20:02Z", "message": "Reference JSL."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a69b2b975757b34df24a0846c372a45d6a0b1b5e", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a69b2b975757b34df24a0846c372a45d6a0b1b5e", "committedDate": "2021-06-24T22:18:27Z", "message": "Tweak Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8205a69f22ee63f8c610da081a28e4f3415272ff", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8205a69f22ee63f8c610da081a28e4f3415272ff", "committedDate": "2021-06-24T22:40:29Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fbfbaf7f8ebcbbd0a71a9b8ea328027cb383376", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6fbfbaf7f8ebcbbd0a71a9b8ea328027cb383376", "committedDate": "2021-06-25T16:43:10Z", "message": "Move code around to make it clear what's a work around."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d39be44e4c3119a9cc64f62c6ce70ab0bf4c161", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5d39be44e4c3119a9cc64f62c6ce70ab0bf4c161", "committedDate": "2021-06-25T16:43:23Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afc9d93b2bdf172c61738f1c1132d486c25394eb", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/afc9d93b2bdf172c61738f1c1132d486c25394eb", "committedDate": "2021-06-25T16:46:35Z", "message": "Use correct term."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c911d54a7d5d5ebd23db3be3df7e606bf84ab005", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c911d54a7d5d5ebd23db3be3df7e606bf84ab005", "committedDate": "2021-06-25T22:11:54Z", "message": "Add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d531c58c57c4a46a67bc9047a42ebd3d32a25e7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/1d531c58c57c4a46a67bc9047a42ebd3d32a25e7", "committedDate": "2021-06-28T19:04:52Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2Njg2OTY1", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-536686965", "createdAt": "2020-11-23T17:18:21Z", "commit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoxODoyMVrOH4XoEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozNjoyMFrOH4YU-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2OTM5NA==", "bodyText": "This test looks wrong to me.  I think the && should be ||.\nHowever, I would rewrite it to correspond closely to the Javadoc comment @code type} and {@code typeMirror} must both be declared types.:\n        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n            return false;\n\t}\nI think a closer correspondence between the Javadoc and the code makes the code easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528869394", "createdAt": "2020-11-23T17:18:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MDc0Nw==", "bodyText": "The first and fourth disjuncts logically belong to the third bullet point in the Javadoc.  Please make this if statement be just about the second bullet point, and put the first and fourth disjuncts afterward, together with the for statement that addresses the third bullet point.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528870747", "createdAt": "2020-11-23T17:20:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MTA5Ng==", "bodyText": "Can capturedTypeMirror be null?  It is not annotated as @Nullable.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528871096", "createdAt": "2020-11-23T17:20:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MTg2NA==", "bodyText": "What is the distinction between these two variables, which have the same Map type?  Does the comment apply to just one of them or to both?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528871864", "createdAt": "2020-11-23T17:21:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MjM2OA==", "bodyText": "Please make the naming preCapturedArg and capturedTypeArg more consistent, probably by renaming preCapturedArg to preCapturedTypeArg.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528872368", "createdAt": "2020-11-23T17:22:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDM0MQ==", "bodyText": "Sometimes a variable named capture refers to a TypeMirror (example: captureToAnnotatedCapture).  Other times it refers to an AnnotatedTypeMirror, as here.\nI think the code will be clearer to read if there is a naming convention to distinguish them.  Maybe you can use a prefix or suffix:\n\n\"a\" vs \"\"\n\"a\" vs \"tm\"\n\"atm\" vs \"tm\"\nmaybe you can come up with a better convention.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528874341", "createdAt": "2020-11-23T17:25:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDgzOQ==", "bodyText": "How is typeDeclaration modified?  (Via aliasing?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528874839", "createdAt": "2020-11-23T17:26:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3OTIyNg==", "bodyText": "Does this need to be public?  It feels like a helper method.\nAlso, I don't find the name free particularly evocative.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528879226", "createdAt": "2020-11-23T17:33:37Z", "author": {"login": "mernst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -879,4 +893,65 @@ public static TypeMirror substitute(\n                 com.sun.tools.javac.util.List.from(newP),\n                 com.sun.tools.javac.util.List.from(newT));\n     }\n+\n+    /**\n+     * Returns a fresh type variable, a captued typed, for {@code typeMirror}, if {@code typeMirror}\n+     * is a wildcard. If it is not a wildcard, {@code typeMirror} is returned\n+     *\n+     * @param typeMirror some type\n+     * @param env processing environment\n+     * @return a fresh type variable if {@code typeMirror} is a wildcard, or {@code type mirror}\n+     */\n+    public static TypeMirror freshTypeVariable(TypeMirror typeMirror, ProcessingEnvironment env) {\n+        JavacProcessingEnvironment javacEnv = (JavacProcessingEnvironment) env;\n+        com.sun.tools.javac.code.Types types =\n+                com.sun.tools.javac.code.Types.instance(javacEnv.getContext());\n+        return types.freshTypeVariables(com.sun.tools.javac.util.List.of((Type) typeMirror)).head;\n+    }\n+\n+    /**\n+     * Returns the list of type variables such that a type variable in the list only references type\n+     * variables at a lower index than itself.\n+     *\n+     * @param collection a collection of type variables\n+     * @param types types\n+     * @return the list of type variables such that a type variable in the list only references type\n+     *     variables at a lower index than itself\n+     */\n+    public static List<TypeVariable> order(Collection<TypeVariable> collection, Types types) {\n+        List<TypeVariable> list = new ArrayList<>(collection);\n+        List<TypeVariable> ordered = new ArrayList<>();\n+        while (!list.isEmpty()) {\n+            TypeVariable free = free(list, types);\n+            list.remove(free);\n+            ordered.add(free);\n+        }\n+        return ordered;\n+    }\n+\n+    /**\n+     * Returns the first TypeVariable in {@code collection} that does not contain any other type in\n+     * the collection, but maybe its self.\n+     *\n+     * @param collection a collection of type variables\n+     * @param types types\n+     * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+     *     the collection, but maybe its self\n+     */\n+    @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+    public static TypeVariable free(Collection<? extends TypeVariable> collection, Types types) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4MDYzNQ==", "bodyText": "What is the distinction between typeArg and annoTypeArg?  Both are AnnotatedTypeMirrors.  Their names only reference their type, not their semantics or content.  Can you rename them?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528880635", "createdAt": "2020-11-23T17:35:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArguments, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture =\n+                TypesUtils.order(captureToAnnotatedCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror typeArg = captureToAnnotatedCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror annoTypeArg = typeToCapture.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 454}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4MDg4OQ==", "bodyText": "This Javadoc comment isn't descriptive, especially since the next formal parameter has the same type.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528880889", "createdAt": "2020-11-23T17:36:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArguments, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture =\n+                TypesUtils.order(captureToAnnotatedCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror typeArg = captureToAnnotatedCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror annoTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeVariable typeVariable =\n+                    (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+            captureWildcard(\n+                    typeVarToTypeArguments,\n+                    captureToAnnotatedCapture,\n+                    (AnnotatedWildcardType) annoTypeArg,\n+                    typeVariable,\n+                    (AnnotatedTypeVariable) typeArg);\n+            newTypeArgs.remove(i);\n+            newTypeArgs.add(i, typeArg);\n+        }\n+        capturedType.setTypeArguments(newTypeArgs);\n+\n+        capturedType.addAnnotations(typeToCapture.getAnnotations());\n+        return capturedType;\n+    }\n+\n+    /**\n+     * Set the annotated bounds for fresh type variable {@code capturedArg}, so that it is the\n+     * capture of {@code wildcard}.\n+     *\n+     * @param argMapping substitution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 476}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzkxMDYy", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-536791062", "createdAt": "2020-11-23T19:43:06Z", "commit": {"oid": "1d5eca70ca42da8b40dcf0edcd905d8951473889"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo0MzowN1rOH4ct5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMzoyMFrOH4dsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MjgwNg==", "bodyText": "One field is named lower, but this one uses Super.  I suggest making them consistent.  I would use \"lower\" rather than \"super\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528952806", "createdAt": "2020-11-23T19:43:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Representation of a wildcard or captured wildcared so that {@link AnnotatedWildcardType} and\n+     * {@link AnnotatedTypeVariable} that are captured types, may be used interchangeably.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5eca70ca42da8b40dcf0edcd905d8951473889"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MzQ2MQ==", "bodyText": "Why is this field needed?  Can't clients just use the value of lower?  I would expect all methods to do the right thing when passed a null type (that is, a type with kind TypeKind.NULL).", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528953461", "createdAt": "2020-11-23T19:44:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Representation of a wildcard or captured wildcared so that {@link AnnotatedWildcardType} and\n+     * {@link AnnotatedTypeVariable} that are captured types, may be used interchangeably.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5eca70ca42da8b40dcf0edcd905d8951473889"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MzQ4Mg==", "bodyText": "Does this need to be protected, or can it be public?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528963482", "createdAt": "2020-11-23T20:02:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2Mzk0MQ==", "bodyText": "Rather than repeating this, I would refer to isContainedBy().  You might be able to reduce the size of the previous paragraph too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528963941", "createdAt": "2020-11-23T20:03:40Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODA2MQ==", "bodyText": "I don't understand the logic of the next 7 lines.\nOne question is why there is a special case that depends on hasSuperBound.  I think that the lower bound will be the null type, and I would expect all the tests to work properly for such a type.\nIt would also be helpful to state the algorithm you are following.\nI think it's something like this:\nIf Outside is not a wildcard:\n  require equality\n  return\n\nif Inside is not a wildcard:\n  Inside must be the appropriate one of Outside's bounds\n  return\n\nlet Outside = ? super Lo extends Uo\nlet Inside = ? super Li extends Ui\nrequire Ui <: Uo\n        Lo <: Li\n\n(which is itself just a simplification of the first 5 bullet points in the containment algorithm of JLS 4.5.1) plus special cases for contravariance that I have not written down.  Is the algorithm as I stated it correct or incorrect?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968061", "createdAt": "2020-11-23T20:11:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODYxMQ==", "bodyText": "I cannot follow this comment.  Is glb the same as annos?  Please define \"lowest bound\".  (I see what it is from the code, but clarifying the intent will help to ensure that the two are consistent.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968611", "createdAt": "2020-11-23T20:12:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasSuperBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasSuperBound) {\n+                    return isSubtype(outside.lower, inside);\n+                } else {\n+                    return isSubtype(inside, outside.upper);\n+                }\n+            }\n+            return isSubtype(outside.lower, inside) && isSubtype(inside, outside.upper);\n         }\n+    }\n \n-        if (outside.getKind() == TypeKind.WILDCARD\n-                && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-            // tests/all-systems/Issue1991.java crashes without this.\n-            return true;\n+    /**\n+     * Add {@code glb} to the lowest bound of {@code type}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODgxNA==", "bodyText": "Please add Javadoc to this method, which is used by your code.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968814", "createdAt": "2020-11-23T20:13:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasSuperBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasSuperBound) {\n+                    return isSubtype(outside.lower, inside);\n+                } else {\n+                    return isSubtype(inside, outside.upper);\n+                }\n+            }\n+            return isSubtype(outside.lower, inside) && isSubtype(inside, outside.upper);\n         }\n+    }\n \n-        if (outside.getKind() == TypeKind.WILDCARD\n-                && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-            // tests/all-systems/Issue1991.java crashes without this.\n-            return true;\n+    /**\n+     * Add {@code glb} to the lowest bound of {@code type}.\n+     *\n+     * @param type annotated type\n+     * @param annos annotations\n+     */\n+    private void addToLowestBound(AnnotatedTypeMirror type, Set<? extends AnnotationMirror> annos) {\n+        AnnotatedTypeMirror lowestBound = type;\n+        while (lowestBound.getKind() == TypeKind.TYPEVAR\n+                || lowestBound.getKind() == TypeKind.WILDCARD) {\n+            switch (lowestBound.getKind()) {\n+                case TYPEVAR:\n+                    lowestBound = ((AnnotatedTypeVariable) lowestBound).getLowerBound();\n+                    break;\n+                case WILDCARD:\n+                    lowestBound = ((AnnotatedWildcardType) lowestBound).getSuperBound();\n+                    break;\n+                default:\n+                    // not reachable\n+            }\n         }\n-        return canBeCovariant || isSubtypeCaching(outsideLowerBound, inside);\n+        lowestBound.replaceAnnotations(annos);\n     }\n \n     private boolean ignoreUninferredTypeArgument(AnnotatedTypeMirror type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 250}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTUwNDc3", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-536950477", "createdAt": "2020-11-24T00:31:43Z", "commit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDozMTo0M1rOH4kxwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDo0NDoxOFrOH4lCoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NDg2NA==", "bodyText": "Why are both of these tested?  I would expect them to have the same value.  Should there be an assertion that the two boolean values are the same?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529084864", "createdAt": "2020-11-24T00:31:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NTE5OQ==", "bodyText": "Why is this size comparison necessary as part of the test?  I think that if it is true, there is some corruption.  Should you change this into an assertion?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529085199", "createdAt": "2020-11-24T00:32:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4ODk3NQ==", "bodyText": "The map's key type is TypeVariable which is a subclass of TypeMirror.  Can you be more specific than \"type mirror\"?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529088975", "createdAt": "2020-11-24T00:43:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()\n+                        != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // A mapping from type variable to its type argument in the captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArgument = new HashMap<>();\n+        // A mapping from the captured type to the annotated captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeMirrorToCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVarTypeMirror =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArgument.put(typeVarTypeMirror, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                typeMirrorToCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArgument.put(typeVarTypeMirror, uncapturedTypeArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArgument, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture = TypesUtils.order(typeMirrorToCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror capturedTypeArg = typeMirrorToCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeVariable typeVariable =\n+                    (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+            captureWildcard(\n+                    typeVarToTypeArgument,\n+                    typeMirrorToCapture,\n+                    (AnnotatedWildcardType) uncapturedTypeArg,\n+                    typeVariable,\n+                    (AnnotatedTypeVariable) capturedTypeArg);\n+            newTypeArgs.remove(i);\n+            newTypeArgs.add(i, capturedTypeArg);\n+        }\n+        capturedType.setTypeArguments(newTypeArgs);\n+\n+        capturedType.addAnnotations(typeToCapture.getAnnotations());\n+        return capturedType;\n+    }\n+\n+    /**\n+     * Set the annotated bounds for fresh type variable {@code capturedArg}, so that it is the\n+     * capture of {@code wildcard}.\n+     *\n+     * @param argMapping mapping from type variable to its type argument\n+     * @param captureToAnnotatedCapture mapping from captured type mirror to captured annotated type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTE4NA==", "bodyText": "The variable naming is confusing.\n\nVariable typeToCapture refers to a single type that needs to be captured.\nVariable typeVarToTypeArgument uses \"To\" to indicate a map type.\nVariable typeMirrorToCapture also uses \"To\", but I'm not sure which meaning of \"To\" it intends.  Maybe it should be \"ToCaptured\"??  Another method uses the name captureToAnnotatedCapture for the same value (I think), which also might be better.  Once you find a good name, use it consistently.\n\nIn the following two variables, the key types are the same, but the documentation refers to it inconsistently as a \"type variable\" (this checks out) and a \"captured type\" (which seems a bit confusing).  Also, how does \"the captured type\" relate to the variable capturedType?\n        // A mapping from type variable to its type argument in the captured type.\n        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArgument = new HashMap<>();\n        // A mapping from the captured type to the annotated captured type.\n        Map<TypeVariable, AnnotatedTypeMirror> typeMirrorToCapture = new HashMap<>();", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529089184", "createdAt": "2020-11-24T00:44:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()\n+                        != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // A mapping from type variable to its type argument in the captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 415}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b20962ff63c67870cd120140b7f6507712fcd05", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2b20962ff63c67870cd120140b7f6507712fcd05", "committedDate": "2020-11-24T02:34:49Z", "message": "Add missing changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d311ef15be2f58100f074d6a56b861f8970387d7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d311ef15be2f58100f074d6a56b861f8970387d7", "committedDate": "2020-11-24T02:38:35Z", "message": "Address code review feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c8bf98d39ff9e54dd2a37f6aa49ae5465f741d6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0c8bf98d39ff9e54dd2a37f6aa49ae5465f741d6", "committedDate": "2020-11-24T02:40:03Z", "message": "Merge remote-tracking branch 'remotes/smillst/for-loop-capture' into for-loop-capture\n\n# Conflicts:\n#\tdataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a31557004b6ca437e027b933004fa8b3700fc279", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a31557004b6ca437e027b933004fa8b3700fc279", "committedDate": "2020-11-24T02:42:02Z", "message": "code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8104b39102579c9b43e9ce9e0cc1ef71c3bfd55f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8104b39102579c9b43e9ce9e0cc1ef71c3bfd55f", "committedDate": "2020-11-24T02:42:16Z", "message": "Merge remote-tracking branch 'origin/master' into visitHistory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7f0361bda671e35249278fbd4f9345f8666cfb3", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b7f0361bda671e35249278fbd4f9345f8666cfb3", "committedDate": "2020-11-24T02:42:56Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb6e40018e9556e963543bd90df16a2d85ca5ee0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/fb6e40018e9556e963543bd90df16a2d85ca5ee0", "committedDate": "2020-11-24T02:45:11Z", "message": "Merge branch 'visitHistory' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9fe698b47825fb76c9964e51ecfd3b2ba178fc2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f9fe698b47825fb76c9964e51ecfd3b2ba178fc2", "committedDate": "2020-11-24T02:47:22Z", "message": "Merge branch 'for-loop-capture' into capture-conversion\n\n# Conflicts:\n#\tdataflow/src/main/java/org/checkerframework/dataflow/cfg/builder/CFGTranslationPhaseOne.java\n#\tdataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java\n#\tframework/src/main/java/org/checkerframework/framework/flow/CFAbstractTransfer.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92c5820c0ad4b7110baccd489183c1e395b337a0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/92c5820c0ad4b7110baccd489183c1e395b337a0", "committedDate": "2020-11-24T02:51:11Z", "message": "Fix merge error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fe2467ae64c4920cba75d4cf144625ec769a768", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5fe2467ae64c4920cba75d4cf144625ec769a768", "committedDate": "2020-11-24T02:52:14Z", "message": "Merge branch 'capture-conversion' of github.com:smillst/checker-framework into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa9b510019abf697e011d6115143af5208793351", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/aa9b510019abf697e011d6115143af5208793351", "committedDate": "2020-11-24T12:51:43Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into capture-conversion\n\n# Conflicts:\n#\tframework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b692826fd907100dd28b7b621cc7f199e2bd320", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7b692826fd907100dd28b7b621cc7f199e2bd320", "committedDate": "2020-11-24T14:18:58Z", "message": "Tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d85d4a6564d791dc722fa313ca3473435f7a4c5a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d85d4a6564d791dc722fa313ca3473435f7a4c5a", "committedDate": "2020-11-24T14:19:53Z", "message": "Remove change that isn't needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfdf93916ad062faf13ecae2bf4f4242a2453a92", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/cfdf93916ad062faf13ecae2bf4f4242a2453a92", "committedDate": "2020-11-24T14:32:05Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e5bbebbc97df1c819c3bf50df226cf5cd46fc2e", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0e5bbebbc97df1c819c3bf50df226cf5cd46fc2e", "committedDate": "2020-11-24T14:43:03Z", "message": "Renames."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51b4364df7cba74a798f0bf9eb7be4b232b282de", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/51b4364df7cba74a798f0bf9eb7be4b232b282de", "committedDate": "2020-11-24T14:49:00Z", "message": "Code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92771daabbbba6ff3b0802b17a2319e891852041", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/92771daabbbba6ff3b0802b17a2319e891852041", "committedDate": "2020-11-24T16:06:30Z", "message": "Fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "124cb8662b8c2ed1ccd9056a793b84064f5f8049", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/124cb8662b8c2ed1ccd9056a793b84064f5f8049", "committedDate": "2020-11-24T16:07:01Z", "message": "Comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e566f157511666b90ec98c255f1a4461b7c73072", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e566f157511666b90ec98c255f1a4461b7c73072", "committedDate": "2020-11-24T17:22:40Z", "message": "Tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3791b3338e4e43067a31a9eba097f503087dc298", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3791b3338e4e43067a31a9eba097f503087dc298", "committedDate": "2020-11-24T17:51:54Z", "message": "This special case isn't needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f221abb4861730d01316519005249565ac49bee", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7f221abb4861730d01316519005249565ac49bee", "committedDate": "2020-11-24T17:52:55Z", "message": "This special case isn't needed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1d2db9da072d579d4ee91e40c4d923f6580cc38", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f1d2db9da072d579d4ee91e40c4d923f6580cc38", "committedDate": "2020-11-24T20:34:01Z", "message": "Merge remote-tracking branch 'origin/master' into for-loop-capture"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e346b8bf3c6cfe046a707fab572d6e3ad02757d5", "committedDate": "2020-11-24T21:05:27Z", "message": "Documentation improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bf1ebfc1d6da90c03fd20f072165ae554a80644", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/4bf1ebfc1d6da90c03fd20f072165ae554a80644", "committedDate": "2020-11-24T21:05:58Z", "message": "Remove AnnotatedTypes#getIteratedType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be087ec007db5e9ccdf9c16c627ccf97fc980c8f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/be087ec007db5e9ccdf9c16c627ccf97fc980c8f", "committedDate": "2020-11-24T21:06:50Z", "message": "Merge branch 'for-loop-capture' of github.com:smillst/checker-framework into for-loop-capture"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7655a8732285038ee70c7dcb7d562fe8652821f5", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7655a8732285038ee70c7dcb7d562fe8652821f5", "committedDate": "2020-11-24T21:37:24Z", "message": "Tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0254b58c9eb6f45a55da04ad13628e193f86fa58", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/0254b58c9eb6f45a55da04ad13628e193f86fa58", "committedDate": "2020-11-24T21:43:23Z", "message": "Tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f846b92251eb2ebc39351867491af76c36470332", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f846b92251eb2ebc39351867491af76c36470332", "committedDate": "2020-11-24T21:56:24Z", "message": "Add code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdac840ce17d9cf5866e18ba7133cca0b18bbc02", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/fdac840ce17d9cf5866e18ba7133cca0b18bbc02", "committedDate": "2020-11-24T21:59:40Z", "message": "Undo unrelated whitespace change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbbc698721887123059960d79d0c4dc66210478a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/dbbc698721887123059960d79d0c4dc66210478a", "committedDate": "2020-11-24T21:59:52Z", "message": "Fix typo and clarify wording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60fec345256b5c79843b71a180eb0f1b9e06646f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/60fec345256b5c79843b71a180eb0f1b9e06646f", "committedDate": "2020-11-24T22:27:27Z", "message": "Fix change log."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb24bd35e0ace6d19c72cfea5de242d82315c516", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/eb24bd35e0ace6d19c72cfea5de242d82315c516", "committedDate": "2020-11-24T22:27:30Z", "message": "Merge remote-tracking branch 'origin/master' into for-loop-capture"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "638a9bcec861e1165dcae57ed8dda7173b8e7a24", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/638a9bcec861e1165dcae57ed8dda7173b8e7a24", "committedDate": "2020-11-24T22:27:40Z", "message": "Merge branch 'for-loop-capture' of github.com:smillst/checker-framework into for-loop-capture"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bcf5612f49f2123beed9c1be432190e424b9176", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2bcf5612f49f2123beed9c1be432190e424b9176", "committedDate": "2020-11-24T22:30:56Z", "message": "Rename to getIterableElementType."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/9734eb47c03b442894b167b0dcfce454bb3e9de4", "committedDate": "2020-11-24T23:01:31Z", "message": "Merge remote-tracking branch 'smillst/for-loop-capture' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11588b248ec0487497bbd06144f1ac515af435dd", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/11588b248ec0487497bbd06144f1ac515af435dd", "committedDate": "2020-11-25T15:10:41Z", "message": "Improve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "262e7fabba685b4155e97fa3a9817bc5811027de", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/262e7fabba685b4155e97fa3a9817bc5811027de", "committedDate": "2020-11-25T15:10:46Z", "message": "Throw BugInCF if impossible situation arises"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8a5e78810674c1b90b369b7aac4d69273395ddc", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d8a5e78810674c1b90b369b7aac4d69273395ddc", "committedDate": "2020-11-25T15:11:09Z", "message": "Make code shorter and hopefully no less clear"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5438d41dc3d70df645e2854ab6d6b0713225eb6a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5438d41dc3d70df645e2854ab6d6b0713225eb6a", "committedDate": "2020-11-25T15:15:54Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NTczNzM1", "url": "https://github.com/typetools/checker-framework/pull/3922#pullrequestreview-538573735", "createdAt": "2020-11-25T14:48:06Z", "commit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo0ODowNlrOH52w7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxMTo0N1rOH531vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQyODE0MQ==", "bodyText": "Here or in the overview documentation of BoundType, please state the object invariants.  I think that one of the two fields lower and upper is always trivial/vacuous/degenerate; that is, either the lower bound is Void/NULL, or the upper bound is Object.  It is also possible for both of those conditions to hold.  Is that correct?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530428141", "createdAt": "2020-11-25T14:48:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzMDE5Mg==", "bodyText": "Is it the case that the algorithm can ignore the other bound because it is always trivial (is a Void/NULL lower bound or is an Object upper bound)?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530430192", "createdAt": "2020-11-25T14:50:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzMTgzNg==", "bodyText": "Why is the outside.hasExplicitLowerBound part of this test necessary?  If my guess about object invariants is correct, then if there is an explicit lower bound, the upper bound is Object, and the other disjunct will definitely evaluate to true.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530431836", "createdAt": "2020-11-25T14:53:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzNDkxMg==", "bodyText": "This logic looks wrong to me (and it differs from the last 4 lines of isContainedBy.\nI think the logic should be\n(canBeCovariant && isSubtype(outside.lower, insideBoundType.lower))\n|| isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant)\nor\ncanBeCovariant ? isSubtype(outside.lower, insideBoundType.lower))\n: isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant)\nNote that these two proposals are not logically equivalent.  Both express approximately:  \"if canBeCovariant is true, then use isSubtype, otherwise use isContainedByBoundType.\"  I'm not sure which one you would want to use.  If the current code is correct, please explain it.\nThe same comment applies just below.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530434912", "createdAt": "2020-11-25T14:57:04Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzODczMQ==", "bodyText": "Rather than using negation, it might be a touch clearer here to add a method hasExplicitUpperBound() to BoundType.  Then this test can be\nif (insideBoundType.hasExplicitUpperBound() && outside.hasExplicitUpperBound())\nwhich I think is more readable.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530438731", "createdAt": "2020-11-25T15:02:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MDM4MA==", "bodyText": "Another confusing thing about this code is that it is within a test !insideBoundType.hasExplicitLowerBound and it uses outsideBoundType.lower.  If my guess about object invariants is right, then whenever hasExplicitLowerBound is false, the lower bound is Void/NULL, and there doesn't seem to be much point in doing a test against two occurrences of Void/NULL.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530440380", "createdAt": "2020-11-25T15:04:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MTQyMA==", "bodyText": "The following code also seems to assume that at least one of the bounds of BoundType is non-trivial.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530441420", "createdAt": "2020-11-25T15:05:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MjI4OA==", "bodyText": "I'm not sure how this affects the result.  It changes outside's lowest bound, but the return statement on the next line uses outsideUpper which is unaffected by this method call.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530442288", "createdAt": "2020-11-25T15:06:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NTc1OQ==", "bodyText": "Is this if test an optimization to save resources compared to the return ... && ... statement on line 435, or is it logically necessary?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530445759", "createdAt": "2020-11-25T15:11:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasExplicitLowerBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 225}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "663c29fb520ecb7180120eb03c9c284da53de6b6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/663c29fb520ecb7180120eb03c9c284da53de6b6", "committedDate": "2020-11-25T15:55:17Z", "message": "Renames."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37ced953b4d6601eb5787514ab2f4e43c81f8639", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/37ced953b4d6601eb5787514ab2f4e43c81f8639", "committedDate": "2020-11-25T18:30:39Z", "message": "Merge ../checker-framework-fork-smillst-branch-for-loop-capture into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dbcc757975605c396a89a1af26a5330ed9175c6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7dbcc757975605c396a89a1af26a5330ed9175c6", "committedDate": "2020-11-25T18:31:06Z", "message": "Merge ../checker-framework-branch-master into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e9a22640163fa6c6376d8f29c2fffc38f5e9472", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7e9a22640163fa6c6376d8f29c2fffc38f5e9472", "committedDate": "2020-11-30T18:10:29Z", "message": "Revert \"Merge ../checker-framework-branch-master into capture-conversion\"\n\nThis reverts commit 7dbcc757975605c396a89a1af26a5330ed9175c6, reversing\nchanges made to 37ced953b4d6601eb5787514ab2f4e43c81f8639."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6f713dbf0d0cc596888664a4ae1798f291dec62", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e6f713dbf0d0cc596888664a4ae1798f291dec62", "committedDate": "2020-11-30T18:13:49Z", "message": "Merge branch 'master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1893cd9f257e73b1f87e5f070a3344a332faf2bc", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/1893cd9f257e73b1f87e5f070a3344a332faf2bc", "committedDate": "2020-11-30T20:57:51Z", "message": "Fix regression."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20e052afe222240d65124433f60b859e9930ece1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/20e052afe222240d65124433f60b859e9930ece1", "committedDate": "2020-11-30T21:48:22Z", "message": "Add TODOs at all the places that mention the lack of capture conversion.\n\nEach location needs to be reviewed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571c9935901bcfb30de75be86087b3232ee52bf2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/571c9935901bcfb30de75be86087b3232ee52bf2", "committedDate": "2020-11-30T21:57:15Z", "message": "Remove work around."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecefa8f914560b37f57980a9f58e5fa284bb22bc", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ecefa8f914560b37f57980a9f58e5fa284bb22bc", "committedDate": "2020-12-02T20:24:27Z", "message": "Use TypeVarSubstitutor\n\nThis can't be merged first because it crashes in master in isContainedBy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "845e14f63916a8a94aca9dd935f4d9e9d885e592", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/845e14f63916a8a94aca9dd935f4d9e9d885e592", "committedDate": "2020-12-02T20:25:16Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93ad81d38ffc8fd5364f933cc42c5530bca84aa9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/93ad81d38ffc8fd5364f933cc42c5530bca84aa9", "committedDate": "2020-12-04T21:01:28Z", "message": "Clean up StructuralEqualityComparer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4758b58f9c87b10b70d6ba0195d3abb310783880", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/4758b58f9c87b10b70d6ba0195d3abb310783880", "committedDate": "2020-12-04T21:01:34Z", "message": "Handle case when bounds are equal."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de374af5db4533aa3a5ab9572d2d860115ba69a5", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/de374af5db4533aa3a5ab9572d2d860115ba69a5", "committedDate": "2020-12-04T21:03:01Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fa5c07e1f449b636457ecc0282db3f955a53220", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/5fa5c07e1f449b636457ecc0282db3f955a53220", "committedDate": "2020-12-04T21:10:53Z", "message": "Update Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cb70d2b20c5b8dedd77d5632817ec5ab0ccc681", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7cb70d2b20c5b8dedd77d5632817ec5ab0ccc681", "committedDate": "2020-12-04T21:18:35Z", "message": "Add expected errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "100ba255d00647011c22fdc66ef2c6489f4f2cb4", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/100ba255d00647011c22fdc66ef2c6489f4f2cb4", "committedDate": "2020-12-04T21:36:33Z", "message": "Clean up."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b919c729cb3f5436511c4280cfadf506e40b5767", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/b919c729cb3f5436511c4280cfadf506e40b5767", "committedDate": "2020-12-10T17:18:58Z", "message": "Temp."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0dc4d807d8a7a52bc73759cfc3c4bbc7adf0721", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f0dc4d807d8a7a52bc73759cfc3c4bbc7adf0721", "committedDate": "2020-12-17T17:13:45Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into capture-conversion\n\n# Conflicts:\n#\tchecker/tests/guieffect/ThrowCatchTest.java\n#\tchecker/tests/nullness/generics/WildcardOverride.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6512d1e8bab57ce982e24c01cf723757feb50d08", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/6512d1e8bab57ce982e24c01cf723757feb50d08", "committedDate": "2020-12-17T17:19:35Z", "message": "Add test case, that fails."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f789db631eac1e7fa73a62152abb7c2f7fb84943", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f789db631eac1e7fa73a62152abb7c2f7fb84943", "committedDate": "2021-01-27T18:26:07Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2be7df943a948ee472d0cabc926106fd58852095", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2be7df943a948ee472d0cabc926106fd58852095", "committedDate": "2021-01-27T19:07:17Z", "message": "Use new mthod."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a429ff0addd1d305efa9eba24742022db12417d7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a429ff0addd1d305efa9eba24742022db12417d7", "committedDate": "2021-01-27T21:02:00Z", "message": "Revert \"Temp.\"\n\nThis reverts commit b919c729cb3f5436511c4280cfadf506e40b5767."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "882a9f9cf6574b6dd50dc2907f47b5e1be7b2da9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/882a9f9cf6574b6dd50dc2907f47b5e1be7b2da9", "committedDate": "2021-01-27T21:10:15Z", "message": "Fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e46a9e40af51beb63e3ceef7be936d99470a4afc", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e46a9e40af51beb63e3ceef7be936d99470a4afc", "committedDate": "2021-01-28T20:35:47Z", "message": "Fix crash."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c574ca10e57fe5cf63762bc490f4b231d4dc6bb3", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c574ca10e57fe5cf63762bc490f4b231d4dc6bb3", "committedDate": "2021-01-28T20:36:41Z", "message": "Fix comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac637c42c668f5218f68921adc1332b70bc6b130", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/ac637c42c668f5218f68921adc1332b70bc6b130", "committedDate": "2021-01-28T22:27:48Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2b9f96623b7115177fb5e0865133cb51131cfca", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/e2b9f96623b7115177fb5e0865133cb51131cfca", "committedDate": "2021-01-28T22:29:38Z", "message": "Use correct method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51b046ffc612795fae8adff23bbde244571f231f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/51b046ffc612795fae8adff23bbde244571f231f", "committedDate": "2021-01-29T17:08:04Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b29511d715f0e5c17fb67e7d06c9641eebb20db", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7b29511d715f0e5c17fb67e7d06c9641eebb20db", "committedDate": "2021-01-29T17:16:43Z", "message": "Correct test case."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fccf79cfdfd102126f1d6df43073eff1f2450e8f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/fccf79cfdfd102126f1d6df43073eff1f2450e8f", "committedDate": "2021-01-29T18:02:00Z", "message": "When building a type tree, don't recur infinitely on wildcards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a80ca5219926d0437c2e1971ef0f5f7fff6073a0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a80ca5219926d0437c2e1971ef0f5f7fff6073a0", "committedDate": "2021-01-29T18:09:26Z", "message": "Tweak."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d83dfb08b42471a1664f3d2c58f60515568a617", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/2d83dfb08b42471a1664f3d2c58f60515568a617", "committedDate": "2021-02-03T22:30:10Z", "message": "Add comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa900d0cad02617995ecbb349bdf5f5d3ef4c0a9", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/aa900d0cad02617995ecbb349bdf5f5d3ef4c0a9", "committedDate": "2021-02-04T00:03:17Z", "message": "Tweak code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1623d0e8636a94f218557221daf0708be3193e7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c1623d0e8636a94f218557221daf0708be3193e7", "committedDate": "2021-02-04T17:01:24Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75a16cbe29ba3ad49b4152e4d357c41aacfc21b1", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/75a16cbe29ba3ad49b4152e4d357c41aacfc21b1", "committedDate": "2021-02-04T17:11:28Z", "message": "Remove unneed suppression."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2c5ab0a0897e89d24dee0453be9fb8ac82f7b64", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c2c5ab0a0897e89d24dee0453be9fb8ac82f7b64", "committedDate": "2021-02-04T17:13:49Z", "message": "Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13c3ef730b12a6edb22ca67b61aee71068e5e2fc", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/13c3ef730b12a6edb22ca67b61aee71068e5e2fc", "committedDate": "2021-02-04T17:34:39Z", "message": "Add test case."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f59484adad0ce0c508752db305ab34bf3aef1a", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/57f59484adad0ce0c508752db305ab34bf3aef1a", "committedDate": "2021-02-04T17:36:34Z", "message": "Tweaks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcb799f35a3f8ac8d24d7c3a663b099507b1245f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/dcb799f35a3f8ac8d24d7c3a663b099507b1245f", "committedDate": "2021-03-09T18:48:23Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion\n\n# Conflicts:\n#\tchecker/tests/nullness/Issue3970.java\n#\tframework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java\n#\tframework/src/main/java/org/checkerframework/framework/util/element/ElementAnnotationUtil.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50dd5e6b3de2b7982c5859113b5adeaf6eb5ba09", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/50dd5e6b3de2b7982c5859113b5adeaf6eb5ba09", "committedDate": "2021-03-09T18:55:09Z", "message": "Revert workaround."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1acfbdd960eb6e926c50914099ac3a3eac142d0", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c1acfbdd960eb6e926c50914099ac3a3eac142d0", "committedDate": "2021-03-26T22:36:27Z", "message": "Merge branch 'before-reformat' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02d24489bd8d671a5298da9163f939fe014b7cf", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c02d24489bd8d671a5298da9163f939fe014b7cf", "committedDate": "2021-03-26T22:38:29Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02344a55ea3e435ad189d6bb15164ee438a03eaa", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/02344a55ea3e435ad189d6bb15164ee438a03eaa", "committedDate": "2021-03-29T20:51:28Z", "message": "Fix type check."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87f1728e4e5477e210764aa2a2bbe3b64babaf60", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/87f1728e4e5477e210764aa2a2bbe3b64babaf60", "committedDate": "2021-04-01T16:11:36Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b2ae5ef0572f7dadaa9c01120943552a6a60d8f", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7b2ae5ef0572f7dadaa9c01120943552a6a60d8f", "committedDate": "2021-04-01T20:00:43Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion\n\n# Conflicts:\n#\tframework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f79b34565591c7b492f0266f9cb9aeb0531047a7", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f79b34565591c7b492f0266f9cb9aeb0531047a7", "committedDate": "2021-04-08T16:10:47Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "373a83f9c5324c0243dda8c52e32a6908375a119", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/373a83f9c5324c0243dda8c52e32a6908375a119", "committedDate": "2021-04-09T16:05:15Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "838d3dbc08bcd13909585608902035b93859bc93", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/838d3dbc08bcd13909585608902035b93859bc93", "committedDate": "2021-04-09T17:45:33Z", "message": "Check point."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9949331785181becd40a11a9100b3bcbd659ff3", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f9949331785181becd40a11a9100b3bcbd659ff3", "committedDate": "2021-04-12T19:29:57Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29753045b59f61062e71ad45b40d4b297280d721", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/29753045b59f61062e71ad45b40d4b297280d721", "committedDate": "2021-04-13T20:13:21Z", "message": "Capture type arguments before checking against bounds."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e8652eb5691ce902415d5651be3298ba76d65a6", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7e8652eb5691ce902415d5651be3298ba76d65a6", "committedDate": "2021-04-13T20:13:42Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eee635ad065427dc7829aebcc506314fda1d59b2", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/eee635ad065427dc7829aebcc506314fda1d59b2", "committedDate": "2021-04-13T20:30:43Z", "message": "Handle type variables in intersection types."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8619222355214a0a51e84c69370163e4ed4db338", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/8619222355214a0a51e84c69370163e4ed4db338", "committedDate": "2021-04-14T17:28:14Z", "message": "Remove some code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61947adba20e2486e6b6462dd14dd4eb726fffea", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/61947adba20e2486e6b6462dd14dd4eb726fffea", "committedDate": "2021-04-14T18:10:21Z", "message": "Fix type variable subtyping rules."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c94137bcf14fbf641f22bce8b4368197dee9dc65", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/c94137bcf14fbf641f22bce8b4368197dee9dc65", "committedDate": "2021-04-14T18:14:24Z", "message": "Tweak tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3f52c2463eb676fb7dd797ff26c51ce0a8f2156", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/d3f52c2463eb676fb7dd797ff26c51ce0a8f2156", "committedDate": "2021-04-14T18:15:26Z", "message": "Merge remote-tracking branch 'origin/master' into capture-conversion"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3570fe6e7afe2c9351cdb19dd27f3b42a7c70a2d", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/3570fe6e7afe2c9351cdb19dd27f3b42a7c70a2d", "committedDate": "2021-04-14T22:08:37Z", "message": "Use the captured type to get the bounds from use."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2531, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}