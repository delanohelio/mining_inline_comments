{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NzA3NzA2", "number": 3338, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToyOToxNVrOEArp_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MTo0N1rOEAr4IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTUwNzE3OnYy", "diffSide": "RIGHT", "path": "checker/tests/nullness/TryWithResourcesAnno.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMToyOToxNVrOGcHaIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTozNzowMVrOGcHolA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNDY5MA==", "bodyText": "Do you want to add a test with an expected error, e.g. for try (@Nullable final AutoCloseable obj = null) {?", "url": "https://github.com/typetools/checker-framework/pull/3338#discussion_r432134690", "createdAt": "2020-05-28T21:29:15Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness/TryWithResourcesAnno.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Test case for https://tinyurl.com/cfissue/3305 .\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public class TryWithResourcesAnno {\n+    public static void f() {\n+        try (@Nullable AutoCloseable obj = null) {\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void g() {\n+        try (@Nullable AutoCloseable obj1 = null;\n+                AutoCloseable obj2 = null) {\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void h() {\n+        try (AutoCloseable obj1 = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5d3c6b396effb79a34e5180b72d4a3bb2fdd84e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODM4OA==", "bodyText": "I now see that the implementation wouldn't find such an issue.\nI'm wondering a bit why the same problem doesn't exist for implicitly public methods in interfaces...\ninterface Foo {\n    @Nullable public Object get();\n}\ncorrectly gives a warning, but when I remove the explicit public the warning goes away.\nMaybe the public isn't added to the modifiers in that situation?\nAnyways, the shortcoming is documented in the method below, so we don't need a todo test.", "url": "https://github.com/typetools/checker-framework/pull/3338#discussion_r432138388", "createdAt": "2020-05-28T21:37:01Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness/TryWithResourcesAnno.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Test case for https://tinyurl.com/cfissue/3305 .\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public class TryWithResourcesAnno {\n+    public static void f() {\n+        try (@Nullable AutoCloseable obj = null) {\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void g() {\n+        try (@Nullable AutoCloseable obj1 = null;\n+                AutoCloseable obj2 = null) {\n+        } catch (Exception e) {\n+        }\n+    }\n+\n+    public static void h() {\n+        try (AutoCloseable obj1 = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNDY5MA=="}, "originalCommit": {"oid": "e5d3c6b396effb79a34e5180b72d4a3bb2fdd84e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTU0MzM3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo0MTo0N1rOGcHwiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMTo1Nzo1OVrOGcILOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQyNw==", "bodyText": "I'm always a bit worried about using Paths, because they can be costly.\nI think you can simplify this significantly:\n\ndetermine the variable kind once kind = TreeUtils.elementFromDeclaration((VariableTree) node).getKind()\nif kind is ENUM_CONSTANT it's an enum constant\nif kind is RESOURCE_VARIABLE it's a try resource\n\nSo you don't need a path and the two checks are more symmetric.", "url": "https://github.com/typetools/checker-framework/pull/3338#discussion_r432140427", "createdAt": "2020-05-28T21:41:47Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -1051,13 +1051,25 @@ public Void visitVariable(VariableTree node, Void p) {\n      * @param modifiersTree the modifiers sub-tree of node\n      */\n     private void warnAboutTypeAnnotationsTooEarly(Tree node, ModifiersTree modifiersTree) {\n-        if (node.getKind() == Tree.Kind.VARIABLE\n-                && TreeUtils.elementFromDeclaration((VariableTree) node).getKind()\n-                        == ElementKind.ENUM_CONSTANT) {\n-            // Enums constants are \"public static final\" by default, so the annotation always\n-            // appears to be before public.\n-            return;\n+\n+        // Don't issue warnings about compiler-inserted modifiers.\n+        // These two tests could be made more precise and catch some user errors in enum constants\n+        // and in try-with-resources declarations, but it doesn't seem worth the effort.\n+        if (node.getKind() == Tree.Kind.VARIABLE) {\n+            if (TreeUtils.elementFromDeclaration((VariableTree) node).getKind()\n+                    == ElementKind.ENUM_CONSTANT) {\n+                // Enum constants are \"public static final\" by default, so the annotation always\n+                // appears to be before \"public\".\n+                return;\n+            }\n+            Tree parent = getCurrentPath().getParentPath().getLeaf();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5d3c6b396effb79a34e5180b72d4a3bb2fdd84e"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NzI1OA==", "bodyText": "Yes, that is better.  I made that change.", "url": "https://github.com/typetools/checker-framework/pull/3338#discussion_r432147258", "createdAt": "2020-05-28T21:57:59Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -1051,13 +1051,25 @@ public Void visitVariable(VariableTree node, Void p) {\n      * @param modifiersTree the modifiers sub-tree of node\n      */\n     private void warnAboutTypeAnnotationsTooEarly(Tree node, ModifiersTree modifiersTree) {\n-        if (node.getKind() == Tree.Kind.VARIABLE\n-                && TreeUtils.elementFromDeclaration((VariableTree) node).getKind()\n-                        == ElementKind.ENUM_CONSTANT) {\n-            // Enums constants are \"public static final\" by default, so the annotation always\n-            // appears to be before public.\n-            return;\n+\n+        // Don't issue warnings about compiler-inserted modifiers.\n+        // These two tests could be made more precise and catch some user errors in enum constants\n+        // and in try-with-resources declarations, but it doesn't seem worth the effort.\n+        if (node.getKind() == Tree.Kind.VARIABLE) {\n+            if (TreeUtils.elementFromDeclaration((VariableTree) node).getKind()\n+                    == ElementKind.ENUM_CONSTANT) {\n+                // Enum constants are \"public static final\" by default, so the annotation always\n+                // appears to be before \"public\".\n+                return;\n+            }\n+            Tree parent = getCurrentPath().getParentPath().getLeaf();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDQyNw=="}, "originalCommit": {"oid": "e5d3c6b396effb79a34e5180b72d4a3bb2fdd84e"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1671, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}