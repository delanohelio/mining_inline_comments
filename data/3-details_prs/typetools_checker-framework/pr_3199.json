{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0Mzk1MTE0", "number": 3199, "title": "Returns Receiver Checker", "bodyText": "Add Returns Receiver Checker as a sub-checker to checkerframework.common package.", "createdAt": "2020-03-26T20:09:27Z", "url": "https://github.com/typetools/checker-framework/pull/3199", "merged": true, "mergeCommit": {"oid": "03db89436d9a48b70e9e9fb54980b2784fc88e44"}, "closed": true, "closedAt": "2020-04-29T19:42:58Z", "author": {"login": "nimakarimipour"}, "timelineItems": {"totalCount": 115, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaVENXgH2gAyMzk0Mzk1MTE0OmUxMGM2ZjVhZDVhZjJkNDYwMDMzYjI3ZGU3M2E4YjkzZTZkOGFjYWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccdFQagH2gAyMzk0Mzk1MTE0OjA3NjBmNTJjZGE4ZTU2NTM2OGU1NWM3YmZlZTQ0Njc4YzI4NTA5ZDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "committedDate": "2020-04-23T04:20:43Z", "message": "add method ref test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzA4NzY5", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-400308769", "createdAt": "2020-04-24T22:37:47Z", "commit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozNzo0N1rOGLrjSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozNzo0N1rOGLrjSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ==", "bodyText": "You could meta-annotate all your qualifiers as org.checkerframework.framework.qual.TargetLocations for RETURN and RECEIVER. The annotation isn't enforced yet, but it might already be good documentation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414901065", "createdAt": "2020-04-24T22:37:47Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "committedDate": "2020-04-27T21:10:10Z", "message": "Modified @This declaration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzM2NTI2", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-401336526", "createdAt": "2020-04-27T21:22:30Z", "commit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyMjozMFrOGM4RDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyODoyNFrOGM4fJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1Nzk2Ng==", "bodyText": "Please delete this code rather than commenting it out", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416157966", "createdAt": "2020-04-27T21:22:30Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            //            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTA1Mg==", "bodyText": "What is the error in this file?  I don't see any method references", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159052", "createdAt": "2020-04-27T21:24:12Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/lambda/Issue450.java", "diffHunk": "@@ -1,3 +1,4 @@\n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\") // See Issue #2931", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTMwOA==", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159308", "createdAt": "2020-04-27T21:24:38Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/memberref/MemberReferences.java", "diffHunk": "@@ -112,6 +112,7 @@ void context(Bound bound) {\n     }\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDAwNA==", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160004", "createdAt": "2020-04-27T21:25:52Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/memberref/Receivers.java", "diffHunk": "@@ -11,6 +11,7 @@\n     R supply();\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDM3Ng==", "bodyText": "Please include // See Issue #2931 at the end of the line.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160376", "createdAt": "2020-04-27T21:26:22Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8inference/Issue1715.java", "diffHunk": "@@ -1,6 +1,7 @@\n import java.util.List;\n import java.util.function.Function;\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTU3NQ==", "bodyText": "This is not a valid error.  We should either use @SuppressWarnings or add a comment indicating this is not a valid error, pointing to #2931", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416161575", "createdAt": "2020-04-27T21:28:24Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,31 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        // :: error: (methodref.receiver.bound.invalid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37668822ca8f01dc2be35df6dae920ed4451eec4", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/37668822ca8f01dc2be35df6dae920ed4451eec4", "committedDate": "2020-04-28T01:58:35Z", "message": "Revert \"Modified @This declaration\"\n\nThis reverts commit 0fd9d340e568332c0c33346e1d9c2e2e05b17ec2."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "committedDate": "2020-04-28T03:14:38Z", "message": "comments on why we don't use @DefaultFor(RECEIVER)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fc8625f339a3090951413d14b87a9fed718b164", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/8fc8625f339a3090951413d14b87a9fed718b164", "committedDate": "2020-04-28T03:30:25Z", "message": "Allow writing @This on receiver type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74e562cf35bad6b7526b5f58c612f009458777e0", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/74e562cf35bad6b7526b5f58c612f009458777e0", "committedDate": "2020-04-28T03:41:35Z", "message": "disallow @This on return type of static method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDc3NzA5", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-401477709", "createdAt": "2020-04-28T03:47:56Z", "commit": {"oid": "74e562cf35bad6b7526b5f58c612f009458777e0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "committedDate": "2020-04-28T16:02:48Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "committedDate": "2020-04-28T16:16:11Z", "message": "add @TargetLocations annotation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjM0ODIx", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-402234821", "createdAt": "2020-04-28T21:44:17Z", "commit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0NDoxN1rOGNoKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1ODoyM1rOGNojZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjYyMw==", "bodyText": "Is that a different person from Nima Karimipour above?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416942623", "createdAt": "2020-04-28T21:44:17Z", "author": {"login": "wmdietl"}, "path": "docs/manual/contributors.tex", "diffHunk": "@@ -97,4 +98,5 @@\n Vlastimil Dort,\n Weitian Xing,\n Werner Dietl,\n-Zhiping Cai.\n+Zhiping Cai,\n+nimakarimipour.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NDQwNg==", "bodyText": "You could adapt this description to make it clear that the receiver is always @This. Or leave this sentence out completely.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416944406", "createdAt": "2020-04-28T21:48:06Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.\n+When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NDgxMg==", "bodyText": "You could add a reference to the section on polymorphic qualifiers.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416944812", "createdAt": "2020-04-28T21:48:59Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NTU0Nw==", "bodyText": "Do you also want to add a sentence about the method caller perspective? The polymorphic annotation gets resolved to UnknownThis and the type on the caller's side doesn't really matter. But maybe that's too much detail.\nIt's just a very different way how this is using the polymorphic qualifier, so it might confuse people that understand that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416945547", "createdAt": "2020-04-28T21:50:41Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.\n+When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annotation\n+\\refqualclass{common/returnsreceiver/qual}{This} on both the method's return and\n+receiver type forces their type qualifiers to be \\emph{equal}.  Hence, the\n+method will only pass the type checker if it returns its receiver argument,\n+achieving the desired checking.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjIxMA==", "bodyText": "Use {@code @This} or a link?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946210", "createdAt": "2020-04-28T21:52:13Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY2NA==", "bodyText": "I'm not sure that's the best description of the method you could come up with...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946664", "createdAt": "2020-04-28T21:53:15Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA==", "bodyText": "Maybe add the note about the automatic defaulting here also. Maybe file a follow-up issue to keep track of method reference handling and the false positives.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416949094", "createdAt": "2020-04-28T21:58:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/0bd569d6bb54ef4843f000e75a45ca5ce3192997", "committedDate": "2020-04-28T22:56:20Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbc22a2451a78beedd97e49a61a4e55762557225", "author": {"user": {"login": "wmdietl", "name": "Werner Dietl"}}, "url": "https://github.com/typetools/checker-framework/commit/cbc22a2451a78beedd97e49a61a4e55762557225", "committedDate": "2020-04-28T23:14:16Z", "message": "Fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0760f52cda8e565368e55c7bfee44678c28509d3", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/0760f52cda8e565368e55c7bfee44678c28509d3", "committedDate": "2020-04-29T18:48:57Z", "message": "tweak to manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beffa549428ba139408bb29bcdb899941b33294b", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/beffa549428ba139408bb29bcdb899941b33294b", "committedDate": "2020-03-25T18:16:00Z", "message": "Initialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b63699b1dcb6aa74e0913a770a3b4012f774428", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/9b63699b1dcb6aa74e0913a770a3b4012f774428", "committedDate": "2020-03-26T19:35:59Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc4298b92e91330a1c62f162bb32956c2018c756", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/bc4298b92e91330a1c62f162bb32956c2018c756", "committedDate": "2020-03-26T19:41:34Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/a77dd34f6a7a54defb7a186be322f7d276ece232", "committedDate": "2020-03-26T20:01:21Z", "message": "resolved comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNTA1NTMz", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-382505533", "createdAt": "2020-03-27T00:17:33Z", "commit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzozM1rOF8fAOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoyMzozM1rOF8fG1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2Njg0MA==", "bodyText": "Please remove any extraneous whitespace changes, like this one.  They make review more difficult.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398966840", "createdAt": "2020-03-27T00:17:33Z", "author": {"login": "msridhar"}, "path": "build.gradle", "diffHunk": "@@ -55,6 +55,7 @@ ext {\n     // This value is always overwritten, but Gradle needs the variable to be initialized.\n     localRepo = \".git\"\n }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2NjkwMw==", "bodyText": "Remove checkerFramework", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398966903", "createdAt": "2020-03-27T00:17:45Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -15,6 +15,14 @@ sourceSets {\n     }\n }\n \n+ext {\n+    versions = [\n+            checkerFramework: \"3.1.1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg==", "bodyText": "@kelloggm do we want these tests and the test data in returnsrcvr sub-folders?  Or should we keep everything at the top level, in which case we should rename tests, e.g., to ReturnsRcvrAutoValueTest?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398968532", "createdAt": "2020-03-27T00:23:33Z", "author": {"login": "msridhar"}, "path": "framework/src/test/java/tests/AutoValueTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f08dc67b501f0072ec03a27fa3892c4801d3e1", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/71f08dc67b501f0072ec03a27fa3892c4801d3e1", "committedDate": "2020-03-27T17:17:25Z", "message": "test git"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9f9e3fd725fcca36f0a09656fcb771229d4200d", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/f9f9e3fd725fcca36f0a09656fcb771229d4200d", "committedDate": "2020-03-27T17:20:38Z", "message": "test git"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "committedDate": "2020-03-28T02:05:04Z", "message": "resolved issues and passed git pre-commit hooks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "committedDate": "2020-03-28T05:21:31Z", "message": "fixed issue with checkBasicStyle task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "committedDate": "2020-03-28T06:36:20Z", "message": "fixed all-test-jdk8 and all-test-jdk11 jobs in pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "committedDate": "2020-03-28T06:50:42Z", "message": "git test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e005df3b5c841dbe272b502dc07bab3d2a41af98", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/e005df3b5c841dbe272b502dc07bab3d2a41af98", "committedDate": "2020-03-28T07:37:32Z", "message": "fixed checkInterning task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7690604d845c8331ce3e03232f192a5525f601b6", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/7690604d845c8331ce3e03232f192a5525f601b6", "committedDate": "2020-03-28T08:27:05Z", "message": "misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "committedDate": "2020-03-28T08:39:37Z", "message": "misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27843ff602ba06a52db49498675e3be561fa1828", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/27843ff602ba06a52db49498675e3be561fa1828", "committedDate": "2020-03-28T19:08:15Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "committedDate": "2020-03-28T19:17:38Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "committedDate": "2020-03-28T21:33:17Z", "message": "returns receiver manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed02ca65fd427780a729589976818098433543f1", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/ed02ca65fd427780a729589976818098433543f1", "committedDate": "2020-03-28T21:34:03Z", "message": "trailing whitespace"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzUxNzAy", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-383351702", "createdAt": "2020-03-28T21:36:52Z", "commit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzUyNjA5", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-383352609", "createdAt": "2020-03-28T21:50:21Z", "commit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMTo1MDoyMVrOF9MlsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMTo1MDoyMVrOF9MlsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMzcxMg==", "bodyText": "For reviewers: this means the Checker Framework will rely on the AutoValue annotations artifact.  This only contains AutoValue annotations, not any of the AutoValue annotation processors.  We could remove this dependence if desired, but it will require adding some reflection to the checker.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399713712", "createdAt": "2020-03-28T21:50:21Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +36,14 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in returns receiver checker\n+    implementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9b5171fe0730113b1248680c19a97e5c3c75c953", "committedDate": "2020-03-29T00:28:07Z", "message": "Add final newline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "committedDate": "2020-03-29T00:37:00Z", "message": "Capitalization fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMzYxOTkz", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-383361993", "createdAt": "2020-03-29T00:39:58Z", "commit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQwMDozOTo1OFrOF9Nbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQwMDo0MzoxN1rOF9NcUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA==", "bodyText": "Each annotation's Javadoc should link to its manual chapter, to enable users to learn more.\nThe bottom type should additionally link to https://checkerframework.org/manual/#bottom-type.\nSee how other qualifiers do this, for example https://checkerframework.org/api/org/checkerframework/checker/nullness/qual/KeyForBottom.html .\nEven more importantly, say what the annotation means.  (The fact that it's the bottom type is relevant but isn't the most important information.)  For example, is null the only value of this type?\nThese comments apply to other annotations as well.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727494", "createdAt": "2020-03-29T00:39:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzY5OA==", "bodyText": "The @This annotation does not represent a method.  Please rephrase.\nNit: please end sentences with punctuation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727698", "createdAt": "2020-03-29T00:43:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/** This represent methods that returns {@code this} */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4532df793fc199e7a440efa35c3051b0abc2e6b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f4532df793fc199e7a440efa35c3051b0abc2e6b", "committedDate": "2020-03-29T15:24:30Z", "message": "Improve naming.  Make switch statements report errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce4f098f11080d20257088603aae6c1b4a23bc51", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ce4f098f11080d20257088603aae6c1b4a23bc51", "committedDate": "2020-03-29T15:41:40Z", "message": "Remove unnecessary text"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/eff17315021c4d2899189b30c6a25149548d5fe5", "committedDate": "2020-03-29T15:41:54Z", "message": "Improve naming"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDIzNDQ2", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-383423446", "createdAt": "2020-03-29T15:28:33Z", "commit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNToyODozM1rOF9Sp7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1OToxOVrOF9S5wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ==", "bodyText": "From this documentation, I cannot tell what a FrameworkSupport is.  Documentation for a type should indicate what it represents.  (And possibly should include other information such as how to use it.)\nFrom later reading, I'm not sure why this needs to be an interface with multiple implementations.\nWhy not just have a method in the Returns Receiver Checker that takes a framework as an argument, or takes a list of frameworks as an argument, and has a switch statement and inlines the definitions?  Or why not put the method in the Framework class?  Either of these designs seems simpler than the FrameworkSupport interface.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813101", "createdAt": "2020-03-29T15:28:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** To add support for frameworks that need to have {@code @This} in certain generated methods */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzIyNA==", "bodyText": "Please indicate what the class does or is used for.  This comment doesn't tell the reader anything that the class name does not.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813224", "createdAt": "2020-03-29T15:29:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzM3MA==", "bodyText": "If it is non-instantiable, the constructor must throw an error.  Making the constructor return normally lets errors creep in later.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813370", "createdAt": "2020-03-29T15:30:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQzOA==", "bodyText": "Please spell names correctly.  There should be no space in \"AutoValue\".", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813438", "createdAt": "2020-03-29T15:30:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQ2MQ==", "bodyText": "Please spell names correctly.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813461", "createdAt": "2020-03-29T15:31:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzcwNQ==", "bodyText": "It seems inside-out to make the framework class a nested class and the utilities be the top-level class.\nAlso, why is this an inner class rather than a static nested class?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813705", "createdAt": "2020-03-29T15:33:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzc5NA==", "bodyText": "Really, if it has an annotation of the given class.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813794", "createdAt": "2020-03-29T15:33:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Determine the framework supports that should be disabled according to the flag {@code\n+     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n+     *\n+     * @param option a comma-separated list of frameworks whose support should be disabled\n+     * @return an EnumSet of all framework supports in use\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFrameworkSupport.toUpperCase()) {\n+                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSet.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n+                        frameworkSet.remove(Framework.LOMBOK);\n+                        break;\n+                }\n+            }\n+        }\n+        return frameworkSet;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has the annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTM3OA==", "bodyText": "This is an odd topic sentence for the paragraph.  What is the paragraph about?  The topic sentence should convey that.  This information is relevant to the @This information and belongs there.\nDon't use jargon like \"polymorphic\" without explaining it.  Here you are just saying that it only has to be written on the return type, not on the receiver.  Do you even need to say that it doesn't need to be written on the receiver?  Just saying that it only needs to be written on the return type is problably enough.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815378", "createdAt": "2020-03-29T15:45:42Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTU0Mw==", "bodyText": "More generally, this whole section doesn't seem very useful to readers.  It describes warnings in vague terms without any examples.  If you are worried that the warnings are not clear to users, then improve the warning text.  I suggest removing this whole section except the parts that are documentation of the @This qualifier, which should be moved.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815543", "createdAt": "2020-03-29T15:47:03Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTY1NQ==", "bodyText": "Where it may be written is useful and essential documentation that belongs in the documentation of @This (probably both in the manual and in the Javadoc, since you don't know which one a reader will see), not in a \"warnings\" section.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815655", "createdAt": "2020-03-29T15:47:55Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTgwMQ==", "bodyText": "As explained at https://checkerframework.org/manual/#creating-documenting-a-checker, please list every annotation and draw a diagram.  Every annotation must be listed because users will search the manual for them.  The diagram is more effective at conveying the type hierarchy than text alone is.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815801", "createdAt": "2020-03-29T15:49:02Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjAwOA==", "bodyText": "\"Framework support\" is vague:  a reader can't tell from the section title what the section is about.  And it's confusing given that the Checker Framework is a framework.  Just be direct and say \"AutoValue and Lombok support\".", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816008", "createdAt": "2020-03-29T15:50:28Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjEzMw==", "bodyText": "\"inject\" is jargon and implementation-specific.  Equally seriously, line 85 uses the word \"add\" for what is (I think) the same process.  Technical writing should always use the same word for the same concept.  Never use \"elegant variation\" as is recommended for novels.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816133", "createdAt": "2020-03-29T15:51:36Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjMwNw==", "bodyText": "Start out by saying what these tools do:  they generate code.  That context is missing.\nThen, say that the generated code gets appropriate @This annotations.  (Users couldn't write that in any event.)\nI'm not sure you need to say much more than that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816307", "createdAt": "2020-03-29T15:52:44Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjQ2MA==", "bodyText": "While writing this paragraph, you had code in mind.  But the reader doesn't know what it is, making the paragraph hard to follow.  Show the code, and show the annotations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816460", "createdAt": "2020-03-29T15:53:51Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjcxNQ==", "bodyText": "\"Disable ... support\" is vague and abstract.  Be specific:  to prevent inserting/injecting/adding (whatever term you use, though I would avoid \"inject\" since it suggests dependency injection) @This annotations in framework-generated code.\nAlso, state briefly why one would want to do that.  Otherwise the feature seems a bit mysterious to readers, and as a result they might not remember the feature nor use it properly.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816715", "createdAt": "2020-03-29T15:56:05Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class\n+\\<AutoValue\\_Animal.Builder> that extends \\<Animal.Builder> and implements its\n+abstract methods.  The Returns Receiver Checker automatically adds a\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation to the return type of\n+\\<Animal.Builder.setName> and \\<Animal.Builder.setNumberOfLegs>, and also to the\n+return types of those methods in the generated subclass.  The Returns Receiver\n+Checker still runs to ensure the implementation of the generated subclass is\n+consistent with the injected annotations.  Project Lombok Builders are supported\n+in a similar fashion.\n+\n+To disable the checker's built-in framework support, use the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjg5MQ==", "bodyText": "The fact that it is \"a code example\" is already obvious from the figure itself.  Try to avoid repeating the obvious.  (I had this same comment about some of your Javadoc.)  Use the caption to say what the point of the example is.  What does it demonstrate, or what does a reader learn from it?\nAlso, the caption should say what this code is.  Is it user-writtten code, automatically generated, or a combination?  Show the automatically-generated code separately, together with the automatically-added @This annotations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816891", "createdAt": "2020-03-29T15:57:29Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNzE1Mw==", "bodyText": "Neither the manual nor the Javadoc has an example of how to use the @This annotation.  Both should contain that.  Otherwise the documentation is abstract, hard to understand, and frustrating to users.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399817153", "createdAt": "2020-03-29T15:59:19Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d13fe35aeee5b038c375da84e9377835b2dd5a84", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d13fe35aeee5b038c375da84e9377835b2dd5a84", "committedDate": "2020-03-30T16:24:48Z", "message": "Fixed contructor throw RuntimeException and javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "committedDate": "2020-03-30T19:33:55Z", "message": "fix misc-jdk8 and misc-jdk11"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85682f77cf4b561fb948799f672369f9238d2fd3", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/85682f77cf4b561fb948799f672369f9238d2fd3", "committedDate": "2020-04-01T17:28:07Z", "message": "working on manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f897ece84d1d0742df8a5d44218f975ff0a800c0", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/f897ece84d1d0742df8a5d44218f975ff0a800c0", "committedDate": "2020-04-01T17:38:52Z", "message": "pass on manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c326d568f2b94e6e3417c27fefac8ad955dab9b", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/2c326d568f2b94e6e3417c27fefac8ad955dab9b", "committedDate": "2020-04-01T17:41:45Z", "message": "changed framework support to enums"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "committedDate": "2020-04-01T17:42:00Z", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "748a84c18498ee263accd07d5107af4927db474d", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/748a84c18498ee263accd07d5107af4927db474d", "committedDate": "2020-04-01T17:50:09Z", "message": "remove paragraph on disabling framework support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "committedDate": "2020-04-01T21:10:47Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1c028fade3062f9cba9fbb3019984ca38b30171", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d1c028fade3062f9cba9fbb3019984ca38b30171", "committedDate": "2020-04-02T01:13:35Z", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "482809a6694b522ffd7c97ca7676a5db936c4866", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/482809a6694b522ffd7c97ca7676a5db936c4866", "committedDate": "2020-04-02T01:28:44Z", "message": "Rename MaybeThis to UnknownThis.\n\nThe name MaybeThis isn't bad, but the rest of the Checker Framework uses\nthe naming convention \"Unknown\" for the top type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc7a321c3c288e4e3a377edf683fe8f0559b6026", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cc7a321c3c288e4e3a377edf683fe8f0559b6026", "committedDate": "2020-04-02T01:51:44Z", "message": "Improve Javadoc: add explanations, examples, links"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf31b932ea22fb758a113f144732cb39bdab46fa", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cf31b932ea22fb758a113f144732cb39bdab46fa", "committedDate": "2020-04-02T02:17:57Z", "message": "Edits to manual section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8e6b7290aad40d59affcf1e0e2113be79188368", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b8e6b7290aad40d59affcf1e0e2113be79188368", "committedDate": "2020-04-02T02:19:05Z", "message": "Mention terminology \"fluent API\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "941d35b64856461dca9c5ae04b253f3f9ec66b4e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/941d35b64856461dca9c5ae04b253f3f9ec66b4e", "committedDate": "2020-04-02T03:56:38Z", "message": "Tweak message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/daafb8f1937dcf9ba1c78f58a69a675465cc62be", "committedDate": "2020-04-02T05:19:49Z", "message": "Edits from code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MzgwODQ4", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-386380848", "createdAt": "2020-04-02T12:34:54Z", "commit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNDo1NFrOF_pF2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMzoxMjo1MFrOF_qhcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA==", "bodyText": "I find it surprising that this block is skipped for constructors, but the above block is not.  What is the reason for the discrepancy?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402277848", "createdAt": "2020-04-02T12:34:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODE4OA==", "bodyText": "Make a field like THIS_ANNOTATION.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278188", "createdAt": "2020-04-02T12:35:29Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODg3MQ==", "bodyText": "If you move the supported frameworks block first in the method, then you can delete these lines as they will be redundant.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278871", "createdAt": "2020-04-02T12:36:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {\n+                // check each supported framework\n+                for (FrameworkSupport frameworkSupport : frameworks) {\n+                    // see if the method in the framework should return this\n+                    if (frameworkSupport.returnsThis(t)) {\n+                        // add @This annotation\n+                        returnType.replaceAnnotation(THIS_ANNOTATION);\n+                        AnnotatedTypeMirror.AnnotatedDeclaredType receiverType =\n+                                t.getReceiverType();\n+                        receiverType.replaceAnnotation(THIS_ANNOTATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MDQxOQ==", "bodyText": "These comments are vacuous:  LOMBOK_SUPPORT is the string representation for LOMBOK_SUPPORT.\nUpon reading the code, I found out that these are the string representation of enum constants.\nIf so, they should be defined near the enum constants, not here in a different package.  Furthermore, there is no need for the enum constants.  It would be better to either iterate through the enum constants getting their toString representation.  (Or maybe create a method that takes a string and returns a matching enum constant.)\nBut, maybe these aren't needed at all if the Returns Receiver Checker doesn't need to support a --disableFrameworks command-line option.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402280419", "createdAt": "2020-04-02T12:39:12Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.source.SupportedOptions;\n+\n+/** Entry point for the Returns Receiver Checker. */\n+@SupportedOptions({ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT})\n+public class ReturnsReceiverChecker extends BaseTypeChecker {\n+    /** String representation for DISABLE_FRAMEWORK_SUPPORTS. */\n+    public static final String DISABLE_FRAMEWORK_SUPPORT = \"disableFrameworks\";\n+    /** String representation for LOMBOK_SUPPORT. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MTE0OA==", "bodyText": "This is a weird name.  What is a \"FrameworkSupport\"?  Each class should represent some clearly-defined concept.\nHere, I think that concept is a framework.  You could name this IFramework, but it would be better to structure the code not to need this class.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402281148", "createdAt": "2020-04-02T12:40:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * A framework supported by the Returns Receiver Checker. That is, some methods generated by the\n+ * framework return their receiver.\n+ */\n+public interface FrameworkSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MjI2Ng==", "bodyText": "How can the return type be null?\nI think it would be a bug in this method if inAnnotationValueBuilder is true but returnType is null.  In that case, I think it's better to throw an exception.  The same comment applies later in this file.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402282266", "createdAt": "2020-04-02T12:42:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework implements FrameworkSupport {\n+    /** AutoValue framework. */\n+    AUTO_VALUE {\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code\n+                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                // if enclosingType is an interface, the superclass has TypeKind NONE\n+                if (superclass.getKind() != TypeKind.NONE) {\n+                    // update enclosingElement to be for the superclass for this case\n+                    enclosingElement = TypesUtils.getTypeElement(superclass);\n+                    inAutoValueBuilder =\n+                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n+                }\n+            }\n+\n+            if (inAutoValueBuilder) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+                return returnType != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDA5OA==", "bodyText": "There is no documentation of this in the manual.  It should either be documented or removed.  I thought we agreed to remove it, so I'm not sure why it is still here in the code.\nIf it is retained, this logic belongs in the checker, not here in a separate package, because it is logically part of the checker.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284098", "createdAt": "2020-04-02T12:45:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDU3Mg==", "bodyText": "Eliminate these constant values and instead iterate through all frameworks, using their toString representation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284572", "createdAt": "2020-04-02T12:46:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDkxMg==", "bodyText": "What is the point of using an ArrayDeque, which is a more expensive data structure than an EnumSet?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284912", "createdAt": "2020-04-02T12:46:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMTI5Nw==", "bodyText": "Can you use the containsSameByClass method from AnnotationUtils or from AnnotatedTypeFactory?\nSame question for the implementation below (AnnotatedTypeFactory has no containsSameByName, but we could add it if needed).", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402301297", "createdAt": "2020-04-02T13:12:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n+                        frameworkSupports.remove(Framework.LOMBOK);\n+                        break;\n+                    default:\n+                        throw new UserError(\n+                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n+                                        + disabledFrameworks);\n+                }\n+            }\n+        }\n+        return frameworkSupports;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has an annotation of that class.\n+     *\n+     * @param element the element that might have an annotation\n+     * @param annotClass the class of the annotation that might be present\n+     * @return true if the element has the annotation\n+     */\n+    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n+        return element.getAnnotationMirrors().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "committedDate": "2020-04-02T19:28:31Z", "message": "Update changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "committedDate": "2020-04-03T07:28:13Z", "message": "removed frameworkSupport Interface and resolved comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MzIwMDI4", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-387320028", "createdAt": "2020-04-03T14:42:13Z", "commit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo0MjoxM1rOGAYh2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTowMDowNlrOGAZThA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTA2Nw==", "bodyText": "I only see one import lombok and that appears in test code and that annotation is already here: https://github.com/typetools/checker-framework/blob/master/checker/src/testannotations/java/lombok/NonNull.java\nSo why do we need a lombok dependency?\nThe lombok annotations are already checked using just strings. Why can't the same be done for AutoValue.Builder in Framework? That is, check for the annotation using a string and add a testannotation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055067", "createdAt": "2020-04-03T14:42:13Z", "author": {"login": "wmdietl"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +36,14 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in returns receiver checker\n+    implementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMzcxMg=="}, "originalCommit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTM5MA==", "bodyText": "The fields in this class should have visibility modifiers.\nCan they be final?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055390", "createdAt": "2020-04-03T14:42:39Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.Framework;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg==", "bodyText": "Note that this only validates explicit annotations in source code.\nYou could instead validate all methods/fields to ensure correct usage to also ensure stub files are correct.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403061882", "createdAt": "2020-04-03T14:52:05Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NDY0NQ==", "bodyText": "Framework is a very vague name. Could you find a better name? SupportedReturnsReceiverSpecialCases is a bit long.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403064645", "createdAt": "2020-04-03T14:55:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ==", "bodyText": "Is this class really worth it?\ngetSupportedFrameworks could be in Frameworks and the other two methods are very simple wrappers. (And I would like to remove the version that uses a Class, to not require a compile-time dependency on each framework.)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403066661", "createdAt": "2020-04-03T14:58:36Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA==", "bodyText": "Is there a reason to use the top type for null, Void, or lower bounds? It would be more standard to use the bottom type for these locations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403067780", "createdAt": "2020-04-03T15:00:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acfb71a082e2aa5ed579bcad04447d36be7ef724", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/acfb71a082e2aa5ed579bcad04447d36be7ef724", "committedDate": "2020-04-05T18:20:05Z", "message": "Don't replace existing annotations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "committedDate": "2020-04-06T02:20:13Z", "message": "fix misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b51b9199f33112538d3ecad583c7934248b13495", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/b51b9199f33112538d3ecad583c7934248b13495", "committedDate": "2020-04-06T23:24:54Z", "message": "removed FrameworkSupportUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "committedDate": "2020-04-07T01:36:46Z", "message": "removed dependecies to AutoValue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "committedDate": "2020-04-07T03:46:33Z", "message": "clean up some logic in type factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe7036cc37fd2929169301e3543ee7aa128683a1", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/fe7036cc37fd2929169301e3543ee7aa128683a1", "committedDate": "2020-04-07T17:18:28Z", "message": "fixed modifiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d54fc10e5111d30df096277d11619b70e1c478bd", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d54fc10e5111d30df096277d11619b70e1c478bd", "committedDate": "2020-04-07T17:18:45Z", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "committedDate": "2020-04-08T00:05:29Z", "message": "test that @This annotations are actually getting inserted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85b047f3fc43707a1f1db671f92bfaf1d50729fb", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/85b047f3fc43707a1f1db671f92bfaf1d50729fb", "committedDate": "2020-04-08T00:54:16Z", "message": "fixed framesupport name & fixed AutoValue string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96ba71365267951399a1b0314d89d9c7460bd92d", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/96ba71365267951399a1b0314d89d9c7460bd92d", "committedDate": "2020-04-08T04:25:16Z", "message": "don't make @UnknownThis default for Void"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8235bfe8873bd936ef456dcbb1996b3e1239c24f", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/8235bfe8873bd936ef456dcbb1996b3e1239c24f", "committedDate": "2020-04-08T04:34:21Z", "message": "fix javadoc and variable names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "319154ff04a573308c2589fbdf61281ca2fb86fa", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/319154ff04a573308c2589fbdf61281ca2fb86fa", "committedDate": "2020-04-08T05:06:12Z", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74d8beb7b29d1acdb2eed153f6796020e594f9fd", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/74d8beb7b29d1acdb2eed153f6796020e594f9fd", "committedDate": "2020-04-08T05:10:41Z", "message": "Don't make a package for just one file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "committedDate": "2020-04-08T16:08:14Z", "message": "javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "committedDate": "2020-04-08T16:11:58Z", "message": "narrow visibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ce086428cbe7931c5964e77f3c7999598d049a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/87ce086428cbe7931c5964e77f3c7999598d049a", "committedDate": "2020-04-08T16:16:35Z", "message": "Code review improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c4a33975b813a0efa9fbee05ca7a1633adca9a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/15c4a33975b813a0efa9fbee05ca7a1633adca9a", "committedDate": "2020-04-08T16:17:15Z", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/45df4580377cef06691e8476aa03042e5d6c208b", "committedDate": "2020-04-08T16:20:35Z", "message": "Code review improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b9d77c45ecbf32674f6dce632616c3687786485", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3b9d77c45ecbf32674f6dce632616c3687786485", "committedDate": "2020-04-08T16:28:17Z", "message": "Punctuation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTMzNzY1", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-390133765", "createdAt": "2020-04-08T16:23:46Z", "commit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyMzo0NlrOGC2__g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNzo0NlrOGC3K1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTQ1NA==", "bodyText": "This code doesn't care about the existence of the FluentAPIGenerator class.  I would be inclined to create a method returnsThis and put the for loop within it.  Then the FluentAPIGenerator enum can be private, since it is only used by that method.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405651454", "createdAt": "2020-04-08T16:23:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                for (FluentAPIGenerator fluentAPIGenerator :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjA4Nw==", "bodyText": "It is inconsistent that this code uses getAnnotationByName but the below code uses containsSameByName.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405652087", "createdAt": "2020-04-08T16:24:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzgxMg==", "bodyText": "Could you clarify this comment?  Is code generated if the superclass is an AutoValue builder, or if the superclass is not?  What is done with generated code:  ignore it, or be sure to process it too?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405653812", "createdAt": "2020-04-08T16:27:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(\n+                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n+                            != null;\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NDIyOQ==", "bodyText": "Could you document this field?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405654229", "createdAt": "2020-04-08T16:27:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "committedDate": "2020-04-08T18:40:48Z", "message": "wrapped FluentAPIGenerators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92ea24988903262e7a706c9b172c9a2ba2e0d578", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/92ea24988903262e7a706c9b172c9a2ba2e0d578", "committedDate": "2020-04-08T19:08:07Z", "message": "fixed javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "committedDate": "2020-04-08T19:21:50Z", "message": "added documantion for AUTO_VALUE_BUILDER field"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwOTg2MzM5", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-390986339", "createdAt": "2020-04-09T17:21:44Z", "commit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMDAwODMy", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-391000832", "createdAt": "2020-04-09T17:42:53Z", "commit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Mjo1M1rOGDi2_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1OToyM1rOGDjcqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw==", "bodyText": "Why does this PR add purity-checker.tex here?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406370047", "createdAt": "2020-04-09T17:42:53Z", "author": {"login": "kelloggm"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTgyNA==", "bodyText": "nit: \"due to a side effect\"", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406371824", "createdAt": "2020-04-09T17:45:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MjQ5MA==", "bodyText": "Nit: this code would be easier to read if you imported AnnotatedExecutableType directly rather than qualifying it everywhere it appears. Most of the other code in the CF uses that style.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406372490", "createdAt": "2020-04-09T17:46:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzAxOA==", "bodyText": "Why RuntimeException rather than BugInCF?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373018", "createdAt": "2020-04-09T17:47:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzgwMg==", "bodyText": "same question about RuntimeException vs BugInCF", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373802", "createdAt": "2020-04-09T17:49:12Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDI0NQ==", "bodyText": "Nit: t is the annotated type of the method signature, not the method itself (which would be an ExecutableElement, probably)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374245", "createdAt": "2020-04-09T17:49:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDU0MQ==", "bodyText": "Same comment as above about t", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374541", "createdAt": "2020-04-09T17:50:31Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTEzOQ==", "bodyText": "It is better style to always use { and } to surround the body of an if, even if it is one statement, because the code might change later to include multiple statements.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406375139", "createdAt": "2020-04-09T17:51:35Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean checkForFluentAPIGenerators(\n+            AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3Njg5OQ==", "bodyText": "Should this error state what the valid locations for @This annotations are?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406376899", "createdAt": "2020-04-09T17:54:38Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NzY5MA==", "bodyText": "Void can't be initialized, so its type probably doesn't matter.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406377690", "createdAt": "2020-04-09T17:55:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODE3Mg==", "bodyText": "Please add a Javadoc comment for this test", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378172", "createdAt": "2020-04-09T17:56:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ==", "bodyText": "This comment is no longer accurate. It can be shortened to just \"tests the returns receiver checker's lombok integration\" or similar", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378559", "createdAt": "2020-04-09T17:57:29Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODc3NA==", "bodyText": "It probably ought to also mention that the test files have been delomobok'd", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378774", "createdAt": "2020-04-09T17:57:51Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTE3Mw==", "bodyText": "We probably don't need this comment here anymore. If nothing else, please change the link so that it's no longer a URL, since these are now in the same repo.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379173", "createdAt": "2020-04-09T17:58:35Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/returnsreceiver} folder. To add a new test\n+ * case, create a Java file in that directory. The file contains \"// ::\" comments to indicate\n+ * expected errors and warnings; see\n+ * https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTY4OQ==", "bodyText": "The tests don't actually run lombok - the code is already delombok'd.\nWe should probably add a script that does, in fact, run delombok on the original source files before running the RR tests.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379689", "createdAt": "2020-04-09T17:59:23Z", "author": {"login": "kelloggm"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +34,13 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8484e84d32c6915f92ff03a62ef31812bc176f4b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8484e84d32c6915f92ff03a62ef31812bc176f4b", "committedDate": "2020-04-09T21:59:55Z", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c99ff12b206151524b2d5941b91ae42664f359a0", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c99ff12b206151524b2d5941b91ae42664f359a0", "committedDate": "2020-04-09T22:00:36Z", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fc75ded7470e0022c3d543df066fb9f88fe05da", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/1fc75ded7470e0022c3d543df066fb9f88fe05da", "committedDate": "2020-04-10T22:23:36Z", "message": "fixed comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "committedDate": "2020-04-13T20:11:18Z", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acada3aca97257d8cb6d01b80c6df509ea6ec91f", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/acada3aca97257d8cb6d01b80c6df509ea6ec91f", "committedDate": "2020-04-13T23:05:33Z", "message": "added delombok task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "committedDate": "2020-04-13T23:12:11Z", "message": "cleaned build.gradle file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9bab392b39000a5a6973ac69050271684d91d0a", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d9bab392b39000a5a6973ac69050271684d91d0a", "committedDate": "2020-04-14T00:29:30Z", "message": "added newLine for framework/build.gradle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7995c9e095d48f3297d8d8091a01b567a64c85f7", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/7995c9e095d48f3297d8d8091a01b567a64c85f7", "committedDate": "2020-04-14T01:29:48Z", "message": "test configurations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aceac536d09448a02432560d9cc05414f03ce8a6", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/aceac536d09448a02432560d9cc05414f03ce8a6", "committedDate": "2020-04-14T21:48:07Z", "message": "added wrapper methods and fixed gradle cache for delombok task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "committedDate": "2020-04-14T22:29:08Z", "message": "Run delombok as an action, not during configuration time"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzQxMTAz", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-393341103", "createdAt": "2020-04-14T22:32:37Z", "commit": {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMjozN1rOGFjUPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMjozN1rOGFjUPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDY4NQ==", "bodyText": "@nimakarimipour can we add a comment here indicating why this canBeResolved flag is needed?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408474685", "createdAt": "2020-04-14T22:32:37Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +35,19 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"\n+}\n+\n+configurations{\n+    testImplementation{\n+        canBeResolved = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "committedDate": "2020-04-14T22:51:01Z", "message": "switch to using testCompileClasspath in delombok task"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzQ5OTky", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-393349992", "createdAt": "2020-04-14T22:54:34Z", "commit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NDozNVrOGFjzKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NDozNVrOGFjzKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjYwMg==", "bodyText": "@kelloggm it seems that if Lombok is run without this option, the Returns Receiver Checker does not add annotations properly, since it looks for @lombok.Generated annotations.  I'm guessing the same is true for Object Construction Checker.  Does this sound right?  If so, we should document it somewhere.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408482602", "createdAt": "2020-04-14T22:54:35Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/lombok.config", "diffHunk": "@@ -0,0 +1 @@\n+lombok.addLombokGeneratedAnnotation = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzc5NjY2", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-393379666", "createdAt": "2020-04-15T00:21:13Z", "commit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMToxM1rOGFleTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMzo1MVrOGFlheA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDAyOQ==", "bodyText": "not -> note\nAlso, I think this comment needs to be updated given the new strategy for delombok'ing the tests.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510029", "createdAt": "2020-04-15T00:21:13Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, please not that the test files have been", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDg0MA==", "bodyText": "These two builders are not \"good\" - they're both incorrect. That comment looks like a holdover from the Object Construction Checker, and should be removed.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510840", "createdAt": "2020-04-15T00:23:51Z", "author": {"login": "kelloggm"}, "path": "framework/tests/returnsreceiverlombok/BuilderTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderTest {\n+    @Getter @Setter private Integer x;\n+    @Getter @Setter @NonNull private Integer y;\n+    @Getter @Setter @NonNull private Integer z;\n+\n+    public static void test_simplePattern() {\n+        BuilderTest.builder().x(0).y(0).build(); // good builder\n+        BuilderTest.builder().y(0).build(); // good builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzgxNzI0", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-393381724", "createdAt": "2020-04-15T00:27:54Z", "commit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyNzo1NFrOGFlmNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyNzo1NFrOGFlmNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA==", "bodyText": "@kelloggm this subclass has the wrapper methods that ensure that @This annotations are getting inserted correctly for Lombok.  I think this should be sufficient for testing, but let us know if you think they belong elsewhere or need better documentation", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408512054", "createdAt": "2020-04-15T00:27:54Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b879b77b7fde9edd496e668100611e9caafa0f68", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/b879b77b7fde9edd496e668100611e9caafa0f68", "committedDate": "2020-04-15T17:55:45Z", "message": "fixed comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f67c44be28b04af2e1602cf6afa046d1281086b7", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/f67c44be28b04af2e1602cf6afa046d1281086b7", "committedDate": "2020-04-15T21:10:40Z", "message": "Added wrapper methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTgwMjI2", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-394180226", "createdAt": "2020-04-15T22:31:48Z", "commit": {"oid": "f67c44be28b04af2e1602cf6afa046d1281086b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "committedDate": "2020-04-16T20:52:07Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ac96286a2c944ce7b0929bba4dc487e69521bd9", "author": {"user": {"login": "wmdietl", "name": "Werner Dietl"}}, "url": "https://github.com/typetools/checker-framework/commit/9ac96286a2c944ce7b0929bba4dc487e69521bd9", "committedDate": "2020-04-17T20:45:55Z", "message": "Fix capitalization."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzI0NzUx", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-395724751", "createdAt": "2020-04-17T19:39:59Z", "commit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTozOTo1OVrOGHaytw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1Mjo1MlrOGHcvPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjE4Mw==", "bodyText": "I like the first sentence from the manual section better than this summary. How about using that here?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410432183", "createdAt": "2020-04-17T19:39:59Z", "author": {"login": "wmdietl"}, "path": "changelog.txt", "diffHunk": "@@ -1,3 +1,8 @@\n+Version 3.3.1, May 1, 2020\n+\n+The Returns Receiver Checker verifies whether a method returns its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw==", "bodyText": "Shouldn't it be legal to explicitly write it on the receiver type?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410433367", "createdAt": "2020-04-17T19:42:43Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzY2Ng==", "bodyText": "Should this mention that the return type has to be exactly the type of the enclosing method? (Or is there a different rule?)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410433666", "createdAt": "2020-04-17T19:43:23Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTc4MQ==", "bodyText": "Pragrammers -> Programmers", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410435781", "createdAt": "2020-04-17T19:47:52Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjI5Mg==", "bodyText": "Why are you telling me about them, then? I find this introduction a bit off-putting. Maybe phrase this more inviting?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410436292", "createdAt": "2020-04-17T19:48:57Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjkwMA==", "bodyText": "The polymorphic qualifier for a hierarchy is a subtype of top for that hierarchy. Top is top...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410436900", "createdAt": "2020-04-17T19:50:12Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzOTk3MA==", "bodyText": "annoattion -> annotation", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410439970", "createdAt": "2020-04-17T19:56:49Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annoattion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MTc0OA==", "bodyText": "This talks about a default that you implemented, it doesn't explain the type hierarchy.\nA polymorphic annotation gets resolved to one of the other qualifiers in the hierarchy. The only other qualifiers are UnknownThis and BottomThis... which one is the default otherwise? You simply reply on the fact that within a method you don't know what a polymorphic qualifier is resolved to and is the only thing that is assignable to a poly return. You don't care at all about polymorphism at the invocation site.\nSo poly resolution and the hierarchy could be described a bit nicer here...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410441748", "createdAt": "2020-04-17T20:00:49Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annoattion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw==", "bodyText": "Documentation of the public purpose of this class would still be useful... is this meant as an opaque token?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444033", "createdAt": "2020-04-17T20:06:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDU3Mg==", "bodyText": "Should the needed instead be needs?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444572", "createdAt": "2020-04-17T20:07:24Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NTUzMQ==", "bodyText": "Should enclosingType be enclosingElement or something else?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410445531", "createdAt": "2020-04-17T20:09:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5Mg==", "bodyText": "The point of the class seems to be method checkForFluentAPIGenerators. So I would have liked to see a documentation of that, not the implementation detail about the enum.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448092", "createdAt": "2020-04-17T20:15:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODk4Nw==", "bodyText": "(I'm also not sure whether I would repeat the class name in the method name... instead of FluentAPIGenerator.checkForFluentAPIGenerators isn't FluentAPIGenerator.check simpler and as clear?)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448987", "createdAt": "2020-04-17T20:17:22Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTI0OQ==", "bodyText": "This is the only public method for this class and should be documented.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449249", "createdAt": "2020-04-17T20:18:00Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the annotated type of the method signature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ==", "bodyText": "Why does this need to be package private? Could it be protected or even private?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449511", "createdAt": "2020-04-17T20:18:30Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDY3Nw==", "bodyText": "Why not simply return if it's a constructor? That makes the intent even clearer and reduces the indentation for the rest of the method.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410450677", "createdAt": "2020-04-17T20:20:53Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MTk5MA==", "bodyText": "Why do you need this special logic?\nCouldn't you simply add @DefaultFor({TypeUseLocation.RECEIVER}) to the declaration of @This?\nAll receivers are @This. The only extra logic you need is to automatically make the fluent API return types @This.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410451990", "createdAt": "2020-04-17T20:23:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQyNw==", "bodyText": "There is a single use of this method.\nWouldn't it be much simpler to simply write if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) { return; } above? (Addressing my earlier comment about returning early.)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410453427", "createdAt": "2020-04-17T20:26:58Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation\n+                // to the receiver type.\n+                AnnotationMirror retAnnotation =\n+                        returnType.getAnnotationInHierarchy(THIS_ANNOTATION);\n+                if (retAnnotation != null\n+                        && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                    AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                    if (!receiverType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        receiverType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+            }\n+            return super.visitExecutable(t, p);\n+        }\n+    }\n+\n+    /**\n+     * @return {@code true} if the param {@code t} is a {@code Constructor}\n+     * @param t a {@link AnnotatedTypeMirror}\n+     */\n+    private boolean isConstructor(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTM0NQ==", "bodyText": "Sure. Maybe we don't have a nice way to validate executable types at the moment. So maybe file a follow-up issue.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455345", "createdAt": "2020-04-17T20:31:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ==", "bodyText": "I find !isReturn && !isCastAnnot easier to look at visually and easier to understand... but you might prefer this way.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455739", "createdAt": "2020-04-17T20:32:31Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NzI2NA==", "bodyText": "You could either use the existing type.invalid annotation or follow that naming type.invalid.this.location.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410457264", "createdAt": "2020-04-17T20:36:28Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NzU2NA==", "bodyText": "Oh, I would find invalid location for @This annotation, only usable on method returns and receivers more helpful.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410457564", "createdAt": "2020-04-17T20:37:15Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3Njg5OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTY4Nw==", "bodyText": "value -> type", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410459687", "createdAt": "2020-04-17T20:42:18Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ==", "bodyText": "Instead of putting it so operationally, why not make this simply a default for all receivers.\nIs there any harm if they are always @This?\nIs there any harm in allowing programmers to explicitly mark receivers @This?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410460189", "createdAt": "2020-04-17T20:43:29Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MTkxMw==", "bodyText": "You should start javadoc sentences with an upper case letter and end it with a ..", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410461913", "createdAt": "2020-04-17T20:47:27Z", "author": {"login": "wmdietl"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, the test files in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac96286a2c944ce7b0929bba4dc487e69521bd9"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MzQ2Ng==", "bodyText": "You could also move the method to the beginning of the class...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410463466", "createdAt": "2020-04-17T20:51:17Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDA2Mg==", "bodyText": "I see one usage outside this package, which could just use areSameByClass...\nat least add a comment why you used package private.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410464062", "createdAt": "2020-04-17T20:52:52Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63ae99f8b3c757104c221ca87f52c2e56fba693e", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/63ae99f8b3c757104c221ca87f52c2e56fba693e", "committedDate": "2020-04-20T00:31:54Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73f6ce9dcf2d274ea08f003243f7db531f446f40", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/73f6ce9dcf2d274ea08f003243f7db531f446f40", "committedDate": "2020-04-20T01:24:46Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "committedDate": "2020-04-20T20:27:47Z", "message": "Spell-check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a89bed9475226d1cce89e009d15ad7eeb0400f8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0a89bed9475226d1cce89e009d15ad7eeb0400f8", "committedDate": "2020-04-20T20:27:52Z", "message": "Improve changelog entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "committedDate": "2020-04-20T20:30:37Z", "message": "Rewordings from review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODMyMTI3", "url": "https://github.com/typetools/checker-framework/pull/3199#pullrequestreview-396832127", "createdAt": "2020-04-20T21:38:32Z", "commit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozODozM1rOGIoyXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozODozM1rOGIoyXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ==", "bodyText": "#3199 (comment)\nDid you try using @DefaultFor({TypeUseLocation.RECEIVER}) on the declaration of @This?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411710045", "createdAt": "2020-04-20T21:38:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aeffa88f34d52e488558c2423c1badc4142192ee", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/aeffa88f34d52e488558c2423c1badc4142192ee", "committedDate": "2020-04-22T17:18:02Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6289b40a4c707268b186464097192be23c668aa", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/e6289b40a4c707268b186464097192be23c668aa", "committedDate": "2020-04-22T17:36:15Z", "message": "add a comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2915, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}