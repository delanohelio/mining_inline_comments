{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MzEzMTMz", "number": 3663, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMTo0NTo1OVrOEjYyTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMTo0NTo1OVrOEjYyTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NTQxNzExOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwMTo0NTo1OVrOHRtdoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0NTo1M1rOHVXV8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA==", "bodyText": "The following should work:\nTypeMirror receiverType = TreeUtils.elementFromDeclaration(node).getReceiverType();\n\nIf the method has no receiver, the type returned with have TypeKind.NONE.", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r488332704", "createdAt": "2020-09-15T01:45:59Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -341,4 +347,71 @@ public boolean validateType(Tree tree, AnnotatedTypeMirror type) {\n \n         return true;\n     }\n+\n+    /**\n+     * Returns true if an expression of the given type can be a compile-time constant value.\n+     *\n+     * @param tm a type\n+     * @return true if an expression of the given type can be a compile-time constant value\n+     */\n+    private boolean canBeConstant(TypeMirror tm) {\n+        return TypesUtils.isPrimitive(tm)\n+                || TypesUtils.isBoxedPrimitive(tm)\n+                || TypesUtils.isString(tm)\n+                || (tm.getKind() == TypeKind.ARRAY\n+                        && canBeConstant(((ArrayType) tm).getComponentType()));\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree node, Void p) {\n+        super.visitMethod(node, p);\n+\n+        ExecutableElement method = TreeUtils.elementFromDeclaration(node);\n+        if (atypeFactory.getDeclAnnotation(method, StaticallyExecutable.class) != null) {\n+            // The method is annotated as @StaticallyExecutable.\n+            if (atypeFactory.getDeclAnnotation(method, Pure.class) == null) {\n+                checker.reportWarning(node, \"statically.executable.not.pure\");\n+            }\n+            TypeMirror returnType = method.getReturnType();\n+            if (returnType.getKind() != TypeKind.VOID && !canBeConstant(returnType)) {\n+                checker.reportError(\n+                        node, \"statically.executable.nonconstant.return.type\", returnType);\n+            }\n+\n+            // Ways to determin the receiver type.\n+            // 1. This definition of receiverType is null when receiver is implicit and method has\n+            //    class com.sun.tools.javac.code.Symbol$MethodSymbol.  WHY?\n+            //        TypeMirror receiverType = method.getReceiverType();\n+            // 2. Can't use the tree, because the receiver might not be explicit.\n+            // 3. Check whether method is static and use the declaring class.  Doesn't handle all\n+            //    cases, but handles the most common ones.\n+            TypeMirror receiverType = method.getReceiverType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af7a853f590d55913e921211dca9b08c2e1de631"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2NTAwNg==", "bodyText": "That doesn't seem to work for me.  It returns a null value.  Please see https://dev.azure.com/mernst22/checker-framework/_build/results?buildId=5190&view=results .", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r488365006", "createdAt": "2020-09-15T03:45:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -341,4 +347,71 @@ public boolean validateType(Tree tree, AnnotatedTypeMirror type) {\n \n         return true;\n     }\n+\n+    /**\n+     * Returns true if an expression of the given type can be a compile-time constant value.\n+     *\n+     * @param tm a type\n+     * @return true if an expression of the given type can be a compile-time constant value\n+     */\n+    private boolean canBeConstant(TypeMirror tm) {\n+        return TypesUtils.isPrimitive(tm)\n+                || TypesUtils.isBoxedPrimitive(tm)\n+                || TypesUtils.isString(tm)\n+                || (tm.getKind() == TypeKind.ARRAY\n+                        && canBeConstant(((ArrayType) tm).getComponentType()));\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree node, Void p) {\n+        super.visitMethod(node, p);\n+\n+        ExecutableElement method = TreeUtils.elementFromDeclaration(node);\n+        if (atypeFactory.getDeclAnnotation(method, StaticallyExecutable.class) != null) {\n+            // The method is annotated as @StaticallyExecutable.\n+            if (atypeFactory.getDeclAnnotation(method, Pure.class) == null) {\n+                checker.reportWarning(node, \"statically.executable.not.pure\");\n+            }\n+            TypeMirror returnType = method.getReturnType();\n+            if (returnType.getKind() != TypeKind.VOID && !canBeConstant(returnType)) {\n+                checker.reportError(\n+                        node, \"statically.executable.nonconstant.return.type\", returnType);\n+            }\n+\n+            // Ways to determin the receiver type.\n+            // 1. This definition of receiverType is null when receiver is implicit and method has\n+            //    class com.sun.tools.javac.code.Symbol$MethodSymbol.  WHY?\n+            //        TypeMirror receiverType = method.getReceiverType();\n+            // 2. Can't use the tree, because the receiver might not be explicit.\n+            // 3. Check whether method is static and use the declaring class.  Doesn't handle all\n+            //    cases, but handles the most common ones.\n+            TypeMirror receiverType = method.getReceiverType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}, "originalCommit": {"oid": "af7a853f590d55913e921211dca9b08c2e1de631"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDMxNw==", "bodyText": "That's strange.  The documentation of ExecutableType does not match its implementation.  You can still use that method, just check for null.", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r492164317", "createdAt": "2020-09-21T15:45:27Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -341,4 +347,71 @@ public boolean validateType(Tree tree, AnnotatedTypeMirror type) {\n \n         return true;\n     }\n+\n+    /**\n+     * Returns true if an expression of the given type can be a compile-time constant value.\n+     *\n+     * @param tm a type\n+     * @return true if an expression of the given type can be a compile-time constant value\n+     */\n+    private boolean canBeConstant(TypeMirror tm) {\n+        return TypesUtils.isPrimitive(tm)\n+                || TypesUtils.isBoxedPrimitive(tm)\n+                || TypesUtils.isString(tm)\n+                || (tm.getKind() == TypeKind.ARRAY\n+                        && canBeConstant(((ArrayType) tm).getComponentType()));\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree node, Void p) {\n+        super.visitMethod(node, p);\n+\n+        ExecutableElement method = TreeUtils.elementFromDeclaration(node);\n+        if (atypeFactory.getDeclAnnotation(method, StaticallyExecutable.class) != null) {\n+            // The method is annotated as @StaticallyExecutable.\n+            if (atypeFactory.getDeclAnnotation(method, Pure.class) == null) {\n+                checker.reportWarning(node, \"statically.executable.not.pure\");\n+            }\n+            TypeMirror returnType = method.getReturnType();\n+            if (returnType.getKind() != TypeKind.VOID && !canBeConstant(returnType)) {\n+                checker.reportError(\n+                        node, \"statically.executable.nonconstant.return.type\", returnType);\n+            }\n+\n+            // Ways to determin the receiver type.\n+            // 1. This definition of receiverType is null when receiver is implicit and method has\n+            //    class com.sun.tools.javac.code.Symbol$MethodSymbol.  WHY?\n+            //        TypeMirror receiverType = method.getReceiverType();\n+            // 2. Can't use the tree, because the receiver might not be explicit.\n+            // 3. Check whether method is static and use the declaring class.  Doesn't handle all\n+            //    cases, but handles the most common ones.\n+            TypeMirror receiverType = method.getReceiverType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}, "originalCommit": {"oid": "af7a853f590d55913e921211dca9b08c2e1de631"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDU5NA==", "bodyText": "Or you can merge this pull request as is.", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r492164594", "createdAt": "2020-09-21T15:45:53Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -341,4 +347,71 @@ public boolean validateType(Tree tree, AnnotatedTypeMirror type) {\n \n         return true;\n     }\n+\n+    /**\n+     * Returns true if an expression of the given type can be a compile-time constant value.\n+     *\n+     * @param tm a type\n+     * @return true if an expression of the given type can be a compile-time constant value\n+     */\n+    private boolean canBeConstant(TypeMirror tm) {\n+        return TypesUtils.isPrimitive(tm)\n+                || TypesUtils.isBoxedPrimitive(tm)\n+                || TypesUtils.isString(tm)\n+                || (tm.getKind() == TypeKind.ARRAY\n+                        && canBeConstant(((ArrayType) tm).getComponentType()));\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree node, Void p) {\n+        super.visitMethod(node, p);\n+\n+        ExecutableElement method = TreeUtils.elementFromDeclaration(node);\n+        if (atypeFactory.getDeclAnnotation(method, StaticallyExecutable.class) != null) {\n+            // The method is annotated as @StaticallyExecutable.\n+            if (atypeFactory.getDeclAnnotation(method, Pure.class) == null) {\n+                checker.reportWarning(node, \"statically.executable.not.pure\");\n+            }\n+            TypeMirror returnType = method.getReturnType();\n+            if (returnType.getKind() != TypeKind.VOID && !canBeConstant(returnType)) {\n+                checker.reportError(\n+                        node, \"statically.executable.nonconstant.return.type\", returnType);\n+            }\n+\n+            // Ways to determin the receiver type.\n+            // 1. This definition of receiverType is null when receiver is implicit and method has\n+            //    class com.sun.tools.javac.code.Symbol$MethodSymbol.  WHY?\n+            //        TypeMirror receiverType = method.getReceiverType();\n+            // 2. Can't use the tree, because the receiver might not be explicit.\n+            // 3. Check whether method is static and use the declaring class.  Doesn't handle all\n+            //    cases, but handles the most common ones.\n+            TypeMirror receiverType = method.getReceiverType();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}, "originalCommit": {"oid": "af7a853f590d55913e921211dca9b08c2e1de631"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1532, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}