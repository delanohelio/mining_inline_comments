{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMjE5Njc5", "number": 3678, "title": "Mention TreeAnnotator and TypeAnnotator in \"creating a checker\"", "bodyText": "", "createdAt": "2020-09-22T22:06:23Z", "url": "https://github.com/typetools/checker-framework/pull/3678", "merged": true, "mergeCommit": {"oid": "a4bc1d827109c84fae70d7c51cb23f5393a2d936"}, "closed": true, "closedAt": "2020-09-24T01:50:32Z", "author": {"login": "mernst"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLebfhgH2gAyNDkxMjE5Njc5OmYyODFmMTFjZDJmYmUyMjk2NGZjMWQ2MGJiNjA3OGNiODQ2NzE0MTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdL02BGAH2gAyNDkxMjE5Njc5OjI4MjA3Njk1ODllZTIyNGRkYzBmN2M5YjRkMGM0ODQ2NGIxZDllZGI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f281f11cd2fbe22964fc1d60bb6078cb84671416", "committedDate": "2020-09-22T20:57:35Z", "message": "Mention TreeAnnotator and TypeAnnotator in \"creating a checker\""}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0OTAzNzM0", "url": "https://github.com/typetools/checker-framework/pull/3678#pullrequestreview-494903734", "createdAt": "2020-09-23T17:49:06Z", "commit": {"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzo0OTowNlrOHW50sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNzo1MjoyNFrOHW584w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3ODA5Ng==", "bodyText": "PropagationTreeAnnotator isn't the only annotator that super runs.", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493778096", "createdAt": "2020-09-23T17:49:06Z", "author": {"login": "smillst"}, "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3OTAzNg==", "bodyText": "It adds annotations to AnnotatedTypeMirrors that do not have an annotation.", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493779036", "createdAt": "2020-09-23T17:50:28Z", "author": {"login": "smillst"}, "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,\n+  which is run by default, adds annotations to unannotated trees, but has", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc4MDE5NQ==", "bodyText": "I think you should have deleted the rest of this section?", "url": "https://github.com/typetools/checker-framework/pull/3678#discussion_r493780195", "createdAt": "2020-09-23T17:52:24Z", "author": {"login": "smillst"}, "path": "docs/manual/creating-a-checker.tex", "diffHunk": "@@ -1182,29 +1182,77 @@\n \\subsectionAndLabel{Procedurally specifying type introduction rules}{creating-procedurally-specifying-implicit-annotations}\n \n If the meta-annotations are not sufficiently expressive, then you\n-can write your own type introduction rules.  To do so, create a subclass of\n-\\refclass{framework/type}{AnnotatedTypeFactory} and override its\n-two \\<addComputedTypeAnnotations> methods.\n-\n-\\<AnnotatedTypeFactory>, when given a program\n-expression, returns the expression's type.  This should include not only\n-the qualifiers that the programmer explicitly wrote in the source code, but\n-also default annotations and type\n-refinement (see Section~\\ref{effective-qualifier} for explanations of these\n-concepts).\n-\n-To add type introduction rules, you should override\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror)}\n-(or\n-\\refmethodanchortext{framework/type}{GenericAnnotatedTypeFactory}{addComputedTypeAnnotations}{-com.sun.source.tree.Tree-org.checkerframework.framework.type.AnnotatedTypeMirror-boolean-}{addComputedTypeAnnotations(Tree,AnnotatedTypeMirror,boolean)}\n-if extending \\code{GenericAnnotatedTypeFactory})\n-and\n-\\refmethodanchortext{framework/type}{AnnotatedTypeFactory}{addComputedTypeAnnotations}{-javax.lang.model.element.Element-org.checkerframework.framework.type.AnnotatedTypeMirror-}{addComputedTypeAnnotations(Element,AnnotatedTypeMirror)}.\n-The methods operate on \\refclass{framework/type}{AnnotatedTypeMirror},\n-which is the Checker Framework's representation of an annotated type.\n-The methods can make arbitrary changes to the annotations on a type.\n+can write your own type introduction rules.  There are three ways to do so.\n+\n+\\begin{enumerate}\n+\\item\n+  Define a subclass of\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TreeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TreeAnnotator> for every AST node, and the visitor\n+  has access to both the tree (the AST node) and its type.  In your\n+  subclass of \\<AnnotatedTypeFactory>, override \\<createTreeAnnotator> to\n+  return a \\<ListTreeAnnotator> containing that annotator, as in\n \n-%TODO: document tree and type annotators here, which should be used instead of override addComputedTypeAnnotations if possible.\n+\\begin{Verbatim}\n+  @Override\n+  protected TreeAnnotator createTreeAnnotator() {\n+      return new ListTreeAnnotator(super.createTreeAnnotator(), new MyTreeAnnotator(this));\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TreeAnnotator first; note that \\<PropagationTreeAnnotator>,\n+  which is run by default, adds annotations to unannotated trees, but has\n+  no effect on trees that have an annotation).\n+\n+\\item\n+  Define a subclass of a\n+  \\refclass{org/checkerframework/framework/type/treeannotator}{TypeAnnotator},\n+  typically as a private inner class of your \\<AnnotatedTypeFactory>.\n+  There is a method of \\<TypeAnnotator> for every kind of type, and the\n+  visitor has access to only the type.  In your subclass of\n+  \\<AnnotatedTypeFactory>, override \\<createTypeAnnotator> to return a\n+  \\<ListTypeAnnotator> containing that annotator, as in\n+\n+\\begin{Verbatim}\n+  @Override\n+  protected TypeAnnotator createTypeAnnotator() {\n+      return new ListTypeAnnotator(new MyTypeAnnotator(this), super.createTypeAnnotator());\n+  }\n+\\end{Verbatim}\n+\n+  \\noindent\n+  (or put your TypeAnnotator last).\n+\n+\\item\n+  Create a subclass of \\refclass{framework/type}{AnnotatedTypeFactory} and\n+  override its two \\<addComputedTypeAnnotations> methods.  This is a last\n+  resort, if your logic cannot be implemented using a TreeAnnotator or a\n+  TypeAnnotator.  The implementation of \\<addComputedTypeAnnotations> in\n+  \\<GenericAnnotatedTypeFactory> calls the tree annotator and the type\n+  annotator (in that order), but by overriding the method you can cause\n+  your logic to be run even earlier or even later.\n+\n+  \\<AnnotatedTypeFactory>, when given a program\n+  expression, returns the expression's type.  This should include not only\n+  the qualifiers that the programmer explicitly wrote in the source code, but\n+  also default annotations and type\n+  refinement (see Section~\\ref{effective-qualifier} for explanations of these\n+  concepts).\n+\n+  To add type introduction rules, you should override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f281f11cd2fbe22964fc1d60bb6078cb84671416"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "568a4fe88e674bebd0806e90723eef34fe73118b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/568a4fe88e674bebd0806e90723eef34fe73118b", "committedDate": "2020-09-23T19:52:35Z", "message": "Tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1438f4dabca5a4d9e9cc29d8e3b92e2b339ff78", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c1438f4dabca5a4d9e9cc29d8e3b92e2b339ff78", "committedDate": "2020-09-23T23:04:19Z", "message": "Clarify writing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2820769589ee224ddc0f7c9b4d0c48464b1d9edb", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2820769589ee224ddc0f7c9b4d0c48464b1d9edb", "committedDate": "2020-09-23T23:04:28Z", "message": "Merge ../checker-framework-branch-master into documentation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2644, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}