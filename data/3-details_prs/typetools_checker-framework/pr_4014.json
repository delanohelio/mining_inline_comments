{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5MDAxMzYw", "number": 4014, "title": "Infer method contracts", "bodyText": "Review supertypes before subtypes, to see specifications for newly-added methods.\nMerge with typetools/annotation-tools#337.", "createdAt": "2020-12-13T18:55:37Z", "url": "https://github.com/typetools/checker-framework/pull/4014", "merged": true, "mergeCommit": {"oid": "f3c9ecc242b879a3949a9e3163545be4eb23d86c"}, "closed": true, "closedAt": "2020-12-22T18:08:41Z", "author": {"login": "mernst"}, "timelineItems": {"totalCount": 88, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdk938AgH2gAyNTM5MDAxMzYwOjRlM2I0ODg1MzU2ZmRjZDQ4MjgzNDRiMThiNGFiZjJkYzVjNzUwZDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdorpg0AH2gAyNTM5MDAxMzYwOjBlMDJlNDM1MDBiNmYzZGM1YjQzMTVlZGNjY2ExZmRkNjQ5YTFkNzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4e3b4885356fdcd4828344b18b4abf2dc5c750d4", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4e3b4885356fdcd4828344b18b4abf2dc5c750d4", "committedDate": "2020-12-11T01:43:49Z", "message": "Infer method preconditions and postconditions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0730cf9e57906adbb78550e860a21329412bc4e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c0730cf9e57906adbb78550e860a21329412bc4e", "committedDate": "2020-12-11T01:46:46Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36c96f401d096cb0036f16110e5b0ef7e7137e8a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/36c96f401d096cb0036f16110e5b0ef7e7137e8a", "committedDate": "2020-12-11T03:16:26Z", "message": "Implement inference of `@MonotonicNonNull`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "581b8dc7e0fc54b9a7613ed6a56ba191377155ca", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/581b8dc7e0fc54b9a7613ed6a56ba191377155ca", "committedDate": "2020-12-11T04:42:15Z", "message": "Pass binary names to Class.forName"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a50ae2cfddb6d41bb52100fe85a4e21ec1cde62", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8a50ae2cfddb6d41bb52100fe85a4e21ec1cde62", "committedDate": "2020-12-11T06:42:09Z", "message": "Implement getAnnotationFieldType without depending on values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eeb3ca31c4e38b28a7c1d99ec8f4a29d4a1547d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1eeb3ca31c4e38b28a7c1d99ec8f4a29d4a1547d", "committedDate": "2020-12-11T15:03:10Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecdf3e459aeae4667bca87044085aff26d95f6e9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ecdf3e459aeae4667bca87044085aff26d95f6e9", "committedDate": "2020-12-11T17:11:17Z", "message": "Don't return null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1caed254d202dd5c33ee2479ac4b20d7f798cfa9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1caed254d202dd5c33ee2479ac4b20d7f798cfa9", "committedDate": "2020-12-11T17:20:05Z", "message": "Merge ../checker-framework-fork-mernst-branch-typeMirrorToAnnotationFieldType into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dc1d52a3ddd46fa8ab3f04cb412b9b6b842dbbf", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0dc1d52a3ddd46fa8ab3f04cb412b9b6b842dbbf", "committedDate": "2020-12-11T18:26:24Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "975f4662ef0100e93404affaf49472e6e1ae8e1a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/975f4662ef0100e93404affaf49472e6e1ae8e1a", "committedDate": "2020-12-12T04:52:02Z", "message": "annotationMirrorToAnnotation returns a non-null value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be4fb3a7c112a3e05c23c01820fc68a1de1e42b7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/be4fb3a7c112a3e05c23c01820fc68a1de1e42b7", "committedDate": "2020-12-12T04:57:44Z", "message": "Add field WholeProgramInferenceScenesStorage.atypeFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43875eb6399e7b0d0417da98d284c49052566510", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/43875eb6399e7b0d0417da98d284c49052566510", "committedDate": "2020-12-12T05:02:24Z", "message": "Merge ../checker-framework-fork-mernst-branch-annotationMirrorToAnnotation-is-non-null into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "007f0b8bab5f95a2bca053cd61d9c0d59eac8f8e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/007f0b8bab5f95a2bca053cd61d9c0d59eac8f8e", "committedDate": "2020-12-12T05:08:59Z", "message": "Merge ../checker-framework-fork-mernst-branch-WholeProgramInferenceScenesStorage-atypeFactory into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5201941af96f83ef2b3ba7a9d9b81a34f95d204f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5201941af96f83ef2b3ba7a9d9b81a34f95d204f", "committedDate": "2020-12-12T06:13:40Z", "message": "Merge ../checker-framework-branch-master into annotationMirrorToAnnotation-is-non-null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1559cc04db3c9d795a57008d69fbdfee07056e04", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1559cc04db3c9d795a57008d69fbdfee07056e04", "committedDate": "2020-12-12T06:14:22Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e787d66662ceda35f6e2516cdced179ffa7533cb", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e787d66662ceda35f6e2516cdced179ffa7533cb", "committedDate": "2020-12-12T06:15:06Z", "message": "Merge ../checker-framework-fork-mernst-branch-annotationMirrorToAnnotation-is-non-null into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34324b09a1fc53dec286c692f896ad0f84ae98f9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/34324b09a1fc53dec286c692f896ad0f84ae98f9", "committedDate": "2020-12-12T14:36:03Z", "message": "Merge ../checker-framework-branch-master into WholeProgramInferenceScenesStorage-atypeFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a04a3ed175d86d035eb9b8e7f237783cf4d39d7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9a04a3ed175d86d035eb9b8e7f237783cf4d39d7", "committedDate": "2020-12-12T14:55:00Z", "message": "Add prepareSceneForWriting hook"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49ce9520af5afff83c9c422f02d8d97293e1dd48", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/49ce9520af5afff83c9c422f02d8d97293e1dd48", "committedDate": "2020-12-12T14:56:08Z", "message": "Updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "440b630a92a70d0c7caab619231bc48090dc5a2c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/440b630a92a70d0c7caab619231bc48090dc5a2c", "committedDate": "2020-12-12T14:57:05Z", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c37997a7a3bd427dc68890f6caeac0c4cf63a77", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1c37997a7a3bd427dc68890f6caeac0c4cf63a77", "committedDate": "2020-12-12T15:11:51Z", "message": "Tweak documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3ea3902aec56ba71aa63386586fe763b0659a36", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c3ea3902aec56ba71aa63386586fe763b0659a36", "committedDate": "2020-12-12T15:56:23Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23c9da5265436d385f362c8d76c00861db850d52", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/23c9da5265436d385f362c8d76c00861db850d52", "committedDate": "2020-12-12T15:58:24Z", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "539178173ad24845c61c8f0efe3c72c0976ee634", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/539178173ad24845c61c8f0efe3c72c0976ee634", "committedDate": "2020-12-12T18:06:33Z", "message": "Fix format string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4f95cc59b1261f98246d46477514437055d3ccf", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c4f95cc59b1261f98246d46477514437055d3ccf", "committedDate": "2020-12-13T06:34:53Z", "message": "Merge ../checker-framework-branch-master into prepareSceneForWriting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07c646b23ea3c772ac6f130d8604d69eb74b21a7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/07c646b23ea3c772ac6f130d8604d69eb74b21a7", "committedDate": "2020-12-13T06:37:21Z", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b5cbe9c0ae2c07c26a16e6963ab7b05cdf3bd76", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/6b5cbe9c0ae2c07c26a16e6963ab7b05cdf3bd76", "committedDate": "2020-12-13T06:39:11Z", "message": "Add annotation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aef8875790d08ff2166932673d4155fe1b80a2ef", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/aef8875790d08ff2166932673d4155fe1b80a2ef", "committedDate": "2020-12-13T15:58:32Z", "message": "Undo some diagnostic output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "766b4b027163c061afb63c007845b0aca19c13ea", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/766b4b027163c061afb63c007845b0aca19c13ea", "committedDate": "2020-12-13T17:14:03Z", "message": "Merge ../checker-framework-branch-master into WholeProgramInferenceScenesStorage-atypeFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e82c2f591ac40d42030b789d2ff96056aa386a97", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e82c2f591ac40d42030b789d2ff96056aa386a97", "committedDate": "2020-12-13T17:14:39Z", "message": "Merge ../checker-framework-fork-mernst-branch-WholeProgramInferenceScenesStorage-atypeFactory into prepareSceneForWriting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8c2a3ee73a54fdc120a20a067c5a591ef6c701", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/eb8c2a3ee73a54fdc120a20a067c5a591ef6c701", "committedDate": "2020-12-13T17:14:50Z", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d7dc3c47c7e161601e43e2c983dc574d884ecec", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2d7dc3c47c7e161601e43e2c983dc574d884ecec", "committedDate": "2020-12-13T18:47:40Z", "message": "Expand changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd769c38bbb3bdf42bbf9b89eec5055c3bfc2241", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cd769c38bbb3bdf42bbf9b89eec5055c3bfc2241", "committedDate": "2020-12-13T18:48:05Z", "message": "Undo changes to reduce diffs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/297f5c733e8b10e3143b0005e395abdd3f1a03a1", "committedDate": "2020-12-14T17:44:07Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTE5MDA1", "url": "https://github.com/typetools/checker-framework/pull/4014#pullrequestreview-551919005", "createdAt": "2020-12-14T21:45:08Z", "commit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0NTowOFrOIFrmTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo0MzozMlrOIGaYeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyODEwOQ==", "bodyText": "You could pass the AnnotatedTypeFactory instead of the checker.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542828109", "createdAt": "2020-12-14T21:45:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/SceneToStubWriter.java", "diffHunk": "@@ -706,7 +723,11 @@ private static void printClass(\n             printWriter.println();\n             for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n                 printMethodDeclaration(\n-                        methodEntry.getValue(), innermostClassname, printWriter, indentLevel);\n+                        methodEntry.getValue(),\n+                        innermostClassname,\n+                        printWriter,\n+                        indentLevel,\n+                        checker.getTypeFactory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyOTQ0OA==", "bodyText": "You added a formal parameter, so is this fixed?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542829448", "createdAt": "2020-12-14T21:46:28Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenesStorage.java", "diffHunk": "@@ -488,8 +494,10 @@ private void updateTypeElementFromATM(\n             typeToUpdate.tlAnnotationsHere.removeAll(annosToRemove);\n         }\n \n+        // PROBLEM:  This causes pre- and post-conditions to be ignored, though they might be\n+        // stronger.  Add a formal parameter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzNTY1MA==", "bodyText": "Instead of passing in the checker, could you add the contracts to the AMethod before writing out the scene, reusing the code below?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542835650", "createdAt": "2020-12-14T21:52:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -144,9 +150,23 @@ public void writeToFile(\n             try {\n                 switch (outputFormat) {\n                     case STUB:\n-                        SceneToStubWriter.write(this, filepath);\n+                        SceneToStubWriter.write(this, filepath, checker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NDc0OQ==", "bodyText": "This checks if the field is declared in the current class, but it doesn't make sure that the receiver of the field access is this.  (For static fields, you don't have to check.)", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543584749", "createdAt": "2020-12-15T18:29:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NjE5NA==", "bodyText": "Instead of looping through all the field accesses in the store above, could you just add an else branch here that does the same thing as the code above?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543586194", "createdAt": "2020-12-15T18:31:20Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {\n+                continue;\n+            }\n+\n+            AnnotatedTypeMirror atm = convertCFAbstractValueToAnnotatedTypeMirror(v, fieldType);\n+            adjustForUpdateNonField(atm);\n+\n+            AField afield = vivifyAndAddTypeMirrorToContract(amethod, preOrPost, fieldElement);\n+\n+            updateAnnotationSetInScene(\n+                    afield.type, TypeUseLocation.FIELD, atm, fieldType, jaifPath, false);\n+        }\n+\n+        // Process fields that are not in the store.\n+        TypeElement containingClass = (TypeElement) methodElt.getEnclosingElement();\n+        ThisReference thisReference = new ThisReference(containingClass.asType());\n+        ClassName classNameReceiver = new ClassName(containingClass.asType());\n+        for (VariableElement fieldElement :\n+                ElementFilter.fieldsIn(containingClass.getEnclosedElements())) {\n+            FieldAccess fa =\n+                    new FieldAccess(\n+                            (ElementUtils.isStatic(fieldElement)\n+                                    ? classNameReceiver\n+                                    : thisReference),\n+                            fieldElement.asType(),\n+                            fieldElement);\n+            if (store.getFieldValue(fa) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDE3Ng==", "bodyText": "It's not clear what \"all the below\" is referring to.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590176", "createdAt": "2020-12-15T18:37:27Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDcyMQ==", "bodyText": "I think this is done? Or should precondition be postcondition?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590721", "createdAt": "2020-12-15T18:38:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.\n+\n+    /**\n+     * Return the string representation of postcondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        return result;\n+    }\n+\n+    // TODO: Implement this here in this class, reading @PreconditionAnnotation meta-annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDYxNw==", "bodyText": "There's another version of this method org.checkerframework.javacutil.TypeAnnotationUtils#unannotatedType.  It makes more sense to have this method in TypesUtils.  Or at least that's where I always look for it first.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543594617", "createdAt": "2020-12-15T18:43:32Z", "author": {"login": "smillst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -893,4 +894,24 @@ public static TypeMirror substitute(\n                 com.sun.tools.javac.util.List.from(newP),\n                 com.sun.tools.javac.util.List.from(newT));\n     }\n+\n+    // This method is necessary because Type.stripMetadata does no work for primitive types.\n+    /**\n+     * Returns a copy of a type without annotations. May return tm itself if it has no annotations.\n+     *\n+     * @param tm a TypeMirror\n+     * @return a copy of the given type without annotations\n+     */\n+    public static TypeMirror unannotatedType(TypeMirror tm) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d88af64646d21e358ae57629811e5822e66de06", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0d88af64646d21e358ae57629811e5822e66de06", "committedDate": "2020-12-15T20:21:37Z", "message": "Don't re-implement a method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b65247e9f4b53e6727f1cdeff639236fd615f7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/34b65247e9f4b53e6727f1cdeff639236fd615f7", "committedDate": "2020-12-15T20:22:09Z", "message": "Clarify comments (that show this pull request is not yet ready)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff43d062c058da27220e36edd8583b49472340a8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ff43d062c058da27220e36edd8583b49472340a8", "committedDate": "2020-12-15T21:40:19Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e45175eabb529216d78e38f9f48fc07f71b2b76", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9e45175eabb529216d78e38f9f48fc07f71b2b76", "committedDate": "2020-12-15T23:57:02Z", "message": "Update expected output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "984286ea3c6f10fbb70983722a6dda36b5e6c72d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/984286ea3c6f10fbb70983722a6dda36b5e6c72d", "committedDate": "2020-12-16T06:00:17Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7956d6137f18ab2aea9da16da866a1a9fd65d643", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7956d6137f18ab2aea9da16da866a1a9fd65d643", "committedDate": "2020-12-16T15:33:16Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb9104a39dae25b4282b78e3f01d887e349dfd3c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cb9104a39dae25b4282b78e3f01d887e349dfd3c", "committedDate": "2020-12-16T21:17:16Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "811064aee981050af6f4ccc1e5a5ef397beb5a05", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/811064aee981050af6f4ccc1e5a5ef397beb5a05", "committedDate": "2020-12-17T03:14:47Z", "message": "Fix Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec223a70d21d084f9640bc4b6f504e05053ac2b7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ec223a70d21d084f9640bc4b6f504e05053ac2b7", "committedDate": "2020-12-17T15:40:08Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c38a658e31ac5759d1a1cb3a19d918f21739bff2", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c38a658e31ac5759d1a1cb3a19d918f21739bff2", "committedDate": "2020-12-17T17:22:16Z", "message": "Add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f2d2fb2d01f64133c473005ea6ffca4a7d1cf9c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2f2d2fb2d01f64133c473005ea6ffca4a7d1cf9c", "committedDate": "2020-12-18T14:35:48Z", "message": "Rename checker/tests/whole-program-inference/ to checker/tests/wpi-testchecker/"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0f7cb89df81ad67a0f2a981e37490502e44685d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f0f7cb89df81ad67a0f2a981e37490502e44685d", "committedDate": "2020-12-18T14:38:03Z", "message": "Remove debugging output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3faa277cc79b86fe563f00f824cf642f7c598795", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3faa277cc79b86fe563f00f824cf642f7c598795", "committedDate": "2020-12-18T14:58:27Z", "message": "Renamings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "771c8f66508c8992fa0566f43483cd78454e9c0b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/771c8f66508c8992fa0566f43483cd78454e9c0b", "committedDate": "2020-12-18T15:24:22Z", "message": "Tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4993c744c33101db6f7c811dcc696cebbb69185a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4993c744c33101db6f7c811dcc696cebbb69185a", "committedDate": "2020-12-18T15:25:02Z", "message": "Merge ../checker-framework-branch-master into wpi-tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9444b7d5b784018c3e563272040bca65165bdee8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9444b7d5b784018c3e563272040bca65165bdee8", "committedDate": "2020-12-18T15:27:05Z", "message": "Checkpoint while renaming and adding tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee8d54acdd252126a3268f707f7f7af99a3a8c1d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ee8d54acdd252126a3268f707f7f7af99a3a8c1d", "committedDate": "2020-12-18T15:30:53Z", "message": "Merge ../checker-framework-fork-mernst-branch-wpi-tests into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db0755fd8dc597c4ae1d793bb69a1e4ce947329e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/db0755fd8dc597c4ae1d793bb69a1e4ce947329e", "committedDate": "2020-12-18T17:59:04Z", "message": "Task renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bd2952e1b5037cb7a327ce509db17d997f2b01e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7bd2952e1b5037cb7a327ce509db17d997f2b01e", "committedDate": "2020-12-18T18:56:38Z", "message": "Add test for `@MonotonicNonNull`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a10f3889c5e9f66df566af8f634369e6f40b0d4", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5a10f3889c5e9f66df566af8f634369e6f40b0d4", "committedDate": "2020-12-18T19:01:36Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2d821fdcb4fbb63e3535eb48fa10785920a92d3", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e2d821fdcb4fbb63e3535eb48fa10785920a92d3", "committedDate": "2020-12-18T20:09:21Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3e85211f646dd7fb2176fa3cb33b5995d8763c4", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b3e85211f646dd7fb2176fa3cb33b5995d8763c4", "committedDate": "2020-12-18T20:47:13Z", "message": "Infer postcondition annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5683807cb4f8fc71097c21ad0f48d88bc0735ef7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5683807cb4f8fc71097c21ad0f48d88bc0735ef7", "committedDate": "2020-12-18T20:49:41Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36cde2ef26e6a2efffcbb26c4dea4212cff4279a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/36cde2ef26e6a2efffcbb26c4dea4212cff4279a", "committedDate": "2020-12-18T21:13:52Z", "message": "Fix name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e47fd39ca6c8e40bc5d1939c3bde105a99c33240", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e47fd39ca6c8e40bc5d1939c3bde105a99c33240", "committedDate": "2020-12-18T21:14:42Z", "message": "Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "316ee94c43d7f1a27cc72c74704f203710e98785", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/316ee94c43d7f1a27cc72c74704f203710e98785", "committedDate": "2020-12-18T21:16:23Z", "message": "Compute contract annotations in one place, centrally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e897b37386d3900be5cb2bcae8d40c75067b4b8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5e897b37386d3900be5cb2bcae8d40c75067b4b8", "committedDate": "2020-12-18T21:17:03Z", "message": "Suppress inference for irrelevant type system"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "395aab11629b3bbc2ced47482c61542e8a7b00f2", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/395aab11629b3bbc2ced47482c61542e8a7b00f2", "committedDate": "2020-12-18T21:36:56Z", "message": "Don't put AFU manipulations outside SceneToStubWriter and ASceneWrapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94917d36729349ea0048205ff4cbbb1321662f07", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/94917d36729349ea0048205ff4cbbb1321662f07", "committedDate": "2020-12-18T21:55:54Z", "message": "Rename method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5a7f271aa35bb32258a6d7fcb1775d3d17ea726", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d5a7f271aa35bb32258a6d7fcb1775d3d17ea726", "committedDate": "2020-12-18T22:50:29Z", "message": "Remove undesirable diagnostic output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea227d51887038b43681d0c65e6da2332c48c2db", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ea227d51887038b43681d0c65e6da2332c48c2db", "committedDate": "2020-12-18T22:59:33Z", "message": "Fix classpath"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7598f37a0a22e86fe1aba6562c158e861fcd29c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c7598f37a0a22e86fe1aba6562c158e861fcd29c", "committedDate": "2020-12-18T23:01:55Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80e438c60ca029bf52816a5dbe29ada4a335c406", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/80e438c60ca029bf52816a5dbe29ada4a335c406", "committedDate": "2020-12-18T23:40:11Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17896389456fdb386eefc82cbe56d3fc934eef56", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/17896389456fdb386eefc82cbe56d3fc934eef56", "committedDate": "2020-12-19T00:20:43Z", "message": "Undo refactoring to bring computation of preconditions together"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "765eb78c6f6bdb6e586f2b3e3d2e0e6ba1e1037b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/765eb78c6f6bdb6e586f2b3e3d2e0e6ba1e1037b", "committedDate": "2020-12-19T12:34:44Z", "message": "Use plume-lib version 1.3.0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4faf92cb7ae85f048fc864043566ecc8d133997f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4faf92cb7ae85f048fc864043566ecc8d133997f", "committedDate": "2020-12-19T16:52:14Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e0d03ec65921bc240d726583265e973bc3b8df2", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4e0d03ec65921bc240d726583265e973bc3b8df2", "committedDate": "2020-12-21T06:52:10Z", "message": "Prepare for merge (reduce differences with upstream)"}, "afterCommit": {"oid": "4faf92cb7ae85f048fc864043566ecc8d133997f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4faf92cb7ae85f048fc864043566ecc8d133997f", "committedDate": "2020-12-19T16:52:14Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3fd36c185c0b18a8c71d964eae984fa5fb0ee76", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b3fd36c185c0b18a8c71d964eae984fa5fb0ee76", "committedDate": "2020-12-21T07:02:20Z", "message": "Merge commit '45e666188db4ddfd2625c06cd3ddad1b65dfaf81' into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c41cd455b2ab483222ad06d37bd34e747797d1c9", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c41cd455b2ab483222ad06d37bd34e747797d1c9", "committedDate": "2020-12-21T07:02:25Z", "message": "Merge commit '8f345c13969a7371bbe11d1d8cdfe4b27f26ab44' into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c720dcc29b70a5afcbf593ad4e169ac34f1f6511", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c720dcc29b70a5afcbf593ad4e169ac34f1f6511", "committedDate": "2020-12-21T13:52:00Z", "message": "Reorder methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f596f391f8248d2c72d0be0e0f94fdabc7664c6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4f596f391f8248d2c72d0be0e0f94fdabc7664c6", "committedDate": "2020-12-21T14:08:41Z", "message": "Renamings to prepare for merging with d305a562c62f9db1155c2b86a65b9fac489db00c"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9c371832640094daf1865bdab02e5396ba12f16", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a9c371832640094daf1865bdab02e5396ba12f16", "committedDate": "2020-12-21T14:19:21Z", "message": "Merge commit 'd305a562c62f9db1155c2b86a65b9fac489db00c' into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ee89d4fea8798318c75404b292baff5c3df995a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2ee89d4fea8798318c75404b292baff5c3df995a", "committedDate": "2020-12-21T14:20:18Z", "message": "Merge commit 'bc9fea3987bde1543fb0671bab114c2b3511db00' into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bdcbe42afc844a5322ba717c8ca0f647d0f917f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2bdcbe42afc844a5322ba717c8ca0f647d0f917f", "committedDate": "2020-12-21T15:52:35Z", "message": "Reduce whitespace differences"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a94f1474443ac0fae11fc29152a5a510faffe5ea", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a94f1474443ac0fae11fc29152a5a510faffe5ea", "committedDate": "2020-12-21T15:55:18Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "608e52287df88b1939d20ffbc25dd0484a0d67dc", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/608e52287df88b1939d20ffbc25dd0484a0d67dc", "committedDate": "2020-12-21T18:13:26Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe16a0aff276c7caffd26bce4cda6487ca854e3c", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/fe16a0aff276c7caffd26bce4cda6487ca854e3c", "committedDate": "2020-12-21T23:11:38Z", "message": "Refer to test directory correctly."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/a7c8699a9b41fea3716994d8339837978502c254", "committedDate": "2020-12-21T23:12:43Z", "message": "Fix comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f32bf985eabb6a1eab550c36251d925d06563faa", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/f32bf985eabb6a1eab550c36251d925d06563faa", "committedDate": "2020-12-21T23:43:59Z", "message": "Add Nullable."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzIzNzE0", "url": "https://github.com/typetools/checker-framework/pull/4014#pullrequestreview-556723714", "createdAt": "2020-12-21T23:19:28Z", "commit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoxOToyOVrOIJpCBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNTowOFrOIJpTpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDM1OQ==", "bodyText": "I think we avoid statically importing methods/fields.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980359", "createdAt": "2020-12-21T23:19:29Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -1,19 +1,24 @@\n package org.checkerframework.common.wholeprograminference.scenelib;\n \n+import static org.plumelib.util.CollectionsPlume.mapList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDY5OQ==", "bodyText": "This for loop is now duplicated above.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980699", "createdAt": "2020-12-21T23:20:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -139,14 +144,48 @@ public void writeToFile(\n                 throw new BugInCF(\"Unhandled outputFormat \" + outputFormat);\n         }\n         new File(filepath).delete();\n+        // Only write non-empty scenes into files.\n         if (!scene.isEmpty()) {\n-            // Only write non-empty scenes into files.\n             try {\n+                for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {\n+                    AClass aClass = classEntry.getValue();\n+                    for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n+                        AMethod aMethod = methodEntry.getValue();\n+                        List<AnnotationMirror> contractAnnotationMirrors =\n+                                checker.getTypeFactory().getContractAnnotations(aMethod);\n+                        List<Annotation> contractAnnotations =\n+                                mapList(\n+                                        AnnotationConverter::annotationMirrorToAnnotation,\n+                                        contractAnnotationMirrors);\n+                        aMethod.contracts = contractAnnotations;\n+                    }\n+                }\n+\n                 switch (outputFormat) {\n                     case STUB:\n+                        // For stub files, pass in the checker to compute contracts on the fly;\n+                        // precomputing yields incorrect annotations, most likely due to nested\n+                        // classes.\n                         SceneToStubWriter.write(this, filepath, checker);\n                         break;\n                     case JAIF:\n+                        // For .jaif files, precompute contracts because the Annotation File\n+                        // Utilities knows nothing about (and cannot depend on) the Checker\n+                        // Framework.\n+                        for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MjIwMA==", "bodyText": "More static imports.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546982200", "createdAt": "2020-12-21T23:25:56Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1,5 +1,9 @@\n package org.checkerframework.framework.type;\n \n+import static org.checkerframework.dataflow.analysis.Analysis.BeforeOrAfter.AFTER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDU4NQ==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984585", "createdAt": "2020-12-21T23:34:04Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDc1Mw==", "bodyText": "This can be replaced with result.sort(Ordering.usingToString()); if you like.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984753", "createdAt": "2020-12-21T23:34:39Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDgxNQ==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984815", "createdAt": "2020-12-21T23:34:59Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDg3MA==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984870", "createdAt": "2020-12-21T23:35:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(\n+            VariableElement elt, AField f, List<AnnotationMirror> preconds) {\n+        return getPreOrPostconditionAnnotation(elt, f, AFTER, preconds);\n+    }\n+\n+    /**\n+     * Helper method for {@link #getPreconditionAnnotation} and {@link #getPostconditionAnnotation}.\n+     *\n+     * <p>Returns an {@code @EnsuresQualifier} or {@code @EnsuresQualifier} annotation for the given\n+     * field. Returns null if none can be created, because the qualifier has elements/arguments,\n+     * which {@code @EnsuresQualifier} and {@code @RequiresQualifier} do not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preOrPost whether to return preconditions or postconditions\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions; non-null exactly when {@code preOrPost} is {@code AFTER}\n+     * @return a postcondition annotation for the element, or null if none is appropriate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e978f3d51be9b6f249994601a502082f461a4d3c", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e978f3d51be9b6f249994601a502082f461a4d3c", "committedDate": "2020-12-22T14:36:50Z", "message": "Merge ../checker-framework-branch-master into infer-contracts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "822c6fda4a2b1b6710ed28c6d4d8fe8cde5f9289", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/822c6fda4a2b1b6710ed28c6d4d8fe8cde5f9289", "committedDate": "2020-12-22T14:37:35Z", "message": "Remove duplicated code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e02e43500b6f3dc5b4315edccca1fdd649a1d79", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0e02e43500b6f3dc5b4315edccca1fdd649a1d79", "committedDate": "2020-12-22T14:45:28Z", "message": "Address code review feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2451, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}