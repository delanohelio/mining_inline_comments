{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNTk4MzM3", "number": 3044, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzoyMTo0MVrODXS0qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzoyMTo0MVrODXS0qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzUyMjMyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzoyMTo0MVrOFcibLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzoyMTo0MVrOFcibLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ2ODQ2MQ==", "bodyText": "I'm wondering whether this is a bit too coarse-grained.\nWith this change, even if somewhere deep within a generic type there is an uninferred type argument, only the primary annotations are checked.\nLet's take a type @A M<@B C, @D ?> where the second type argument is uninferred.\nWith this change, only @A is checked. Wouldn't it be better if also @B is checked?\nThe first type argument isn't affected by the failure to infer the second argument.\nWhat happens if you remove lines 157--159 and 164--174 from the patch? Methods like isContainedBy already check for uninferred type arguments, so maybe only the check in isSubtype was missing?\nThen you wouldn't even need the new containsUninferredTypeArguments method.", "url": "https://github.com/typetools/checker-framework/pull/3044#discussion_r365468461", "createdAt": "2020-01-10T23:21:41Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -154,6 +154,25 @@ protected StructuralEqualityComparer createEqualityComparer() {\n     @Override\n     public boolean isSubtype(\n             final AnnotatedTypeMirror subtype, final AnnotatedTypeMirror supertype) {\n+        if (subtype.atypeFactory.ignoreUninferredTypeArguments\n+                && (subtype.containsUninferredTypeArguments()\n+                        || supertype.containsUninferredTypeArguments())) {\n+            if (ignoreUninferredTypeArgument(subtype) || ignoreUninferredTypeArgument(supertype)) {\n+                // If either is an uninferred type argument don't check primary annotations.\n+                return true;\n+            }\n+            // Check primary annotations.\n+            for (final AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\n+                AnnotationMirror subAnno = subtype.getAnnotationInHierarchy(top);\n+                AnnotationMirror superAnno = supertype.getAnnotationInHierarchy(top);\n+                if (subAnno != null\n+                        && superAnno != null\n+                        && !qualifierHierarchy.isSubtype(subAnno, superAnno)) {\n+                    return false;\n+                }\n+            }\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e942a76f73fb5719ca95234a732487385685c23a"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1840, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}