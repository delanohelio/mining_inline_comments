{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5MDA0NTE4", "number": 3476, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzoxMjozN1rOEOdt7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoxMTo0MFrOEQZ0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjAyNDEzOnYy", "diffSide": "RIGHT", "path": "framework/tests/accumulation/SimpleInferenceMerge.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzoxMjozN1rOGxohAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODoxNjo1MVrOGy254Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NzIxNg==", "bodyText": "This test case is unrelated to predicates, right?", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r454697216", "createdAt": "2020-07-14T23:12:37Z", "author": {"login": "msridhar"}, "path": "framework/tests/accumulation/SimpleInferenceMerge.java", "diffHunk": "@@ -0,0 +1,37 @@\n+import testaccumulation.qual.*;\n+\n+class SimpleInferenceMerge {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4MTUzNw==", "bodyText": "Yeah. It probably should have been included in the original AccumulationChecker PR, but was left off somehow. I included it here since it passes and I moved over a bunch of the other tests, so it didn't seem like it needed its own.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r455981537", "createdAt": "2020-07-16T18:16:51Z", "author": {"login": "kelloggm"}, "path": "framework/tests/accumulation/SimpleInferenceMerge.java", "diffHunk": "@@ -0,0 +1,37 @@\n+import testaccumulation.qual.*;\n+\n+class SimpleInferenceMerge {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5NzIxNg=="}, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjAyODA5OnYy", "diffSide": "RIGHT", "path": "docs/manual/accumulation-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzoxNDowNFrOGxojKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMzoxNDowNFrOGxojKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY5Nzc2OQ==", "bodyText": "We probably want some documentation of the unsound handling of negation", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r454697769", "createdAt": "2020-07-14T23:14:04Z", "author": {"login": "msridhar"}, "path": "docs/manual/accumulation-checker.tex", "diffHunk": "@@ -55,15 +55,21 @@\n \\href{https://github.com/typetools/checker-framework/blob/master/framework/src/test/java/testaccumulation/qual/TestAccumulationBottom.java}{TestAccumulationBottom.java}.\n It should take no arguments, and should be a subtype of the accumulator type you defined earlier.\n \n+You may also choose to define a predicate annotation, analogous to\n+\\href{https://github.com/typetools/checker-framework/blob/master/framework/src/test/java/testaccumulation/qual/TestAccumulationPredicate.java}{TestAccumulationPredicate.java}.\n+A predicate annotation allows you to write specifications with disjunctions (the accumulation annotation implicitly already permits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjIxNzQzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDo0ODo1OVrOGxqP-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMDo0ODo1OVrOGxqP-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyNTYyNQ==", "bodyText": "BugInCF is only for bugs in the Checker Framework itself.  This looks more like it should be a UserError.  Or, pass the exception up to the caller.\nPlease check all the uses of BugInCF.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r454725625", "createdAt": "2020-07-15T00:48:59Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -324,9 +439,184 @@ public boolean isSubtype(final AnnotationMirror subAnno, final AnnotationMirror\n                 return false;\n             }\n \n+            if (isPredicate(subAnno)) {\n+                return isPredicateSubtype(\n+                        convertToPredicate(subAnno), convertToPredicate(superAnno));\n+            } else if (isPredicate(superAnno)) {\n+                return evaluatePredicate(subAnno, convertToPredicate(superAnno));\n+            }\n+\n             List<String> subVal = getAccumulatedValues(subAnno);\n             List<String> superVal = getAccumulatedValues(superAnno);\n             return subVal.containsAll(superVal);\n         }\n     }\n+\n+    /**\n+     * Extension point for complex subtyping behavior between predicates. The standard\n+     * implementation conservatively returns true only if the predicates are equal, or if the\n+     * prospective supertype (q) is equivalent to top (that is, the empty string).\n+     *\n+     * @param p a predicate\n+     * @param q another predicate\n+     * @return true if p is a subtype of q\n+     */\n+    protected boolean isPredicateSubtype(String p, String q) {\n+        return \"\".equals(q) || p.equals(q);\n+    }\n+\n+    /**\n+     * Evaluates whether the accumulator annotation {@code subAnno} makes the predicate {@code pred}\n+     * true.\n+     *\n+     * @param subAnno an accumulator annotation\n+     * @param pred a predicate\n+     * @return whether the accumulator annotation satisfies the predicate\n+     */\n+    protected boolean evaluatePredicate(AnnotationMirror subAnno, String pred) {\n+        if (!isAccumulatorAnnotation(subAnno)) {\n+            throw new BugInCF(\n+                    \"tried to evaluate a predicate using an annotation that wasn't an accumulator: \"\n+                            + subAnno);\n+        }\n+        List<String> trueVariables = getAccumulatedValues(subAnno);\n+        return evaluatePredicate(trueVariables, pred);\n+    }\n+\n+    /**\n+     * Checks that the given annotation either:\n+     *\n+     * <ul>\n+     *   <li>does not contain a predicate, or\n+     *   <li>contains a parse-able predicate\n+     * </ul>\n+     *\n+     * Used by the visitor to throw \"predicate.invalid\" errors; thus must be package-private.\n+     *\n+     * @param anm any annotation supported by this checker\n+     * @return null if there is nothing wrong with the predicate, or an error message indicating the\n+     *     problem if the predicate is invalid\n+     */\n+    /* package-private */\n+    @Nullable String isValidPredicate(AnnotationMirror anm) {\n+        String pred = convertToPredicate(anm);\n+        try {\n+            evaluatePredicate(Collections.emptyList(), pred);\n+        } catch (BugInCF bugInCF) {\n+            return bugInCF.getLocalizedMessage();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Evaluates whether treating the variables in {@code trueVariables} as {@code true} literals\n+     * (and all other names as {@code false} literals) makes the predicate {@code pred} evaluate to\n+     * true.\n+     *\n+     * @param trueVariables a list of names that should be replaced with {@code true}\n+     * @param pred a predicate\n+     * @return whether the true variables satisfy the predicate\n+     */\n+    protected boolean evaluatePredicate(List<String> trueVariables, String pred) {\n+        /*for (String cmMethod : trueVariables) {\n+            pred = pred.replaceAll(\"\\\\b\" + cmMethod + \"\\\\b\", \"true\");\n+        }\n+        pred = pred.replaceAll(\"(?!true)\\\\b[_a-zA-Z][_a-zA-Z0-9]*\\\\b\", \"false\");*/\n+        Expression expression;\n+        try {\n+            expression = StaticJavaParser.parseExpression(pred);\n+        } catch (ParseProblemException p) {\n+            throw new BugInCF(\"unparseable predicate: \" + pred + \". Parse exception: \" + p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjI3MTM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToxNzo1NlrOGxqvaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToxNzo1NlrOGxqvaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMzY3Mw==", "bodyText": "Use reportError rather than report.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r454733673", "createdAt": "2020-07-15T01:17:56Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationVisitor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.AnnotationTree;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * The visitor for an accumulation checker. Issues predicate.invalid errors if the user writes an\n+ * invalid predicate.\n+ */\n+public class AccumulationVisitor extends BaseTypeVisitor<AccumulationAnnotatedTypeFactory> {\n+\n+    /**\n+     * Constructor matching super.\n+     *\n+     * @param checker the checker\n+     */\n+    public AccumulationVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    /** Checks each predicate annotation to make sure the predicate is well-formed. */\n+    @Override\n+    public Void visitAnnotation(final AnnotationTree node, final Void p) {\n+        AnnotationMirror anno = TreeUtils.annotationFromAnnotationTree(node);\n+        if (atypeFactory.isPredicate(anno)) {\n+            String errorMessage = atypeFactory.isValidPredicate(anno);\n+            if (errorMessage != null) {\n+                checker.report(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjI3MjY2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToxODo0MVrOGxqwNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToxODo0MVrOGxqwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczMzg3Ng==", "bodyText": "Why not give the superclass the opportunity to issue more errors, if there are others?", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r454733876", "createdAt": "2020-07-15T01:18:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationVisitor.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.AnnotationTree;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * The visitor for an accumulation checker. Issues predicate.invalid errors if the user writes an\n+ * invalid predicate.\n+ */\n+public class AccumulationVisitor extends BaseTypeVisitor<AccumulationAnnotatedTypeFactory> {\n+\n+    /**\n+     * Constructor matching super.\n+     *\n+     * @param checker the checker\n+     */\n+    public AccumulationVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    /** Checks each predicate annotation to make sure the predicate is well-formed. */\n+    @Override\n+    public Void visitAnnotation(final AnnotationTree node, final Void p) {\n+        AnnotationMirror anno = TreeUtils.annotationFromAnnotationTree(node);\n+        if (atypeFactory.isPredicate(anno)) {\n+            String errorMessage = atypeFactory.isValidPredicate(anno);\n+            if (errorMessage != null) {\n+                checker.report(\n+                        node,\n+                        new DiagMessage(Diagnostic.Kind.ERROR, \"predicate.invalid\", errorMessage));\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c0c821b709605345aa6ca50bce28b33ecf9618"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjM0Nzg5OnYy", "diffSide": "LEFT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzowNzowNVrOG0iTeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzo1MjoyNFrOG0jKEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MTE3OA==", "bodyText": "Was calling postInit() here before a bug?", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457741178", "createdAt": "2020-07-20T23:07:05Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -58,38 +73,70 @@\n      *     argument named \"value\" whose type is a String array.\n      * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n      *     accumulator}. The bottom type should be an annotation with no arguments.\n+     * @param predicate the predicate annotation. Either null (if predicates are not supported), or\n+     *     an annotation with a single element named \"value\" whose type is a String.\n      */\n     protected AccumulationAnnotatedTypeFactory(\n             BaseTypeChecker checker,\n             Class<? extends Annotation> accumulator,\n-            Class<? extends Annotation> bottom) {\n+            Class<? extends Annotation> bottom,\n+            @Nullable Class<? extends Annotation> predicate) {\n         super(checker);\n \n         this.accumulator = accumulator;\n-\n         // Check that the requirements of the accumulator are met.\n         Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n         if (accDeclaredMethods.length != 1) {\n             rejectMalformedAccumulator(\"have exactly one element\");\n         }\n-        Method value = accDeclaredMethods[0];\n-        if (value.getName() != \"value\") { // interned\n+\n+        Method accValue = accDeclaredMethods[0];\n+        if (accValue.getName() != \"value\") { // interned\n             rejectMalformedAccumulator(\"name its element \\\"value\\\"\");\n         }\n-        if (!value.getReturnType().isInstance(new String[0])) {\n+        if (!accValue.getReturnType().isInstance(new String[0])) {\n             rejectMalformedAccumulator(\"have an element of type String[]\");\n         }\n-        if (((String[]) value.getDefaultValue()).length != 0) {\n+        if (((String[]) accValue.getDefaultValue()).length != 0) {\n             rejectMalformedAccumulator(\"have the empty String array {} as its default value\");\n         }\n \n+        this.predicate = predicate;\n+        // If there is a predicate annotation, check that its requirements are met.\n+        if (predicate != null) {\n+            Method[] predDeclaredMethods = predicate.getDeclaredMethods();\n+            if (predDeclaredMethods.length != 1) {\n+                rejectMalformedPredicate(\"have exactly one element\");\n+            }\n+            Method predValue = predDeclaredMethods[0];\n+            if (predValue.getName() != \"value\") { // interned\n+                rejectMalformedPredicate(\"name its element \\\"value\\\"\");\n+            }\n+            if (!predValue.getReturnType().isInstance(\"\")) {\n+                rejectMalformedPredicate(\"have an element of type String\");\n+            }\n+        }\n+\n         this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n         this.top = createAccumulatorAnnotation(Collections.emptyList());\n \n-        // Every subclass must call postInit!  This does not do so for subclasses.\n-        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n-            this.postInit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc1NTE1Mg==", "bodyText": "The condition was always false, because this is an abstract class. All subclasses have to call postInit.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457755152", "createdAt": "2020-07-20T23:52:24Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -58,38 +73,70 @@\n      *     argument named \"value\" whose type is a String array.\n      * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n      *     accumulator}. The bottom type should be an annotation with no arguments.\n+     * @param predicate the predicate annotation. Either null (if predicates are not supported), or\n+     *     an annotation with a single element named \"value\" whose type is a String.\n      */\n     protected AccumulationAnnotatedTypeFactory(\n             BaseTypeChecker checker,\n             Class<? extends Annotation> accumulator,\n-            Class<? extends Annotation> bottom) {\n+            Class<? extends Annotation> bottom,\n+            @Nullable Class<? extends Annotation> predicate) {\n         super(checker);\n \n         this.accumulator = accumulator;\n-\n         // Check that the requirements of the accumulator are met.\n         Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n         if (accDeclaredMethods.length != 1) {\n             rejectMalformedAccumulator(\"have exactly one element\");\n         }\n-        Method value = accDeclaredMethods[0];\n-        if (value.getName() != \"value\") { // interned\n+\n+        Method accValue = accDeclaredMethods[0];\n+        if (accValue.getName() != \"value\") { // interned\n             rejectMalformedAccumulator(\"name its element \\\"value\\\"\");\n         }\n-        if (!value.getReturnType().isInstance(new String[0])) {\n+        if (!accValue.getReturnType().isInstance(new String[0])) {\n             rejectMalformedAccumulator(\"have an element of type String[]\");\n         }\n-        if (((String[]) value.getDefaultValue()).length != 0) {\n+        if (((String[]) accValue.getDefaultValue()).length != 0) {\n             rejectMalformedAccumulator(\"have the empty String array {} as its default value\");\n         }\n \n+        this.predicate = predicate;\n+        // If there is a predicate annotation, check that its requirements are met.\n+        if (predicate != null) {\n+            Method[] predDeclaredMethods = predicate.getDeclaredMethods();\n+            if (predDeclaredMethods.length != 1) {\n+                rejectMalformedPredicate(\"have exactly one element\");\n+            }\n+            Method predValue = predDeclaredMethods[0];\n+            if (predValue.getName() != \"value\") { // interned\n+                rejectMalformedPredicate(\"name its element \\\"value\\\"\");\n+            }\n+            if (!predValue.getReturnType().isInstance(\"\")) {\n+                rejectMalformedPredicate(\"have an element of type String\");\n+            }\n+        }\n+\n         this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n         this.top = createAccumulatorAnnotation(Collections.emptyList());\n \n-        // Every subclass must call postInit!  This does not do so for subclasses.\n-        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n-            this.postInit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MTE3OA=="}, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjM1MTQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzowODo1OVrOG0iVuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzo1MzoyNlrOG0jLPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MTc1Mg==", "bodyText": "Does this mean that after converting the accumulator to a predicate, P must equal that predicate (i.e., it falls into the next case of predicate subtyping)?", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457741752", "createdAt": "2020-07-20T23:08:59Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -248,6 +320,21 @@ public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n      *        |\n      *      bottom\n      * </pre>\n+     *\n+     * Predicate subtyping is defined as follows:\n+     *\n+     * <ul>\n+     *   <li>An accumulator is a subtype of a predicate if substitution from the accumulator to the\n+     *       predicate makes the predicate true. For example, {@code Acc(A)} is a subtype of {@code\n+     *       AccPred(\"A || B\")}, because when A is replaced with {@code true} and B is replaced with\n+     *       {@code false}, the resulting boolean formula evaluates to true.\n+     *   <li>A predicate P is a subtype of an accumulator iff after converting the accumulator into\n+     *       a predicate representing the conjunction of its elements, P is a subtype of that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc1NTQ1NA==", "bodyText": "In the default implementation, yes, but if the accumulation checker writer has implemented a more complex predicate subtyping rule that would also be taken into account.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457755454", "createdAt": "2020-07-20T23:53:26Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -248,6 +320,21 @@ public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n      *        |\n      *      bottom\n      * </pre>\n+     *\n+     * Predicate subtyping is defined as follows:\n+     *\n+     * <ul>\n+     *   <li>An accumulator is a subtype of a predicate if substitution from the accumulator to the\n+     *       predicate makes the predicate true. For example, {@code Acc(A)} is a subtype of {@code\n+     *       AccPred(\"A || B\")}, because when A is replaced with {@code true} and B is replaced with\n+     *       {@code false}, the resulting boolean formula evaluates to true.\n+     *   <li>A predicate P is a subtype of an accumulator iff after converting the accumulator into\n+     *       a predicate representing the conjunction of its elements, P is a subtype of that", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MTc1Mg=="}, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjM1NzQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzoxMTo0MFrOG0iZEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzo1NjoxOFrOG0jOaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MjYxMA==", "bodyText": "It might be good to document what the \"right thing\" to do would be, and why we deviate from that.  I think the \"right thing\" here is logical implication, i.e., P is a subtype of Q iff P implies Q.  But we don't bake in the implication check to keep things simple and minimize dependencies.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457742610", "createdAt": "2020-07-20T23:11:40Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -248,6 +320,21 @@ public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n      *        |\n      *      bottom\n      * </pre>\n+     *\n+     * Predicate subtyping is defined as follows:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc1NjI2NQ==", "bodyText": "I'll add a comment.", "url": "https://github.com/typetools/checker-framework/pull/3476#discussion_r457756265", "createdAt": "2020-07-20T23:56:18Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -248,6 +320,21 @@ public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n      *        |\n      *      bottom\n      * </pre>\n+     *\n+     * Predicate subtyping is defined as follows:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0MjYxMA=="}, "originalCommit": {"oid": "bcc60473548733302c041308687e5ab4bb063c8a"}, "originalPosition": 164}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1565, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}