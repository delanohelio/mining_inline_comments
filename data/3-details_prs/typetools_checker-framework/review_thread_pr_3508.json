{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NDYxNjg2", "number": 3508, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjo1ODoyMFrOETdQVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDoyMzozNlrOET42xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODM3NzE2OnYy", "diffSide": "RIGHT", "path": "checker/tests/signedness/LocalVarDefaults.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjo1ODoyMFrOG5NI_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowMDowM1rOG5plzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzMwOA==", "bodyText": "I guess the @Unsigned is the invalid one. Could you split it up in two methods to make clearer?", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462637308", "createdAt": "2020-07-29T22:58:20Z", "author": {"login": "wmdietl"}, "path": "checker/tests/signedness/LocalVarDefaults.java", "diffHunk": "@@ -0,0 +1,29 @@\n+import org.checkerframework.checker.signedness.qual.Signed;\n+import org.checkerframework.checker.signedness.qual.Unsigned;\n+\n+public class LocalVarDefaults {\n+\n+    void methodInt(@Unsigned int unsignedInt, @Signed int signedInt) {\n+        int local = unsignedInt;\n+        int local2 = signedInt;\n+    }\n+\n+    // :: error: (type.invalid.annotations.on.use)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMzQzOA==", "bodyText": "The purpose of this test is to check local variable defaults, not type.invalid.annotations.on.use, so it makes sense to keep the similar tests together.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463103438", "createdAt": "2020-07-30T16:00:03Z", "author": {"login": "smillst"}, "path": "checker/tests/signedness/LocalVarDefaults.java", "diffHunk": "@@ -0,0 +1,29 @@\n+import org.checkerframework.checker.signedness.qual.Signed;\n+import org.checkerframework.checker.signedness.qual.Unsigned;\n+\n+public class LocalVarDefaults {\n+\n+    void methodInt(@Unsigned int unsignedInt, @Signed int signedInt) {\n+        int local = unsignedInt;\n+        int local2 = signedInt;\n+    }\n+\n+    // :: error: (type.invalid.annotations.on.use)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNzMwOA=="}, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODM4MzE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowMDo1NVrOG5NMfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowMDo1NVrOG5NMfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzODIwNg==", "bodyText": "Could you clarify the javadoc? It's confusing given the method name that this applies to anything other than declared types.\nCan you call out explicitly what happens with ARRAY (and what else? intersection?)", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462638206", "createdAt": "2020-07-29T23:00:55Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -95,7 +95,7 @@ public boolean isValid(AnnotatedTypeMirror type, Tree tree) {\n      * @return whether or not the top-level type should be checked\n      */\n     protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree tree) {\n-        if (type.getKind() != TypeKind.DECLARED) {\n+        if (type.getKind() != TypeKind.DECLARED && !type.getKind().isPrimitive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODM5MDQ2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowNDowNlrOG5NQyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowNDowNlrOG5NQyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzOTMwNw==", "bodyText": "Can you add a comment why the order is different for expressions?", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462639307", "createdAt": "2020-07-29T23:04:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1513,9 +1527,15 @@ protected void addComputedTypeAnnotations(\n                 : \"GenericAnnotatedTypeFactory.addComputedTypeAnnotations: \"\n                         + \" root needs to be set when used on trees; factory: \"\n                         + this.getClass();\n-        addAnnotationsFromDefaultQualifierForUse(TreeUtils.elementFromTree(tree), type);\n+\n+        if (!TreeUtils.isExpressionTree(tree)) {\n+            addAnnotationsFromDefaultQualifierForUse(TreeUtils.elementFromTree(tree), type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODM5NzQzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowNzoyOFrOG5NUzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowNzoyOFrOG5NUzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MDMzMg==", "bodyText": "Could you update the javadoc?\nThis now also applies the defaultForTypeAnnotator, which is surprising given the method name.\nIt looks like null is passed as element to change what would happen by default, so calling that out would be good.\nI was also surprised by the special case for primitives, so giving a reason for that would be good.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462640332", "createdAt": "2020-07-29T23:07:28Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1839,20 +1859,28 @@ public void postAsMemberOf(\n      */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQxNTc2OnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzoxNjoyNFrOG5NfsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzoxNjoyNFrOG5NfsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MzEyMQ==", "bodyText": "I would prefer something more descriptive than the type, although \"type to test\" is also not much better.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462643121", "createdAt": "2020-07-29T23:16:24Z", "author": {"login": "wmdietl"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -248,9 +248,25 @@ public static boolean isIntegral(TypeMirror type) {\n         }\n     }\n \n+    /**\n+     * Returns true iff the argument is a boxed floating point type.\n+     *\n+     * @param type type mirror", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQxODM3OnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzoxNzo0NFrOG5NhMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowNzo1OVrOG5p5Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MzUwNg==", "bodyText": "At some point we should figure out and document what the proper way is. Name defines a contentEquals, which might be more direct than calling toString. However, for multiple comparisons one approach might be more efficient.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462643506", "createdAt": "2020-07-29T23:17:44Z", "author": {"login": "wmdietl"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -248,9 +248,25 @@ public static boolean isIntegral(TypeMirror type) {\n         }\n     }\n \n+    /**\n+     * Returns true iff the argument is a boxed floating point type.\n+     *\n+     * @param type type mirror\n+     * @return whether the argument is a boxed floating point type\n+     */\n+    public static boolean isBoxedFloating(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+\n+        String qualifiedName = getQualifiedName((DeclaredType) type).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODQzNQ==", "bodyText": "That does sound like a good future improvement.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463108435", "createdAt": "2020-07-30T16:07:59Z", "author": {"login": "smillst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -248,9 +248,25 @@ public static boolean isIntegral(TypeMirror type) {\n         }\n     }\n \n+    /**\n+     * Returns true iff the argument is a boxed floating point type.\n+     *\n+     * @param type type mirror\n+     * @return whether the argument is a boxed floating point type\n+     */\n+    public static boolean isBoxedFloating(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+\n+        String qualifiedName = getQualifiedName((DeclaredType) type).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MzUwNg=="}, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQyMTgyOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzoxOTozMFrOG5NjSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzo0NDo0NVrOG5OBuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0NDA0MQ==", "bodyText": "Nit. Make the validator capitalization consistent with the use in the class javadoc.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462644041", "createdAt": "2020-07-29T23:19:30Z", "author": {"login": "wmdietl"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessVisitor.java", "diffHunk": "@@ -648,4 +652,38 @@ public Void visitAnnotation(AnnotationTree node, Void p) {\n         // All annotation arguments are non-null and initialized, so no need to check them.\n         return null;\n     }\n+\n+    @Override\n+    protected TypeValidator createTypeValidator() {\n+        return new NullnessValidator(checker, this, atypeFactory);\n+    }\n+\n+    /**\n+     * Nullness Validator. Check that primitive types are annotated with {@code @NonNull} even if\n+     * they are the type of a local variable.\n+     */\n+    private static class NullnessValidator extends BaseTypeValidator {\n+\n+        /**\n+         * Create Nullness validator.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MTgzMw==", "bodyText": "I think it's OK to write \"NullnessValidator\" or \"Nullness validator\".  I wouldn't write \"Nullness Validator\", though \"Nullness BaseTypeValidator\" would also be OK.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462651833", "createdAt": "2020-07-29T23:44:45Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessVisitor.java", "diffHunk": "@@ -648,4 +652,38 @@ public Void visitAnnotation(AnnotationTree node, Void p) {\n         // All annotation arguments are non-null and initialized, so no need to check them.\n         return null;\n     }\n+\n+    @Override\n+    protected TypeValidator createTypeValidator() {\n+        return new NullnessValidator(checker, this, atypeFactory);\n+    }\n+\n+    /**\n+     * Nullness Validator. Check that primitive types are annotated with {@code @NonNull} even if\n+     * they are the type of a local variable.\n+     */\n+    private static class NullnessValidator extends BaseTypeValidator {\n+\n+        /**\n+         * Create Nullness validator.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0NDA0MQ=="}, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQyNzE0OnYy", "diffSide": "LEFT", "path": "checker/tests/signedness/CastedShifts.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzoyMTo1NVrOG5NmfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzo0Mzo0M1rOG5OAbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0NDg2MA==", "bodyText": "It looks like all the signed char casts are removed from this test. Should at least one remain and expect an error? Or what is supposed to happen if somebody writes that?", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462644860", "createdAt": "2020-07-29T23:21:55Z", "author": {"login": "wmdietl"}, "path": "checker/tests/signedness/CastedShifts.java", "diffHunk": "@@ -36,35 +36,25 @@ public void CastedIntShifts(@Unsigned int unsigned, @Signed int signed) {\n         byteRes = (@Signed byte) (signed >> 0);\n \n         // Cast to char.\n-        @UnknownSignedness char charRes;\n+        char charRes;\n \n         // Shifting right by 23, the introduced bits are cast away\n         charRes = (@Unsigned char) (unsigned >>> 23);\n         charRes = (@Unsigned char) (unsigned >> 23);\n-        charRes = (@Signed char) (signed >>> 23);\n-        charRes = (@Signed char) (signed >> 23);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MTUwMg==", "bodyText": "It is an error to write @Signed char.  We'll add a test later, in pull requests after this one.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r462651502", "createdAt": "2020-07-29T23:43:43Z", "author": {"login": "mernst"}, "path": "checker/tests/signedness/CastedShifts.java", "diffHunk": "@@ -36,35 +36,25 @@ public void CastedIntShifts(@Unsigned int unsigned, @Signed int signed) {\n         byteRes = (@Signed byte) (signed >> 0);\n \n         // Cast to char.\n-        @UnknownSignedness char charRes;\n+        char charRes;\n \n         // Shifting right by 23, the introduced bits are cast away\n         charRes = (@Unsigned char) (unsigned >>> 23);\n         charRes = (@Unsigned char) (unsigned >> 23);\n-        charRes = (@Signed char) (signed >>> 23);\n-        charRes = (@Signed char) (signed >> 23);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0NDg2MA=="}, "originalCommit": {"oid": "632d72e67be7dc38e1359b847e715ae6e9806c6b"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mjg5MTE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDoxOTowNFrOG54C3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDozNzoyM1rOG54VoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDI1Mg==", "bodyText": "Could you deprecate this method and introduce a better name?\nIt makes no sense to use DeclaredType in the method name if it actually is also for primitive types.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463340252", "createdAt": "2020-07-31T00:19:04Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -86,16 +86,19 @@ public boolean isValid(AnnotatedTypeMirror type, Tree tree) {\n     }\n \n     /**\n-     * Should the top-level declared type be checked?\n+     * Should the top-level declared or primitive type be checked?\n+     *\n+     * <p>If {@code type} is not a declared or primitive type, then this method returns true.\n      *\n      * <p>Top-level type is not checked if tree is a local variable or an expression tree.\n      *\n      * @param type AnnotatedTypeMirror being validated\n      * @param tree a Tree whose type is {@code type}\n-     * @return whether or not the top-level type should be checked\n+     * @return whether or not the top-level type should be checked, if {@code type} is a declared or\n+     *     primitive type.\n      */\n     protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree tree) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MzY0NQ==", "bodyText": "We can't deprecate methods the might be overridden by subclass.  I can rename it and mention it in the change log.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463343645", "createdAt": "2020-07-31T00:31:52Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -86,16 +86,19 @@ public boolean isValid(AnnotatedTypeMirror type, Tree tree) {\n     }\n \n     /**\n-     * Should the top-level declared type be checked?\n+     * Should the top-level declared or primitive type be checked?\n+     *\n+     * <p>If {@code type} is not a declared or primitive type, then this method returns true.\n      *\n      * <p>Top-level type is not checked if tree is a local variable or an expression tree.\n      *\n      * @param type AnnotatedTypeMirror being validated\n      * @param tree a Tree whose type is {@code type}\n-     * @return whether or not the top-level type should be checked\n+     * @return whether or not the top-level type should be checked, if {@code type} is a declared or\n+     *     primitive type.\n      */\n     protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree tree) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDI1Mg=="}, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NTA1Nw==", "bodyText": "You can deprecate it and have the new method call the deprecated method (suppressing the warning).\nAll CF overrides can change to override the new method and external overrides would still be considered by the new method in this class.\nBut as this will be a minor release anyways, directly renaming sounds good to me.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463345057", "createdAt": "2020-07-31T00:37:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -86,16 +86,19 @@ public boolean isValid(AnnotatedTypeMirror type, Tree tree) {\n     }\n \n     /**\n-     * Should the top-level declared type be checked?\n+     * Should the top-level declared or primitive type be checked?\n+     *\n+     * <p>If {@code type} is not a declared or primitive type, then this method returns true.\n      *\n      * <p>Top-level type is not checked if tree is a local variable or an expression tree.\n      *\n      * @param type AnnotatedTypeMirror being validated\n      * @param tree a Tree whose type is {@code type}\n-     * @return whether or not the top-level type should be checked\n+     * @return whether or not the top-level type should be checked, if {@code type} is a declared or\n+     *     primitive type.\n      */\n     protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree tree) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDI1Mg=="}, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mjg5NDY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDoyMDo0NlrOG54E0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDozNTo1M1rOG54UMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDc1Mg==", "bodyText": "The August release will be the next minor release. So isn't now the right time to make this change?", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463340752", "createdAt": "2020-07-31T00:20:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1841,25 +1868,37 @@ public void postAsMemberOf(\n      * Adds default qualifiers bases on the underlying type of {@code type} to {@code type}. If\n      * {@code element} is a local variable, then the defaults are not added.\n      *\n+     * <p>(This uses both the {@link DefaultQualifierForUseTypeAnnotator} and {@link\n+     * DefaultForTypeAnnotator}.)\n+     *\n      * @param element possibly null element whose type is {@code type}\n      * @param type the type to which defaults are added\n      */\n+    // TODO: rename in the next minor release.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NDY5MQ==", "bodyText": "Yes, I didn't realize breaking changes were merged.  I'll fix it.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463344691", "createdAt": "2020-07-31T00:35:53Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1841,25 +1868,37 @@ public void postAsMemberOf(\n      * Adds default qualifiers bases on the underlying type of {@code type} to {@code type}. If\n      * {@code element} is a local variable, then the defaults are not added.\n      *\n+     * <p>(This uses both the {@link DefaultQualifierForUseTypeAnnotator} and {@link\n+     * DefaultForTypeAnnotator}.)\n+     *\n      * @param element possibly null element whose type is {@code type}\n      * @param type the type to which defaults are added\n      */\n+    // TODO: rename in the next minor release.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MDc1Mg=="}, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5Mjg5OTI1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/treeannotator/PropagationTreeAnnotator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDoyMzozNlrOG54HjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQwMDozNTozNVrOG54T8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MTQ1Mw==", "bodyText": "In other recent pull requests you used quals as the name for such qualifier sets.\nMaybe addQualOrBound would also be a better method name?", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463341453", "createdAt": "2020-07-31T00:23:36Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/treeannotator/PropagationTreeAnnotator.java", "diffHunk": "@@ -204,4 +209,27 @@ private boolean hasPrimaryAnnotationInAllHierarchies(AnnotatedTypeMirror type) {\n         }\n         return annotated;\n     }\n+\n+    /**\n+     * Adds the qualifiers in {@code annos} to {@code type} that are below the qualifier upper bound\n+     * of type and for which type does not already have annotation in the same hierarchy. If a\n+     * qualifier in {@code annos} is above the bound, then the bound is added to {@code type}\n+     * instead.\n+     *\n+     * @param type annotations are added to this type\n+     * @param annos annotations to add to type\n+     */\n+    private void addAnnoOrBound(AnnotatedTypeMirror type, Set<? extends AnnotationMirror> annos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0NDYyNw==", "bodyText": "This file uses \"annotation\" rather \"qualifier\".  So Anno is more consistent.", "url": "https://github.com/typetools/checker-framework/pull/3508#discussion_r463344627", "createdAt": "2020-07-31T00:35:35Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/treeannotator/PropagationTreeAnnotator.java", "diffHunk": "@@ -204,4 +209,27 @@ private boolean hasPrimaryAnnotationInAllHierarchies(AnnotatedTypeMirror type) {\n         }\n         return annotated;\n     }\n+\n+    /**\n+     * Adds the qualifiers in {@code annos} to {@code type} that are below the qualifier upper bound\n+     * of type and for which type does not already have annotation in the same hierarchy. If a\n+     * qualifier in {@code annos} is above the bound, then the bound is added to {@code type}\n+     * instead.\n+     *\n+     * @param type annotations are added to this type\n+     * @param annos annotations to add to type\n+     */\n+    private void addAnnoOrBound(AnnotatedTypeMirror type, Set<? extends AnnotationMirror> annos) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MTQ1Mw=="}, "originalCommit": {"oid": "fed35423131bcf6284fef3386edffb46797d9095"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1587, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}