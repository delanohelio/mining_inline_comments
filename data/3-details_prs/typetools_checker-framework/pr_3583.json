{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NzQyNDY1", "number": 3583, "title": "Decode annotations on enclosing types correctly", "bodyText": "Fixes #3562 .", "createdAt": "2020-08-10T21:31:55Z", "url": "https://github.com/typetools/checker-framework/pull/3583", "merged": true, "mergeCommit": {"oid": "4a6045b5d9fec762ec2a88d5c83d9b4ec2d4d4f6"}, "closed": true, "closedAt": "2020-08-12T20:21:22Z", "author": {"login": "smillst"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9o6zxAH2gAyNDY1NzQyNDY1OjAwYTEwZTJiZjQ2MGQxNmQ3OWJiNTgwNWY2NjgwNDQwMGI1MDhlNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-OcIVgH2gAyNDY1NzQyNDY1OmJlMmUwZDZjZmM2MmZhNDYxMmQzMGNjNWU4YTljMjdhNTU2MDBkN2M=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "00a10e2bf460d16d79bb5805f66804400b508e62", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/00a10e2bf460d16d79bb5805f66804400b508e62", "committedDate": "2020-08-10T21:15:54Z", "message": "Handling annotations on enclosing types correctly."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dab64649fda0aa2bb5019ee79a5e36b9cfa0c03", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/7dab64649fda0aa2bb5019ee79a5e36b9cfa0c03", "committedDate": "2020-08-10T21:29:53Z", "message": "Tweak comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ff082138822dbf5f4da04c8b41bf0c5ce23b4260", "committedDate": "2020-08-11T20:50:11Z", "message": "Tweak comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDE5MjI5", "url": "https://github.com/typetools/checker-framework/pull/3583#pullrequestreview-465419229", "createdAt": "2020-08-11T20:51:09Z", "commit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MToxMFrOG_IxUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1NDozNVrOG_I4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzE2OQ==", "bodyText": "\"For example\" sounds like it is following up on a previous point, but I think here it might be introducing a new point.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857169", "createdAt": "2020-08-11T20:51:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzYwOA==", "bodyText": "Are they stored on the same node (that is, both are stored on the node for Inner)?  If so, I would say that.  If not, the fact that they apply to different types may not be so surprising.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857608", "createdAt": "2020-08-11T20:52:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1Nzk1Mw==", "bodyText": "I don't understand why this comment is attached to the curly brace rather than on a separate line.  Can you clarify why?", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857953", "createdAt": "2020-08-11T20:52:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to\n+            // different types.\n+            AnnotatedDeclaredType annotatedDeclaredType = (AnnotatedDeclaredType) result;\n+            // The underlying type of result does not have all annotations, but the TypeMirror of\n+            // node.getType() does.\n+            DeclaredType declaredType = (DeclaredType) TreeUtils.typeOf(node.getType());\n+            AnnotatedTypes.applyAnnotationsFromDeclaredType(annotatedDeclaredType, declaredType);\n+\n+            // Handle declaration annotations\n+            for (AnnotationMirror anno : modifierAnnos) {\n+                if (AnnotationUtils.isDeclarationAnnotation(anno)) {\n+                    // This does not treat Checker Framework compatqual annotations differently,\n+                    // because it's not clear whether the annotation should apply to the outermost\n+                    // enclosing type or the innermost.\n+                    result.addAnnotation(anno);\n+                } // If anno is not a declaration annotation, it should have been applied in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1ODk3Ng==", "bodyText": "Maybe state explictly that this includes both declaration and type annotations.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468858976", "createdAt": "2020-08-11T20:54:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -1444,4 +1445,25 @@ public static void copyOnlyExplicitConstructorAnnotations(\n             }\n         }\n     }\n+\n+    /**\n+     * Add all the annotations in {@code declaredType} to {@code annotatedDeclaredType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be2e0d6cfc62fa4612d30cc5e8a9c27a55600d7c", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/be2e0d6cfc62fa4612d30cc5e8a9c27a55600d7c", "committedDate": "2020-08-12T16:58:47Z", "message": "Code review."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2609, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}