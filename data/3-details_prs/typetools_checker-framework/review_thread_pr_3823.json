{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NTI3ODk0", "number": 3823, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxNzozN1rOEw7bCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMjozN1rOEy8gWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzQwNjgwOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessValue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxNzozN1rOHmyQ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxNzozN1rOHmyQ-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzMTQ4Mw==", "bodyText": "This needs to be updated.", "url": "https://github.com/typetools/checker-framework/pull/3823#discussion_r510431483", "createdAt": "2020-10-22T20:17:37Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessValue.java", "diffHunk": "@@ -3,18 +3,26 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.checkerframework.checker.nullness.qual.Nullable;\n import org.checkerframework.checker.nullness.qual.PolyNull;\n+import org.checkerframework.dataflow.qual.Pure;\n+import org.checkerframework.dataflow.qual.SideEffectFree;\n import org.checkerframework.framework.flow.CFAbstractAnalysis;\n import org.checkerframework.framework.flow.CFAbstractValue;\n import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n \n /**\n  * Behaves just like {@link CFValue}, but additionally tracks whether at this point {@link PolyNull}\n  * is known to be {@link Nullable}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1941ee6ffce8c78997e2d5ec9d4cda6f265cb7f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODUwMTQ3OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowODo0N1rOHp3R4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODowODo0N1rOHp3R4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1OTM2MQ==", "bodyText": "te -> to", "url": "https://github.com/typetools/checker-framework/pull/3823#discussion_r513659361", "createdAt": "2020-10-28T18:08:47Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessStore.java", "diffHunk": "@@ -44,22 +48,26 @@ public NullnessStore(\n             CFAbstractAnalysis<NullnessValue, NullnessStore, ?> analysis,\n             boolean sequentialSemantics) {\n         super(analysis, sequentialSemantics);\n+        isPolyNullNonNull = false;\n         isPolyNullNull = false;\n     }\n \n+    /**\n+     * Create a NullnessStore (copy constructor).\n+     *\n+     * @param s a store te copy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d33cc35c447bdc068d6484071cfcef5c20b3a7"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODUyMjgzOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessTransfer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoxNDoxNVrOHp3fAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoxNDoxNVrOHp3fAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MjcyMA==", "bodyText": "You can do this by using a SimpleAnnotatedTypeScanner:\nnew SimpleAnnotatedTypeScanner<>(\n                    (type, p) ->\n                            type.hasAnnotation(POLYNULL),\n                    Boolean::logicalOr,\n                    false);", "url": "https://github.com/typetools/checker-framework/pull/3823#discussion_r513662720", "createdAt": "2020-10-28T18:14:15Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessTransfer.java", "diffHunk": "@@ -205,6 +225,78 @@ protected NullnessValue finishValue(\n         return res;\n     }\n \n+    /**\n+     * Returns true if every formal parameter that is declared as @PolyNull is currently known to be\n+     * non-null.\n+     *\n+     * @param method a method\n+     * @param s a store\n+     * @return true if every formal parameter declared as @PolyNull is non-null\n+     */\n+    private boolean polyNullIsNonNull(ExecutableElement method, NullnessStore s) {\n+        // No need to check the receiver, which is always non-null.\n+        for (VariableElement var : method.getParameters()) {\n+            AnnotatedTypeMirror varType = atypeFactory.fromElement(var);\n+\n+            if (containsPolyNullNotAtTopLevel(varType)) {\n+                return false;\n+            }\n+\n+            if (varType.hasAnnotation(POLYNULL)) {\n+                NullnessValue v = s.getValue(new LocalVariable(var));\n+                if (!AnnotationUtils.containsSameByName(v.getAnnotations(), NONNULL)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if there is an occurrence of @PolyNull that is not at the top level.\n+     *\n+     * @param t a type\n+     * @return true if there is an occurrence of @PolyNull that is not at the top level\n+     */\n+    private boolean containsPolyNullNotAtTopLevel(AnnotatedTypeMirror t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d33cc35c447bdc068d6484071cfcef5c20b3a7"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxODU1NTc3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/flow/CFAbstractAnalysis.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMjozN1rOHp3zng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxODoyMjozN1rOHp3zng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2Nzk5OA==", "bodyText": "Should this change be reverted?  You can call getTypeFactory() to access this field.", "url": "https://github.com/typetools/checker-framework/pull/3823#discussion_r513667998", "createdAt": "2020-10-28T18:22:37Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/flow/CFAbstractAnalysis.java", "diffHunk": "@@ -51,7 +51,7 @@\n     protected final DependentTypesHelper dependentTypesHelper;\n \n     /** A type factory that can provide static type annotations for AST Trees. */\n-    protected final GenericAnnotatedTypeFactory<V, S, T, ? extends CFAbstractAnalysis<V, S, T>>\n+    public final GenericAnnotatedTypeFactory<V, S, T, ? extends CFAbstractAnalysis<V, S, T>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28d33cc35c447bdc068d6484071cfcef5c20b3a7"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 867, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}