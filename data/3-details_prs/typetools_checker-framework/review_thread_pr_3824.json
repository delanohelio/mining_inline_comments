{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NjQwODQ0", "number": 3824, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozMDowOFrOExkw7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozOTowNVrOFAjL9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDE4MDI5OnYy", "diffSide": "RIGHT", "path": "docs/manual/inference.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozMDowOFrOHny2aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozMDowOFrOHny2aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTY0MQ==", "bodyText": "The dljc usage string does not include --checker as a permitted command-line option.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r511489641", "createdAt": "2020-10-24T16:30:08Z", "author": {"login": "mernst"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -140,46 +142,86 @@\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n-\\begin{sloppypar}\n-To use whole-program inference, make sure that\n-\\<insert-annotations-to-source>, from the Annotation File Utilities project,\n-is on your path (for example, its directory is in the \\<\\$PATH> environment variable).\n-Then, run the script \\<checker-framework/checker/bin/infer-and-annotate.sh>.\n-Its command-line arguments are:\n-\\end{sloppypar}\n+To run whole-program inference on a single project, use the \\<wpi.sh>\n+script (Section~\\ref{wpi-one}).  To run it on many projects (say, when\n+running it on projects from GitHub), use the \\<wpi-many.sh> script\n+(Section~\\ref{wpi-one}).  All WPI-related scripts appear in the\n+\\<checker/bin/> directory.\n \n-\\begin{enumerate}\n-\\item Optional: Command-line arguments to\n-  \\href{https://checkerframework.org/annotation-file-utilities/#insert-annotations-to-source}{\\<insert-annotations-to-source>}.\n-\\item Processor's name.\n-\\item Target program's classpath.  This argument is required; pass \"\" if it\n-  is empty.\n-\\item Optional: Extra processor arguments which will be passed to the checker, if any.\n-  You may supply any number of such arguments, or none.  Each such argument\n-  must start with a hyphen.\n-\\item Optional: Paths to \\<.jaif> files used as input in the inference\n-    process.\n-\\item Paths to \\<.java> files in the program.\n-\\end{enumerate}\n+Here are requirements to run the scripts:\n+\n+\\begin{itemize}\n+\\item The project on which inference is run must contain an Ant, Gradle,\n+  or Maven buildfile that compiles the project.\n+\\item \\verb|JAVA8_HOME| environment variable must point to a Java 8 JDK.\n+\\item \\verb|JAVA11_HOME| environment variable must point to a Java 11 JDK.\n+\\item \\<CHECKERFRAMEWORK> environment variable must point to a built copy of the Checker Framework.\n+\\item Other dependencies:\n+  ant,\n+  awk,\n+  curl,\n+  git,\n+  gradle,\n+  mvn,\n+  python2.7 (for dljc),\n+  wget.\n+\n+  Python2.7 modules:\n+  subprocess32.\n+\\end{itemize}\n+\n+\n+\\subsectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of whole-program inference is\n+\n+\\begin{Verbatim}\n+  wpi.sh -d . -- --checker nullness\n+\\end{Verbatim}\n+\n+TODO: What is the result?  A log file?  Placed where?\n+\n+The full syntax for invoking \\<wpi.sh> is\n \n-% TODO: Change the example project that is being annotated, since plume-lib is now deprecated.\n-For example, to add annotations to the \\<plume-lib> project:\n \\begin{Verbatim}\n-git clone https://github.com/mernst/plume-lib.git\n-cd plume-lib\n-make jar\n-$CHECKERFRAMEWORK/checker/bin/infer-and-annotate.sh \\\n-    \"LockChecker,NullnessChecker\" java/plume.jar:java/lib/junit-4.12.jar:$JAVA_HOME/lib/tools.jar \\\n-    `find java/src/plume/ -name \"*.java\"`\n-# View the results\n-git diff\n+  wpi.sh -d PROJECTDIR [-t TIMEOUT] -- [DLJC-ARGS]\n+\\end{Verbatim}\n+\n+Arguments in square brackets are optional.\n+Here is an explanation of the arguments:\n+\n+\\begin{description}\n+\\item[-d PROJECTDIR]\n+  The top-level directory of the project.  It must contain an Ant, Gradle,\n+  or Maven buildfile.\n+\n+\\item[-t TIMEOUT]\n+  The timeout for running the checker, in seconds\n+\n+\\item[DLJC-ARGS]\n+  Arguments that are passed directly to\n+  \\ahref{https://github.com/kelloggm/do-like-javac}{do-like-javac}'s\n+  \\<dljc> program without\n+  modification.  One argument is required: \\<--checker>, which indicates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dc868592de4060ed3aa927930d68869cff72feb"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDE4MDc2OnYy", "diffSide": "RIGHT", "path": "checker/bin/wpi.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozMDo1N1rOHny2oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjozMDo1N1rOHny2oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4OTY5Nw==", "bodyText": "Is the -d command-line argument to wpi.sh needed?\nHere are two ideas, either of which may simplify invocation of the script:\n\nMake it optional, using the current directory if not supplied.\nRemove it, and take the directory as the first non-command-line argument.  Then there is no need for the -- on the wpi.sh command line, either.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r511489697", "createdAt": "2020-10-24T16:30:57Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,170 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:u:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dc868592de4060ed3aa927930d68869cff72feb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNDE5NTM1OnYy", "diffSide": "RIGHT", "path": "checker/bin/wpi.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjo1MToxOFrOHny9rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNjo1MToxOFrOHny9rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ5MTUwMQ==", "bodyText": "Running wpi.sh creates a new directory checker/do-like-javac/.\n\nPlease put it under checker/bin/.\nStart the name with a period, as is done for the clone of plume-scripts and run-google-java-format in checker/bin-devel.\nPut it in the .gitignore", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r511491501", "createdAt": "2020-10-24T16:51:18Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,170 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh was called without a -d argument. The -d argument must be the absolute path to the directory containing the project on which to run WPI.\"\n+    exit 4\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ ! -d \"${SCRIPTDIR}/../do-like-javac\" ]; then", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85fd788700b28972e9792c7d5bfced2e7932c039"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODE2NDg1OnYy", "diffSide": "RIGHT", "path": "docs/manual/inference.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjoxMzo0OFrOHrWKmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjoxMzo0OFrOHrWKmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxMzk3OQ==", "bodyText": "Can you further explain \"each candidate set of annotations\"?  Is that from each iteration of type-checking?  Users only want to see the results of the final iteration.  Say how to see that.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515213979", "createdAt": "2020-10-30T16:13:48Z", "author": {"login": "mernst"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -126,22 +92,209 @@\n Cascade applies it.  Cascade works with any checker built on the Checker\n Framework.\n You can find installation instructions and a video tutorial at \\url{https://github.com/reprogrammer/cascade}.\n+% See last commit at https://github.com/reprogrammer/cascade/commits/master .\n+Cascade was last updated in November 2014, so it might or might not work for you.\n+\n+\\end{description}\n+\n+Except for one of the nullness inference tools, all these\n+type inference tools are static analyses.  They analyze your program's\n+source code, but they do not run your program.\n \n \n \\sectionAndLabel{Whole-program inference}{whole-program-inference}\n \n-Whole-program inference is an interprocedural inference that\n+Whole-program inference\n infers types for fields, method parameters, and method return types that do not\n have a user-written qualifier (for the given type system).\n-The inferred type qualifiers are inserted into\n-your program.\n+The inferred type qualifiers are output into annotation files.\n The inferred type is the most specific type that is compatible with all the\n uses in the program.  For example, the inferred type for a field is the\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n+There are three scripts that you can use to run whole-program inference.\n+Each has advantages and disadvantages, discussed below:\n+\n+\\begin{itemize}\n+    \\item\n+    To run whole-program inference on a single project without modifying its source code,\n+    use the \\<wpi.sh> script (Section~\\ref{wpi-one}). This script can automatically understand\n+    many Ant, Maven, and Gradle build files, so it requires little manual configuration.\n+\n+    \\item\n+    To run whole-program inference on many projects without modifying their source code\n+    (say, when running it on projects from GitHub), use the \\<wpi-many.sh> script (Section~\\ref{wpi-many}).\n+    This script can understand the same build files as \\<wpi.sh>.\n+\n+    \\item\n+    If you want to insert the inferred annotations directly into a single\n+    project's source code, use the \\<infer-and-annotate.sh> script (Section~\\ref{wpi-insert}).\n+\\end{itemize}\n+\n+These type inference scripts appear in the \\<checker/bin/> directory.\n+The remainder of this chapter describes them\n+(Sections~\\ref{wpi-one}--\\ref{wpi-insert}), then concludes with discussion\n+that applies to all of them.x\n+\n+\n+\\sectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh -- --checker nullness\n+\\end{Verbatim}\n+\n+The result is a set of log files placed in the \\<dljc-out> folder of the\n+target project. The results of type-checking with each candidate set of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ba103323b7a97dab70e5bd166d1befc53a2ac4e"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODE3MDgwOnYy", "diffSide": "RIGHT", "path": "docs/manual/inference.tex", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjoxNToxOVrOHrWOYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxOToyMjoyM1rOHrc9gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxNDk0NA==", "bodyText": "This text belongs in the \"single project\" section, I think.  This text also differs slightly from what is already there.  Please move the text and reconcile the versions.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515214944", "createdAt": "2020-10-30T16:15:19Z", "author": {"login": "mernst"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -126,22 +92,209 @@\n Cascade applies it.  Cascade works with any checker built on the Checker\n Framework.\n You can find installation instructions and a video tutorial at \\url{https://github.com/reprogrammer/cascade}.\n+% See last commit at https://github.com/reprogrammer/cascade/commits/master .\n+Cascade was last updated in November 2014, so it might or might not work for you.\n+\n+\\end{description}\n+\n+Except for one of the nullness inference tools, all these\n+type inference tools are static analyses.  They analyze your program's\n+source code, but they do not run your program.\n \n \n \\sectionAndLabel{Whole-program inference}{whole-program-inference}\n \n-Whole-program inference is an interprocedural inference that\n+Whole-program inference\n infers types for fields, method parameters, and method return types that do not\n have a user-written qualifier (for the given type system).\n-The inferred type qualifiers are inserted into\n-your program.\n+The inferred type qualifiers are output into annotation files.\n The inferred type is the most specific type that is compatible with all the\n uses in the program.  For example, the inferred type for a field is the\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n+There are three scripts that you can use to run whole-program inference.\n+Each has advantages and disadvantages, discussed below:\n+\n+\\begin{itemize}\n+    \\item\n+    To run whole-program inference on a single project without modifying its source code,\n+    use the \\<wpi.sh> script (Section~\\ref{wpi-one}). This script can automatically understand\n+    many Ant, Maven, and Gradle build files, so it requires little manual configuration.\n+\n+    \\item\n+    To run whole-program inference on many projects without modifying their source code\n+    (say, when running it on projects from GitHub), use the \\<wpi-many.sh> script (Section~\\ref{wpi-many}).\n+    This script can understand the same build files as \\<wpi.sh>.\n+\n+    \\item\n+    If you want to insert the inferred annotations directly into a single\n+    project's source code, use the \\<infer-and-annotate.sh> script (Section~\\ref{wpi-insert}).\n+\\end{itemize}\n+\n+These type inference scripts appear in the \\<checker/bin/> directory.\n+The remainder of this chapter describes them\n+(Sections~\\ref{wpi-one}--\\ref{wpi-insert}), then concludes with discussion\n+that applies to all of them.x\n+\n+\n+\\sectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh -- --checker nullness\n+\\end{Verbatim}\n+\n+The result is a set of log files placed in the \\<dljc-out> folder of the\n+target project. The results of type-checking with each candidate set of\n+annotations will be concatenated into the file \\<dljc-out/wpi.log>.\n+\n+The full syntax for invoking \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh [-d PROJECTDIR] [-t TIMEOUT] -- [DLJC-ARGS]\n+\\end{Verbatim}\n+\n+Arguments in square brackets are optional.\n+Here is an explanation of the arguments:\n+\n+\\begin{description}\n+\\item[-d PROJECTDIR]\n+  The top-level directory of the project.  It must contain an Ant, Gradle,\n+  or Maven buildfile. The default is the current working directory.\n+\n+\\item[-t TIMEOUT]\n+  The timeout for running the checker, in seconds\n+\n+\\item[DLJC-ARGS]\n+  Arguments that are passed directly to\n+  \\ahref{https://github.com/kelloggm/do-like-javac}{do-like-javac}'s\n+  \\<dljc> program without\n+  modification.  One argument is required: \\<-\\relax-checker>, which indicates\n+  what type-checker to run (use the fully-qualified name of the checker).\n+  The \\ahrefforurl{https://github.com/kelloggm/do-like-javac}{documentation of do-like-javac}\n+  describes the other commands that its WPI tool supports.\n+\\end{description}\n+\n+You may need to wait a few minutes for the command to complete.\n+\n+\n+\\sectionAndLabel{Requirements for whole-program inference scripts}{wpi-shared-requirements}\n+\n+The requirements to run \\<wpi.sh> and \\<wpi-many.sh> are the same:\n+\n+\\begin{itemize}\n+\\item The project on which inference is run must contain an Ant, Gradle,\n+  or Maven buildfile that compiles the project.\n+\\item \\verb|JAVA8_HOME| environment variable must point to a Java 8 JDK.\n+\\item \\verb|JAVA11_HOME| environment variable must point to a Java 11 JDK.\n+\\item \\<CHECKERFRAMEWORK> environment variable must point to a built copy of the Checker Framework.\n+\\item Other dependencies:\n+  ant,\n+  awk,\n+  curl,\n+  git,\n+  gradle,\n+  mvn,\n+  python2.7 (for dljc),\n+  wget.\n+\n+  Python2.7 modules:\n+  subprocess32.\n+\\end{itemize}\n+\n+\n+\n+\\sectionAndLabel{Running whole-program inference on many projects}{wpi-many}\n+\n+The requirements to run \\<wpi.sh> and \\<wpi-many.sh> are the same. See Section~\\ref{wpi-shared-requirements}\n+for the list of requirements.\n+\n+To run an experiment on many projects:\n+\\begin{enumerate}\n+\\item Use \\<query-github.sh> to search GitHub for candidate repositories.\n+File \\<securerandom.query> is an example query, and file\n+\\<securerandom.list>\n+was created by running \\<query-github.sh securerandom.query 100>. If you do\n+not want to use GitHub, construct a file yourself that matches the format of\n+the file \\<securerandom.list>.\n+\n+\\item Use \\<wpi-many.sh> to run whole-program inference on every\n+Ant, Gradle, or Maven project in a list of (GitHub repository URL, git hash)\n+pairs.\n+\\begin{itemize}\n+\\item If you are using a checker that is distributed with the Checker\n+Framework, use \\<wpi-many.sh> directly.\n+\\item If you are using a checker that is not distributed with the Checker\n+Framework (also known as a \"custom checker\"), file\n+\\<custom-checker-example.sh> is a no-arguments\n+script that serves as an example of how to use \\<wpi-many.sh>.\n+\\end{itemize}\n+\n+Log files are copied into a results directory.\n+For a failed run, the log file indicates the reason that WPI could not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ba103323b7a97dab70e5bd166d1befc53a2ac4e"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyNTMxMw==", "bodyText": "It does not. wpi-many.sh processes the log files produced by wpi-one.sh and filters out those for which no actual results are available (and putting a log file with the reason a project was removed in the results directory). It also copies the dlcj-out/wpi.log file for projects for which results actually were available. This pre-processing makes it easier for users running large experiments to go through all the results quickly, by placing the top-level result for each project in a single directory.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515325313", "createdAt": "2020-10-30T19:22:23Z", "author": {"login": "kelloggm"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -126,22 +92,209 @@\n Cascade applies it.  Cascade works with any checker built on the Checker\n Framework.\n You can find installation instructions and a video tutorial at \\url{https://github.com/reprogrammer/cascade}.\n+% See last commit at https://github.com/reprogrammer/cascade/commits/master .\n+Cascade was last updated in November 2014, so it might or might not work for you.\n+\n+\\end{description}\n+\n+Except for one of the nullness inference tools, all these\n+type inference tools are static analyses.  They analyze your program's\n+source code, but they do not run your program.\n \n \n \\sectionAndLabel{Whole-program inference}{whole-program-inference}\n \n-Whole-program inference is an interprocedural inference that\n+Whole-program inference\n infers types for fields, method parameters, and method return types that do not\n have a user-written qualifier (for the given type system).\n-The inferred type qualifiers are inserted into\n-your program.\n+The inferred type qualifiers are output into annotation files.\n The inferred type is the most specific type that is compatible with all the\n uses in the program.  For example, the inferred type for a field is the\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n+There are three scripts that you can use to run whole-program inference.\n+Each has advantages and disadvantages, discussed below:\n+\n+\\begin{itemize}\n+    \\item\n+    To run whole-program inference on a single project without modifying its source code,\n+    use the \\<wpi.sh> script (Section~\\ref{wpi-one}). This script can automatically understand\n+    many Ant, Maven, and Gradle build files, so it requires little manual configuration.\n+\n+    \\item\n+    To run whole-program inference on many projects without modifying their source code\n+    (say, when running it on projects from GitHub), use the \\<wpi-many.sh> script (Section~\\ref{wpi-many}).\n+    This script can understand the same build files as \\<wpi.sh>.\n+\n+    \\item\n+    If you want to insert the inferred annotations directly into a single\n+    project's source code, use the \\<infer-and-annotate.sh> script (Section~\\ref{wpi-insert}).\n+\\end{itemize}\n+\n+These type inference scripts appear in the \\<checker/bin/> directory.\n+The remainder of this chapter describes them\n+(Sections~\\ref{wpi-one}--\\ref{wpi-insert}), then concludes with discussion\n+that applies to all of them.x\n+\n+\n+\\sectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh -- --checker nullness\n+\\end{Verbatim}\n+\n+The result is a set of log files placed in the \\<dljc-out> folder of the\n+target project. The results of type-checking with each candidate set of\n+annotations will be concatenated into the file \\<dljc-out/wpi.log>.\n+\n+The full syntax for invoking \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh [-d PROJECTDIR] [-t TIMEOUT] -- [DLJC-ARGS]\n+\\end{Verbatim}\n+\n+Arguments in square brackets are optional.\n+Here is an explanation of the arguments:\n+\n+\\begin{description}\n+\\item[-d PROJECTDIR]\n+  The top-level directory of the project.  It must contain an Ant, Gradle,\n+  or Maven buildfile. The default is the current working directory.\n+\n+\\item[-t TIMEOUT]\n+  The timeout for running the checker, in seconds\n+\n+\\item[DLJC-ARGS]\n+  Arguments that are passed directly to\n+  \\ahref{https://github.com/kelloggm/do-like-javac}{do-like-javac}'s\n+  \\<dljc> program without\n+  modification.  One argument is required: \\<-\\relax-checker>, which indicates\n+  what type-checker to run (use the fully-qualified name of the checker).\n+  The \\ahrefforurl{https://github.com/kelloggm/do-like-javac}{documentation of do-like-javac}\n+  describes the other commands that its WPI tool supports.\n+\\end{description}\n+\n+You may need to wait a few minutes for the command to complete.\n+\n+\n+\\sectionAndLabel{Requirements for whole-program inference scripts}{wpi-shared-requirements}\n+\n+The requirements to run \\<wpi.sh> and \\<wpi-many.sh> are the same:\n+\n+\\begin{itemize}\n+\\item The project on which inference is run must contain an Ant, Gradle,\n+  or Maven buildfile that compiles the project.\n+\\item \\verb|JAVA8_HOME| environment variable must point to a Java 8 JDK.\n+\\item \\verb|JAVA11_HOME| environment variable must point to a Java 11 JDK.\n+\\item \\<CHECKERFRAMEWORK> environment variable must point to a built copy of the Checker Framework.\n+\\item Other dependencies:\n+  ant,\n+  awk,\n+  curl,\n+  git,\n+  gradle,\n+  mvn,\n+  python2.7 (for dljc),\n+  wget.\n+\n+  Python2.7 modules:\n+  subprocess32.\n+\\end{itemize}\n+\n+\n+\n+\\sectionAndLabel{Running whole-program inference on many projects}{wpi-many}\n+\n+The requirements to run \\<wpi.sh> and \\<wpi-many.sh> are the same. See Section~\\ref{wpi-shared-requirements}\n+for the list of requirements.\n+\n+To run an experiment on many projects:\n+\\begin{enumerate}\n+\\item Use \\<query-github.sh> to search GitHub for candidate repositories.\n+File \\<securerandom.query> is an example query, and file\n+\\<securerandom.list>\n+was created by running \\<query-github.sh securerandom.query 100>. If you do\n+not want to use GitHub, construct a file yourself that matches the format of\n+the file \\<securerandom.list>.\n+\n+\\item Use \\<wpi-many.sh> to run whole-program inference on every\n+Ant, Gradle, or Maven project in a list of (GitHub repository URL, git hash)\n+pairs.\n+\\begin{itemize}\n+\\item If you are using a checker that is distributed with the Checker\n+Framework, use \\<wpi-many.sh> directly.\n+\\item If you are using a checker that is not distributed with the Checker\n+Framework (also known as a \"custom checker\"), file\n+\\<custom-checker-example.sh> is a no-arguments\n+script that serves as an example of how to use \\<wpi-many.sh>.\n+\\end{itemize}\n+\n+Log files are copied into a results directory.\n+For a failed run, the log file indicates the reason that WPI could not", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxNDk0NA=="}, "originalCommit": {"oid": "2ba103323b7a97dab70e5bd166d1befc53a2ac4e"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTAyNDM3OnYy", "diffSide": "RIGHT", "path": "checker/bin/wpi.sh", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDowODozNFrOHrejqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMzo1MTo0OVrOHtEh5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MTQ2NA==", "bodyText": "The -g .gradle command causes gradle to core dump, when the .gradle directory does not exist.  Is it needed?  Or, can it be supplied only if a .gradle/ directory exists?", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515351464", "createdAt": "2020-10-30T20:08:34Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,175 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh was called without a -d argument. Running on the current directory instead.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "179c19122c3bb099954c0c053c76ff49877f9d10"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyNjg2NA==", "bodyText": "As we discussed on our call, I intended to just guard this behind a flag. But I did some digging and now I remember why this is here. There is a relevant Gradle issue (gradle/gradle#1319), which I'll link from a TODO comment in the script. The gist is that Gradle doesn't play nicely with distributed file systems (like those used on the cycle servers) because it tries to put its caches in the user's home directory by default (which can cause either contention if you're using multiple servers or use too much space. And in the cycle servers case, it's also slow! The -g option controls where those caches go, in addition to controlling where to look first for user configuration etc. So this is here to force gradle to cache everything in the .gradle directory relative to the project, which means each project gets its own cache.\nI've implemented a check for whether .gradle exists that creates the directory if it doesn't exist. This leaves the gradle command line invocation unchanged. This should fix your immediate problem, but it leaves the larger problem of not sharing caches; I'm not sure if we want to fix that or not.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r516326864", "createdAt": "2020-11-02T23:22:55Z", "author": {"login": "kelloggm"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,175 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh was called without a -d argument. Running on the current directory instead.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MTQ2NA=="}, "originalCommit": {"oid": "179c19122c3bb099954c0c053c76ff49877f9d10"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMDgxOQ==", "bodyText": "If it is convenient to do, I would prefer to use a location in /scratch/$USER/ or /tmp/$USER/.  This would permit sharing the cache and would reduce repeated downloads.  This isn't critical but would be nice to do.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r516830819", "createdAt": "2020-11-03T17:17:52Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,175 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh was called without a -d argument. Running on the current directory instead.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MTQ2NA=="}, "originalCommit": {"oid": "179c19122c3bb099954c0c053c76ff49877f9d10"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAyMjE4MQ==", "bodyText": "That would work on the CSE cycle servers, but these scripts should be portable and we can't know a priori what's part of a shared file system and what is not. For that reason, I think it's better to default this to a directory that's exclusive to the project, even if it makes these scripts less efficient.\nYou're right that on a system like the CSE file servers it would be nice to have an option that will change where this default is. I've added one: -g. Hopefully that will address your concerns.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r517022181", "createdAt": "2020-11-03T23:51:49Z", "author": {"login": "kelloggm"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,175 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh was called without a -d argument. Running on the current directory instead.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1MTQ2NA=="}, "originalCommit": {"oid": "179c19122c3bb099954c0c053c76ff49877f9d10"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTA0NjIxOnYy", "diffSide": "RIGHT", "path": "docs/manual/inference.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxNjo0NFrOHrew7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxNjo0NFrOHrew7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NDg2MA==", "bodyText": "https://github.com/kelloggm/do-like-javac says:\n\nThe --checker option is required. Its argument is the fully-qualified name of the checker you want to run.\n\nCan --checker be supplied multiple times?  Or can I supply multiple checkers in comma-separated form, as in javac's -processor argument (https://checkerframework.org/manual/#shorthand-for-checkers)?\n(Please fix that in do-like-javac rather than here, though this text might need to be tweaked slightly.)", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515354860", "createdAt": "2020-10-30T20:16:44Z", "author": {"login": "mernst"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -126,22 +84,209 @@\n Cascade applies it.  Cascade works with any checker built on the Checker\n Framework.\n You can find installation instructions and a video tutorial at \\url{https://github.com/reprogrammer/cascade}.\n+% See last commit at https://github.com/reprogrammer/cascade/commits/master .\n+Cascade was last updated in November 2014, so it might or might not work for you.\n+\n+\\end{description}\n+\n+Except for one of the nullness inference tools, all these\n+type inference tools are static analyses.  They analyze your program's\n+source code, but they do not run your program.\n \n \n \\sectionAndLabel{Whole-program inference}{whole-program-inference}\n \n-Whole-program inference is an interprocedural inference that\n+Whole-program inference\n infers types for fields, method parameters, and method return types that do not\n have a user-written qualifier (for the given type system).\n-The inferred type qualifiers are inserted into\n-your program.\n+The inferred type qualifiers are output into annotation files.\n The inferred type is the most specific type that is compatible with all the\n uses in the program.  For example, the inferred type for a field is the\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n+There are three scripts that you can use to run whole-program inference.\n+Each has advantages and disadvantages, discussed below:\n+\n+\\begin{itemize}\n+    \\item\n+    To run whole-program inference on a single project without modifying its source code,\n+    use the \\<wpi.sh> script (Section~\\ref{wpi-one}). This script can automatically understand\n+    many Ant, Maven, and Gradle build files, so it requires little manual configuration.\n+\n+    \\item\n+    To run whole-program inference on many projects without modifying their source code\n+    (say, when running it on projects from GitHub), use the \\<wpi-many.sh> script (Section~\\ref{wpi-many}).\n+    This script can understand the same build files as \\<wpi.sh>.\n+\n+    \\item\n+    If you want to insert the inferred annotations directly into a single\n+    project's source code, use the \\<infer-and-annotate.sh> script (Section~\\ref{wpi-insert}).\n+\\end{itemize}\n+\n+These type inference scripts appear in the \\<checker/bin/> directory.\n+The remainder of this chapter describes them\n+(Sections~\\ref{wpi-one}--\\ref{wpi-insert}), then concludes with discussion\n+that applies to all of them.x\n+\n+\n+\\sectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh -- --checker nullness\n+\\end{Verbatim}\n+\n+The result is a set of log files placed in the \\<dljc-out> folder of the\n+target project. The results of type-checking with each candidate set of\n+annotations will be concatenated into the file \\<dljc-out/wpi.log>.\n+\n+The full syntax for invoking \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh [-d PROJECTDIR] [-t TIMEOUT] -- [DLJC-ARGS]\n+\\end{Verbatim}\n+\n+Arguments in square brackets are optional.\n+Here is an explanation of the arguments:\n+\n+\\begin{description}\n+\\item[-d PROJECTDIR]\n+  The top-level directory of the project.  It must contain an Ant, Gradle,\n+  or Maven buildfile. The default is the current working directory.\n+\n+\\item[-t TIMEOUT]\n+  The timeout for running the checker, in seconds\n+\n+\\item[DLJC-ARGS]\n+  Arguments that are passed directly to\n+  \\ahref{https://github.com/kelloggm/do-like-javac}{do-like-javac}'s\n+  \\<dljc> program without\n+  modification.  One argument is required: \\<-\\relax-checker>, which indicates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTA0NzQwOnYy", "diffSide": "RIGHT", "path": "docs/manual/inference.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxNzoxM1rOHrexqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxNzoxM1rOHrexqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTA1MA==", "bodyText": "It seems to work to use shorthands as described in https://checkerframework.org/manual/#shorthand-for-checkers .", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515355050", "createdAt": "2020-10-30T20:17:13Z", "author": {"login": "mernst"}, "path": "docs/manual/inference.tex", "diffHunk": "@@ -126,22 +84,209 @@\n Cascade applies it.  Cascade works with any checker built on the Checker\n Framework.\n You can find installation instructions and a video tutorial at \\url{https://github.com/reprogrammer/cascade}.\n+% See last commit at https://github.com/reprogrammer/cascade/commits/master .\n+Cascade was last updated in November 2014, so it might or might not work for you.\n+\n+\\end{description}\n+\n+Except for one of the nullness inference tools, all these\n+type inference tools are static analyses.  They analyze your program's\n+source code, but they do not run your program.\n \n \n \\sectionAndLabel{Whole-program inference}{whole-program-inference}\n \n-Whole-program inference is an interprocedural inference that\n+Whole-program inference\n infers types for fields, method parameters, and method return types that do not\n have a user-written qualifier (for the given type system).\n-The inferred type qualifiers are inserted into\n-your program.\n+The inferred type qualifiers are output into annotation files.\n The inferred type is the most specific type that is compatible with all the\n uses in the program.  For example, the inferred type for a field is the\n least upper bound of the types of all the expressions that are assigned\n into the field.\n \n+There are three scripts that you can use to run whole-program inference.\n+Each has advantages and disadvantages, discussed below:\n+\n+\\begin{itemize}\n+    \\item\n+    To run whole-program inference on a single project without modifying its source code,\n+    use the \\<wpi.sh> script (Section~\\ref{wpi-one}). This script can automatically understand\n+    many Ant, Maven, and Gradle build files, so it requires little manual configuration.\n+\n+    \\item\n+    To run whole-program inference on many projects without modifying their source code\n+    (say, when running it on projects from GitHub), use the \\<wpi-many.sh> script (Section~\\ref{wpi-many}).\n+    This script can understand the same build files as \\<wpi.sh>.\n+\n+    \\item\n+    If you want to insert the inferred annotations directly into a single\n+    project's source code, use the \\<infer-and-annotate.sh> script (Section~\\ref{wpi-insert}).\n+\\end{itemize}\n+\n+These type inference scripts appear in the \\<checker/bin/> directory.\n+The remainder of this chapter describes them\n+(Sections~\\ref{wpi-one}--\\ref{wpi-insert}), then concludes with discussion\n+that applies to all of them.x\n+\n+\n+\\sectionAndLabel{Running whole-program inference on a single project}{wpi-one}\n+\n+A typical invocation of \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh -- --checker nullness\n+\\end{Verbatim}\n+\n+The result is a set of log files placed in the \\<dljc-out> folder of the\n+target project. The results of type-checking with each candidate set of\n+annotations will be concatenated into the file \\<dljc-out/wpi.log>.\n+\n+The full syntax for invoking \\<wpi.sh> is\n+\n+\\begin{Verbatim}\n+  wpi.sh [-d PROJECTDIR] [-t TIMEOUT] -- [DLJC-ARGS]\n+\\end{Verbatim}\n+\n+Arguments in square brackets are optional.\n+Here is an explanation of the arguments:\n+\n+\\begin{description}\n+\\item[-d PROJECTDIR]\n+  The top-level directory of the project.  It must contain an Ant, Gradle,\n+  or Maven buildfile. The default is the current working directory.\n+\n+\\item[-t TIMEOUT]\n+  The timeout for running the checker, in seconds\n+\n+\\item[DLJC-ARGS]\n+  Arguments that are passed directly to\n+  \\ahref{https://github.com/kelloggm/do-like-javac}{do-like-javac}'s\n+  \\<dljc> program without\n+  modification.  One argument is required: \\<-\\relax-checker>, which indicates\n+  what type-checker to run (use the fully-qualified name of the checker).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTA1MTk2OnYy", "diffSide": "RIGHT", "path": "checker/bin/wpi.sh", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoxOTowNVrOHre0eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMjozODowOFrOHriOYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTc2OA==", "bodyText": "It is distracting and confusing that the pushd and popd commands produce user-visible output.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515355768", "createdAt": "2020-10-30T20:19:05Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"\n+    touch .cannot-run-wpi\n+fi\n+\n+popd || exit 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5MTg3MA==", "bodyText": "That's what the pushd and popd commands do, and I'm under the impression that they're still the preferred way to switch directories (vs cd). Personally, I don't find it distracting - especially because the user isn't meant to look at the output of wpi.sh or wpi-many.sh unless something goes wrong. The user should look at the produced log files instead.\nDo you have a specific suggestion for how to avoid the output, such as a different set of commands to use? One option, suggested by this stack overflow post is to redefine the commands to pipe their output to /dev/null, but redefining commands always makes me nervous, and reduces the readability of the scripts.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515391870", "createdAt": "2020-10-30T21:31:21Z", "author": {"login": "kelloggm"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"\n+    touch .cannot-run-wpi\n+fi\n+\n+popd || exit 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTc2OA=="}, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NzQxNw==", "bodyText": "Personally, I don't find it distracting\n\nMaybe because that's because you know the implementation.  I had to read the script to determine that this was normal output and not part of an error message.\n\nThe user should look at the produced log files instead.\n\nThat's reasonable.  Maybe the script should produce:\n\nno output when it succeeds.\na single line saying to look at the log file when it fails.\n\n\nDo you have a specific suggestion for how to avoid the output, such as a different set of commands to use?\n\nI don't have a specific suggestion for you.  When the directories are known (as in this case), I use cd, because I don't see that pushd and popd provide any benefit.  (Am I missing some benefit?)", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515397417", "createdAt": "2020-10-30T21:47:39Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"\n+    touch .cannot-run-wpi\n+fi\n+\n+popd || exit 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTc2OA=="}, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5OTg3NA==", "bodyText": "I don't have a specific suggestion for you. When the directories are known (as in this case), I use cd, because I don't see that pushd and popd provide any benefit. (Am I missing some benefit?)\n\nUsing pushd/popd is safer, because it stores the history of the directories that have been the current working directory. cd only stores the most recent directory (-). If the script encounters a problem we didn't anticipate that causes the directory structure to be messed up, then the pushd/popd approach is more likely to recover, in my experience. That's the only benefit I know of.\n\nThat's reasonable. Maybe the script should produce:\n\nno output when it succeeds.\na single line saying to look at the log file when it fails.\n\n\nEven when the script succeeds, the user should look at the log file. The documentation indicates this:\n\nThe result is a set of log files placed in the <dljc-out> folder of the\ntarget project. The results of type-checking with each candidate set of\nannotations will be concatenated into the file <dljc-out/wpi.log>; the final\nresults (i.e. those obtained using the most precise, consistent set of annotations)\nwill appear at the end of this file.\n\nA simpler option than changing the scripts would be to modify the documentation to note that any output from the script itself is merely informational. Would that alleviate your concern?", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515399874", "createdAt": "2020-10-30T21:55:04Z", "author": {"login": "kelloggm"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"\n+    touch .cannot-run-wpi\n+fi\n+\n+popd || exit 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTc2OA=="}, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxMTU1Mw==", "bodyText": "I didn't see any error-handling code that uses the pushd/popd stack, but maybe I missed it.\nMaybe the script should prefix and suffix its output with a remark to look elsewhere.  (Because users might not remember all details of the documentation.)  Even if so, it's friendly to users to remove output that isn't useful.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515411553", "createdAt": "2020-10-30T22:38:08Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"\n+    touch .cannot-run-wpi\n+fi\n+\n+popd || exit 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NTc2OA=="}, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTA1NjUwOnYy", "diffSide": "RIGHT", "path": "checker/bin/wpi.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoyMDo0NFrOHre3Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMDoyMDo0NFrOHre3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM1NjQ2Ng==", "bodyText": "Please add output telling the user where to look for diagnostic output.\nI think the answer is \"in the dljc-out directory\".", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r515356466", "createdAt": "2020-10-30T20:20:44Z", "author": {"login": "mernst"}, "path": "checker/bin/wpi.sh", "diffHunk": "@@ -0,0 +1,174 @@\n+#!/bin/bash\n+\n+# This script performs whole-program inference on a project directory.\n+\n+# For usage and requirements, see the \"Whole-program inference\"\n+# section of the Checker Framework manual:\n+# https://checkerframework.org/manual/#whole-program-inference\n+\n+\n+while getopts \"d:t:\" opt; do\n+  case $opt in\n+    d) DIR=\"$OPTARG\"\n+       ;;\n+    t) TIMEOUT=\"$OPTARG\"\n+       ;;\n+    \\?) # echo \"Invalid option -$OPTARG\" >&2\n+       ;;\n+  esac\n+done\n+\n+# Make $@ be the arguments that should be passed to dljc.\n+shift $(( OPTIND - 1 ))\n+\n+# check required arguments and environment variables:\n+\n+# Testing for JAVA8_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA8_HOME}\" = \"x\" ]; then\n+    echo \"JAVA8_HOME must be set to a Java 8 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA8_HOME}\" ]; then\n+    echo \"JAVA8_HOME is set to a non-existent directory ${JAVA8_HOME}\"\n+    exit 1\n+fi\n+\n+# Testing for JAVA11_HOME, not a misspelling of JAVA_HOME.\n+# shellcheck disable=SC2153\n+if [ \"x${JAVA11_HOME}\" = \"x\" ]; then\n+    echo \"JAVA11_HOME must be set to a Java 11 JDK\"\n+    exit 1\n+fi\n+\n+if [ ! -d \"${JAVA11_HOME}\" ]; then\n+    echo \"JAVA11_HOME is set to a non-existent directory ${JAVA11_HOME}\"\n+    exit 1\n+fi\n+\n+JAVA_HOME=\"${JAVA11_HOME}\"\n+\n+if [ \"x${CHECKERFRAMEWORK}\" = \"x\" ]; then\n+    echo \"CHECKERFRAMEWORK is not set; it must be set to a locally-built Checker Framework. Please clone and build github.com/typetools/checker-framework\"\n+    exit 2\n+fi\n+\n+if [ ! -d \"${CHECKERFRAMEWORK}\" ]; then\n+    echo \"CHECKERFRAMEWORK is set to a non-existent directory ${CHECKERFRAMEWORK}\"\n+    exit 2\n+fi\n+\n+if [ \"x${DIR}\" = \"x\" ]; then\n+    echo \"wpi.sh: no -d argument supplied, using the current directory.\"\n+    DIR=$(pwd)\n+fi\n+\n+if [ ! -d \"${DIR}\" ]; then\n+    echo \"wpi.sh's -d argument was not a directory: ${DIR}\"\n+    exit 4\n+fi\n+\n+function configure_and_exec_dljc {\n+\n+  if [ -f build.gradle ]; then\n+      if [ -f gradlew ]; then\n+    chmod +x gradlew\n+    GRADLE_EXEC=\"./gradlew\"\n+      else\n+    GRADLE_EXEC=\"gradle\"\n+      fi\n+      CLEAN_CMD=\"${GRADLE_EXEC} clean -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+      BUILD_CMD=\"${GRADLE_EXEC} clean compileJava -g .gradle -Dorg.gradle.java.home=${JAVA_HOME}\"\n+  elif [ -f pom.xml ]; then\n+      if [ -f mvnw ]; then\n+    chmod +x mvnw\n+    MVN_EXEC=\"./mvnw\"\n+      else\n+    MVN_EXEC=\"mvn\"\n+      fi\n+      # if running on java 8, need /jre at the end of this Maven command\n+      if [ \"${JAVA_HOME}\" = \"${JAVA8_HOME}\" ]; then\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}/jre\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}/jre\"\n+      else\n+          CLEAN_CMD=\"${MVN_EXEC} clean -Djava.home=${JAVA_HOME}\"\n+          BUILD_CMD=\"${MVN_EXEC} clean compile -Djava.home=${JAVA_HOME}\"\n+      fi\n+  elif [ -f build.xml ]; then\n+    # TODO: test these more thoroughly\n+    CLEAN_CMD=\"ant clean\"\n+    BUILD_CMD=\"ant clean compile\"\n+  else\n+      echo \"no build file found for ${REPO_NAME}; not calling DLJC\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  DLJC_CMD=\"${DLJC} -t wpi $* -- ${BUILD_CMD}\"\n+\n+  if [ ! \"x${TIMEOUT}\" = \"x\" ]; then\n+      TMP=\"${DLJC_CMD}\"\n+      DLJC_CMD=\"timeout ${TIMEOUT} ${TMP}\"\n+  fi\n+\n+  # Remove old DLJC output.\n+  rm -rf dljc-out\n+\n+  # ensure the project is clean before invoking DLJC\n+  eval \"${CLEAN_CMD}\" < /dev/null\n+\n+  echo \"${DLJC_CMD}\"\n+\n+  # This command also includes \"clean\"; I'm not sure why it is necessary.\n+  eval \"${DLJC_CMD}\" < /dev/null\n+\n+  if [[ $? -eq 124 ]]; then\n+      echo \"dljc timed out for ${DIR}\"\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+      return\n+  fi\n+\n+  if [ -f dljc-out/wpi.log ]; then\n+      WPI_RESULTS_AVAILABLE=\"yes\"\n+  else\n+      WPI_RESULTS_AVAILABLE=\"no\"\n+  fi\n+}\n+\n+#### Check and setup dependencies\n+\n+SCRIPTDIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" >/dev/null 2>&1 && pwd )\"\n+\n+# clone or update DLJC\n+if [ -d \"${SCRIPTDIR}/.do-like-javac\" ]; then\n+    git -C \"${SCRIPTDIR}/.do-like-javac\" pull\n+else\n+    git -C \"${SCRIPTDIR}\" clone https://github.com/kelloggm/do-like-javac --depth 1 .do-like-javac || (echo \"Cannot clone do-like-javac\" && exit 1)\n+fi\n+\n+DLJC=\"${SCRIPTDIR}/.do-like-javac/dljc\"\n+\n+#### Main script\n+\n+pushd \"${DIR}\" || exit 1\n+\n+configure_and_exec_dljc \"$@\"\n+\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+      # if running under Java 11 fails, try to run\n+      # under Java 8 instead\n+    export JAVA_HOME=\"${JAVA8_HOME}\"\n+    echo \"couldn't build using Java 11; trying Java 8\"\n+    configure_and_exec_dljc \"$@\"\n+    export JAVA_HOME=\"${JAVA11_HOME}\"\n+fi\n+\n+# support wpi-many.sh's ability to delete projects without usable results\n+# automatically\n+if [ \"${WPI_RESULTS_AVAILABLE}\" = \"no\" ]; then\n+    echo \"dljc could not run the build successfully\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cae815c2952ac49ff277d15868493f9208647ace"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTE5NzI3OnYy", "diffSide": "RIGHT", "path": "checker/bin-devel/Makefile", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozNToxOFrOH-6DZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1ODozOVrOIDYmDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyNDkwMg==", "bodyText": "What is the Makefile make?  Could you add a summary comment?", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r535724902", "createdAt": "2020-12-03T23:35:18Z", "author": {"login": "smillst"}, "path": "checker/bin-devel/Makefile", "diffHunk": "@@ -0,0 +1,18 @@\n+remove-annotations.sh:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c883a347c5c5a72bb34a23981fb0b20be9dd014"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxOTU5OQ==", "bodyText": "A Makefile target (unless it is marked as PHONY) is a file that the rule creates.  So, this rule creates the file remove-annotations-sh.", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r540419599", "createdAt": "2020-12-10T18:58:39Z", "author": {"login": "mernst"}, "path": "checker/bin-devel/Makefile", "diffHunk": "@@ -0,0 +1,18 @@\n+remove-annotations.sh:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyNDkwMg=="}, "originalCommit": {"oid": "1c883a347c5c5a72bb34a23981fb0b20be9dd014"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTIwMTM1OnYy", "diffSide": "RIGHT", "path": "checker/bin-devel/remove-annotations.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozNjozNFrOH-6Fgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozNjozNFrOH-6Fgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyNTQ0Mg==", "bodyText": "How is \"trusted\" defined? Should new annotations be added to this list by hand or was it generated?", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r535725442", "createdAt": "2020-12-03T23:36:34Z", "author": {"login": "smillst"}, "path": "checker/bin-devel/remove-annotations.sh", "diffHunk": "@@ -0,0 +1,311 @@\n+#!/bin/sh\n+# Remove Checker Framework annotations (except trusted ones) from all files under the current directory.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c883a347c5c5a72bb34a23981fb0b20be9dd014"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTIwODIyOnYy", "diffSide": "RIGHT", "path": "docs/examples/wpi-many/securerandom.query", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozOTowNVrOH-6JRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzozOTowNVrOH-6JRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyNjQwNA==", "bodyText": "Does it matter that this is missing a new line?", "url": "https://github.com/typetools/checker-framework/pull/3824#discussion_r535726404", "createdAt": "2020-12-03T23:39:05Z", "author": {"login": "smillst"}, "path": "docs/examples/wpi-many/securerandom.query", "diffHunk": "@@ -0,0 +1 @@\n+\"import java.security.SecureRandom;\" -filename:*Test.java language:Java -user:kelloggm -user:AndroidSDKSources", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c883a347c5c5a72bb34a23981fb0b20be9dd014"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 870, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}