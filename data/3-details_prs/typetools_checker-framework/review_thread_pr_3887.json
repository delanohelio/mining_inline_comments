{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NzA5OTQy", "number": 3887, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0NjoyOVrOE3Yvug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1Njo1MFrOE4xbUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEyNTcwOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/index/lowerbound/LowerBoundAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0NjoyOVrOHws_gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDozNjoxMFrOHwuo2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMDg0OQ==", "bodyText": "Why was this change necessary? It seems unrelated to the other work in this PR.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520830849", "createdAt": "2020-11-10T19:46:29Z", "author": {"login": "kelloggm"}, "path": "checker/src/main/java/org/checkerframework/checker/index/lowerbound/LowerBoundAnnotatedTypeFactory.java", "diffHunk": "@@ -175,7 +176,9 @@ public void addComputedTypeAnnotations(Tree tree, AnnotatedTypeMirror type, bool\n         // If dataflow shouldn't be used to compute this type, then do not use the result from\n         // the Value Checker, because dataflow is used to compute that type.  (Without this,\n         // \"int i = 1; --i;\" fails.)\n-        if (iUseFlow && tree != null && TreeUtils.isExpressionTree(tree)) {\n+        if (tree != null\n+                && TreeUtils.isExpressionTree(tree)\n+                && (iUseFlow || tree instanceof LiteralTree)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg1NzgxOQ==", "bodyText": "Without this, the interaction between the Initialized Fields Checker and the Index Checker fails, because the Initialized Fields Checker calls this (transitively) with iUseFlow set to false.\nLiterals don't depend on flow, so this change seems safe.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520857819", "createdAt": "2020-11-10T20:36:10Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/index/lowerbound/LowerBoundAnnotatedTypeFactory.java", "diffHunk": "@@ -175,7 +176,9 @@ public void addComputedTypeAnnotations(Tree tree, AnnotatedTypeMirror type, bool\n         // If dataflow shouldn't be used to compute this type, then do not use the result from\n         // the Value Checker, because dataflow is used to compute that type.  (Without this,\n         // \"int i = 1; --i;\" fails.)\n-        if (iUseFlow && tree != null && TreeUtils.isExpressionTree(tree)) {\n+        if (tree != null\n+                && TreeUtils.isExpressionTree(tree)\n+                && (iUseFlow || tree instanceof LiteralTree)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMDg0OQ=="}, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEzMDc2OnYy", "diffSide": "RIGHT", "path": "docs/manual/initialized-fields-checker.tex", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0Nzo1OFrOHwtC0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0ODoxOVrOHwtDpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMTY5Nw==", "bodyText": "This isn't quite true - every type system that has an annotation that is inconsistent with null, 0, or false is unsound. Those that do not (such as e.g. the Tainting Checker) aren't unsound.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520831697", "createdAt": "2020-11-10T19:47:58Z", "author": {"login": "kelloggm"}, "path": "docs/manual/initialized-fields-checker.tex", "diffHunk": "@@ -0,0 +1,172 @@\n+\\htmlhr\n+\\chapterAndLabel{Initialized Fields Checker}{initialized-fields-checker}\n+\n+The Initialized Fields Checker warns if a constructor does not initialize a\n+field.\n+If you run it together with other checkers (by supplying multiple checkers\n+to the \\<-processor> command-line option), then it issues warnings only if\n+the default value assigned by Java (0, true, or null) is not consistent\n+with the field's annotation, for the other checkers.\n+% It's actually the checkers and their subcheckers if any.  Saying that\n+% would be confusing to most users, who don't know what a \"subchecker\" is.\n+% The term \"subchecker\" appears only in the \"creating a checker\" section of\n+% the manual.\n+\n+An example invocation is\n+\n+\\begin{Verbatim}\n+javac -processor ValueChecker,InitializedFieldsChecker MyFile.java\n+\\end{Verbatim}\n+\n+\n+\\sectionAndLabel{Motivation:  uninitialized fields}{initialized-fields-motivation}\n+\n+Without the Initialized Fields Checker, every type system (except the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMTkwOQ==", "bodyText": "It might be okay to leave this as-is, though, because bringing up that detail might make this too wordy.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520831909", "createdAt": "2020-11-10T19:48:19Z", "author": {"login": "kelloggm"}, "path": "docs/manual/initialized-fields-checker.tex", "diffHunk": "@@ -0,0 +1,172 @@\n+\\htmlhr\n+\\chapterAndLabel{Initialized Fields Checker}{initialized-fields-checker}\n+\n+The Initialized Fields Checker warns if a constructor does not initialize a\n+field.\n+If you run it together with other checkers (by supplying multiple checkers\n+to the \\<-processor> command-line option), then it issues warnings only if\n+the default value assigned by Java (0, true, or null) is not consistent\n+with the field's annotation, for the other checkers.\n+% It's actually the checkers and their subcheckers if any.  Saying that\n+% would be confusing to most users, who don't know what a \"subchecker\" is.\n+% The term \"subchecker\" appears only in the \"creating a checker\" section of\n+% the manual.\n+\n+An example invocation is\n+\n+\\begin{Verbatim}\n+javac -processor ValueChecker,InitializedFieldsChecker MyFile.java\n+\\end{Verbatim}\n+\n+\n+\\sectionAndLabel{Motivation:  uninitialized fields}{initialized-fields-motivation}\n+\n+Without the Initialized Fields Checker, every type system (except the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMTY5Nw=="}, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE1MTI1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1MzozN1rOHwtPyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1MzozN1rOHwtPyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNTAxOA==", "bodyText": "I think you can replace this with executableElement.getKind() == ElementKind.CONSTRUCTOR to avoid the string comparison", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520835018", "createdAt": "2020-11-10T19:53:37Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,240 @@\n+package org.checkerframework.common.initializedfields;\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Options;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.common.initializedfields.qual.EnsuresInitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsBottom;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsPredicate;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.framework.util.Contract;\n+import org.checkerframework.framework.util.ContractsUtils;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Initialized Fields Checker. */\n+public class InitializedFieldsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The type factories that determine whether the default value is consistent with the annotated\n+     * type. If empty, warn about all uninitialized fields.\n+     */\n+    List<GenericAnnotatedTypeFactory<?, ?, ?, ?>> defaultValueAtypeFactories;\n+\n+    /**\n+     * Creates a new InitializedFieldsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public InitializedFieldsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                InitializedFields.class,\n+                InitializedFieldsBottom.class,\n+                InitializedFieldsPredicate.class);\n+\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        String checkerNames = Options.instance(context).get(\"-processor\");\n+        defaultValueAtypeFactories = new ArrayList<>();\n+        for (String checkerName : checkerNames.split(\",\")) {\n+            if (checkerName.equals(InitializedFieldsChecker.class.getCanonicalName())) {\n+                continue;\n+            }\n+            @SuppressWarnings(\"signature:argument.type.incompatible\") // -processor is a binary name\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = getTypeFactory(checkerName);\n+            if (atf == null) {\n+                throw new UserError(\n+                        \"Cannot find %s; check the classpath or processorpath\", checkerName);\n+            }\n+            defaultValueAtypeFactories.add(atf);\n+        }\n+\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Returns the type factory for the given checker.\n+     *\n+     * @param checkerName the fully-qualified class name of a checker\n+     * @return the type factory for the given checker\n+     */\n+    GenericAnnotatedTypeFactory<?, ?, ?, ?> getTypeFactory(@BinaryName String checkerName) {\n+        try {\n+            Class<?> checkerClass = Class.forName(checkerName);\n+            @SuppressWarnings(\"unchecked\")\n+            BaseTypeChecker c =\n+                    ((Class<? extends BaseTypeChecker>) checkerClass)\n+                            .getDeclaredConstructor()\n+                            .newInstance();\n+            c.init(processingEnv);\n+            c.initChecker();\n+            BaseTypeVisitor<?> v = c.createSourceVisitorPublic();\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = v.createTypeFactoryPublic();\n+            return atf;\n+        } catch (ClassNotFoundException\n+                | InstantiationException\n+                | InvocationTargetException\n+                | IllegalAccessException\n+                | NoSuchMethodException e) {\n+            throw new UserError(\"Problem instantiating \" + checkerName, e);\n+        }\n+    }\n+\n+    @Override\n+    public InitializedFieldsContractsUtils getContractsUtils() {\n+        return new InitializedFieldsContractsUtils(this);\n+    }\n+\n+    /**\n+     * A subclass of ContractsUtils that adds a postcondition contract to each constructor,\n+     * requiring that it initializes all fields.\n+     */\n+    private class InitializedFieldsContractsUtils extends ContractsUtils {\n+        /**\n+         * Creates an InitializedFieldsContractsUtils for the given factory.\n+         *\n+         * @param factory the type factory associated with the newly-created ContractsUtils\n+         */\n+        public InitializedFieldsContractsUtils(GenericAnnotatedTypeFactory<?, ?, ?, ?> factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Set<Contract.Postcondition> getPostconditions(ExecutableElement executableElement) {\n+            Set<Contract.Postcondition> result = super.getPostconditions(executableElement);\n+\n+            // Only process methods defined in source code being type-checked.\n+            if (declarationFromElement(executableElement) != null) {\n+\n+                if (executableElement.getSimpleName().contentEquals(\"<init>\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE1ODUxOnYy", "diffSide": "RIGHT", "path": "docs/manual/initialized-fields-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1NTo0OVrOHwtUUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1NTo0OVrOHwtUUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjE3Nw==", "bodyText": "The default value for booleans in Java is false, not true. This should probably also mention 0.0, which is the default for floating point types.\nI think the code gets this right, but this documentation is wrong.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520836177", "createdAt": "2020-11-10T19:55:49Z", "author": {"login": "kelloggm"}, "path": "docs/manual/initialized-fields-checker.tex", "diffHunk": "@@ -0,0 +1,172 @@\n+\\htmlhr\n+\\chapterAndLabel{Initialized Fields Checker}{initialized-fields-checker}\n+\n+The Initialized Fields Checker warns if a constructor does not initialize a\n+field.\n+If you run it together with other checkers (by supplying multiple checkers\n+to the \\<-processor> command-line option), then it issues warnings only if\n+the default value assigned by Java (0, true, or null) is not consistent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE2NjY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1Nzo1MVrOHwtY9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1Nzo1MVrOHwtY9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzM2Ng==", "bodyText": "The default value for booleans is false, not true", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520837366", "createdAt": "2020-11-10T19:57:51Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,240 @@\n+package org.checkerframework.common.initializedfields;\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Options;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.common.initializedfields.qual.EnsuresInitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsBottom;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsPredicate;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.framework.util.Contract;\n+import org.checkerframework.framework.util.ContractsUtils;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Initialized Fields Checker. */\n+public class InitializedFieldsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The type factories that determine whether the default value is consistent with the annotated\n+     * type. If empty, warn about all uninitialized fields.\n+     */\n+    List<GenericAnnotatedTypeFactory<?, ?, ?, ?>> defaultValueAtypeFactories;\n+\n+    /**\n+     * Creates a new InitializedFieldsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public InitializedFieldsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                InitializedFields.class,\n+                InitializedFieldsBottom.class,\n+                InitializedFieldsPredicate.class);\n+\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        String checkerNames = Options.instance(context).get(\"-processor\");\n+        defaultValueAtypeFactories = new ArrayList<>();\n+        for (String checkerName : checkerNames.split(\",\")) {\n+            if (checkerName.equals(InitializedFieldsChecker.class.getCanonicalName())) {\n+                continue;\n+            }\n+            @SuppressWarnings(\"signature:argument.type.incompatible\") // -processor is a binary name\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = getTypeFactory(checkerName);\n+            if (atf == null) {\n+                throw new UserError(\n+                        \"Cannot find %s; check the classpath or processorpath\", checkerName);\n+            }\n+            defaultValueAtypeFactories.add(atf);\n+        }\n+\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Returns the type factory for the given checker.\n+     *\n+     * @param checkerName the fully-qualified class name of a checker\n+     * @return the type factory for the given checker\n+     */\n+    GenericAnnotatedTypeFactory<?, ?, ?, ?> getTypeFactory(@BinaryName String checkerName) {\n+        try {\n+            Class<?> checkerClass = Class.forName(checkerName);\n+            @SuppressWarnings(\"unchecked\")\n+            BaseTypeChecker c =\n+                    ((Class<? extends BaseTypeChecker>) checkerClass)\n+                            .getDeclaredConstructor()\n+                            .newInstance();\n+            c.init(processingEnv);\n+            c.initChecker();\n+            BaseTypeVisitor<?> v = c.createSourceVisitorPublic();\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = v.createTypeFactoryPublic();\n+            return atf;\n+        } catch (ClassNotFoundException\n+                | InstantiationException\n+                | InvocationTargetException\n+                | IllegalAccessException\n+                | NoSuchMethodException e) {\n+            throw new UserError(\"Problem instantiating \" + checkerName, e);\n+        }\n+    }\n+\n+    @Override\n+    public InitializedFieldsContractsUtils getContractsUtils() {\n+        return new InitializedFieldsContractsUtils(this);\n+    }\n+\n+    /**\n+     * A subclass of ContractsUtils that adds a postcondition contract to each constructor,\n+     * requiring that it initializes all fields.\n+     */\n+    private class InitializedFieldsContractsUtils extends ContractsUtils {\n+        /**\n+         * Creates an InitializedFieldsContractsUtils for the given factory.\n+         *\n+         * @param factory the type factory associated with the newly-created ContractsUtils\n+         */\n+        public InitializedFieldsContractsUtils(GenericAnnotatedTypeFactory<?, ?, ?, ?> factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Set<Contract.Postcondition> getPostconditions(ExecutableElement executableElement) {\n+            Set<Contract.Postcondition> result = super.getPostconditions(executableElement);\n+\n+            // Only process methods defined in source code being type-checked.\n+            if (declarationFromElement(executableElement) != null) {\n+\n+                if (executableElement.getSimpleName().contentEquals(\"<init>\")) {\n+                    // It's a constructor\n+\n+                    String[] fieldsToInitialize =\n+                            fieldsToInitialize(\n+                                    (TypeElement) executableElement.getEnclosingElement());\n+                    if (fieldsToInitialize.length != 0) {\n+\n+                        AnnotationMirror initializedFieldsAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            InitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", fieldsToInitialize);\n+                            initializedFieldsAnno = builder.build();\n+                        }\n+                        AnnotationMirror ensuresAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            EnsuresInitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", new String[] {\"this\"});\n+                            builder.setValue(\"fields\", fieldsToInitialize);\n+                            ensuresAnno = builder.build();\n+                        }\n+                        Contract.Postcondition ensuresContract =\n+                                new Contract.Postcondition(\n+                                        \"this\", initializedFieldsAnno, ensuresAnno);\n+\n+                        result.add(ensuresContract);\n+                    }\n+                }\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fields that the constructor must initialize. These are the fields F declared in\n+     * this class that satisfy all of the following conditions:\n+     *\n+     * <ul>\n+     *   <li>F is a non-final field (if final, Java will issue a warning, so we don't need to).\n+     *   <li>F's declaration has no initializer.\n+     *   <li>No initialization block or static initialization block sets the field. (This seems to\n+     *       be handled automagically. There is no code for it in this method, but the tests pass.)\n+     *   <li>F's annotated type is not consistent with the default value (0, 0.0, false, or null)\n+     * </ul>\n+     *\n+     * @param type the type whose fields to list\n+     * @return the fields whose type is not consistent with the default value, so the constructor\n+     *     must initialize them\n+     */\n+    // It is a bit wasteful that this is recomputed for each constructor.\n+    private String[] fieldsToInitialize(TypeElement type) {\n+        List<String> result = new ArrayList<String>();\n+\n+        for (Element member : type.getEnclosedElements()) {\n+\n+            if (member.getKind() != ElementKind.FIELD) {\n+                continue;\n+            }\n+\n+            VariableElement field = (VariableElement) member;\n+            if (ElementUtils.isFinal(field)) {\n+                continue;\n+            }\n+\n+            VariableTree fieldTree = (VariableTree) declarationFromElement(field);\n+            if (fieldTree.getInitializer() != null) {\n+                continue;\n+            }\n+\n+            if (!defaultValueIsOK(field)) {\n+                result.add(field.getSimpleName().toString());\n+            }\n+        }\n+\n+        return result.toArray(new String[result.size()]);\n+    }\n+\n+    /**\n+     * Returns true if the default field value (0, true, or null) is consistent with the field's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE2OTYyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/EnsuresInitializedFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1ODo0N1rOHwta1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1ODo0N1rOHwta1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzg0NA==", "bodyText": "Why can't you add this default? It would just be adding default {\"this} to the end of this line, right?", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520837844", "createdAt": "2020-11-10T19:58:47Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/EnsuresInitializedFields.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.checkerframework.common.initializedfields.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PostconditionAnnotation;\n+import org.checkerframework.framework.qual.QualifierArgument;\n+\n+/**\n+ * A method postcondition annotation indicates which fields the method definitely initializes.\n+ *\n+ * @checker_framework.manual #initialized-fields-checker Initialized Fields Checker\n+ */\n+@PostconditionAnnotation(qualifier = InitializedFields.class)\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.METHOD})\n+public @interface EnsuresInitializedFields {\n+    /**\n+     * The object(s) whose fields this method initializes.\n+     *\n+     * @return object(s) whose fields are initialized\n+     */\n+    public String[] value(); // TODO: default \"this\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE3NzAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/InitializedFieldsPredicate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMDo0MFrOHwtfOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMTowOVrOHwtgaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODk3MA==", "bodyText": "Why do you need InitializedFieldsPredicate? I can't think of a situation where it would be useful.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520838970", "createdAt": "2020-11-10T20:00:40Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/InitializedFieldsPredicate.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.checkerframework.common.initializedfields.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+\n+/**\n+ * A predicate annotation for the Initialized Fields type system.\n+ *\n+ * @checker_framework.manual #initialized-fields-checker Initialized Fields Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@SubtypeOf({InitializedFields.class})\n+public @interface InitializedFieldsPredicate {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTI3Mg==", "bodyText": "(There is a constructor in AccumulationAnnotatedTypeFactory that doesn't require a predicate annotation.)", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520839272", "createdAt": "2020-11-10T20:01:09Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/InitializedFieldsPredicate.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.checkerframework.common.initializedfields.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+\n+/**\n+ * A predicate annotation for the Initialized Fields type system.\n+ *\n+ * @checker_framework.manual #initialized-fields-checker Initialized Fields Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@SubtypeOf({InitializedFields.class})\n+public @interface InitializedFieldsPredicate {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODk3MA=="}, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE4MDU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/qual/PostconditionAnnotation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMTozNlrOHwthVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo0MjoxNlrOHwu2CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTUxMA==", "bodyText": "Extraneous whitespace changes?", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520839510", "createdAt": "2020-11-10T20:01:36Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/framework/qual/PostconditionAnnotation.java", "diffHunk": "@@ -33,10 +33,10 @@\n  * <pre><code>\n  * {@literal @}PostconditionAnnotation(qualifier = MinLen.class)\n  * {@literal @}Target({ElementType.METHOD, ElementType.CONSTRUCTOR})\n- * public {@literal @}interface EnsuresMinLen {\n- *   String[] value();\n- *   {@literal @}QualifierArgument(\"value\")\n- *   int targetValue() default 0;\n+ *  public {@literal @}interface EnsuresMinLen {\n+ *    String[] value();\n+ *    {@literal @}QualifierArgument(\"value\")\n+ *    int targetValue() default 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2MTE5Mg==", "bodyText": "The whitespace was wrong before; this makes it line up in the generated HTML.  I could move it into a different pull request if you prefer.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520861192", "createdAt": "2020-11-10T20:42:16Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/qual/PostconditionAnnotation.java", "diffHunk": "@@ -33,10 +33,10 @@\n  * <pre><code>\n  * {@literal @}PostconditionAnnotation(qualifier = MinLen.class)\n  * {@literal @}Target({ElementType.METHOD, ElementType.CONSTRUCTOR})\n- * public {@literal @}interface EnsuresMinLen {\n- *   String[] value();\n- *   {@literal @}QualifierArgument(\"value\")\n- *   int targetValue() default 0;\n+ *  public {@literal @}interface EnsuresMinLen {\n+ *    String[] value();\n+ *    {@literal @}QualifierArgument(\"value\")\n+ *    int targetValue() default 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzOTUxMA=="}, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTE4NTEzOnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/GenericExtendsTypeVars.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMjo1N1rOHwtkLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowMjo1N1rOHwtkLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MDIzNw==", "bodyText": "Does this new constructor remove the need for the suppress warnings above?", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r520840237", "createdAt": "2020-11-10T20:02:57Z", "author": {"login": "kelloggm"}, "path": "framework/tests/all-systems/GenericExtendsTypeVars.java", "diffHunk": "@@ -20,11 +20,20 @@ void context() {\n class Test<KK extends FF, FF extends MMyMap<KK, KK>> {\n     KK kk;\n     FF ff;\n+\n+    Test(KK kk, FF ff) {\n+        this.kk = kk;\n+        this.ff = ff;\n+    }\n }\n \n @SuppressWarnings(\"initialization.fields.uninitialized\")\n class RecursiveTypevarClass<T extends RecursiveTypevarClass<T>> {\n     T t;\n+\n+    RecursiveTypevarClass(T t) {\n+        this.t = t;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe3a5d3271a354cb2448b54737f48b8eeef2bb75"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDY2NDAxOnYy", "diffSide": "RIGHT", "path": "docs/manual/initialized-fields-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozNzo1NFrOHyIfBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozNzo1NFrOHyIfBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTg2MQ==", "bodyText": "What's the subtyping relationship between @InitializedFields annotations?", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522329861", "createdAt": "2020-11-12T18:37:54Z", "author": {"login": "smillst"}, "path": "docs/manual/initialized-fields-checker.tex", "diffHunk": "@@ -0,0 +1,174 @@\n+\\htmlhr\n+\\chapterAndLabel{Initialized Fields Checker}{initialized-fields-checker}\n+\n+The Initialized Fields Checker warns if a constructor does not initialize a\n+field.\n+If you run it together with other checkers (by supplying multiple checkers\n+to the \\<-processor> command-line option), then it issues warnings only if\n+the default value assigned by Java (0, false, or null) is not consistent\n+with the field's annotation, for the other checkers.\n+% It's actually the checkers and their subcheckers if any.  Saying that\n+% would be confusing to most users, who don't know what a \"subchecker\" is.\n+% The term \"subchecker\" appears only in the \"creating a checker\" section of\n+% the manual.\n+\n+An example invocation is\n+\n+\\begin{Verbatim}\n+javac -processor ValueChecker,InitializedFieldsChecker MyFile.java\n+\\end{Verbatim}\n+\n+\n+\\sectionAndLabel{Motivation:  uninitialized fields}{initialized-fields-motivation}\n+\n+Without the Initialized Fields Checker, every type system is\n+unsound with respect to fields that are never set.  (Exception:  The\n+Nullness Checker (\\chapterpageref{nullness-checker}) is sound. Also, a type\n+system is sound if every annotation is consistent with 0, false, and null.)\n+Consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+  @Positive int x;\n+  MyClass() {\n+    // empty body\n+  }\n+\n+  @Positive int getX() {\n+    return x;\n+  }\n+}\n+\\end{Verbatim}\n+\n+\\noindent\n+Method \\<getX> is incorrect because it returns 0, which is not positive.\n+However, the code type-checks because there is never an assignment to \\<x>\n+whose right-hand side is not positive.\n+If you run the Index Checker together with the Initialized Fields Checker,\n+then the code correctly does not type-check.\n+\n+\n+\\subsubsectionAndLabel{Remaining unsoundness}{initialized-fields-remaining-unsoundness}\n+\n+Even with the Initialized Fields Checker, every type system (except the\n+Nullness Checker, \\chapterpageref{nullness-checker}) is unsound with\n+respect to partially-initialized fields.  Consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+  @Positive int x;\n+  MyClass() {\n+    foo(this);\n+    x = 1;\n+  }\n+\n+  @Positive int foo() {\n+    // ... use x, expecting it to be positive ...\n+  }\n+}\n+\\end{Verbatim}\n+\n+\\noindent\n+Within method \\<foo>, \\<x> can have the value 0 even though the type of\n+\\<x> is \\<@Positive int>.\n+\n+\n+\\sectionAndLabel{Example}{initialized-fields-example}\n+\n+As an example, consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+\n+  @Positive int x;\n+  @Positive int y;\n+  int z;\n+\n+  // Warning: field y is not initialized\n+  MyClass() {\n+    x = 1;\n+  }\n+}\n+\\end{Verbatim}\n+\n+When run by itself, the Initialized Fields Checker warns that fields \\<y>\n+and field \\<z> are not set.\n+\n+When run together with the Index Checker, the Initialized Fields Checker\n+warns that field \\<y> is not set.  It does not warn about field \\<z>,\n+because its default value (0) is consistent with its annotations.\n+\n+\n+\\sectionAndLabel{Annotations}{initialized-fields-annotations}\n+\n+The Initialized Fields type system uses the following type annotations:\n+\\begin{description}\n+\\item[\\refqualclass{checker/initializedfields/qual}{InitializedFields}]\n+  indicates which fields have definitely been initialized so far.\n+\\item[\\refqualclass{checker/initializedfields/qual}{InitializedFieldsBottom}]\n+  is the type of \\<null>.  Programmers rarely write this type.\n+\\item[\\refqualclass{checker/initializedfields/qual}{PolyInitializedFields}]\n+  is a qualifier that is polymorphic over field initialization (see\n+  Section~\\ref{method-qualifier-polymorphism}).\n+\\end{description}\n+\n+% TODO: draw a diagram of the type hierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDY4MDQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo0MTo1NVrOHyIo4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo0MTo1NVrOHyIo4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMjM4Nw==", "bodyText": "The processor list can contain classes that are not BaseTypeCheckers.  Those class should be ignored rather than cause an exception.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522332387", "createdAt": "2020-11-12T18:41:55Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.checkerframework.common.initializedfields;\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Options;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.common.initializedfields.qual.EnsuresInitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsBottom;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.framework.util.Contract;\n+import org.checkerframework.framework.util.ContractsUtils;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Initialized Fields Checker. */\n+public class InitializedFieldsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The type factories that determine whether the default value is consistent with the annotated\n+     * type. If empty, warn about all uninitialized fields.\n+     */\n+    List<GenericAnnotatedTypeFactory<?, ?, ?, ?>> defaultValueAtypeFactories;\n+\n+    /**\n+     * Creates a new InitializedFieldsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public InitializedFieldsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker, InitializedFields.class, InitializedFieldsBottom.class);\n+\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        String checkerNames = Options.instance(context).get(\"-processor\");\n+        defaultValueAtypeFactories = new ArrayList<>();\n+        for (String checkerName : checkerNames.split(\",\")) {\n+            if (checkerName.equals(InitializedFieldsChecker.class.getCanonicalName())) {\n+                continue;\n+            }\n+            @SuppressWarnings(\"signature:argument.type.incompatible\") // -processor is a binary name\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = getTypeFactory(checkerName);\n+            if (atf == null) {\n+                throw new UserError(\n+                        \"Cannot find %s; check the classpath or processorpath\", checkerName);\n+            }\n+            defaultValueAtypeFactories.add(atf);\n+        }\n+\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Returns the type factory for the given checker.\n+     *\n+     * @param checkerName the fully-qualified class name of a checker\n+     * @return the type factory for the given checker\n+     */\n+    GenericAnnotatedTypeFactory<?, ?, ?, ?> getTypeFactory(@BinaryName String checkerName) {\n+        try {\n+            Class<?> checkerClass = Class.forName(checkerName);\n+            @SuppressWarnings(\"unchecked\")\n+            BaseTypeChecker c =\n+                    ((Class<? extends BaseTypeChecker>) checkerClass)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDcxMjYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo1MDozMFrOHyI9Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo1MDozMFrOHyI9Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNzU4Nw==", "bodyText": "If you just want to check primary annotations, then you can call QualifierHierarchy#isSubtype.   But the fieldType might be a type variable in which case, the field type might not have a primary annotation.  So, what you have written is correct.  (I would delete this comment.)", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522337587", "createdAt": "2020-11-12T18:50:30Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.checkerframework.common.initializedfields;\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Options;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.common.initializedfields.qual.EnsuresInitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsBottom;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.framework.util.Contract;\n+import org.checkerframework.framework.util.ContractsUtils;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Initialized Fields Checker. */\n+public class InitializedFieldsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The type factories that determine whether the default value is consistent with the annotated\n+     * type. If empty, warn about all uninitialized fields.\n+     */\n+    List<GenericAnnotatedTypeFactory<?, ?, ?, ?>> defaultValueAtypeFactories;\n+\n+    /**\n+     * Creates a new InitializedFieldsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public InitializedFieldsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker, InitializedFields.class, InitializedFieldsBottom.class);\n+\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        String checkerNames = Options.instance(context).get(\"-processor\");\n+        defaultValueAtypeFactories = new ArrayList<>();\n+        for (String checkerName : checkerNames.split(\",\")) {\n+            if (checkerName.equals(InitializedFieldsChecker.class.getCanonicalName())) {\n+                continue;\n+            }\n+            @SuppressWarnings(\"signature:argument.type.incompatible\") // -processor is a binary name\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = getTypeFactory(checkerName);\n+            if (atf == null) {\n+                throw new UserError(\n+                        \"Cannot find %s; check the classpath or processorpath\", checkerName);\n+            }\n+            defaultValueAtypeFactories.add(atf);\n+        }\n+\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Returns the type factory for the given checker.\n+     *\n+     * @param checkerName the fully-qualified class name of a checker\n+     * @return the type factory for the given checker\n+     */\n+    GenericAnnotatedTypeFactory<?, ?, ?, ?> getTypeFactory(@BinaryName String checkerName) {\n+        try {\n+            Class<?> checkerClass = Class.forName(checkerName);\n+            @SuppressWarnings(\"unchecked\")\n+            BaseTypeChecker c =\n+                    ((Class<? extends BaseTypeChecker>) checkerClass)\n+                            .getDeclaredConstructor()\n+                            .newInstance();\n+            c.init(processingEnv);\n+            c.initChecker();\n+            BaseTypeVisitor<?> v = c.createSourceVisitorPublic();\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = v.createTypeFactoryPublic();\n+            return atf;\n+        } catch (ClassNotFoundException\n+                | InstantiationException\n+                | InvocationTargetException\n+                | IllegalAccessException\n+                | NoSuchMethodException e) {\n+            throw new UserError(\"Problem instantiating \" + checkerName, e);\n+        }\n+    }\n+\n+    @Override\n+    public InitializedFieldsContractsUtils getContractsUtils() {\n+        return new InitializedFieldsContractsUtils(this);\n+    }\n+\n+    /**\n+     * A subclass of ContractsUtils that adds a postcondition contract to each constructor,\n+     * requiring that it initializes all fields.\n+     */\n+    private class InitializedFieldsContractsUtils extends ContractsUtils {\n+        /**\n+         * Creates an InitializedFieldsContractsUtils for the given factory.\n+         *\n+         * @param factory the type factory associated with the newly-created ContractsUtils\n+         */\n+        public InitializedFieldsContractsUtils(GenericAnnotatedTypeFactory<?, ?, ?, ?> factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Set<Contract.Postcondition> getPostconditions(ExecutableElement executableElement) {\n+            Set<Contract.Postcondition> result = super.getPostconditions(executableElement);\n+\n+            // Only process methods defined in source code being type-checked.\n+            if (declarationFromElement(executableElement) != null) {\n+\n+                if (executableElement.getKind() == ElementKind.CONSTRUCTOR) {\n+                    // It's a constructor\n+\n+                    String[] fieldsToInitialize =\n+                            fieldsToInitialize(\n+                                    (TypeElement) executableElement.getEnclosingElement());\n+                    if (fieldsToInitialize.length != 0) {\n+\n+                        AnnotationMirror initializedFieldsAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            InitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", fieldsToInitialize);\n+                            initializedFieldsAnno = builder.build();\n+                        }\n+                        AnnotationMirror ensuresAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            EnsuresInitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", new String[] {\"this\"});\n+                            builder.setValue(\"fields\", fieldsToInitialize);\n+                            ensuresAnno = builder.build();\n+                        }\n+                        Contract.Postcondition ensuresContract =\n+                                new Contract.Postcondition(\n+                                        \"this\", initializedFieldsAnno, ensuresAnno);\n+\n+                        result.add(ensuresContract);\n+                    }\n+                }\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fields that the constructor must initialize. These are the fields F declared in\n+     * this class that satisfy all of the following conditions:\n+     *\n+     * <ul>\n+     *   <li>F is a non-final field (if final, Java will issue a warning, so we don't need to).\n+     *   <li>F's declaration has no initializer.\n+     *   <li>No initialization block or static initialization block sets the field. (This seems to\n+     *       be handled automagically. There is no code for it in this method, but the tests pass.)\n+     *   <li>F's annotated type is not consistent with the default value (0, 0.0, false, or null)\n+     * </ul>\n+     *\n+     * @param type the type whose fields to list\n+     * @return the fields whose type is not consistent with the default value, so the constructor\n+     *     must initialize them\n+     */\n+    // It is a bit wasteful that this is recomputed for each constructor.\n+    private String[] fieldsToInitialize(TypeElement type) {\n+        List<String> result = new ArrayList<String>();\n+\n+        for (Element member : type.getEnclosedElements()) {\n+\n+            if (member.getKind() != ElementKind.FIELD) {\n+                continue;\n+            }\n+\n+            VariableElement field = (VariableElement) member;\n+            if (ElementUtils.isFinal(field)) {\n+                continue;\n+            }\n+\n+            VariableTree fieldTree = (VariableTree) declarationFromElement(field);\n+            if (fieldTree.getInitializer() != null) {\n+                continue;\n+            }\n+\n+            if (!defaultValueIsOK(field)) {\n+                result.add(field.getSimpleName().toString());\n+            }\n+        }\n+\n+        return result.toArray(new String[result.size()]);\n+    }\n+\n+    /**\n+     * Returns true if the default field value (0, false, or null) is consistent with the field's\n+     * declared type.\n+     *\n+     * @param field a field\n+     * @return true if the default field value is consistent with the field's declared type\n+     */\n+    private boolean defaultValueIsOK(VariableElement field) {\n+        if (defaultValueAtypeFactories.isEmpty()) {\n+            return false;\n+        }\n+\n+        for (GenericAnnotatedTypeFactory<?, ?, ?, ?> defaultValueAtypeFactory :\n+                defaultValueAtypeFactories) {\n+\n+            AnnotatedTypeMirror fieldType = defaultValueAtypeFactory.getAnnotatedType(field);\n+            AnnotatedTypeMirror defaultValueType =\n+                    defaultValueAtypeFactory.getDefaultValueAnnotatedType(\n+                            fieldType.getUnderlyingType());\n+            // Could call isPrimarySubtype, but that is only defined in DefaultTypeHierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDczNjE5OnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/WildCardCrash.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo1NjozNVrOHyJLlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODo1NjozNVrOHyJLlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MTI2OQ==", "bodyText": "contracts.postcondition.not.satisfied should have the checker name prefix.  Also, no need to add value = .", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522341269", "createdAt": "2020-11-12T18:56:35Z", "author": {"login": "smillst"}, "path": "framework/tests/all-systems/WildCardCrash.java", "diffHunk": "@@ -16,7 +16,7 @@ public SomeGen(CFAbstractAnalysis123<CFValue123, ?, ?> analysis) {}\n \n class CFValue123 extends CFAbstractValue123<CFValue123> {}\n \n-@SuppressWarnings(\"initialization\")\n+@SuppressWarnings(value = {\"initialization\", \"contracts.postcondition.not.satisfied\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc1NDYxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowMTo0OFrOHyJXXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowMTo0OFrOHyJXXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NDI4NQ==", "bodyText": "I think these fields are still included in the returned array.  It's just that dataflow visits initialization block or static initialization block as part of the constructor.  So, I would delete this bullet point.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522344285", "createdAt": "2020-11-12T19:01:48Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/InitializedFieldsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.checkerframework.common.initializedfields;\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Options;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.common.initializedfields.qual.EnsuresInitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFields;\n+import org.checkerframework.common.initializedfields.qual.InitializedFieldsBottom;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.framework.util.Contract;\n+import org.checkerframework.framework.util.ContractsUtils;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Initialized Fields Checker. */\n+public class InitializedFieldsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The type factories that determine whether the default value is consistent with the annotated\n+     * type. If empty, warn about all uninitialized fields.\n+     */\n+    List<GenericAnnotatedTypeFactory<?, ?, ?, ?>> defaultValueAtypeFactories;\n+\n+    /**\n+     * Creates a new InitializedFieldsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public InitializedFieldsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker, InitializedFields.class, InitializedFieldsBottom.class);\n+\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        String checkerNames = Options.instance(context).get(\"-processor\");\n+        defaultValueAtypeFactories = new ArrayList<>();\n+        for (String checkerName : checkerNames.split(\",\")) {\n+            if (checkerName.equals(InitializedFieldsChecker.class.getCanonicalName())) {\n+                continue;\n+            }\n+            @SuppressWarnings(\"signature:argument.type.incompatible\") // -processor is a binary name\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = getTypeFactory(checkerName);\n+            if (atf == null) {\n+                throw new UserError(\n+                        \"Cannot find %s; check the classpath or processorpath\", checkerName);\n+            }\n+            defaultValueAtypeFactories.add(atf);\n+        }\n+\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Returns the type factory for the given checker.\n+     *\n+     * @param checkerName the fully-qualified class name of a checker\n+     * @return the type factory for the given checker\n+     */\n+    GenericAnnotatedTypeFactory<?, ?, ?, ?> getTypeFactory(@BinaryName String checkerName) {\n+        try {\n+            Class<?> checkerClass = Class.forName(checkerName);\n+            @SuppressWarnings(\"unchecked\")\n+            BaseTypeChecker c =\n+                    ((Class<? extends BaseTypeChecker>) checkerClass)\n+                            .getDeclaredConstructor()\n+                            .newInstance();\n+            c.init(processingEnv);\n+            c.initChecker();\n+            BaseTypeVisitor<?> v = c.createSourceVisitorPublic();\n+            GenericAnnotatedTypeFactory<?, ?, ?, ?> atf = v.createTypeFactoryPublic();\n+            return atf;\n+        } catch (ClassNotFoundException\n+                | InstantiationException\n+                | InvocationTargetException\n+                | IllegalAccessException\n+                | NoSuchMethodException e) {\n+            throw new UserError(\"Problem instantiating \" + checkerName, e);\n+        }\n+    }\n+\n+    @Override\n+    public InitializedFieldsContractsUtils getContractsUtils() {\n+        return new InitializedFieldsContractsUtils(this);\n+    }\n+\n+    /**\n+     * A subclass of ContractsUtils that adds a postcondition contract to each constructor,\n+     * requiring that it initializes all fields.\n+     */\n+    private class InitializedFieldsContractsUtils extends ContractsUtils {\n+        /**\n+         * Creates an InitializedFieldsContractsUtils for the given factory.\n+         *\n+         * @param factory the type factory associated with the newly-created ContractsUtils\n+         */\n+        public InitializedFieldsContractsUtils(GenericAnnotatedTypeFactory<?, ?, ?, ?> factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Set<Contract.Postcondition> getPostconditions(ExecutableElement executableElement) {\n+            Set<Contract.Postcondition> result = super.getPostconditions(executableElement);\n+\n+            // Only process methods defined in source code being type-checked.\n+            if (declarationFromElement(executableElement) != null) {\n+\n+                if (executableElement.getKind() == ElementKind.CONSTRUCTOR) {\n+                    // It's a constructor\n+\n+                    String[] fieldsToInitialize =\n+                            fieldsToInitialize(\n+                                    (TypeElement) executableElement.getEnclosingElement());\n+                    if (fieldsToInitialize.length != 0) {\n+\n+                        AnnotationMirror initializedFieldsAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            InitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", fieldsToInitialize);\n+                            initializedFieldsAnno = builder.build();\n+                        }\n+                        AnnotationMirror ensuresAnno;\n+                        {\n+                            AnnotationBuilder builder =\n+                                    new AnnotationBuilder(\n+                                            processingEnv,\n+                                            EnsuresInitializedFields.class.getCanonicalName());\n+                            builder.setValue(\"value\", new String[] {\"this\"});\n+                            builder.setValue(\"fields\", fieldsToInitialize);\n+                            ensuresAnno = builder.build();\n+                        }\n+                        Contract.Postcondition ensuresContract =\n+                                new Contract.Postcondition(\n+                                        \"this\", initializedFieldsAnno, ensuresAnno);\n+\n+                        result.add(ensuresContract);\n+                    }\n+                }\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Returns the fields that the constructor must initialize. These are the fields F declared in\n+     * this class that satisfy all of the following conditions:\n+     *\n+     * <ul>\n+     *   <li>F is a non-final field (if final, Java will issue a warning, so we don't need to).\n+     *   <li>F's declaration has no initializer.\n+     *   <li>No initialization block or static initialization block sets the field. (This seems to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc3OTkxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/EnsuresInitializedFields.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNzozOVrOHyJm3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTowNzozOVrOHyJm3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0ODI1NQ==", "bodyText": "What does @EnsuresInitializedFields(value = {\"this\", \"a\"}, fields = { \"c\", \"d\"}) mean?  I think that value should just be a string.  Then @EnsuresInitializedFields should be repeatable.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522348255", "createdAt": "2020-11-12T19:07:39Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/initializedfields/qual/EnsuresInitializedFields.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.checkerframework.common.initializedfields.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PostconditionAnnotation;\n+import org.checkerframework.framework.qual.QualifierArgument;\n+\n+/**\n+ * A method postcondition annotation indicates which fields the method definitely initializes.\n+ *\n+ * @checker_framework.manual #initialized-fields-checker Initialized Fields Checker\n+ */\n+@PostconditionAnnotation(qualifier = InitializedFields.class)\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.METHOD})\n+public @interface EnsuresInitializedFields {\n+    /**\n+     * The object(s) whose fields this method initializes.\n+     *\n+     * @return object(s) whose fields are initialized\n+     */\n+    public String[] value() default {\"this\"};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDc5MDEyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToxMDowM1rOHyJs3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1MzozMVrOHy5Ctg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0OTc5MA==", "bodyText": "This seems wrong to me.  I'm assuming there's a problem because of the LiteralTrees created by the Initialized Fields Checker.  I'll see if I can find a better work around.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522349790", "createdAt": "2020-11-12T19:10:03Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1633,7 +1634,7 @@ protected final void addComputedTypeAnnotations(Tree tree, AnnotatedTypeMirror t\n      */\n     protected void addComputedTypeAnnotations(\n             Tree tree, AnnotatedTypeMirror type, boolean iUseFlow) {\n-        assert root != null\n+        assert root != null || tree instanceof LiteralTree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyNzIwNg==", "bodyText": "@smillst That is correct.  The synthetic LiteralTrees lack some information, such as a path in source code.  There are a few hard-coded checks for LiteralTree in this pull request.  Fixing that would be nice.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r522427206", "createdAt": "2020-11-12T21:08:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1633,7 +1634,7 @@ protected final void addComputedTypeAnnotations(Tree tree, AnnotatedTypeMirror t\n      */\n     protected void addComputedTypeAnnotations(\n             Tree tree, AnnotatedTypeMirror type, boolean iUseFlow) {\n-        assert root != null\n+        assert root != null || tree instanceof LiteralTree", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0OTc5MA=="}, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyNTQzMA==", "bodyText": "I was able to remove these.  See my last commit.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r523125430", "createdAt": "2020-11-13T17:53:31Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1633,7 +1634,7 @@ protected final void addComputedTypeAnnotations(Tree tree, AnnotatedTypeMirror t\n      */\n     protected void addComputedTypeAnnotations(\n             Tree tree, AnnotatedTypeMirror type, boolean iUseFlow) {\n-        assert root != null\n+        assert root != null || tree instanceof LiteralTree", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0OTc5MA=="}, "originalCommit": {"oid": "35159e5aba2f9f6b4ea50988541d2d199e2bc8b6"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTQ2ODE2OnYy", "diffSide": "RIGHT", "path": "docs/manual/initialized-fields-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMjozM1rOHy3XZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoxMjozM1rOHy3XZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5Nzk1Ng==", "bodyText": "I think this is done, so this line can be removed.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r523097956", "createdAt": "2020-11-13T17:12:33Z", "author": {"login": "kelloggm"}, "path": "docs/manual/initialized-fields-checker.tex", "diffHunk": "@@ -0,0 +1,183 @@\n+\\htmlhr\n+\\chapterAndLabel{Initialized Fields Checker}{initialized-fields-checker}\n+\n+The Initialized Fields Checker warns if a constructor does not initialize a\n+field.\n+If you run it together with other checkers (by supplying multiple checkers\n+to the \\<-processor> command-line option), then it issues warnings only if\n+the default value assigned by Java (0, false, or null) is not consistent\n+with the field's annotation, for the other checkers.\n+% It's actually the checkers and their subcheckers if any.  Saying that\n+% would be confusing to most users, who don't know what a \"subchecker\" is.\n+% The term \"subchecker\" appears only in the \"creating a checker\" section of\n+% the manual.\n+\n+An example invocation is\n+\n+\\begin{Verbatim}\n+javac -processor ValueChecker,InitializedFieldsChecker MyFile.java\n+\\end{Verbatim}\n+\n+\n+\\sectionAndLabel{Motivation:  uninitialized fields}{initialized-fields-motivation}\n+\n+Without the Initialized Fields Checker, every type system is\n+unsound with respect to fields that are never set.  (Exception:  The\n+Nullness Checker (\\chapterpageref{nullness-checker}) is sound. Also, a type\n+system is sound if every annotation is consistent with 0, false, and null.)\n+Consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+  @Positive int x;\n+  MyClass() {\n+    // empty body\n+  }\n+\n+  @Positive int getX() {\n+    return x;\n+  }\n+}\n+\\end{Verbatim}\n+\n+\\noindent\n+Method \\<getX> is incorrect because it returns 0, which is not positive.\n+However, the code type-checks because there is never an assignment to \\<x>\n+whose right-hand side is not positive.\n+If you run the Index Checker together with the Initialized Fields Checker,\n+then the code correctly does not type-check.\n+\n+\n+\\subsubsectionAndLabel{Remaining unsoundness}{initialized-fields-remaining-unsoundness}\n+\n+Even with the Initialized Fields Checker, every type system (except the\n+Nullness Checker, \\chapterpageref{nullness-checker}) is unsound with\n+respect to partially-initialized fields.  Consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+  @Positive int x;\n+  MyClass() {\n+    foo(this);\n+    x = 1;\n+  }\n+\n+  @Positive int foo() {\n+    // ... use x, expecting it to be positive ...\n+  }\n+}\n+\\end{Verbatim}\n+\n+\\noindent\n+Within method \\<foo>, \\<x> can have the value 0 even though the type of\n+\\<x> is \\<@Positive int>.\n+\n+\n+\\sectionAndLabel{Example}{initialized-fields-example}\n+\n+As an example, consider the following code:\n+\n+\\begin{Verbatim}\n+import org.checkerframework.checker.index.qual.Positive;\n+\n+class MyClass {\n+\n+  @Positive int x;\n+  @Positive int y;\n+  int z;\n+\n+  // Warning: field y is not initialized\n+  MyClass() {\n+    x = 1;\n+  }\n+}\n+\\end{Verbatim}\n+\n+When run by itself, the Initialized Fields Checker warns that fields \\<y>\n+and field \\<z> are not set.\n+\n+When run together with the Index Checker, the Initialized Fields Checker\n+warns that field \\<y> is not set.  It does not warn about field \\<z>,\n+because its default value (0) is consistent with its annotations.\n+\n+\n+\\sectionAndLabel{Annotations}{initialized-fields-annotations}\n+\n+The Initialized Fields type system uses the following type annotations:\n+\\begin{description}\n+\\item[\\refqualclass{checker/initializedfields/qual}{InitializedFields}]\n+  indicates which fields have definitely been initialized so far.\n+\\item[\\refqualclass{checker/initializedfields/qual}{InitializedFieldsBottom}]\n+  is the type of \\<null>.  Programmers rarely write this type.\n+\\item[\\refqualclass{checker/initializedfields/qual}{PolyInitializedFields}]\n+  is a qualifier that is polymorphic over field initialization (see\n+  Section~\\ref{method-qualifier-polymorphism}).\n+\\end{description}\n+\n+\\begin{figure}\n+\\includeimage{initializedfields}{4.5cm}\n+\\caption{The type qualifier hierarchy of the Initialized Fields Checker.\n+\\<@InitializedFieldsBottom> is rarely written by a programmer.}\n+\\label{fig-initialized-fields-hierarchy}\n+\\end{figure}\n+\n+Figure~\\ref{fig-initialized-fields-hierarchy} shows the the subtyping\n+relationships among the type qualifiers.\n+\n+% TODO: draw a diagram of the type hierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb5b8f5ce9543c3970cfb7f818592ed4ab66e713"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3OTY1NTIyOnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/AnnotationUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1Njo1MFrOHy5Juw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzo1Njo1MFrOHy5Juw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyNzIyNw==", "bodyText": "The Collections.singletonList returns an immutable list, so clients can't side-effect it.", "url": "https://github.com/typetools/checker-framework/pull/3887#discussion_r523127227", "createdAt": "2020-11-13T17:56:50Z", "author": {"login": "smillst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/AnnotationUtils.java", "diffHunk": "@@ -809,6 +811,43 @@ public NoSuchElementException(String message) {\n         return result;\n     }\n \n+    /**\n+     * Get the element with the name {@code elementName} of the annotation {@code anno}. The element\n+     * has type {@code expectedType} or array of {@code expectedType}.\n+     *\n+     * <p>Parameter useDefaults is used to determine whether default values should be used for\n+     * annotation values. Finding defaults requires more computation, so should be false when no\n+     * defaulting is needed.\n+     *\n+     * @param anno the annotation to disassemble\n+     * @param elementName the name of the element to access\n+     * @param expectedType the expected type used to cast the return type\n+     * @param <T> the class of the expected type\n+     * @param useDefaults whether to apply default values to the element\n+     * @return the value of the element with the given name; it is a new list, so it is safe for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d01f2e2bbaafe1934da1a30c9769cff7030a11a1"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 917, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}