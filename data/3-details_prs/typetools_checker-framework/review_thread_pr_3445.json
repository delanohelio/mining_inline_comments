{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NzEzNDUx", "number": 3445, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDoyNzoxNFrOEPqomA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1Nzo0OFrOETXUxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODYyNjE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDoyNzoxNFrOGzgPeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMDo0MToxMVrOG29Itw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODgwOA==", "bodyText": "Should these be {@link QualifierHierarchy}?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456658808", "createdAt": "2020-07-17T20:27:14Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.\n-     *   <li>There should not be more annotations than the width of the qualifier hierarchy.\n+     *   <li>There should not be more annotations than the width of the QualifierHierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3Nzk0Mw==", "bodyText": "I don't think it needs to be linked every place it is referring to the QualifierHierarchy.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277943", "createdAt": "2020-07-24T20:41:11Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.\n-     *   <li>There should not be more annotations than the width of the qualifier hierarchy.\n+     *   <li>There should not be more annotations than the width of the QualifierHierarchy.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODgwOA=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODYyNzA1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDoyNzozNFrOGzgP-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDo1MTo1OFrOG48StA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw==", "bodyText": "Should the hierarchy here also be {@link QH}?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456658937", "createdAt": "2020-07-17T20:27:34Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NzYwNA==", "bodyText": "No, this is a qualifier hierarchy.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277604", "createdAt": "2020-07-24T20:40:28Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2MTI2OA==", "bodyText": "Then why not change the ambiguous \"hierarchy\" to \"qualifier hierarchy\"? That would make the bullet points more consistent with each other and highlight the distinction between the two concepts.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462361268", "createdAt": "2020-07-29T14:51:58Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -111,9 +111,9 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      *\n      * <ol>\n      *   <li>There should not be multiple annotations from the same hierarchy.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1ODkzNw=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY2ODM0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo0NDowNVrOGzgptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMToxMDo0NVrOG0faWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NTUyNg==", "bodyText": "Do you like this distinction? Do we follow this in the documentation? I would have assumed we say \"qualifier hierarchy\" whenever we mean a \"QualifierHierarchy\", which can always be multiple tops/bottoms.\nSo maybe in #3404 we should also look into cleaning that up.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456665526", "createdAt": "2020-07-17T20:44:05Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -5,23 +5,32 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeKind;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n \n /**\n- * Represents a type qualifier hierarchy.\n+ * Represents multiple type qualifier hierarchies. {@link #getWidth} gives the number of hierarchies\n+ * that this object represents. Each hierarchy has its own top and bottom, and subtyping\n+ * relationships exist only within each hierarchy.\n  *\n- * <p>All method parameter annotations need to be type qualifiers recognized within this hierarchy.\n+ * <p>Note the distinction in terminology between a qualifier hierarchy, which has one top and one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5Mzc4Ng==", "bodyText": "We discussed this.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r457693786", "createdAt": "2020-07-20T21:10:45Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -5,23 +5,32 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeKind;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n \n /**\n- * Represents a type qualifier hierarchy.\n+ * Represents multiple type qualifier hierarchies. {@link #getWidth} gives the number of hierarchies\n+ * that this object represents. Each hierarchy has its own top and bottom, and subtyping\n+ * relationships exist only within each hierarchy.\n  *\n- * <p>All method parameter annotations need to be type qualifiers recognized within this hierarchy.\n+ * <p>Note the distinction in terminology between a qualifier hierarchy, which has one top and one", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NTUyNg=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY3NzczOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo0NzoxOFrOGzgvQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1NToyMVrOG5DsnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng==", "bodyText": "Is it worth saying what happens when qualifier isn't in any of the hierarchies?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456666946", "createdAt": "2020-07-17T20:47:18Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -38,40 +47,48 @@ public int getWidth() {\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n     public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NzI3OA==", "bodyText": "My thought was to leave it undefined.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r460277278", "createdAt": "2020-07-24T20:39:42Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -38,40 +47,48 @@ public int getWidth() {\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n     public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MjU4OQ==", "bodyText": "At some point it would probably be good to resolve all such undefined behavior, but I'm fine with ignoring it for now.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462482589", "createdAt": "2020-07-29T17:55:21Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -38,40 +47,48 @@ public int getWidth() {\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n     public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2Njk0Ng=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY4MTY1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo0OTowMFrOGzgxqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo0OTowMFrOGzgxqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2NzU2Mg==", "bodyText": "Should this be possible sub qualifier of, like in the @return?\nSomewhere later, I see subqualifier. So maybe these sub/super qualifiers should be made consistent.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456667562", "createdAt": "2020-07-17T20:49:00Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY4OTY4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1MjowN1rOGzg2Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1MjowN1rOGzg2Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2ODc1OQ==", "bodyText": "the null -> that null?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456668759", "createdAt": "2020-07-17T20:52:07Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}\n+     * @param superQualifier possible superQualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a sub qualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    public abstract boolean isSubtype(\n+            AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n     public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact the null is returned if the qualifiers are not in the same hierarchy is used by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY5MDUzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1MjoyOVrOGzg22A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1MjoyOVrOGzg22A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2ODg4OA==", "bodyText": "of two the two?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456668888", "createdAt": "2020-07-17T20:52:29Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -88,45 +105,88 @@ public int getWidth() {\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subQualifier of {@code superQualifier}\n+     * @param superQualifier possible superQualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a sub qualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    public abstract boolean isSubtype(\n+            AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n     public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact the null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror leastUpperBound(\n+            AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY5NjE1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1NDo0NlrOGzg6YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1NDo0NlrOGzg6YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY2OTc5Mw==", "bodyText": "and -> as?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456669793", "createdAt": "2020-07-17T20:54:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODY5Nzk0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1NToxNlrOGzg7bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1NToxNlrOGzg7bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MDA2MA==", "bodyText": "and -> as?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456670060", "createdAt": "2020-07-17T20:55:16Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcwMjA1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1Njo1N1rOGzg9-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1Njo1N1rOGzg9-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MDcxMw==", "bodyText": "leastUpperBound earlier renamed the parameters to qualifier1 and qualifier2. Same would be good here?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456670713", "createdAt": "2020-07-17T20:56:57Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcwNTE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1ODowNFrOGzg_5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1ODowNFrOGzg_5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTIwNg==", "bodyText": "set -> collection. Maybe also add @see between the different versions that belong together, here and earlier?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671206", "createdAt": "2020-07-17T20:58:04Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcwNjE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1ODoyNVrOGzhAjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1ODoyNVrOGzhAjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTM3Mw==", "bodyText": "two the two sets", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671373", "createdAt": "2020-07-17T20:58:25Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcwNzQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1OTowMlrOGzhBVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1OTowMlrOGzhBVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTU3NQ==", "bodyText": "set -> collection? Or should the parameter types be changed?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671575", "createdAt": "2020-07-17T20:59:02Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 312}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcwODU3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1OToyOVrOGzhCCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDo1OToyOVrOGzhCCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MTc1Mg==", "bodyText": "two the two Maybe I missed other occurrences of this...", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456671752", "createdAt": "2020-07-17T20:59:29Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcxMzMwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTowMToxMlrOGzhE2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTowMToxMlrOGzhE2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjQ3NA==", "bodyText": "Should it be fully annotated?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456672474", "createdAt": "2020-07-17T21:01:12Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcxNzU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTowMzowNFrOGzhHiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTowMzowNFrOGzhHiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzE2MA==", "bodyText": "Is it really whether it can be an empty set? Shouldn't it be whether fewer than the qualifier hierarchy width qualifiers appear on the type?\nFor example in nullness, a <T> @Nullable T foo()... is valid, even though the qualifier hierarchy has width 2.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456673160", "createdAt": "2020-07-17T21:03:04Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODcyMzcxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMTowNTozM1rOGzhLdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo0ODoxOVrOG5Dcaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw==", "bodyText": "Would using @KeyFor(#1) T key as parameter type work instead?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456674167", "createdAt": "2020-07-17T21:05:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     *     set\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 472}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUyMjUzMA==", "bodyText": "No, key does not be a key in map.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r457522530", "createdAt": "2020-07-20T16:01:47Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     *     set\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 472}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3ODQ0Mw==", "bodyText": "Could you update the description of the key parameter then? The the key to update description would be clearer as the key to update or add.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462478443", "createdAt": "2020-07-29T17:48:19Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -138,298 +198,248 @@ public int numberOfIterationsBeforeWidening() {\n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy and {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy and {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n     public AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers a1 and a2. Returns null if the qualifiers\n+     * are not from the same qualifier hierarchy.\n      *\n      * @param a1 first annotation\n      * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // set version of LUB below.\n+    public abstract @Nullable AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, AnnotationMirror a2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of two the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of two the two sets of qualifiers\n      */\n     public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     * set even if the type has been fully-annotated.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return an empty\n+     *     set\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    public <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NDE2Nw=="}, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 472}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODczNjcxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/AtmLubVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToxMDo1OVrOGzhTWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMToxMDo1OVrOGzhTWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NjE4Ng==", "bodyText": "Is this equivalent and a bit clearer:\nif (anno1 != null && anno2 != null) {\n    AnnotationMirror glb = qualifierHierarchy.greatestLowerBound(anno1, anno2);\n    lubLowerBound.replaceAnnotation(glb);\n}\nAs anno1 and anno2 are from the same hierarchy, their glb must exist. The two ifs are confusing the logic for me.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r456676186", "createdAt": "2020-07-17T21:10:59Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AtmLubVisitor.java", "diffHunk": "@@ -245,12 +245,14 @@ private void lubWildcard(\n         visit(type1LowerBound, type2LowerBound, lubLowerBound);\n \n         for (AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\n-            AnnotationMirror glb =\n-                    qualifierHierarchy.greatestLowerBound(\n-                            type1LowerBound,\n-                            type2LowerBound,\n-                            type1LowerBound.getAnnotationInHierarchy(top),\n-                            type2LowerBound.getAnnotationInHierarchy(top));\n+            AnnotationMirror anno1 = type1LowerBound.getAnnotationInHierarchy(top);\n+            AnnotationMirror anno2 = type2LowerBound.getAnnotationInHierarchy(top);\n+\n+            AnnotationMirror glb = null;\n+            if (anno1 != null && anno2 != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86a4037ee6fd5f6af8f43174bec6231da102c123"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjY0NTAwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDo1MjoyNVrOG48T5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNDo1MjoyNVrOG48T5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2MTU3Mg==", "bodyText": "Linking to the type of the parameter is redundant, as the parameter itself already is a link.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462361572", "createdAt": "2020-07-29T14:52:25Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -136,7 +136,7 @@ protected boolean shouldCheckTopLevelDeclaredType(AnnotatedTypeMirror type, Tree\n      * Checks every property listed in {@link #isValidType}, but only for the top level type. If\n      * successful, returns an empty list. If not successful, returns diagnostics.\n      *\n-     * @param qualifierHierarchy the qualifier hierarchy\n+     * @param qualifierHierarchy the {@link QualifierHierarchy}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI1NDA5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxNzo1OVrOG5CUWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxNzo1OVrOG5CUWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1OTk5Mg==", "bodyText": "Here and in a few other comments, should the \"type hierarchies\" be replaced with \"qualifier hierarchies\", to not confuse with TypeHierarchy instances? Sometimes it's the combined \"type qualifier hierarchies\".", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462459992", "createdAt": "2020-07-29T17:17:59Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -32,46 +41,56 @@\n     /**\n      * Returns the width of this hierarchy, i.e. the expected number of annotations on any valid\n      * type.\n+     *\n+     * @return the width of this QualifierHierarchy\n      */\n-    public int getWidth() {\n+    default int getWidth() {\n         return getTopAnnotations().size();\n     }\n \n     /**\n-     * Returns the top (ultimate super) type qualifiers in the type system.\n+     * Returns the top (ultimate super) type qualifiers in the type system. The size of this set is\n+     * equal to {@link #getWidth}.\n      *\n      * @return the top (ultimate super) type qualifiers in the type system\n      */\n-    public abstract Set<? extends AnnotationMirror> getTopAnnotations();\n+    Set<? extends AnnotationMirror> getTopAnnotations();\n \n     /**\n      * Return the top qualifier for the given qualifier, that is, the qualifier that is a supertype\n-     * of start but no further supertypes exist.\n+     * of {@code qualifier} but no further supertypes exist.\n+     *\n+     * @param qualifier any qualifier from one of the type hierarchies represented by this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzMzNzQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo0MDowOVrOG5DIAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo0MDowOVrOG5DIAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3MzIxNw==", "bodyText": "Just repeating the type doesn't add much. \"the type to test\"?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462473217", "createdAt": "2020-07-29T17:40:09Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 396}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzM3NTQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo0OTo0NVrOG5DfzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMDoxNDoyNVrOG5IeIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3OTMwOA==", "bodyText": "I'm confused about the suppression. Both the variable key and the key-type of map are T, so just saying key is of type T, doesn't explain why there is an error that can be suppressed.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462479308", "createdAt": "2020-07-29T17:49:45Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2MDgwMQ==", "bodyText": "The type of the parameter of containsKey is @NonNull Object.  Call is legal because key is of type T.  I added a reference to #2000.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462560801", "createdAt": "2020-07-29T20:14:25Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ3OTMwOA=="}, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 498}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzM4NTI0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1MjoxOFrOG5DlxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1MjoxOFrOG5DlxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MDgzNg==", "bodyText": "For all the deprecated methods, can you point to the methods that should be used instead?", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462480836", "createdAt": "2020-07-29T17:52:18Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        AnnotationMirror top = this.getTopAnnotation(annotationMirror);\n+        return findAnnotationInHierarchy(annos, top);\n+    }\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n-     *\n-     * <p>Examples:\n-     *\n-     * <ul>\n-     *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rarr; Nullable\n-     * </ul>\n-     *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the hierarchy for which annotationMirror is top.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param annos set of annotations to search\n+     * @param top the top annotation in the hierarchy to which the returned annotation belongs\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    public abstract AnnotationMirror leastUpperBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        for (AnnotationMirror anno : annos) {\n+            if (isSubtype(anno, top)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Update a mapping from {@code key} to a set of AnnotationMirrors. If {@code key} is not\n+     * already in the map, then put it in the map with a value of a new set containing {@code\n+     * qualifier}. If the map contains {@code key}, then add {@code qualifier} to the set to which\n+     * {@code key} maps. If that set contains a qualifier in the same hierarchy as {@code\n+     * qualifier}, then don't add it and return false.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n+     * @param map the mapping to modify\n+     * @param key the key to update\n+     * @param qualifier the value to add\n+     * @param <T> type of the map's keys\n+     * @return true if the update was done; false if there was a qualifier hierarchy collision\n      */\n-    public abstract AnnotationMirror greatestLowerBoundTypeVariable(\n-            AnnotationMirror a1, AnnotationMirror a2);\n+    default <T> boolean updateMappingToMutableSet(\n+            Map<T, Set<AnnotationMirror>> map, T key, AnnotationMirror qualifier) {\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\") // key is of type T.\n+        boolean mapContainsKey = map.containsKey(key);\n+        if (mapContainsKey) {\n+            @SuppressWarnings(\"nullness:assignment.type.incompatible\") // key is a key for map.\n+            @NonNull Set<AnnotationMirror> prevs = map.get(key);\n+            AnnotationMirror old = findAnnotationInSameHierarchy(prevs, qualifier);\n+            if (old != null) {\n+                return false;\n+            }\n+            prevs.add(qualifier);\n+            map.put(key, prevs);\n+        } else {\n+            Set<AnnotationMirror> set = AnnotationUtils.createAnnotationSet();\n+            set.add(qualifier);\n+            map.put(key, set);\n+        }\n+        return true;\n+    }\n \n     /**\n-     * Returns the type qualifiers that are the least upper bound of the qualifiers in annos1 and\n-     * annos2.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Throws an exception if the given collections do not have the same size.\n      *\n-     * @return the least upper bound of annos1 and annos2\n+     * @param c1 the first collection\n+     * @param c2 the second collection\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBoundsTypeVariable(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror top : getTopAnnotations()) {\n-            AnnotationMirror anno1ForTop = null;\n-            for (AnnotationMirror anno1 : annos1) {\n-                if (isSubtypeTypeVariable(anno1, top)) {\n-                    anno1ForTop = anno1;\n-                }\n-            }\n-            AnnotationMirror anno2ForTop = null;\n-            for (AnnotationMirror anno2 : annos2) {\n-                if (isSubtypeTypeVariable(anno2, top)) {\n-                    anno2ForTop = anno2;\n-                }\n-            }\n-            AnnotationMirror t = leastUpperBoundTypeVariable(anno1ForTop, anno2ForTop);\n-            if (t != null) {\n-                result.add(t);\n-            }\n+    static void assertSameSize(Collection<?> c1, Collection<?> c2) {\n+        if (c1.size() != c2.size()) {\n+            throw new BugInCF(\n+                    \"inconsistent sizes (%d, %d):%n  %s%n  %s\", c1.size(), c2.size(), c1, c2);\n         }\n-        return result;\n     }\n \n     /**\n-     * Returns the type qualifiers that are the greatest lower bound of the qualifiers in annos1 and\n-     * annos2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Throws an exception if the result does not have the same size as the inputs (which are\n+     * assumed to have the same size as one another).\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return greatest lower bound of the two collections of qualifiers\n+     * @param c1 the first collection\n+     * @param c2 the second collection\n+     * @param result the result collection\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBoundsTypeVariable(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror top : getTopAnnotations()) {\n-            AnnotationMirror anno1ForTop = null;\n-            for (AnnotationMirror anno1 : annos1) {\n-                if (isSubtypeTypeVariable(anno1, top)) {\n-                    anno1ForTop = anno1;\n-                }\n-            }\n-            AnnotationMirror anno2ForTop = null;\n-            for (AnnotationMirror anno2 : annos2) {\n-                if (isSubtypeTypeVariable(anno2, top)) {\n-                    anno2ForTop = anno2;\n-                }\n-            }\n-            AnnotationMirror t = greatestLowerBoundTypeVariable(anno1ForTop, anno2ForTop);\n-            if (t != null) {\n-                result.add(t);\n-            }\n+    static void assertSameSize(Collection<?> c1, Collection<?> c2, Collection<?> result) {\n+        if (c1.size() != result.size()) {\n+            throw new BugInCF(\n+                    \"inconsistent sizes (%d, %d, %d):%n  %s%n  %s%n  %s\",\n+                    c1.size(), c2.size(), result.size(), c1, c2, result);\n         }\n-        return result;\n     }\n \n+    // **********************************************************************\n+    // Deprecated methods\n+    // **********************************************************************\n+\n     /**\n-     * Returns true if and only if the given type can have empty annotation sets (and thus the\n-     * *TypeVariable methods need to be used).\n-     */\n-    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n-        return type.getKind() == TypeKind.TYPEVAR\n-                || type.getKind() == TypeKind.WILDCARD\n-                ||\n-                // TODO: or should the union/intersection be the LUB of the alternatives?\n-                type.getKind() == TypeKind.UNION\n-                || type.getKind() == TypeKind.INTERSECTION;\n+     * Tests whether {@code subQualifier} is a sub-qualifier of, or equal to, {@code\n+     * superQualifier}, according to the type qualifier hierarchy.\n+     *\n+     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n+     * 'null' AnnotationMirror is a legal argument that represents no annotation.\n+     *\n+     * @param subQualifier a qualifier that might be a subtype\n+     * @param superQualifier a qualifier that might be a subtype\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n+     * @deprecated Without the bounds of the type variable, it is not possible to correctly compute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 637}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzQwNTUwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1Nzo0OFrOG5DyeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzo1Nzo0OFrOG5DyeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4NDA4OA==", "bodyText": "Other methods in this interface would call these qualifiers and qualifier, I think. Let's try to use consistent names within a class/interface. A few other places below.", "url": "https://github.com/typetools/checker-framework/pull/3445#discussion_r462484088", "createdAt": "2020-07-29T17:57:48Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -81,361 +100,351 @@ public int getWidth() {\n      * @return {@code true} if the qualifier is a polymorphic qualifier; otherwise, returns {@code\n      *     false}.\n      */\n-    public abstract boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n+    boolean isPolymorphicQualifier(AnnotationMirror qualifier);\n \n     // **********************************************************************\n     // Qualifier Hierarchy Queries\n     // **********************************************************************\n \n     /**\n-     * Tests whether rhs is equal to or a sub-qualifier of lhs, according to the type qualifier\n-     * hierarchy. This checks only the qualifiers, not the Java type.\n+     * Tests whether {@code subQualifier} is equal to or a sub-qualifier of {@code superQualifier},\n+     * according to the type qualifier hierarchy.\n      *\n-     * @return true iff rhs is a sub qualifier of lhs\n+     * @param subQualifier possible subqualifier of {@code superQualifier}\n+     * @param superQualifier possible superqualifier of {@code subQualifier}\n+     * @return true iff {@code subQualifier} is a subqualifier of, or equal to, {@code\n+     *     superQualifier}\n      */\n-    public abstract boolean isSubtype(AnnotationMirror rhs, AnnotationMirror lhs);\n+    boolean isSubtype(AnnotationMirror subQualifier, AnnotationMirror superQualifier);\n \n     /**\n-     * Tests whether there is any annotation in lhs that is a super qualifier of, or equal to, some\n-     * annotation in rhs. lhs and rhs contain only the annotations, not the Java type.\n+     * Tests whether all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     * qualifier in the same hierarchy in {@code superQualifiers}.\n      *\n-     * @return true iff an annotation in lhs is a super of one in rhs\n+     * @param subQualifiers set of qualifiers; exactly one per hierarchy\n+     * @param superQualifiers set of qualifiers; exactly one per hierarchy\n+     * @return true iff all qualifiers in {@code subQualifiers} are a subqualifier or equal to the\n+     *     qualifier in the same hierarchy in {@code superQualifiers}\n      */\n-    public abstract boolean isSubtype(\n-            Collection<? extends AnnotationMirror> rhs, Collection<? extends AnnotationMirror> lhs);\n+    boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subQualifiers,\n+            Collection<? extends AnnotationMirror> superQualifiers);\n \n     /**\n-     * Returns the least upper bound for the qualifiers a1 and a2.\n+     * Returns the least upper bound (LUB) of the qualifiers {@code qualifier1} and {@code\n+     * qualifier2}. Returns {@code null} if the qualifiers are not from the same qualifier\n+     * hierarchy.\n      *\n      * <p>Examples:\n      *\n      * <ul>\n      *   <li>For NonNull, leastUpperBound('Nullable', 'NonNull') &rArr; Nullable\n      * </ul>\n      *\n-     * The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * @param qualifier1 the first qualifier; may not be in the same hierarchy as {@code qualifier2}\n+     * @param qualifier2 the second qualifier; may not be in the same hierarchy as {@code\n+     *     qualifier1}\n+     * @return the least upper bound of the qualifiers, or {@code null} if the qualifiers are from\n+     *     different hierarchies\n+     */\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror leastUpperBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n+\n+    /**\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @return the least restrictive qualifiers for both types\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public abstract AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2);\n+    default Set<? extends AnnotationMirror> leastUpperBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n+            throw new BugInCF(\n+                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n+        }\n+\n+        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n+                AnnotationMirror lub = leastUpperBound(a1, a2);\n+                if (lub != null) {\n+                    result.add(lub);\n+                }\n+            }\n+        }\n+\n+        assertSameSize(result, qualifiers1);\n+        return result;\n+    }\n \n     /**\n      * Returns the number of iterations dataflow should perform before {@link\n      * #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should never be\n      * called.\n      *\n-     * <p>Subclasses overriding this method should return some positive number or -1.\n-     *\n      * @return the number of iterations dataflow should perform before {@link\n      *     #widenedUpperBound(AnnotationMirror, AnnotationMirror)} is called or -1 if it should\n      *     never be called.\n      */\n-    public int numberOfIterationsBeforeWidening() {\n+    default int numberOfIterationsBeforeWidening() {\n         return -1;\n     }\n \n     /**\n      * If the type hierarchy has an infinite ascending chain, then the dataflow analysis might never\n      * reach a fixed point. To prevent this, implement this method such that it returns an upper\n-     * bound for the two qualifiers that is a super type and not equal to the least upper bound. If\n-     * this method is implemented, also override {@link #numberOfIterationsBeforeWidening()} and\n-     * change its return to a positive number.\n+     * bound for the two qualifiers that is a strict super type of the least upper bound. If this\n+     * method is implemented, also override {@link #numberOfIterationsBeforeWidening()} to return a\n+     * positive number.\n      *\n      * <p>{@code newQualifier} is newest qualifier dataflow computed for some expression and {@code\n      * previousQualifier} is the qualifier dataflow computed on the last iteration.\n      *\n      * <p>If the type hierarchy has no infinite ascending chain, returns the least upper bound of\n      * the two annotations.\n      *\n-     * @param newQualifier new qualifier dataflow computed for some expression\n-     * @param previousQualifier the previous qualifier dataflow computed on the last iteration\n-     * @return an upper bound that is wider than the least upper bound of newQualifier and\n+     * @param newQualifier new qualifier dataflow computed for some expression; must be in the same\n+     *     hierarchy as {@code previousQualifier}\n+     * @param previousQualifier the previous qualifier dataflow computed on the last iteration; must\n+     *     be in the same hierarchy as {@code previousQualifier}\n+     * @return an upper bound that is higher than the least upper bound of newQualifier and\n      *     previousQualifier (or the lub if the type hierarchy does not require this)\n      */\n-    public AnnotationMirror widenedUpperBound(\n+    default AnnotationMirror widenedUpperBound(\n             AnnotationMirror newQualifier, AnnotationMirror previousQualifier) {\n-        return leastUpperBound(newQualifier, previousQualifier);\n+        AnnotationMirror widenUpperBound = leastUpperBound(newQualifier, previousQualifier);\n+        if (widenUpperBound == null) {\n+            throw new BugInCF(\n+                    \"Passed two unrelated qualifiers to QualifierHierarchy#widenedUpperBound. %s %s.\",\n+                    newQualifier, previousQualifier);\n+        }\n+        return widenUpperBound;\n     }\n \n     /**\n-     * Returns the greatest lower bound for the qualifiers a1 and a2.\n-     *\n-     * <p>The two qualifiers have to be from the same qualifier hierarchy. Otherwise, null will be\n-     * returned.\n+     * Returns the greatest lower bound for the qualifiers qualifier1 and qualifier2. Returns null\n+     * if the qualifiers are not from the same qualifier hierarchy.\n      *\n-     * @param a1 first annotation\n-     * @param a2 second annotation\n-     * @return greatest lower bound of the two annotations\n-     */\n-    public abstract AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2);\n-\n-    /**\n-     * Returns the least upper bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n-     *\n-     * <p>This is necessary for determining the type of a conditional expression ({@code ?:}), where\n-     * the type of the expression is the least upper bound of the true and false clauses.\n-     *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise least upper bounds of elements of the input collections (which need not be\n-     *     sorted in the same order)\n+     * @param qualifier1 first qualifier\n+     * @param qualifier2 second qualifier\n+     * @return greatest lower bound of the two annotations or null if the two annotations are not\n+     *     from the same hierarchy\n      */\n-    public Set<? extends AnnotationMirror> leastUpperBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n-            throw new BugInCF(\n-                    \"QualifierHierarchy.leastUpperBounds: tried to determine LUB with empty sets\");\n-        }\n-\n-        Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n-                AnnotationMirror lub = leastUpperBound(a1, a2);\n-                if (lub != null) {\n-                    result.add(lub);\n-                }\n-            }\n-        }\n-\n-        assertSameSize(result, annos1);\n-\n-        return result;\n-    }\n+    // The fact that null is returned if the qualifiers are not in the same hierarchy is used by the\n+    // collection version of LUB below.\n+    @Nullable AnnotationMirror greatestLowerBound(AnnotationMirror qualifier1, AnnotationMirror qualifier2);\n \n     /**\n-     * Returns the greatest lower bound of two types. Each type is represented as a set of type\n-     * qualifiers, as is the result.\n-     *\n-     * <p>Annos1 and annos2 must have the same size, and each annotation in them must be from a\n-     * different type hierarchy.\n+     * Returns the least upper bound of the two sets of qualifiers. The result is the lub of the\n+     * qualifier for the same hierarchy in each set.\n      *\n-     * @param annos1 first collection of qualifiers\n-     * @param annos2 second collection of qualifiers\n-     * @return pairwise greatest lower bounds of elements of the input collections (which need not\n-     *     be sorted in the same order)\n+     * @param qualifiers1 set of qualifiers; exactly one per hierarchy\n+     * @param qualifiers2 set of qualifiers; exactly one per hierarchy\n+     * @return the least upper bound of the two sets of qualifiers\n      */\n-    public Set<? extends AnnotationMirror> greatestLowerBounds(\n-            Collection<? extends AnnotationMirror> annos1,\n-            Collection<? extends AnnotationMirror> annos2) {\n-        assertSameSize(annos1, annos2);\n-        if (annos1.isEmpty()) {\n+    default Set<? extends AnnotationMirror> greatestLowerBounds(\n+            Collection<? extends AnnotationMirror> qualifiers1,\n+            Collection<? extends AnnotationMirror> qualifiers2) {\n+        assertSameSize(qualifiers1, qualifiers2);\n+        if (qualifiers1.isEmpty()) {\n             throw new BugInCF(\n                     \"QualifierHierarchy.greatestLowerBounds: tried to determine GLB with empty sets\");\n         }\n \n         Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\n-        for (AnnotationMirror a1 : annos1) {\n-            for (AnnotationMirror a2 : annos2) {\n+        for (AnnotationMirror a1 : qualifiers1) {\n+            for (AnnotationMirror a2 : qualifiers2) {\n                 AnnotationMirror glb = greatestLowerBound(a1, a2);\n                 if (glb != null) {\n                     result.add(glb);\n                 }\n             }\n         }\n \n-        assertSameSize(annos1, annos2, result);\n-\n+        assertSameSize(qualifiers1, qualifiers2, result);\n         return result;\n     }\n \n     /**\n-     * Tests whether {@code subAnno} is a sub-qualifier of, or equal to, {@code superAnno},\n-     * according to the type qualifier hierarchy. This checks only the qualifiers, not the Java\n-     * type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     * with fewer qualifiers than the width of the QualifierHierarchy.\n      *\n-     * @param subAnno a qualifier that might be a subtype\n-     * @param superAnno a qualifier that might be a subtype\n-     * @return true iff {@code subAnno} is a sub qualifier of, or equal to, {@code superAnno}\n+     * @param type annotated type mirror\n+     * @return true if and only if {@link AnnotatedTypeMirror#getAnnotations()} can return a set\n+     *     with fewer qualifiers than the width of the QualifierHierarchy\n      */\n-    public abstract boolean isSubtypeTypeVariable(\n-            AnnotationMirror subAnno, AnnotationMirror superAnno);\n+    public static boolean canHaveEmptyAnnotationSet(AnnotatedTypeMirror type) {\n+        return type.getKind() == TypeKind.TYPEVAR\n+                || type.getKind() == TypeKind.WILDCARD\n+                ||\n+                // TODO: or should the union/intersection be the LUB of the alternatives?\n+                type.getKind() == TypeKind.UNION\n+                || type.getKind() == TypeKind.INTERSECTION;\n+    }\n \n     /**\n-     * Tests whether there is any annotation in superAnnos that is a super qualifier of or equal to\n-     * some annotation in subAnnos. superAnnos and subAnnos contain only the annotations, not the\n-     * Java type.\n-     *\n-     * <p>This method works even if the underlying Java type is a type variable. In that case, a\n-     * 'null' AnnnotationMirror and the empty set represent a meaningful value (namely, no\n-     * annotation).\n+     * Returns the annotation in annos that is in the same hierarchy as annotationMirror.\n      *\n-     * @return true iff an annotation in superAnnos is a supertype of, or equal to, one in subAnnos\n+     * @param annos set of annotations to search\n+     * @param annotationMirror annotation that is in the same hierarchy as the returned annotation\n+     * @return annotation in the same hierarchy as annotationMirror, or null if one is not found\n      */\n-    // This method requires more revision.\n-    public abstract boolean isSubtypeTypeVariable(\n-            Collection<? extends AnnotationMirror> subAnnos,\n-            Collection<? extends AnnotationMirror> superAnnos);\n+    default @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20809ebb5f1341ade01f3f5f43e05b7d2cef9802"}, "originalPosition": 431}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1752, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}