{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MDUyNTM2", "number": 3790, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMzo0ODozMVrOEuuryQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDowMDo0MFrOEuuukw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM0ODI1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMzo0ODozMVrOHjT-lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwMzo0ODozMVrOHjT-lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4OTUyNA==", "bodyText": "In this example, the annotation isn't just copied to the primary annotation location, but to every bound of the intersection.\nAlso, it would be helpful to indicate that the primary annotation location is different than all the annotations on the bounds.  The example doesn't actually show the primary annotation location.  So, I find the example a bit confusing.", "url": "https://github.com/typetools/checker-framework/pull/3790#discussion_r506789524", "createdAt": "2020-10-17T03:48:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "diffHunk": "@@ -2118,27 +2132,67 @@ public AnnotatedIntersectionType shallowCopy() {\n             return shallowCopy(true);\n         }\n \n-        protected List<AnnotatedDeclaredType> supertypes;\n-\n+        /**\n+         * {@inheritDoc}\n+         *\n+         * <p>This returns the same types as {@link #getBounds()}.\n+         *\n+         * @return the direct super types of this\n+         */\n         @Override\n-        public List<AnnotatedDeclaredType> directSuperTypes() {\n-            if (supertypes == null) {\n+        public List<? extends AnnotatedTypeMirror> directSuperTypes() {\n+            return getBounds();\n+        }\n+\n+        /**\n+         * This returns the bounds of the intersection type. Although only declared types can appear\n+         * in an explicitly written intersections, during capture conversion, intersections with\n+         * other kinds of types are created.\n+         *\n+         * <p>This returns the same types as {@link #directSuperTypes()}.\n+         *\n+         * @return the bounds of this, which are also the direct super types of this\n+         */\n+        public List<AnnotatedTypeMirror> getBounds() {\n+            if (bounds == null) {\n                 List<? extends TypeMirror> ubounds = ((IntersectionType) actualType).getBounds();\n-                List<AnnotatedDeclaredType> res = new ArrayList<>(ubounds.size());\n+                List<AnnotatedTypeMirror> res = new ArrayList<>(ubounds.size());\n                 for (TypeMirror bnd : ubounds) {\n-                    res.add((AnnotatedDeclaredType) createType(bnd, atypeFactory, false));\n+                    res.add(createType(bnd, atypeFactory, false));\n                 }\n-                supertypes = Collections.unmodifiableList(res);\n+                bounds = Collections.unmodifiableList(res);\n+                fixupBoundAnnotations();\n             }\n-            return supertypes;\n+            return bounds;\n         }\n \n-        public List<AnnotatedDeclaredType> directSuperTypesField() {\n-            return supertypes;\n+        /**\n+         * Sets the bounds.\n+         *\n+         * @param bounds bounds to use\n+         */\n+        /*default-visibility*/ void setBounds(List<AnnotatedTypeMirror> bounds) {\n+            this.bounds = bounds;\n         }\n \n-        void setDirectSuperTypes(List<AnnotatedDeclaredType> supertypes) {\n-            this.supertypes = new ArrayList<>(supertypes);\n+        /**\n+         * Copy the first annotation (in each hierarchy) on a bound to the primary annotation\n+         * location of the intersection type.\n+         *\n+         * <p>For example, {@code @NonNull Object & @Initialized @Nullable Serializable} is changed\n+         * to {@code @NonNull @Initialized Object & @Initialized @NonNull Serializable}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bd31b6138e677591d15ef0e48e2dfe9cafdb0f"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM1NTM5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDowMDo0MFrOHjUB-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQyMTowNTo1NVrOHkhpag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDM5Mw==", "bodyText": "When this is called, have the primary annotations already been applied to every bound, so that each bound stands on its own without any need to refer to the primary annotations?", "url": "https://github.com/typetools/checker-framework/pull/3790#discussion_r506790393", "createdAt": "2020-10-17T04:00:40Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -1016,6 +990,26 @@ protected boolean visitIntersectionSupertype(\n         return result;\n     }\n \n+    /**\n+     * An intersection is a subtype if one of its bounds is a subtype of {@code supertype}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24bd31b6138e677591d15ef0e48e2dfe9cafdb0f"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA1OTE3MA==", "bodyText": "Yes.  This method is only called on fully-annotated types.  That means that the intersection type has a primary annotation for every qualifier hierarchy.", "url": "https://github.com/typetools/checker-framework/pull/3790#discussion_r508059170", "createdAt": "2020-10-19T21:00:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -1016,6 +990,26 @@ protected boolean visitIntersectionSupertype(\n         return result;\n     }\n \n+    /**\n+     * An intersection is a subtype if one of its bounds is a subtype of {@code supertype}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDM5Mw=="}, "originalCommit": {"oid": "24bd31b6138e677591d15ef0e48e2dfe9cafdb0f"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA2MjA1OA==", "bodyText": "TOOD: Add comment.", "url": "https://github.com/typetools/checker-framework/pull/3790#discussion_r508062058", "createdAt": "2020-10-19T21:05:55Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -1016,6 +990,26 @@ protected boolean visitIntersectionSupertype(\n         return result;\n     }\n \n+    /**\n+     * An intersection is a subtype if one of its bounds is a subtype of {@code supertype}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDM5Mw=="}, "originalCommit": {"oid": "24bd31b6138e677591d15ef0e48e2dfe9cafdb0f"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 981, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}