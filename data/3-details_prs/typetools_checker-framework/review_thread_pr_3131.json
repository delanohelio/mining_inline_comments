{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0Mzk4MDU3", "number": 3131, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0MjoxNFrODlmMdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNTozOTo0M1rODl10oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ5Njg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0MjoxNFrOFylNZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTo0MjoxNFrOFylNZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4Mjc1OQ==", "bodyText": "This should be in the change log.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388582759", "createdAt": "2020-03-05T21:42:14Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -607,25 +637,24 @@ public AnnotationProvider getAnnotationProvider() {\n      *\n      * @return a {@link Properties} that maps error keys to error message text\n      */\n-    public Properties getMessages() {\n-        if (this.messages != null) {\n-            return this.messages;\n+    public Properties getMessagesProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48a0ed73ccbdf2cc036251af02a69dc6c3b30506"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDAwMTU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNToyNDoyMlrOFy8ogQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjowNzowNlrOFy-MXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NjUyOQ==", "bodyText": "Should this method be private? Or protected? I don't see a need for package visibility.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388966529", "createdAt": "2020-03-06T15:24:22Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -499,6 +504,31 @@ public final synchronized void init(ProcessingEnvironment env) {\n         }\n     }\n \n+    /** True if the git.properties file has been printed. */\n+    private static boolean gitPropertiesPrinted = false;\n+\n+    /** Print information about the git repository from which the Checker Framework was compiled. */\n+    void printGitProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5MjA5Mw==", "bodyText": "I made it private.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388992093", "createdAt": "2020-03-06T16:07:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -499,6 +504,31 @@ public final synchronized void init(ProcessingEnvironment env) {\n         }\n     }\n \n+    /** True if the git.properties file has been printed. */\n+    private static boolean gitPropertiesPrinted = false;\n+\n+    /** Print information about the git repository from which the Checker Framework was compiled. */\n+    void printGitProperties() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NjUyOQ=="}, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDAwNTA2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNToyNToyMlrOFy8qsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjowODoyOFrOFy-PRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NzA5MA==", "bodyText": "Could we move/keep these support/debugging methods to the bottom of the file? Is there a reason to move them up?", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388967090", "createdAt": "2020-03-06T15:25:22Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -499,6 +504,31 @@ public final synchronized void init(ProcessingEnvironment env) {\n         }\n     }\n \n+    /** True if the git.properties file has been printed. */\n+    private static boolean gitPropertiesPrinted = false;\n+\n+    /** Print information about the git repository from which the Checker Framework was compiled. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5MjgzNw==", "bodyText": "It is only called by init, so I put it next to init.  I have now moved it to the end of the file.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388992837", "createdAt": "2020-03-06T16:08:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -499,6 +504,31 @@ public final synchronized void init(ProcessingEnvironment env) {\n         }\n     }\n \n+    /** True if the git.properties file has been printed. */\n+    private static boolean gitPropertiesPrinted = false;\n+\n+    /** Print information about the git repository from which the Checker Framework was compiled. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2NzA5MA=="}, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDAxMTcyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNToyNzowNlrOFy8u5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNToyNzowNlrOFy8u5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk2ODE2NA==", "bodyText": "I would also move shutdown logic towards the bottom.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388968164", "createdAt": "2020-03-06T15:27:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -1066,178 +895,79 @@ public void typeProcess(TypeElement e, TreePath p) {\n         }\n     }\n \n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     */\n-    protected void warnUnneededSuppressions() {\n-        if (!hasOption(\"warnUnneededSuppressions\")) {\n-            return;\n-        }\n-\n-        Set<Element> elementsSuppress = new HashSet<>(this.elementsWithSuppressedWarnings);\n-        this.elementsWithSuppressedWarnings.clear();\n-        Set<String> checkerKeys = new HashSet<>(getSuppressWarningsKeys());\n-        Set<String> errorKeys = new HashSet<>(messages.stringPropertyNames());\n-        warnUnneedSuppressions(elementsSuppress, checkerKeys, errorKeys);\n-        getVisitor().treesWithSuppressWarnings.clear();\n-    }\n-\n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     *\n-     * @param elementsSuppress elements with a {@code @SuppressWarnings} that actually suppressed a\n-     *     warning\n-     * @param checkerKeys suppress warning keys that suppress any warning from this checker\n-     * @param errorKeys error keys that can be issued by this checker\n-     */\n-    protected void warnUnneedSuppressions(\n-            Set<Element> elementsSuppress, Set<String> checkerKeys, Set<String> errorKeys) {\n-        // It's not clear for which checker \"all\" is intended, so never report it as unused.\n-        checkerKeys.remove(SourceChecker.SUPPRESS_ALL_KEY);\n-\n-        // Is the name of the checker required to suppress a warning?\n-        boolean requirePrefix = hasOption(\"requirePrefixInWarningSuppressions\");\n-\n-        for (Tree tree : getVisitor().treesWithSuppressWarnings) {\n-            Element elt = TreeUtils.elementFromTree(tree);\n-            // TODO: This test is too coarse.  The fact that this @SuppressWarnings suppressed\n-            // *some* warning doesn't mean that every value in it did so.\n-            if (elementsSuppress.contains(elt)) {\n-                continue;\n-            }\n-            SuppressWarnings suppressAnno = elt.getAnnotation(SuppressWarnings.class);\n-            // Check each value of the user-written @SuppressWarnings annotation.\n-            for (String userKey : suppressAnno.value()) {\n-                String fullUserKey = userKey;\n-                int colonPos = userKey.indexOf(\":\");\n-                if (colonPos == -1) {\n-                    // User-written error key contains no \":\".\n-                    if (checkerKeys.contains(userKey)) {\n-                        reportUnneededSuppression(tree, userKey);\n-                    }\n-                    if (requirePrefix) {\n-                        // This user-written key is not for the Checker Framework\n-                        continue;\n-                    }\n-                } else {\n-                    // User-written error key contains \":\".\n-                    String userCheckerKey = userKey.substring(0, colonPos);\n-                    if (userCheckerKey.equals(SourceChecker.SUPPRESS_ALL_KEY)\n-                            || !checkerKeys.contains(userCheckerKey)) {\n-                        // This user-written key is for some other checker\n-                        continue;\n-                    }\n-                    userKey = userKey.substring(colonPos + 1);\n-                }\n-                for (String errorKey : errorKeys) {\n-                    // The userKey may only be a part of an error key.\n-                    // For example, @SuppressWarnings(\"purity\") suppresses errors with keys:\n-                    // purity.deterministic.void.method, purity.deterministic.constructor, etc.\n-                    if (errorKey.contains(userKey)) {\n-                        reportUnneededSuppression(tree, fullUserKey);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    ///////////////////////////////////////////////////////////////////////////", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 582}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDA0MDA1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNTozNDo1NlrOFy9A6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjoxMDowMlrOFy-TjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3Mjc3Ng==", "bodyText": "I'm not sure what the \"main entry point\" is supposed to mean. Can you clarify?\nThe two methods that visitors should use are report() and message(Diagnostic.Kind kind, String msg, Object... args), so maybe list those two?", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388972776", "createdAt": "2020-03-06T15:34:56Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -1066,178 +895,79 @@ public void typeProcess(TypeElement e, TreePath p) {\n         }\n     }\n \n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     */\n-    protected void warnUnneededSuppressions() {\n-        if (!hasOption(\"warnUnneededSuppressions\")) {\n-            return;\n-        }\n-\n-        Set<Element> elementsSuppress = new HashSet<>(this.elementsWithSuppressedWarnings);\n-        this.elementsWithSuppressedWarnings.clear();\n-        Set<String> checkerKeys = new HashSet<>(getSuppressWarningsKeys());\n-        Set<String> errorKeys = new HashSet<>(messages.stringPropertyNames());\n-        warnUnneedSuppressions(elementsSuppress, checkerKeys, errorKeys);\n-        getVisitor().treesWithSuppressWarnings.clear();\n-    }\n-\n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     *\n-     * @param elementsSuppress elements with a {@code @SuppressWarnings} that actually suppressed a\n-     *     warning\n-     * @param checkerKeys suppress warning keys that suppress any warning from this checker\n-     * @param errorKeys error keys that can be issued by this checker\n-     */\n-    protected void warnUnneedSuppressions(\n-            Set<Element> elementsSuppress, Set<String> checkerKeys, Set<String> errorKeys) {\n-        // It's not clear for which checker \"all\" is intended, so never report it as unused.\n-        checkerKeys.remove(SourceChecker.SUPPRESS_ALL_KEY);\n-\n-        // Is the name of the checker required to suppress a warning?\n-        boolean requirePrefix = hasOption(\"requirePrefixInWarningSuppressions\");\n-\n-        for (Tree tree : getVisitor().treesWithSuppressWarnings) {\n-            Element elt = TreeUtils.elementFromTree(tree);\n-            // TODO: This test is too coarse.  The fact that this @SuppressWarnings suppressed\n-            // *some* warning doesn't mean that every value in it did so.\n-            if (elementsSuppress.contains(elt)) {\n-                continue;\n-            }\n-            SuppressWarnings suppressAnno = elt.getAnnotation(SuppressWarnings.class);\n-            // Check each value of the user-written @SuppressWarnings annotation.\n-            for (String userKey : suppressAnno.value()) {\n-                String fullUserKey = userKey;\n-                int colonPos = userKey.indexOf(\":\");\n-                if (colonPos == -1) {\n-                    // User-written error key contains no \":\".\n-                    if (checkerKeys.contains(userKey)) {\n-                        reportUnneededSuppression(tree, userKey);\n-                    }\n-                    if (requirePrefix) {\n-                        // This user-written key is not for the Checker Framework\n-                        continue;\n-                    }\n-                } else {\n-                    // User-written error key contains \":\".\n-                    String userCheckerKey = userKey.substring(0, colonPos);\n-                    if (userCheckerKey.equals(SourceChecker.SUPPRESS_ALL_KEY)\n-                            || !checkerKeys.contains(userCheckerKey)) {\n-                        // This user-written key is for some other checker\n-                        continue;\n-                    }\n-                    userKey = userKey.substring(colonPos + 1);\n-                }\n-                for (String errorKey : errorKeys) {\n-                    // The userKey may only be a part of an error key.\n-                    // For example, @SuppressWarnings(\"purity\") suppresses errors with keys:\n-                    // purity.deterministic.void.method, purity.deterministic.constructor, etc.\n-                    if (errorKey.contains(userKey)) {\n-                        reportUnneededSuppression(tree, fullUserKey);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Shutdown\n+    ///\n \n     /**\n-     * Issues a warning that the key in a {@code @SuppressWarnings} on {@code tree} isn't needed.\n+     * Return true to indicate that method {@link #shutdownHook} should be added as a shutdownHook\n+     * of the JVM.\n      *\n-     * @param tree has unneeded {@code @SuppressWarnings}\n-     * @param key suppress warning key that isn't needed\n+     * @return true to add {@link #shutdownHook} as a shutdown hook of the JVM\n      */\n-    private void reportUnneededSuppression(Tree tree, String key) {\n-        Tree swTree = findSuppressWarningsTree(tree);\n-        report(\n-                Result.warning(\n-                        SourceChecker.UNNEEDED_SUPPRESSION_KEY,\n-                        \"\\\"\" + key + \"\\\"\",\n-                        getClass().getSimpleName()),\n-                swTree);\n+    protected boolean shouldAddShutdownHook() {\n+        return hasOption(\"resourceStats\");\n     }\n \n-    /** The name of the @SuppressWarnings annotation. */\n-    private final String suppressWarningsClassName = SuppressWarnings.class.getCanonicalName();\n     /**\n-     * Finds the tree that is a {@code @SuppressWarnings} annotation.\n-     *\n-     * @param tree a class, method, or variable tree annotated with {@code @SuppressWarnings}\n-     * @return tree for {@code @SuppressWarnings} or {@code default} if one isn't found\n+     * Method that gets called exactly once at shutdown time of the JVM. Checkers can override this\n+     * method to customize the behavior.\n      */\n-    private Tree findSuppressWarningsTree(Tree tree) {\n-        List<? extends AnnotationTree> annotations;\n-        if (TreeUtils.isClassTree(tree)) {\n-            annotations = ((ClassTree) tree).getModifiers().getAnnotations();\n-        } else if (tree.getKind() == Tree.Kind.METHOD) {\n-            annotations = ((MethodTree) tree).getModifiers().getAnnotations();\n-        } else {\n-            annotations = ((VariableTree) tree).getModifiers().getAnnotations();\n+    protected void shutdownHook() {\n+        if (hasOption(\"resourceStats\")) {\n+            // Check for the \"resourceStats\" option and don't call shouldAddShutdownHook\n+            // to allow subclasses to override shouldXXX and shutdownHook and simply\n+            // call the super implementations.\n+            printStats();\n         }\n+    }\n \n-        for (AnnotationTree annotationTree : annotations) {\n-            if (AnnotationUtils.areSameByName(\n-                    TreeUtils.annotationFromAnnotationTree(annotationTree),\n-                    suppressWarningsClassName)) {\n-                return annotationTree;\n-            }\n+    /** Print resource usage statistics. */\n+    protected void printStats() {\n+        List<MemoryPoolMXBean> memoryPools = ManagementFactory.getMemoryPoolMXBeans();\n+        for (MemoryPoolMXBean memoryPool : memoryPools) {\n+            System.out.println(\"Memory pool \" + memoryPool.getName() + \" statistics\");\n+            System.out.println(\"  Pool type: \" + memoryPool.getType());\n+            System.out.println(\"  Peak usage: \" + memoryPool.getPeakUsage());\n         }\n-        throw new BugInCF(\"Did not find @SuppressWarnings: \" + tree);\n     }\n \n-    private BugInCF wrapThrowableAsBugInCF(String where, Throwable t, @Nullable TreePath p) {\n-        return new BugInCF(\n-                where\n-                        + \": unexpected Throwable (\"\n-                        + t.getClass().getSimpleName()\n-                        + \")\"\n-                        + ((p == null)\n-                                ? \"\"\n-                                : \" while processing \"\n-                                        + p.getCompilationUnit().getSourceFile().getName())\n-                        + (t.getMessage() == null ? \"\" : \"; message: \" + t.getMessage()),\n-                t);\n-    }\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Reporting type-checking errors; the main entry point is report()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 665}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5MzkzMg==", "bodyText": "message is documented as being \"only for exceptional cases\".  So report is the method that clients should prefer.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388993932", "createdAt": "2020-03-06T16:10:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -1066,178 +895,79 @@ public void typeProcess(TypeElement e, TreePath p) {\n         }\n     }\n \n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     */\n-    protected void warnUnneededSuppressions() {\n-        if (!hasOption(\"warnUnneededSuppressions\")) {\n-            return;\n-        }\n-\n-        Set<Element> elementsSuppress = new HashSet<>(this.elementsWithSuppressedWarnings);\n-        this.elementsWithSuppressedWarnings.clear();\n-        Set<String> checkerKeys = new HashSet<>(getSuppressWarningsKeys());\n-        Set<String> errorKeys = new HashSet<>(messages.stringPropertyNames());\n-        warnUnneedSuppressions(elementsSuppress, checkerKeys, errorKeys);\n-        getVisitor().treesWithSuppressWarnings.clear();\n-    }\n-\n-    /**\n-     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n-     * contains a key that would suppress a warning from this checker.\n-     *\n-     * @param elementsSuppress elements with a {@code @SuppressWarnings} that actually suppressed a\n-     *     warning\n-     * @param checkerKeys suppress warning keys that suppress any warning from this checker\n-     * @param errorKeys error keys that can be issued by this checker\n-     */\n-    protected void warnUnneedSuppressions(\n-            Set<Element> elementsSuppress, Set<String> checkerKeys, Set<String> errorKeys) {\n-        // It's not clear for which checker \"all\" is intended, so never report it as unused.\n-        checkerKeys.remove(SourceChecker.SUPPRESS_ALL_KEY);\n-\n-        // Is the name of the checker required to suppress a warning?\n-        boolean requirePrefix = hasOption(\"requirePrefixInWarningSuppressions\");\n-\n-        for (Tree tree : getVisitor().treesWithSuppressWarnings) {\n-            Element elt = TreeUtils.elementFromTree(tree);\n-            // TODO: This test is too coarse.  The fact that this @SuppressWarnings suppressed\n-            // *some* warning doesn't mean that every value in it did so.\n-            if (elementsSuppress.contains(elt)) {\n-                continue;\n-            }\n-            SuppressWarnings suppressAnno = elt.getAnnotation(SuppressWarnings.class);\n-            // Check each value of the user-written @SuppressWarnings annotation.\n-            for (String userKey : suppressAnno.value()) {\n-                String fullUserKey = userKey;\n-                int colonPos = userKey.indexOf(\":\");\n-                if (colonPos == -1) {\n-                    // User-written error key contains no \":\".\n-                    if (checkerKeys.contains(userKey)) {\n-                        reportUnneededSuppression(tree, userKey);\n-                    }\n-                    if (requirePrefix) {\n-                        // This user-written key is not for the Checker Framework\n-                        continue;\n-                    }\n-                } else {\n-                    // User-written error key contains \":\".\n-                    String userCheckerKey = userKey.substring(0, colonPos);\n-                    if (userCheckerKey.equals(SourceChecker.SUPPRESS_ALL_KEY)\n-                            || !checkerKeys.contains(userCheckerKey)) {\n-                        // This user-written key is for some other checker\n-                        continue;\n-                    }\n-                    userKey = userKey.substring(colonPos + 1);\n-                }\n-                for (String errorKey : errorKeys) {\n-                    // The userKey may only be a part of an error key.\n-                    // For example, @SuppressWarnings(\"purity\") suppresses errors with keys:\n-                    // purity.deterministic.void.method, purity.deterministic.constructor, etc.\n-                    if (errorKey.contains(userKey)) {\n-                        reportUnneededSuppression(tree, fullUserKey);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Shutdown\n+    ///\n \n     /**\n-     * Issues a warning that the key in a {@code @SuppressWarnings} on {@code tree} isn't needed.\n+     * Return true to indicate that method {@link #shutdownHook} should be added as a shutdownHook\n+     * of the JVM.\n      *\n-     * @param tree has unneeded {@code @SuppressWarnings}\n-     * @param key suppress warning key that isn't needed\n+     * @return true to add {@link #shutdownHook} as a shutdown hook of the JVM\n      */\n-    private void reportUnneededSuppression(Tree tree, String key) {\n-        Tree swTree = findSuppressWarningsTree(tree);\n-        report(\n-                Result.warning(\n-                        SourceChecker.UNNEEDED_SUPPRESSION_KEY,\n-                        \"\\\"\" + key + \"\\\"\",\n-                        getClass().getSimpleName()),\n-                swTree);\n+    protected boolean shouldAddShutdownHook() {\n+        return hasOption(\"resourceStats\");\n     }\n \n-    /** The name of the @SuppressWarnings annotation. */\n-    private final String suppressWarningsClassName = SuppressWarnings.class.getCanonicalName();\n     /**\n-     * Finds the tree that is a {@code @SuppressWarnings} annotation.\n-     *\n-     * @param tree a class, method, or variable tree annotated with {@code @SuppressWarnings}\n-     * @return tree for {@code @SuppressWarnings} or {@code default} if one isn't found\n+     * Method that gets called exactly once at shutdown time of the JVM. Checkers can override this\n+     * method to customize the behavior.\n      */\n-    private Tree findSuppressWarningsTree(Tree tree) {\n-        List<? extends AnnotationTree> annotations;\n-        if (TreeUtils.isClassTree(tree)) {\n-            annotations = ((ClassTree) tree).getModifiers().getAnnotations();\n-        } else if (tree.getKind() == Tree.Kind.METHOD) {\n-            annotations = ((MethodTree) tree).getModifiers().getAnnotations();\n-        } else {\n-            annotations = ((VariableTree) tree).getModifiers().getAnnotations();\n+    protected void shutdownHook() {\n+        if (hasOption(\"resourceStats\")) {\n+            // Check for the \"resourceStats\" option and don't call shouldAddShutdownHook\n+            // to allow subclasses to override shouldXXX and shutdownHook and simply\n+            // call the super implementations.\n+            printStats();\n         }\n+    }\n \n-        for (AnnotationTree annotationTree : annotations) {\n-            if (AnnotationUtils.areSameByName(\n-                    TreeUtils.annotationFromAnnotationTree(annotationTree),\n-                    suppressWarningsClassName)) {\n-                return annotationTree;\n-            }\n+    /** Print resource usage statistics. */\n+    protected void printStats() {\n+        List<MemoryPoolMXBean> memoryPools = ManagementFactory.getMemoryPoolMXBeans();\n+        for (MemoryPoolMXBean memoryPool : memoryPools) {\n+            System.out.println(\"Memory pool \" + memoryPool.getName() + \" statistics\");\n+            System.out.println(\"  Pool type: \" + memoryPool.getType());\n+            System.out.println(\"  Peak usage: \" + memoryPool.getPeakUsage());\n         }\n-        throw new BugInCF(\"Did not find @SuppressWarnings: \" + tree);\n     }\n \n-    private BugInCF wrapThrowableAsBugInCF(String where, Throwable t, @Nullable TreePath p) {\n-        return new BugInCF(\n-                where\n-                        + \": unexpected Throwable (\"\n-                        + t.getClass().getSimpleName()\n-                        + \")\"\n-                        + ((p == null)\n-                                ? \"\"\n-                                : \" while processing \"\n-                                        + p.getCompilationUnit().getSourceFile().getName())\n-                        + (t.getMessage() == null ? \"\" : \"; message: \" + t.getMessage()),\n-                t);\n-    }\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Reporting type-checking errors; the main entry point is report()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3Mjc3Ng=="}, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 665}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMDA1NzI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNTozOTo0M1rOFy9LgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNjoxMDo0N1rOFy-VKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NTQ4OQ==", "bodyText": "Should this method be called warnUnneededSuppressions, like the other method above?\nHow does a developer chose between the two version?", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388975489", "createdAt": "2020-03-06T15:39:43Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -2053,100 +1634,551 @@ public final String getOption(String name, String defaultValue) {\n         if (activeOptions.containsKey(name)) {\n             return activeOptions.get(name);\n         } else {\n-            return defaultValue;\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * Map the Checker Framework version of {@link SupportedOptions} to the standard annotation\n+     * provided version {@link javax.annotation.processing.SupportedOptions}.\n+     */\n+    @Override\n+    public Set<String> getSupportedOptions() {\n+        Set<String> options = new HashSet<>();\n+\n+        // Support all options provided with the standard\n+        // {@link javax.annotation.processing.SupportedOptions}\n+        // annotation.\n+        options.addAll(super.getSupportedOptions());\n+\n+        // For the Checker Framework annotation\n+        // {@link org.checkerframework.framework.source.SupportedOptions}\n+        // we additionally add\n+        Class<?> clazz = this.getClass();\n+        List<Class<?>> clazzPrefixes = new ArrayList<>();\n+\n+        do {\n+            clazzPrefixes.add(clazz);\n+\n+            SupportedOptions so = clazz.getAnnotation(SupportedOptions.class);\n+            if (so != null) {\n+                options.addAll(expandCFOptions(clazzPrefixes, so.value()));\n+            }\n+            clazz = clazz.getSuperclass();\n+        } while (clazz != null\n+                && !clazz.getName().equals(AbstractTypeProcessor.class.getCanonicalName()));\n+\n+        return Collections.unmodifiableSet(options);\n+    }\n+\n+    /**\n+     * Generate the possible command-line option names by prefixing each class name from {@code\n+     * classPrefixes} to {@code options}, separated by {@link #OPTION_SEPARATOR}.\n+     *\n+     * @param clazzPrefixes the classes to prefix\n+     * @param options the option names\n+     * @return the possible combinations that should be supported\n+     */\n+    protected Collection<String> expandCFOptions(\n+            List<? extends Class<?>> clazzPrefixes, String[] options) {\n+        Set<String> res = new HashSet<>();\n+\n+        for (String option : options) {\n+            res.add(option);\n+            for (Class<?> clazz : clazzPrefixes) {\n+                res.add(clazz.getCanonicalName() + OPTION_SEPARATOR + option);\n+                res.add(clazz.getSimpleName() + OPTION_SEPARATOR + option);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Overrides the default implementation to always return a singleton set containing only \"*\".\n+     *\n+     * <p>javac uses this list to determine which classes process; javac only runs an annotation\n+     * processor on classes that contain at least one of the mentioned annotations. Thus, the effect\n+     * of returning \"*\" is as if the checker were annotated by\n+     * {@code @SupportedAnnotationTypes(\"*\")}: javac runs the checker on every class mentioned on\n+     * the javac command line. This method also checks that subclasses do not contain a {@link\n+     * SupportedAnnotationTypes} annotation.\n+     *\n+     * <p>To specify the annotations that a checker recognizes as type qualifiers, see {@link\n+     * AnnotatedTypeFactory#createSupportedTypeQualifiers()}.\n+     *\n+     * @throws Error if a subclass is annotated with {@link SupportedAnnotationTypes}\n+     */\n+    @Override\n+    public final Set<String> getSupportedAnnotationTypes() {\n+\n+        SupportedAnnotationTypes supported =\n+                this.getClass().getAnnotation(SupportedAnnotationTypes.class);\n+        if (supported != null) {\n+            throw new BugInCF(\n+                    \"@SupportedAnnotationTypes should not be written on any checker;\"\n+                            + \" supported annotation types are inherited from SourceChecker.\");\n+        }\n+        return Collections.singleton(\"*\");\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Warning suppression and unneeded warnings\n+    ///\n+\n+    /**\n+     * @return collection of lower-case string keys that a checker honors for suppressing warnings\n+     *     and errors that it issues. Each such key suppresses all warnings issued by the checker.\n+     * @see SuppressWarningsKeys\n+     */\n+    public Collection<String> getSuppressWarningsKeys() {\n+        return getStandardSuppressWarningsKeys();\n+    }\n+\n+    /**\n+     * Only ever called once; the value is cached in field {@link #suppressWarnings}.\n+     *\n+     * @param options the command-line options\n+     * @return the argument to -AsuppressWarnings, split on commas, or null if no such argument\n+     */\n+    private String @Nullable [] createSuppressWarnings(Map<String, String> options) {\n+        if (!options.containsKey(\"suppressWarnings\")) {\n+            return null;\n+        }\n+\n+        String swString = options.get(\"suppressWarnings\");\n+        if (swString == null) {\n+            return null;\n+        }\n+\n+        return arrayToLowerCase(swString.split(\",\"));\n+    }\n+\n+    /**\n+     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n+     * contains a key that would suppress a warning from this checker.\n+     */\n+    protected void warnUnneededSuppressions() {\n+        if (!hasOption(\"warnUnneededSuppressions\")) {\n+            return;\n+        }\n+\n+        Set<Element> elementsSuppress = new HashSet<>(this.elementsWithSuppressedWarnings);\n+        this.elementsWithSuppressedWarnings.clear();\n+        Set<String> checkerKeys = new HashSet<>(getSuppressWarningsKeys());\n+        Set<String> errorKeys = new HashSet<>(messagesProperties.stringPropertyNames());\n+        warnUnneedSuppressions(elementsSuppress, checkerKeys, errorKeys);\n+        getVisitor().treesWithSuppressWarnings.clear();\n+    }\n+\n+    /**\n+     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n+     * contains a key that would suppress a warning from this checker.\n+     *\n+     * @param elementsSuppress elements with a {@code @SuppressWarnings} that actually suppressed a\n+     *     warning\n+     * @param checkerKeys suppress warning keys that suppress any warning from this checker\n+     * @param errorKeys error keys that can be issued by this checker\n+     */\n+    protected void warnUnneedSuppressions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 1643}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5NDM0NQ==", "bodyText": "That was the name before, but I have changed it.", "url": "https://github.com/typetools/checker-framework/pull/3131#discussion_r388994345", "createdAt": "2020-03-06T16:10:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -2053,100 +1634,551 @@ public final String getOption(String name, String defaultValue) {\n         if (activeOptions.containsKey(name)) {\n             return activeOptions.get(name);\n         } else {\n-            return defaultValue;\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * Map the Checker Framework version of {@link SupportedOptions} to the standard annotation\n+     * provided version {@link javax.annotation.processing.SupportedOptions}.\n+     */\n+    @Override\n+    public Set<String> getSupportedOptions() {\n+        Set<String> options = new HashSet<>();\n+\n+        // Support all options provided with the standard\n+        // {@link javax.annotation.processing.SupportedOptions}\n+        // annotation.\n+        options.addAll(super.getSupportedOptions());\n+\n+        // For the Checker Framework annotation\n+        // {@link org.checkerframework.framework.source.SupportedOptions}\n+        // we additionally add\n+        Class<?> clazz = this.getClass();\n+        List<Class<?>> clazzPrefixes = new ArrayList<>();\n+\n+        do {\n+            clazzPrefixes.add(clazz);\n+\n+            SupportedOptions so = clazz.getAnnotation(SupportedOptions.class);\n+            if (so != null) {\n+                options.addAll(expandCFOptions(clazzPrefixes, so.value()));\n+            }\n+            clazz = clazz.getSuperclass();\n+        } while (clazz != null\n+                && !clazz.getName().equals(AbstractTypeProcessor.class.getCanonicalName()));\n+\n+        return Collections.unmodifiableSet(options);\n+    }\n+\n+    /**\n+     * Generate the possible command-line option names by prefixing each class name from {@code\n+     * classPrefixes} to {@code options}, separated by {@link #OPTION_SEPARATOR}.\n+     *\n+     * @param clazzPrefixes the classes to prefix\n+     * @param options the option names\n+     * @return the possible combinations that should be supported\n+     */\n+    protected Collection<String> expandCFOptions(\n+            List<? extends Class<?>> clazzPrefixes, String[] options) {\n+        Set<String> res = new HashSet<>();\n+\n+        for (String option : options) {\n+            res.add(option);\n+            for (Class<?> clazz : clazzPrefixes) {\n+                res.add(clazz.getCanonicalName() + OPTION_SEPARATOR + option);\n+                res.add(clazz.getSimpleName() + OPTION_SEPARATOR + option);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Overrides the default implementation to always return a singleton set containing only \"*\".\n+     *\n+     * <p>javac uses this list to determine which classes process; javac only runs an annotation\n+     * processor on classes that contain at least one of the mentioned annotations. Thus, the effect\n+     * of returning \"*\" is as if the checker were annotated by\n+     * {@code @SupportedAnnotationTypes(\"*\")}: javac runs the checker on every class mentioned on\n+     * the javac command line. This method also checks that subclasses do not contain a {@link\n+     * SupportedAnnotationTypes} annotation.\n+     *\n+     * <p>To specify the annotations that a checker recognizes as type qualifiers, see {@link\n+     * AnnotatedTypeFactory#createSupportedTypeQualifiers()}.\n+     *\n+     * @throws Error if a subclass is annotated with {@link SupportedAnnotationTypes}\n+     */\n+    @Override\n+    public final Set<String> getSupportedAnnotationTypes() {\n+\n+        SupportedAnnotationTypes supported =\n+                this.getClass().getAnnotation(SupportedAnnotationTypes.class);\n+        if (supported != null) {\n+            throw new BugInCF(\n+                    \"@SupportedAnnotationTypes should not be written on any checker;\"\n+                            + \" supported annotation types are inherited from SourceChecker.\");\n+        }\n+        return Collections.singleton(\"*\");\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// Warning suppression and unneeded warnings\n+    ///\n+\n+    /**\n+     * @return collection of lower-case string keys that a checker honors for suppressing warnings\n+     *     and errors that it issues. Each such key suppresses all warnings issued by the checker.\n+     * @see SuppressWarningsKeys\n+     */\n+    public Collection<String> getSuppressWarningsKeys() {\n+        return getStandardSuppressWarningsKeys();\n+    }\n+\n+    /**\n+     * Only ever called once; the value is cached in field {@link #suppressWarnings}.\n+     *\n+     * @param options the command-line options\n+     * @return the argument to -AsuppressWarnings, split on commas, or null if no such argument\n+     */\n+    private String @Nullable [] createSuppressWarnings(Map<String, String> options) {\n+        if (!options.containsKey(\"suppressWarnings\")) {\n+            return null;\n+        }\n+\n+        String swString = options.get(\"suppressWarnings\");\n+        if (swString == null) {\n+            return null;\n+        }\n+\n+        return arrayToLowerCase(swString.split(\",\"));\n+    }\n+\n+    /**\n+     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n+     * contains a key that would suppress a warning from this checker.\n+     */\n+    protected void warnUnneededSuppressions() {\n+        if (!hasOption(\"warnUnneededSuppressions\")) {\n+            return;\n+        }\n+\n+        Set<Element> elementsSuppress = new HashSet<>(this.elementsWithSuppressedWarnings);\n+        this.elementsWithSuppressedWarnings.clear();\n+        Set<String> checkerKeys = new HashSet<>(getSuppressWarningsKeys());\n+        Set<String> errorKeys = new HashSet<>(messagesProperties.stringPropertyNames());\n+        warnUnneedSuppressions(elementsSuppress, checkerKeys, errorKeys);\n+        getVisitor().treesWithSuppressWarnings.clear();\n+    }\n+\n+    /**\n+     * Issues a warning about any {@code @SuppressWarnings} that isn't used by this checker, but\n+     * contains a key that would suppress a warning from this checker.\n+     *\n+     * @param elementsSuppress elements with a {@code @SuppressWarnings} that actually suppressed a\n+     *     warning\n+     * @param checkerKeys suppress warning keys that suppress any warning from this checker\n+     * @param errorKeys error keys that can be issued by this checker\n+     */\n+    protected void warnUnneedSuppressions(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NTQ4OQ=="}, "originalCommit": {"oid": "8d985a1a5770da995ca82f49760b20eb1bdbb7ac"}, "originalPosition": 1643}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1877, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}