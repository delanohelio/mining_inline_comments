{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NDE2MDM1", "number": 3877, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDo1NToxMlrOE28wtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMjoxM1rOE2_stg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MDU0MDY5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDo1NToxMlrOHwBPuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMDo1NToxMlrOHwBPuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDExNDEwNA==", "bodyText": "org.checkerframework.javacutil.trees.TreeBuilder#buildLiteral seems to build a literal tree from a given value.\nYou should be able to do something like this:\n    public static LiteralTree buildLiteral(Object value, ProcessingEnvironment env) {\n        Context context = ((JavacProcessingEnvironment) env).getContext();\n         TreeMaker maker = TreeMaker.instance(context);\n        return maker.Literal(value);\n    }\n\n(This sort of method should be in TreeUtils.)\nIn case it's not easy to figure out.  Here are the imports for the code above:\nimport com.sun.tools.javac.tree.TreeMaker;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.processing.JavacProcessingEnvironment;", "url": "https://github.com/typetools/checker-framework/pull/3877#discussion_r520114104", "createdAt": "2020-11-09T20:55:12Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2174,4 +2181,76 @@ private boolean isRelevantHelper(TypeMirror tm) {\n                 throw new BugInCF(\"isRelevantHelper(%s): Unexpected TypeKind %s\", tm, tm.getKind());\n         }\n     }\n+\n+    /**\n+     * Return the type of the default value of the given type. The default value is 0, false, or\n+     * null.\n+     *\n+     * @param typeMirror a type\n+     * @return the annotated type of {@code type}'s default value\n+     */\n+    public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n+        return getAnnotatedType(getDefaultValueTree(typeMirror));\n+    }\n+\n+    /**\n+     * Return a tree for the default value of the given type. The default value is 0, false, or\n+     * null.\n+     *\n+     * @param typeMirror a type\n+     * @return a tree for {@code type}'s default value\n+     */\n+    private static LiteralTree getDefaultValueTree(TypeMirror typeMirror) {\n+        switch (typeMirror.getKind()) {\n+            case BYTE:\n+                return createJCLiteral(TypeTag.BYTE, (byte) 0, typeMirror);\n+            case CHAR:\n+                return createJCLiteral(TypeTag.CHAR, '\\u0000', typeMirror);\n+            case SHORT:\n+                return createJCLiteral(TypeTag.SHORT, (short) 0, typeMirror);\n+            case LONG:\n+                return createJCLiteral(TypeTag.LONG, 0L, typeMirror);\n+            case FLOAT:\n+                return createJCLiteral(TypeTag.FLOAT, 0.0f, typeMirror);\n+            case INT:\n+                return createJCLiteral(TypeTag.INT, 0, typeMirror);\n+            case DOUBLE:\n+                return createJCLiteral(TypeTag.DOUBLE, 0.0d, typeMirror);\n+            case BOOLEAN:\n+                return createJCLiteral(TypeTag.BOOLEAN, false, typeMirror);\n+            default:\n+                return createJCLiteral(TypeTag.BOT, null, typeMirror);\n+        }\n+    }\n+\n+    /** The constructor for the JCLiteral class. */\n+    private static Constructor<JCLiteral> jcLiteralConstructor;\n+\n+    {\n+        try {\n+            jcLiteralConstructor =\n+                    JCLiteral.class.getDeclaredConstructor(TypeTag.class, Object.class);\n+        } catch (NoSuchElementException | NoSuchMethodException e) {\n+            throw new BugInCF(e);\n+        }\n+        jcLiteralConstructor.setAccessible(true);\n+    }\n+\n+    /**\n+     * Calls the protected JCLiteral constructor.\n+     *\n+     * @param typeTag the literal's type tag\n+     * @param value the literal's value\n+     * @param typeMirror the typeMirror for the literal\n+     * @return a JCLiteral tree for the given type tag and value\n+     */\n+    private static JCLiteral createJCLiteral(TypeTag typeTag, Object value, TypeMirror typeMirror) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d726a544d24a676a79294c56bbac8325086ad27"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAxOTA0OnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMTowMFrOHwFuTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMTowMFrOHwFuTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzQ2OQ==", "bodyText": "maker.Literal(TypeTag.BOT, null) should be  maker.Literal(typeTag, value), right?  Why doesn't maker.Literal(typeTag, value) work? I don't think there are any test for this, so I can't check myself.", "url": "https://github.com/typetools/checker-framework/pull/3877#discussion_r520187469", "createdAt": "2020-11-09T23:31:00Z", "author": {"login": "smillst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "diffHunk": "@@ -1641,4 +1644,25 @@ public static boolean isWideningBinary(BinaryTree node) {\n             }\n         }\n     }\n+\n+    /**\n+     * Creates a LiteralTree for the given value.\n+     *\n+     * @param typeTag the literal's type tag\n+     * @param value a wrapped primitive, null, or a String\n+     * @param typeMirror the typeMirror for the literal\n+     * @param processingEnv the processing environment\n+     * @return a LiteralTree for the given type tag and value\n+     */\n+    public static LiteralTree createLiteral(\n+            TypeTag typeTag,\n+            Object value,\n+            TypeMirror typeMirror,\n+            ProcessingEnvironment processingEnv) {\n+        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\n+        TreeMaker maker = TreeMaker.instance(context);\n+        LiteralTree result = maker.Literal(TypeTag.BOT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bcca8cbc67a865485a9bbe07acec1ec58511a46"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MTAyMTk4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMjoxNFrOHwFwDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMzozMjoxNFrOHwFwDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE4NzkxOQ==", "bodyText": "This should be in TreeUtils because it imports a class from outside the support complier API, (com.sun.tools.javac.code.TypeTag).", "url": "https://github.com/typetools/checker-framework/pull/3877#discussion_r520187919", "createdAt": "2020-11-09T23:32:14Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2198,4 +2200,46 @@ private boolean isRelevantHelper(TypeMirror tm) {\n                 throw new BugInCF(\"isRelevantHelper(%s): Unexpected TypeKind %s\", tm, tm.getKind());\n         }\n     }\n+\n+    /**\n+     * Return the type of the default value of the given type. The default value is 0, false, or\n+     * null.\n+     *\n+     * @param typeMirror a type\n+     * @return the annotated type of {@code type}'s default value\n+     */\n+    // TODO: Cache results to avoid recomputation.\n+    public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n+        return getAnnotatedType(getDefaultValueTree(typeMirror));\n+    }\n+\n+    /**\n+     * Return a tree for the default value of the given type. The default value is 0, false, or\n+     * null.\n+     *\n+     * @param typeMirror a type\n+     * @return a tree for {@code type}'s default value\n+     */\n+    private LiteralTree getDefaultValueTree(TypeMirror typeMirror) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bcca8cbc67a865485a9bbe07acec1ec58511a46"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 905, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}