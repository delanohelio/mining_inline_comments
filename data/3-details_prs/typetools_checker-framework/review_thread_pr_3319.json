{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNTc3Mjc3", "number": 3319, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0ODoxMlrOEFmB5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowNjozOFrOEFmgQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzAxNDE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/poly/AbstractQualifierPolymorphism.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0ODoxMlrOGj4KMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0ODoxMlrOGj4KMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI3MzQ1OA==", "bodyText": "At least for the completer I think I would keep the separate non-anonymous class. The lambda contains a nested lambda and it get's quite hard to read.", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440273458", "createdAt": "2020-06-15T15:48:12Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/poly/AbstractQualifierPolymorphism.java", "diffHunk": "@@ -98,6 +98,33 @@ protected AbstractQualifierPolymorphism(\n         this.atypeFactory = factory;\n         this.qualHierarchy = factory.getQualifierHierarchy();\n         this.topQuals = new AnnotationMirrorSet(qualHierarchy.getTopAnnotations());\n+\n+        this.completer =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzAyMjc1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/AnnotatedTypeScanner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1MDoxN1rOGj4P1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1MDoxN1rOGj4P1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI3NDkwMQ==", "bodyText": "Should the overriden be overriding?", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440274901", "createdAt": "2020-06-15T15:50:17Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/AnnotatedTypeScanner.java", "diffHunk": "@@ -15,46 +16,140 @@\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedWildcardType;\n \n /**\n- * A TypeVisitor that visits all the child tree nodes. To visit types of a particular type, just\n- * override the corresponding visitXYZ method. Inside your method, call super.visitXYZ to visit\n- * descendant nodes.\n+ * An {@code AnnotatedTypeScanner} visits an {@link AnnotatedTypeMirror} and all of its child {@link\n+ * AnnotatedTypeMirror} and preforms some function depending on the kind of type. A {@link\n+ * SimpleAnnotatedTypeScanner} scans an {@link AnnotatedTypeMirror} and preforms the same function\n+ * regardless of the kind of type. The function returns some value with type {@link R} and takes an\n+ * argument of type {@link P}. If the function does not return any value, then {@code R} should be\n+ * {@link Void}. If the function takes not arguments, then {@code P} should be {@link Void}.\n  *\n- * <p>The default implementation of the visitXYZ methods will determine a result as follows:\n+ * <p>The default implementation of the visitAnnotatedTypeMirror methods will determine a result as\n+ * follows:\n  *\n  * <ul>\n- *   <li>If the node being visited has no children, the result will be null.\n- *   <li>If the node being visited has one child, the result will be the result of calling scan on\n- *       that child. The child may be a simple node or itself a list of nodes.\n- *   <li>If the node being visited has more than one child, the result will be determined by calling\n- *       scan each child in turn, and then combining the result of each scan after the first with\n- *       the cumulative result so far, as determined by the reduce(R, R) method. Each child may be\n- *       either a simple node or a list of nodes. The default behavior of the reduce method is such\n- *       that the result of the visitXYZ method will be the result of the last child scanned.\n+ *   <li>If the type being visited has no children, the {@link #defaultResult} is returned.\n+ *   <li>If the type being visited has one child, the result of visiting the child type is returned.\n+ *   <li>If the type being visited has more than one child, the result is determined by visiting\n+ *       each child in turn, and then combining the result of each with the cumulative result so\n+ *       far, as determined by the {@link #reduce} method.\n  * </ul>\n  *\n- * Here is an example to count the parameter types number of nodes in a tree:\n+ * The {@link #reduce} method combines the results of visiting child types. It can be specified by\n+ * passing an {@link Reduce} object to one of the constructors or by overriden the method directly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzAyNjA0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/AnnotatedTypeScanner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1MTowMFrOGj4Ryg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1MTowMFrOGj4Ryg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI3NTQwMg==", "bodyText": "Should overridden be overriding?", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440275402", "createdAt": "2020-06-15T15:51:00Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/AnnotatedTypeScanner.java", "diffHunk": "@@ -15,46 +16,140 @@\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedWildcardType;\n \n /**\n- * A TypeVisitor that visits all the child tree nodes. To visit types of a particular type, just\n- * override the corresponding visitXYZ method. Inside your method, call super.visitXYZ to visit\n- * descendant nodes.\n+ * An {@code AnnotatedTypeScanner} visits an {@link AnnotatedTypeMirror} and all of its child {@link\n+ * AnnotatedTypeMirror} and preforms some function depending on the kind of type. A {@link\n+ * SimpleAnnotatedTypeScanner} scans an {@link AnnotatedTypeMirror} and preforms the same function\n+ * regardless of the kind of type. The function returns some value with type {@link R} and takes an\n+ * argument of type {@link P}. If the function does not return any value, then {@code R} should be\n+ * {@link Void}. If the function takes not arguments, then {@code P} should be {@link Void}.\n  *\n- * <p>The default implementation of the visitXYZ methods will determine a result as follows:\n+ * <p>The default implementation of the visitAnnotatedTypeMirror methods will determine a result as\n+ * follows:\n  *\n  * <ul>\n- *   <li>If the node being visited has no children, the result will be null.\n- *   <li>If the node being visited has one child, the result will be the result of calling scan on\n- *       that child. The child may be a simple node or itself a list of nodes.\n- *   <li>If the node being visited has more than one child, the result will be determined by calling\n- *       scan each child in turn, and then combining the result of each scan after the first with\n- *       the cumulative result so far, as determined by the reduce(R, R) method. Each child may be\n- *       either a simple node or a list of nodes. The default behavior of the reduce method is such\n- *       that the result of the visitXYZ method will be the result of the last child scanned.\n+ *   <li>If the type being visited has no children, the {@link #defaultResult} is returned.\n+ *   <li>If the type being visited has one child, the result of visiting the child type is returned.\n+ *   <li>If the type being visited has more than one child, the result is determined by visiting\n+ *       each child in turn, and then combining the result of each with the cumulative result so\n+ *       far, as determined by the {@link #reduce} method.\n  * </ul>\n  *\n- * Here is an example to count the parameter types number of nodes in a tree:\n+ * The {@link #reduce} method combines the results of visiting child types. It can be specified by\n+ * passing an {@link Reduce} object to one of the constructors or by overriden the method directly.\n+ * If it is not otherwise specified, the reduce returns the first result if it is not null;\n+ * otherwise, the second result is returned. If the default result is nonnull and reduce never\n+ * returns null, then both parameters passed to reduce will be nonnull.\n  *\n- * <pre><code>\n- * class CountTypeVariable extends TreeScanner {\n+ * <p>When overridden a visitAnnotatedTypeMirror method, the returned expression should be {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzA1MjA4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/SimpleAnnotatedTypeScanner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1Njo1MVrOGj4h7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo1Njo1MVrOGj4h7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI3OTUzMg==", "bodyText": "Should the an be and? Or something else should be reformulated here.", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440279532", "createdAt": "2020-06-15T15:56:51Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/visitor/SimpleAnnotatedTypeScanner.java", "diffHunk": "@@ -9,9 +9,92 @@\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedPrimitiveType;\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedTypeVariable;\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedWildcardType;\n+import org.checkerframework.javacutil.BugInCF;\n \n+/**\n+ * An {@link AnnotatedTypeScanner} that scans an {@link AnnotatedTypeMirror} and performs some\n+ * {@link #defaultAction} on each type. The defaultAction can be passed to the constructor {@link\n+ * #SimpleAnnotatedTypeScanner(DefaultAction)} or this class can be extended an {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzA3MTU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/dependenttypes/DependentTypesHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowMTozNVrOGj4uDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowMTozNVrOGj4uDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4MjYzOQ==", "bodyText": "Couldn't you also pass the default action in the super call above?", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440282639", "createdAt": "2020-06-15T16:01:35Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/dependenttypes/DependentTypesHelper.java", "diffHunk": "@@ -829,37 +830,29 @@ private boolean isExpressionAnno(AnnotationMirror am) {\n      * returned.\n      */\n     private class ExpressionErrorChecker\n-            extends AnnotatedTypeScanner<List<DependentTypesError>, Void> {\n+            extends SimpleAnnotatedTypeScanner<List<DependentTypesError>, Void> {\n+\n+        /** Create ExpressionErrorChecker. */\n+        private ExpressionErrorChecker() {\n+            super(\n+                    (r1, r2) -> {\n+                        List<DependentTypesError> newList = new ArrayList<>(r1);\n+                        newList.addAll(r2);\n+                        return newList;\n+                    },\n+                    Collections.emptyList());\n+        }\n \n         @Override\n-        protected List<DependentTypesError> scan(AnnotatedTypeMirror type, Void aVoid) {\n+        protected List<DependentTypesError> defaultAction(AnnotatedTypeMirror type, Void aVoid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzA5MTg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/dependenttypes/DependentTypesHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowNjozOFrOGj46ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjowNjozOFrOGj46ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTg1NA==", "bodyText": "Could this be rewritten something like type.getAnnotations().stream().anyMatch(am -> isExpressionAnno(am))?", "url": "https://github.com/typetools/checker-framework/pull/3319#discussion_r440285854", "createdAt": "2020-06-15T16:06:38Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/dependenttypes/DependentTypesHelper.java", "diffHunk": "@@ -918,40 +911,22 @@ private boolean hasDependentType(AnnotatedTypeMirror atm) {\n         if (atm == null) {\n             return false;\n         }\n-        Boolean b = new ContainsDependentType().visit(atm);\n-        if (b == null) {\n-            return false;\n-        }\n+        boolean b =\n+                new SimpleAnnotatedTypeScanner<>(\n+                                (type, p) -> {\n+                                    for (AnnotationMirror am : type.getAnnotations()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0120a6ebe6437728b7b47e1621eabe59eed0cd3e"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1824, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}