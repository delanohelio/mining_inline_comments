{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjE5OTM4", "number": 3138, "title": "Make annotations repeatable; fixes #1307", "bodyText": "Merge after #3198.", "createdAt": "2020-03-08T03:09:15Z", "url": "https://github.com/typetools/checker-framework/pull/3138", "merged": true, "mergeCommit": {"oid": "a26c842df9ef5074361c5a2be25e161e294b90aa"}, "closed": true, "closedAt": "2020-03-30T13:04:00Z", "author": {"login": "mernst"}, "timelineItems": {"totalCount": 66, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbIN41XAH2gAyMzg1MjE5OTM4OmM3YmM4ZTc2YWMyYmYwYzEzODRjZmY5NzczY2Y3Mzg1MTQ1ODVjMWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSoGSDgH2gAyMzg1MjE5OTM4OjhhZWUzOTc4M2NlMDk5Y2Q4ZTQ4YjY2Y2MwM2E1Njg3NzIxMjI5M2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7bc8e76ac2bf0c1384cff9773cf738514585c1e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c7bc8e76ac2bf0c1384cff9773cf738514585c1e", "committedDate": "2019-08-12T01:37:10Z", "message": "Make annotations repeatable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eff8f9f6edc205f865ec29d0076a72f82d0ebf29", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/eff8f9f6edc205f865ec29d0076a72f82d0ebf29", "committedDate": "2019-08-15T17:07:15Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e98d839d50ddc81e58eb211e67e41b8bf064d16", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/7e98d839d50ddc81e58eb211e67e41b8bf064d16", "committedDate": "2019-08-15T18:09:51Z", "message": "Use inner annotation `List` as wrapper, consistently"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95b89737b84f98eb0c992d790e05468c3e942a4e", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/95b89737b84f98eb0c992d790e05468c3e942a4e", "committedDate": "2019-08-15T19:46:24Z", "message": "Whitespace change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5370f8635f6ea8fea76facadf30c10d7f02feb15", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5370f8635f6ea8fea76facadf30c10d7f02feb15", "committedDate": "2019-08-19T15:32:29Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e000f6a4b57c967bebd054049caaa5157121fe03", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e000f6a4b57c967bebd054049caaa5157121fe03", "committedDate": "2019-08-20T15:18:42Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bffa651f262a5bd7c6528329a837870baa95fc06", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/bffa651f262a5bd7c6528329a837870baa95fc06", "committedDate": "2019-08-20T23:58:58Z", "message": "Merge branch 'repeatable-annotations' of github.com:mernst/checker-framework into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6a450745f92cd662727a7b9cb7ab8953b0599d6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d6a450745f92cd662727a7b9cb7ab8953b0599d6", "committedDate": "2019-09-09T23:15:43Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d60eb4b64bc077712f653ee5de514873a942250", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8d60eb4b64bc077712f653ee5de514873a942250", "committedDate": "2019-09-13T16:41:55Z", "message": "Merge branch 'repeatable-annotations' of github.com:mernst/checker-framework into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d5c2fa26036f75cc6e7c8c0d48c25c9d4c65a8e", "author": {"user": {"login": "mdernsta", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1d5c2fa26036f75cc6e7c8c0d48c25c9d4c65a8e", "committedDate": "2019-09-13T16:42:14Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca5bf57d921e38c1dbf068f3191a80bebb5e97c8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ca5bf57d921e38c1dbf068f3191a80bebb5e97c8", "committedDate": "2019-10-27T23:43:19Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92b3f426188d8e4a8c3740f3d9f22f85f6ff9180", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/92b3f426188d8e4a8c3740f3d9f22f85f6ff9180", "committedDate": "2019-12-08T00:07:29Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d768892aa12458a0e8b7b92150330c44e62ebf6e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d768892aa12458a0e8b7b92150330c44e62ebf6e", "committedDate": "2019-12-08T00:21:17Z", "message": "Make more wrappers into inner classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3328440e226add2378d43ff3d0294b1f4b20625", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e3328440e226add2378d43ff3d0294b1f4b20625", "committedDate": "2019-12-08T00:27:17Z", "message": "Tweak changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28172a5be25f8f4ce091ac4c3c160645d90aa2f1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/28172a5be25f8f4ce091ac4c3c160645d90aa2f1", "committedDate": "2019-12-08T01:21:25Z", "message": "Don't use annotations that were removed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edd58759187e5c3e70d2c8e52a9058be50a79387", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/edd58759187e5c3e70d2c8e52a9058be50a79387", "committedDate": "2019-12-08T03:55:08Z", "message": "Tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7733f1164351d1b5f5237228cedf9c86ed1e668", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a7733f1164351d1b5f5237228cedf9c86ed1e668", "committedDate": "2019-12-08T06:01:35Z", "message": "Use interface rather than class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b857c664624720bb406b39131c4bc20fe62d59a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5b857c664624720bb406b39131c4bc20fe62d59a", "committedDate": "2019-12-08T16:51:51Z", "message": "Typo fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1305eaac4656fad32bace0b3d7db2a90386c6f1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e1305eaac4656fad32bace0b3d7db2a90386c6f1", "committedDate": "2019-12-08T18:23:16Z", "message": "Fix grammar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9257c661c837601ec62541c15639987bad426412", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9257c661c837601ec62541c15639987bad426412", "committedDate": "2019-12-08T18:23:30Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c57390dc48b9b18b3a10f0384782ba4328e6575", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0c57390dc48b9b18b3a10f0384782ba4328e6575", "committedDate": "2019-12-08T18:27:29Z", "message": "Fix grammar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f013251e58b44910cc1a29678461abfb8337a7f3", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f013251e58b44910cc1a29678461abfb8337a7f3", "committedDate": "2019-12-08T18:45:11Z", "message": "Update documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a1641fa5821e96c0d272a36071b3b524fa38d39", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8a1641fa5821e96c0d272a36071b3b524fa38d39", "committedDate": "2019-12-09T04:46:11Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa291783d7f26c9f4eea507bb85003a61948f449", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/aa291783d7f26c9f4eea507bb85003a61948f449", "committedDate": "2019-12-09T04:47:08Z", "message": "Merge branch 'master' of github.com:typetools/checker-framework"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41719e0bdb20dd3b37957e86d71c7fd467888b86", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/41719e0bdb20dd3b37957e86d71c7fd467888b86", "committedDate": "2019-12-09T04:47:28Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c8f03166e874d842e564e7b3df3c354882c8414", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5c8f03166e874d842e564e7b3df3c354882c8414", "committedDate": "2019-12-09T04:53:35Z", "message": "Undo changes in logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a4e17fe3554e9beb4f28393ec4b9b1193c5ead5", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9a4e17fe3554e9beb4f28393ec4b9b1193c5ead5", "committedDate": "2019-12-10T16:12:32Z", "message": "Change directory name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e571e5d38277892fa6a83023440283ee57365fac", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e571e5d38277892fa6a83023440283ee57365fac", "committedDate": "2019-12-10T16:12:54Z", "message": "Improve diagnostics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89b831749a3aa5a60f98323cb779e3ff2138981e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/89b831749a3aa5a60f98323cb779e3ff2138981e", "committedDate": "2019-12-10T16:13:13Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0119aa1cc7b22f13c86002a09ff8dd3bccd16efe", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0119aa1cc7b22f13c86002a09ff8dd3bccd16efe", "committedDate": "2019-12-14T03:04:39Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cb86199e309406ae9a7ced6fb08a875847b0ca1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3cb86199e309406ae9a7ced6fb08a875847b0ca1", "committedDate": "2019-12-14T16:12:28Z", "message": "Add diagnostics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b304b4c802897f11dbbf46d1abd71819cf7e55b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4b304b4c802897f11dbbf46d1abd71819cf7e55b", "committedDate": "2019-12-22T20:58:48Z", "message": "Small changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13edafe5059595c4e66c111a90add302825a69e7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/13edafe5059595c4e66c111a90add302825a69e7", "committedDate": "2019-12-22T20:59:57Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16af1f6b5ba745a54f8e1b6cefbbb2602cbd63ad", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/16af1f6b5ba745a54f8e1b6cefbbb2602cbd63ad", "committedDate": "2019-12-22T21:03:33Z", "message": "Add new test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a7fe46fc945af808c0d75527e751f7829906ec6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2a7fe46fc945af808c0d75527e751f7829906ec6", "committedDate": "2019-12-22T21:03:57Z", "message": "Complete test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2f1534e3da425a3b5e82e00b56f8c7d6288f87f", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/e2f1534e3da425a3b5e82e00b56f8c7d6288f87f", "committedDate": "2019-12-22T21:09:41Z", "message": "Fix compilation failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b19bd8ef842d22e85221ed4c6ce639b3ba36b35", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2b19bd8ef842d22e85221ed4c6ce639b3ba36b35", "committedDate": "2020-01-29T19:47:49Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a75c87c20b325daf430ad82b738b164202a335e7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a75c87c20b325daf430ad82b738b164202a335e7", "committedDate": "2020-03-07T21:56:26Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07cf0eff59a1408373c75c4e91c247b1d1a2b61a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/07cf0eff59a1408373c75c4e91c247b1d1a2b61a", "committedDate": "2020-03-08T02:03:25Z", "message": "Handle wrappers for repeated annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f51c87041a0ce0a03d6088647ba33aafc1dbbd2", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3f51c87041a0ce0a03d6088647ba33aafc1dbbd2", "committedDate": "2020-03-11T06:30:52Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97010040ffd2ecf72ce5b6651466c9cbe74f9887", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/97010040ffd2ecf72ce5b6651466c9cbe74f9887", "committedDate": "2020-03-11T08:12:47Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "720a71c74808e00f6decbbb60677b5b8fb0b0292", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/720a71c74808e00f6decbbb60677b5b8fb0b0292", "committedDate": "2020-03-11T15:51:35Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8529ccec98a07fab5995199500cc012313e1e331", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8529ccec98a07fab5995199500cc012313e1e331", "committedDate": "2020-03-11T16:34:15Z", "message": "Add Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cbea90daecc705347b33e1b254b616d632cfff7", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/2cbea90daecc705347b33e1b254b616d632cfff7", "committedDate": "2020-03-13T00:10:16Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e8110d0bf5383c46cfb147734aa971a29f7d6ec", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0e8110d0bf5383c46cfb147734aa971a29f7d6ec", "committedDate": "2020-03-13T00:10:46Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d88b8258687a00e787fc5a03004ceb0afde3b797", "committedDate": "2020-03-16T00:14:58Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjE5MTk4", "url": "https://github.com/typetools/checker-framework/pull/3138#pullrequestreview-379619198", "createdAt": "2020-03-23T16:48:36Z", "commit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjo0ODozNlrOF6OfGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzozMjo1M1rOF6QZPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5OTA2NA==", "bodyText": "Could you add a comment why these are not the annotations in the annotated JDK?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396599064", "createdAt": "2020-03-23T16:48:36Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness-stubfile/stubfile-ensuresnonnullif.astub", "diffHunk": "@@ -0,0 +1,14 @@\n+import org.checkerframework.checker.nullness.qual.*;\n+\n+package java.lang;\n+\n+public final class String {\n+\n+  @EnsuresNonNullIf(expression={\"#1\"}, result=true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5OTI5NA==", "bodyText": "Do we need these commented-out lines?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396599294", "createdAt": "2020-03-23T16:48:52Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness-stubfile/stubfile-ensuresnonnullif.astub", "diffHunk": "@@ -0,0 +1,14 @@\n+import org.checkerframework.checker.nullness.qual.*;\n+\n+package java.lang;\n+\n+public final class String {\n+\n+  @EnsuresNonNullIf(expression={\"#1\"}, result=true)\n+  public boolean startsWith(@Nullable String prefix);\n+  @EnsuresNonNullIf(expression=\"#1\", result=true)\n+  public boolean endsWith(@Nullable String suffix);\n+\n+  // public boolean contentEquals(@GuardSatisfied StringBuffer sb);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMTIyMg==", "bodyText": "The naming of many of these test files is a bit confusing. Could you add the Ensures etc. word to the test files? For some, e.g. the jtreg tests, you already do this.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396601222", "createdAt": "2020-03-23T16:51:36Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness/RepeatNonNull.java", "diffHunk": "@@ -0,0 +1,91 @@\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public class RepeatNonNull {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNTA1MA==", "bodyText": "How do I chose between the two options?\nIs one when I'm declaring a single annotation and the other when I declare a repeatable annotation? But the repeatable annotation wouldn't contain a result, would it?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396605050", "createdAt": "2020-03-23T16:57:10Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/qual/ConditionalPostconditionAnnotation.java", "diffHunk": "@@ -11,11 +11,17 @@\n  * A meta-annotation that indicates that an annotation E is a conditional postcondition annotation,\n  * i.e., E is a type-specialized version of {@link EnsuresQualifierIf}.\n  *\n- * <p>The annotation E that is meta-annotated as {@link ConditionalPostconditionAnnotation} must\n- * have an element called {@code expression} that is an array of {@code String}s of the same format\n- * and with the same meaning as the value {@code expression} in {@link EnsuresQualifierIf}. E must\n- * also have an element {@code result} with the same meaning as the element {@code result} in {@link\n- * EnsuresQualifierIf}.\n+ * <ul>\n+ *   <li>E must have one of the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNjM1MQ==", "bodyText": "I'm also not clear here how to chose between the two options.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396606351", "createdAt": "2020-03-23T16:58:49Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/qual/PostconditionAnnotation.java", "diffHunk": "@@ -11,9 +11,12 @@\n  * A meta-annotation that indicates that an annotation E is a postcondition annotation, i.e., E is a\n  * type-specialized version of {@link EnsuresQualifier}.\n  *\n- * <p>The annotation E that is meta-annotated as {@link PostconditionAnnotation} must have an\n- * element called {@code value} that is an array of {@code String}s of the same format and with the\n- * same meaning as the value {@code expression} in {@link EnsuresQualifier}.\n+ * <p>E must have an element {@code value} that is one of the following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwOTkzMQ==", "bodyText": "Should this field be private or protected?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396609931", "createdAt": "2020-03-23T17:03:49Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMDE0MQ==", "bodyText": "Can the field be final?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396610141", "createdAt": "2020-03-23T17:04:09Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMDkzMQ==", "bodyText": "Should this method be private or protected?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396610931", "createdAt": "2020-03-23T17:05:20Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotation(AnnotationMirror a) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMTA2Ng==", "bodyText": "Should this method be private or protected?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396611066", "createdAt": "2020-03-23T17:05:32Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        if (!isListForRepeatedAnnotationCache.containsKey(a)) {\n+            isListForRepeatedAnnotationCache.put(a, isListForRepeatedAnnotationImplementation(a));\n+        }\n+        return isListForRepeatedAnnotationCache.get(a);\n+    }\n+\n+    /**\n+     * Returns true if the annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a the annotation to test\n+     * @return true if the annotation is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotationImplementation(AnnotationMirror a) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMDMzMw==", "bodyText": "From the diffs in this file it seems a bit odd why these new imports are required.\nDo you see the reason?", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396630333", "createdAt": "2020-03-23T17:32:53Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/Contract.java", "diffHunk": "@@ -7,12 +7,12 @@\n import org.checkerframework.framework.qual.ConditionalPostconditionAnnotation;\n import org.checkerframework.framework.qual.EnsuresQualifier;\n import org.checkerframework.framework.qual.EnsuresQualifierIf;\n-import org.checkerframework.framework.qual.EnsuresQualifiers;\n-import org.checkerframework.framework.qual.EnsuresQualifiersIf;\n import org.checkerframework.framework.qual.PostconditionAnnotation;\n import org.checkerframework.framework.qual.PreconditionAnnotation;\n import org.checkerframework.framework.qual.RequiresQualifier;\n-import org.checkerframework.framework.qual.RequiresQualifiers;\n+import org.checkerframework.framework.util.Contract.ConditionalPostcondition;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "725734fe16d6b6b9c3f146ea990149aa2a2b1690", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/725734fe16d6b6b9c3f146ea990149aa2a2b1690", "committedDate": "2020-03-23T22:10:14Z", "message": "Remove unnecessary imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "208449471abd46accd660ec69bf58884628d4079", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/208449471abd46accd660ec69bf58884628d4079", "committedDate": "2020-03-23T22:17:18Z", "message": "Remove a stub file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9b46d599ee493176a12424a01a7d1d5f9da71ed", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b9b46d599ee493176a12424a01a7d1d5f9da71ed", "committedDate": "2020-03-23T22:19:51Z", "message": "Rename test files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "331b7e38e64900f274ed207775aedfd220d2208b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/331b7e38e64900f274ed207775aedfd220d2208b", "committedDate": "2020-03-23T22:27:45Z", "message": "Add `private` modifiers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef6ffb11ddb0060c47fe54de81f651ad3b576874", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ef6ffb11ddb0060c47fe54de81f651ad3b576874", "committedDate": "2020-03-23T22:28:45Z", "message": "Remove test that goes along with removed stub file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "255c39a8c9f86f6aa2cf1cc63652d4b1df3654f3", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/255c39a8c9f86f6aa2cf1cc63652d4b1df3654f3", "committedDate": "2020-03-23T22:29:33Z", "message": "Add `final` modifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12ca01fdd864b0f52c1a265b7ad2fe5a488b1114", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/12ca01fdd864b0f52c1a265b7ad2fe5a488b1114", "committedDate": "2020-03-23T22:35:09Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90f61f5e240473a0ea2deba8de07a32ce8399cb", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a90f61f5e240473a0ea2deba8de07a32ce8399cb", "committedDate": "2020-03-23T22:37:49Z", "message": "Javadoc fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/6b46ea13e4427365901c6f4c2202f7cd032a2171", "committedDate": "2020-03-23T22:48:03Z", "message": "Clarify Javadoc comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMDg0NTcw", "url": "https://github.com/typetools/checker-framework/pull/3138#pullrequestreview-382084570", "createdAt": "2020-03-26T14:48:50Z", "commit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo0ODo1MFrOF8KkOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTowMzowMVrOF8LQfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMTk5Mg==", "bodyText": "This should move down into the upcoming 3.3.0 release.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398631992", "createdAt": "2020-03-26T14:48:50Z", "author": {"login": "wmdietl"}, "path": "changelog.txt", "diffHunk": "@@ -1,3 +1,14 @@\n+All postcondition annotations are repeatable (e.g., `@EnsuresNonNull`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMzEwMA==", "bodyText": "The trailing colon shouldn't be necessary any longer.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398633100", "createdAt": "2020-03-26T14:50:11Z", "author": {"login": "wmdietl"}, "path": "checker/src/test/java/tests/NullnessStubfileTest.java", "diffHunk": "@@ -17,7 +17,7 @@ public NullnessStubfileTest(List<File> testFiles) {\n                 \"-AstubWarnIfNotFound\",\n                 \"-Astubs=\"\n                         + \"tests/nullness-stubfile/stubfile1.astub:\"\n-                        + \"tests/nullness-stubfile/stubfile2.astub\");\n+                        + \"tests/nullness-stubfile/stubfile2.astub:\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNDg5MQ==", "bodyText": "You could push these unrelated changes separately to have a more suitable commit message for the change.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398634891", "createdAt": "2020-03-26T14:52:27Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/Analysis.java", "diffHunk": "@@ -124,18 +124,20 @@ public void setCurrentTree(Tree currentTree) {\n         this.currentTree = currentTree;\n     }\n \n+    // `@code`, not `@link`, because dataflow module doesn't depend on framework moduel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0MTUxOA==", "bodyText": "I'm wondering whether this cache should be set with the other caches in the constructor (using CollectionUtils.createLRUCache(cacheSize)) and whether it should be cleared in setRoot, like other caches.\nOtherwise, couldn't this cache grow arbitrarily large, as there can be many different repeated annotations that all have distinct AnnotationMirrors.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398641518", "createdAt": "2020-03-26T15:00:37Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0MzMyNw==", "bodyText": "Should this use a variant of AnnotationUtils.containsSame, to account for AnnotationMirrors coming either from the compiler or a stub file?\nOr maybe this should be rewritten to use the type from the AnnotationMirror (from getAnnotationType()), which will be easier to compare and of which there will be many fewer of (addressing my caching concern above).", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398643327", "createdAt": "2020-03-26T15:03:01Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        if (!isListForRepeatedAnnotationCache.containsKey(a)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a754ff275b924c2c9c4edc25377a0fc3ed45893", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1a754ff275b924c2c9c4edc25377a0fc3ed45893", "committedDate": "2020-03-26T15:19:59Z", "message": "Optimistically move changes into upcoming release"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51adf46f985c095cc25061c9856dc71c2e717586", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/51adf46f985c095cc25061c9856dc71c2e717586", "committedDate": "2020-03-26T15:20:57Z", "message": "Remove colon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f591ca8dfc21eb2f0de626e147b986d574cecb7a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f591ca8dfc21eb2f0de626e147b986d574cecb7a", "committedDate": "2020-03-26T15:21:33Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9353588f21ee9a0e322214c9b54bc370d60d548", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c9353588f21ee9a0e322214c9b54bc370d60d548", "committedDate": "2020-03-26T15:54:06Z", "message": "Reduce size of cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0602e2424dabb88f36a123785308149490be9a6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c0602e2424dabb88f36a123785308149490be9a6", "committedDate": "2020-03-26T15:56:14Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNTA0MDEz", "url": "https://github.com/typetools/checker-framework/pull/3138#pullrequestreview-382504013", "createdAt": "2020-03-27T00:13:25Z", "commit": {"oid": "c0602e2424dabb88f36a123785308149490be9a6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxMzoyNVrOF8e7NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxMzoyNVrOF8e7NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2NTU1Ng==", "bodyText": "It would be good to document the naming and nesting requirement, maybe in the \"how to write a checker\" section of the manual.\nAlso, this is related to the TODO below, as this naming convention shouldn't be a strict requirement.", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398965556", "createdAt": "2020-03-27T00:13:25Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3265,13 +3264,66 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n             // First call copier, if exception, continue normal modula laws.\n             for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n                 if (areSameByClass(ma, metaAnnotationClass)) {\n-                    result.add(Pair.of(candidate, ma));\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<DeclaredType, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        DeclaredType annotationType = a.getAnnotationType();\n+        Boolean resultObject = isListForRepeatedAnnotationCache.get(annotationType);\n+        if (resultObject != null) {\n+            return resultObject;\n+        }\n+        boolean result = isListForRepeatedAnnotationImplementation(annotationType);\n+        isListForRepeatedAnnotationCache.put(annotationType, result);\n+        return result;\n+    }\n+\n+    /**\n+     * Returns true if the annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param annotationType the declaration of the annotation to test\n+     * @return true if the annotation is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotationImplementation(DeclaredType annotationType) {\n+        TypeMirror enclosingType = annotationType.getEnclosingType();\n+        if (enclosingType == null) {\n+            return false;\n+        }\n+        if (!annotationType.asElement().getSimpleName().contentEquals(\"List\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0602e2424dabb88f36a123785308149490be9a6"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0ea5503b1cfe968e6a86bf73e3927c8cc713be1", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c0ea5503b1cfe968e6a86bf73e3927c8cc713be1", "committedDate": "2020-03-27T20:36:28Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76e25c1186bf09daf1f286867eb866de1a881915", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/76e25c1186bf09daf1f286867eb866de1a881915", "committedDate": "2020-03-27T20:52:41Z", "message": "How to make a pre- or post-condition annotation repeatable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8aee39783ce099cd8e48b66cc03a56877212293a", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8aee39783ce099cd8e48b66cc03a56877212293a", "committedDate": "2020-03-30T05:59:47Z", "message": "Merge ../checker-framework-branch-master into repeatable-annotations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3107, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}