{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MTY0NDM1", "number": 3063, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODo1NjoxN1rODa_Hlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNzoyNlrODsIZMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjIzNzAyOnYy", "diffSide": "RIGHT", "path": "docs/manual/nullness-checker.tex", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxODo1NjoxN1rOFiNtLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMDo1Mjo1OVrOFj5jiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQyMDQ2Mw==", "bodyText": "I notice that this is different than using javadoc.stub, for which the docs say to include checker.jar in the parameter value: -Astubs=checker.jar/javadoc.astub. That difference seems quite possibly fine, since this new astub file in a different location (which perhaps the Checker Framework scans by default?), but I figured I'd check.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371420463", "createdAt": "2020-01-27T18:56:17Z", "author": {"login": "cpovirk"}, "path": "docs/manual/nullness-checker.tex", "diffHunk": "@@ -96,6 +96,20 @@\n   See Section~\\ref{nullness-arrays} for a discussion.\n   % TODO: this option is temporary and the sound option\n   % should become the default.\n+\n+\\item\n+  \\label{collection-object-parameters-may-be-null}\n+  If you supply the\n+  \\code{-Astubs=collection-object-parameters-may-be-null.astub}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MjEwOA==", "bodyText": "Because collection-object-parameters-may-be-null.astub is in the same directory as the Nullness Checker, it will automatically be found. You only need to add checker.jar/ is the stub file is in the top level directory of the jar.  (Also, good to ask, though.)", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371962108", "createdAt": "2020-01-28T17:54:48Z", "author": {"login": "smillst"}, "path": "docs/manual/nullness-checker.tex", "diffHunk": "@@ -96,6 +96,20 @@\n   See Section~\\ref{nullness-arrays} for a discussion.\n   % TODO: this option is temporary and the sound option\n   % should become the default.\n+\n+\\item\n+  \\label{collection-object-parameters-may-be-null}\n+  If you supply the\n+  \\code{-Astubs=collection-object-parameters-may-be-null.astub}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQyMDQ2Mw=="}, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NzQ2NQ==", "bodyText": "javadoc.astub is at the top level because it has annotations for multiple type systems.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r373187465", "createdAt": "2020-01-30T20:52:59Z", "author": {"login": "mernst"}, "path": "docs/manual/nullness-checker.tex", "diffHunk": "@@ -96,6 +96,20 @@\n   See Section~\\ref{nullness-arrays} for a discussion.\n   % TODO: this option is temporary and the sound option\n   % should become the default.\n+\n+\\item\n+  \\label{collection-object-parameters-may-be-null}\n+  If you supply the\n+  \\code{-Astubs=collection-object-parameters-may-be-null.astub}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQyMDQ2Mw=="}, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjMwMTEzOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToxNjo1NFrOFiOVVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMToxOTowM1rOFj6QHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMDc0MA==", "bodyText": "At a high level, I see 3 cases:\n\nthe interfaces themselves (like List)\nthe skeletal abstract classes (like AbstractList)\nthe concrete implementations (like ArrayList)\n\nFor (1), we're here exactly because we're aiming to make conservative assumptions by default (though allow them to be loosened with stub files). So we don't want @Nullable on parameters there.\nJumping ahead to (3), I would have guessed that classes like ArrayList would have @Nullable on their parameters, since their implementations support null inputs and their docs reflect this (and the Checker Framework supports generalizing parameter types). I can see a couple possible arguments against that, though I have reservations about each:\n\nFirst, users rarely store objects in variables/fields whose static type is ArrayList, anyway, so the annotations on ArrayList itself rarely matter. (The argument about static types might become somewhat less true as users adopt var.)\nSecond, users can extend ArrayList and override this method to reject null inputs. Taken to the extreme, this seems like an argument against putting @Nullable on a parameter of any extensible method -- and an argument for putting @Nullable on the return value of every extensible method (since anyone might override it to return null). So I think at some point we have to take a stand on which of those overrides are valid and which aren't. Given that ArrayList doesn't document that its methods throw NullPointerException, I'd expect us to permit null here (unless the other argument above this one holds sway).\n\nComing back to (2), I think that's more like (1): Even though a given implementation might support null, the classes that override it might not, and the docs reflect this.\nSo the interesting question is likely to be (3).", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371430740", "createdAt": "2020-01-27T19:16:54Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "diffHunk": "@@ -181,7 +181,7 @@ public E remove(int index) {\n      * @throws NullPointerException {@inheritDoc}\n      */\n     @Pure\n-    public int indexOf(@Nullable Object o) {\n+    public int indexOf(Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE5ODg3Nw==", "bodyText": "My analysis is similar to yours:  @Nullable on any class that makes a commitment to handle null, such as ArrayList, but not on classes that don't make a commitment (like most interfaces and abstract classes).\nYou are right that ArrayList should have @Nullable on its parameters.  Sorry for that mistake; I have corrected it.  (It looks like I overlooked it because it uses slightly different wording about null than other classes.)\n\nusers can extend ArrayList and override this method to reject null inputs.\nSubtypes of ArrayList must also permit null values.  If a subclass of ArrayList were to forbid null elements, it would violate a commitment made by ArrayList, would violate behavioral subtyping, and the Nullness Checker would yield an error when type-checking it.\n\nAre there any other classes that are incorrectly annotated?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r373198877", "createdAt": "2020-01-30T21:19:03Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "diffHunk": "@@ -181,7 +181,7 @@ public E remove(int index) {\n      * @throws NullPointerException {@inheritDoc}\n      */\n     @Pure\n-    public int indexOf(@Nullable Object o) {\n+    public int indexOf(Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMDc0MA=="}, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjMwNTQ2OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxOToxODowM1rOFiOXzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMTozNDozNlrOFj6qJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMTM3NA==", "bodyText": "Do these stubs still need bounds, like <E extends @NonNull Object> in this case?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371431374", "createdAt": "2020-01-27T19:18:03Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,152 @@\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean add(@Nullable E e);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public class PriorityQueue<E> extends AbstractQueue<E>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIwNTU0MQ==", "bodyText": "They do not need them.  Because nothing is written there, the bounds from the annotated JDK are used.\nIt would do no harm to write them, and if you think it would be clearer to do so, I can do that.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r373205541", "createdAt": "2020-01-30T21:34:36Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,152 @@\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean add(@Nullable E e);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public class PriorityQueue<E> extends AbstractQueue<E>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMTM3NA=="}, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTYwOTIzOnYy", "diffSide": "LEFT", "path": "checker/jdk/nullness/src/java/util/ArrayList.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzoyNzo1N1rOFit7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzoyNzo1N1rOFit7ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0ODM4OQ==", "bodyText": "This should stay @Nullable because null is allowed according to the Javadoc. That's true for all the changes in this file.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371948389", "createdAt": "2020-01-28T17:27:57Z", "author": {"login": "smillst"}, "path": "checker/jdk/nullness/src/java/util/ArrayList.java", "diffHunk": "@@ -290,7 +290,7 @@ public boolean isEmpty() {\n      * @return <tt>true</tt> if this list contains the specified element\n      */\n     @Pure\n-    public boolean contains(@Nullable Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTYyMTIxOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNzozMTo0NVrOFiuDHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0ODo0MFrOF4SgCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MDM2NQ==", "bodyText": "This class can be removed if the annotations on ArrayList in the annotated JDK are changed.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r371950365", "createdAt": "2020-01-28T17:31:45Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,152 @@\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NzY4OA==", "bodyText": "I was wondering about this also. In fact, it looks like the annotations on ArrayList in the annotated JDK already match what's here.\nNot that there's any harm in redeclaring them, especially if it's easier for you to generate or organize the stub file that way.\nI think I saw some other classes that were technically redundant, like PriorityQueue.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394567688", "createdAt": "2020-03-18T18:48:40Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,152 @@\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1MDM2NQ=="}, "originalCommit": {"oid": "dd9f7b1c530476dee0e8882247c42f0c96714d2c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTE5OTk0OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentLinkedDeque.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoxNjoxMlrOFlB49g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoxNjoxMlrOFlB49g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3MjU5OA==", "bodyText": "Docs and testing suggest that the parameter to this contains can be null. Note that that's not true of remove below, so definitely keep that one unchanged, as you currently have it.\nThis does raise an additional question -- whether it makes sense to put @Nullable here when contains(null) would always return safely but only by returning false. The advantage would be for a user who happens to have, say, a @Nullable E to pass to this method. Supporting such users is much the reason that Java made contains accept an Object in the first place, rather than an E. But I'm not sure if it's best to emulate that or not.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r374372598", "createdAt": "2020-02-03T22:16:12Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentLinkedDeque.java", "diffHunk": "@@ -1101,7 +1101,7 @@ public boolean removeLastOccurrence(Object o) {\n      * @param o element whose presence in this deque is to be tested\n      * @return {@code true} if this deque contains the specified element\n      */\n-    @Pure public boolean contains(@Nullable Object o) {\n+    @Pure public boolean contains(Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTIwMTUyOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentLinkedQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoxNjo0MFrOFlB52Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoxNjo0MFrOFlB52Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3MjgyNQ==", "bodyText": "In this file, both contains and remove can accept null.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r374372825", "createdAt": "2020-02-03T22:16:40Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentLinkedQueue.java", "diffHunk": "@@ -491,7 +491,7 @@ else if (p == q)\n      * @param o element to be removed from this queue, if present\n      * @return {@code true} if this queue changed as a result of the call\n      */\n-    public boolean remove(@Nullable Object o) {\n+    public boolean remove(Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTIxMDgzOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/Collection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoyMDoxMFrOFlB_nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzo0MzoyNFrOF1o1gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NDMwMA==", "bodyText": "We'd probably want for containsAll, removeAll, and retainAll to require Collection<? extends Object> (or Collection<? extends @NonNull Object> if it's necessary to be explicit here, but I don't think so?).\nThat also goes for the redeclarations on List and Set.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r374374300", "createdAt": "2020-02-03T22:20:10Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/Collection.java", "diffHunk": "@@ -323,7 +323,7 @@\n      * @throws UnsupportedOperationException if the <tt>remove</tt> operation\n      *         is not supported by this collection\n      */\n-    boolean remove(@Nullable Object o);\n+    boolean remove(Object o);\n \n \n     // Bulk Operations", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzkwNA==", "bodyText": "Great point!  I overlooked those methods.  Thanks for pointing them out.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r391787904", "createdAt": "2020-03-12T17:43:24Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/Collection.java", "diffHunk": "@@ -323,7 +323,7 @@\n      * @throws UnsupportedOperationException if the <tt>remove</tt> operation\n      *         is not supported by this collection\n      */\n-    boolean remove(@Nullable Object o);\n+    boolean remove(Object o);\n \n \n     // Bulk Operations", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NDMwMA=="}, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTIxNDEwOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/AbstractMap.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoyMToxOVrOFlCBlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNzo0MzozM1rOF1o14w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NDgwNw==", "bodyText": "Other methods in this class that would benefit from @Nullable Object parameters: containsValue, get, remove.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r374374807", "createdAt": "2020-02-03T22:21:19Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/AbstractMap.java", "diffHunk": "@@ -153,7 +153,7 @@ public boolean containsValue(@Nullable Object value) {\n      */\n     @Pure\n     @EnsuresKeyForIf(result=true, expression=\"#1\", map=\"this\")\n-    public boolean containsKey(@Nullable Object key) {\n+    public boolean containsKey(Object key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4ODAwMw==", "bodyText": "AbstractMap specifies that a NullPointerException is possible from all of those methods.  :-(", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r391788003", "createdAt": "2020-03-12T17:43:33Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/AbstractMap.java", "diffHunk": "@@ -153,7 +153,7 @@ public boolean containsValue(@Nullable Object value) {\n      */\n     @Pure\n     @EnsuresKeyForIf(result=true, expression=\"#1\", map=\"this\")\n-    public boolean containsKey(@Nullable Object key) {\n+    public boolean containsKey(Object key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NDgwNw=="}, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTIxNjAwOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/PriorityQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoyMTo1M1rOFlCCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjoyMTo1M1rOFlCCpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NTA3OA==", "bodyText": "These remove and contains methods both accept null.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r374375078", "createdAt": "2020-02-03T22:21:53Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/PriorityQueue.java", "diffHunk": "@@ -18,8 +18,8 @@\n   public boolean add(E a1) { throw new RuntimeException(\"skeleton method\"); }\n   public boolean offer(E a1) { throw new RuntimeException(\"skeleton method\"); }\n   public @Nullable E peek() { throw new RuntimeException(\"skeleton method\"); }\n-  public boolean remove(@Nullable Object a1) { throw new RuntimeException(\"skeleton method\"); }\n-  @Pure public boolean contains(@Nullable Object a1) { throw new RuntimeException(\"skeleton method\"); }\n+  public boolean remove(Object a1) { throw new RuntimeException(\"skeleton method\"); }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9487c0c498bb4818a3eb0024acf95b669496553"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTYwODE2OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/Vector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODozMDo0OVrOF4R4Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODozMDo0OVrOF4R4Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1NzQ2Ng==", "bodyText": "The docs suggest that these Vector bulk operations throw NPE only if the collection is null. They do look like they accept null element.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394557466", "createdAt": "2020-03-18T18:30:49Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/Vector.java", "diffHunk": "@@ -880,7 +881,7 @@ public void clear() {\n      * @throws NullPointerException if the specified collection is null\n      */\n     @Pure\n-    public synchronized boolean containsAll(Collection<?> c) {\n+    public synchronized boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTYzMzQyOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentHashMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODozNzo0N1rOF4SH8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNDowNjowMVrOF7crlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MTUyMQ==", "bodyText": "It looks like these methods probably accept null elements in practice.\nThe only documentation of this fact is that they inherit the doc from Collection.containsAll, etc. and don't request to also inherit the @throws doc.\nThat could easily be accidental, especially because this class didn't use to be publicly accessible. Well, this class still isn't publicly accessible, but its subclass ConcurrentHashMap.KeySetView is as of 1.8 after being hidden before.\nIt's also a bit surprising that the collection views' query methods permit null elements when methods on ConcurrentHashMap itself do not.\nI'm not sure what you want to do with all that :) But that's my read of the situation.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394561521", "createdAt": "2020-03-18T18:37:47Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentHashMap.java", "diffHunk": "@@ -4519,7 +4519,7 @@ public final String toString() {\n             return sb.append(']').toString();\n         }\n \n-        public final boolean containsAll(Collection<?> c) {\n+        public final boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg4MDIxMg==", "bodyText": "As with the other example, I won't take (possibly accidental) omission of @throws to mean that null is a legal argument.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397880212", "createdAt": "2020-03-25T14:06:01Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentHashMap.java", "diffHunk": "@@ -4519,7 +4519,7 @@ public final String toString() {\n             return sb.append(']').toString();\n         }\n \n-        public final boolean containsAll(Collection<?> c) {\n+        public final boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MTUyMQ=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTYzNDg0OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentSkipListSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODozODoxNFrOF4SI2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODozODoxNFrOF4SI2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MTc1Mg==", "bodyText": "I think you want @NonNull here.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394561752", "createdAt": "2020-03-18T18:38:14Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentSkipListSet.java", "diffHunk": "@@ -335,7 +335,7 @@ public boolean equals(@Nullable Object o) {\n      * @throws NullPointerException if the specified collection or any\n      *         of its elements are null\n      */\n-    public boolean removeAll(Collection<?> c) {\n+    public boolean removeAll(Collection<? extends @Nullable Object> c) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY0NjE2OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/SynchronousQueue.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0MToyNVrOF4SP8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0NzowMFrOF7byOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzU2OA==", "bodyText": "All the bulk methods on SynchronousQueue, plus the single-element contains and remove, are documented to suggest that null elements are permitted. (And an implementation would have to go out of its way to throw NPE for them.)\nThat said, I also grant that these bulk methods aren't documented to throw NPE for a null collection, and yet clearly doing so would be acceptable behavior (probably even the only right behavior in the case of containsAll)....", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394563568", "createdAt": "2020-03-18T18:41:25Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/SynchronousQueue.java", "diffHunk": "@@ -1028,7 +1028,7 @@ public boolean remove(Object o) {\n      * @param c the collection\n      * @return {@code false} unless given collection is empty\n      */\n-    @Pure public boolean containsAll(Collection<?> c) {\n+    @Pure public boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgzNTEzNw==", "bodyText": "All the bulk methods on SynchronousQueue, plus the single-element contains and remove, are documented to suggest that null elements are permitted.\n\nCan you point me at that documentation?  I must be overlooking it, because I can't seem to find it.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397835137", "createdAt": "2020-03-25T13:02:42Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/concurrent/SynchronousQueue.java", "diffHunk": "@@ -1028,7 +1028,7 @@ public boolean remove(Object o) {\n      * @param c the collection\n      * @return {@code false} unless given collection is empty\n      */\n-    @Pure public boolean containsAll(Collection<?> c) {\n+    @Pure public boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzU2OA=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0Mjc0NQ==", "bodyText": "Sorry, \"documented\" in the sense that these methods do not include @throws NullPointerException, in contrast to methods like put. But as noted, bulk methods like containsAll also don't include @throws NullPointerException for when the collection itself is null, so we might not want to read too much into the lack of a @throws clause.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397842745", "createdAt": "2020-03-25T13:14:41Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/SynchronousQueue.java", "diffHunk": "@@ -1028,7 +1028,7 @@ public boolean remove(Object o) {\n      * @param c the collection\n      * @return {@code false} unless given collection is empty\n      */\n-    @Pure public boolean containsAll(Collection<?> c) {\n+    @Pure public boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzU2OA=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NTUyOQ==", "bodyText": "Thanks for the clarification.  I don't want to read too much into that.  I'll leave them as is in the annotated JDK for now.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397865529", "createdAt": "2020-03-25T13:47:00Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/concurrent/SynchronousQueue.java", "diffHunk": "@@ -1028,7 +1028,7 @@ public boolean remove(Object o) {\n      * @param c the collection\n      * @return {@code false} unless given collection is empty\n      */\n-    @Pure public boolean containsAll(Collection<?> c) {\n+    @Pure public boolean containsAll(Collection<? extends @NonNull Object> c) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzU2OA=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY0NzYzOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0MTo1MFrOF4SQ5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0MTo1MFrOF4SQ5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzgxNA==", "bodyText": "This section about EnumMap appears both here and above.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394563814", "createdAt": "2020-03-18T18:41:50Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY1NjY5OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0NDoyM1rOF4SWgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0NDoyM1rOF4SWgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NTI0OA==", "bodyText": "I notice a mix of Collection<?> and Collection<? extends @Nullable Object> in this stub file. I don't know if that makes any difference to the tool (or to humans).", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394565248", "createdAt": "2020-03-18T18:44:23Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY1OTgzOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0NToxOFrOF4SYfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0NToxOFrOF4SYfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NTc1Nw==", "bodyText": "I don't think we want @Nullable here: A Comparator for @Nullable Foo objects would be a Comparator<@Nullable Foo>.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394565757", "createdAt": "2020-03-18T18:45:18Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY2MjIwOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0NTo1NlrOF4SZ_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0ODowN1rOF7b1jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NjE0MQ==", "bodyText": "I believe this should forbid nulls.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394566141", "createdAt": "2020-03-18T18:45:56Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+class ConcurrentSkipListSet {\n+    public boolean removeAll(Collection<?> c);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgzNTE4Ng==", "bodyText": "That would be the same as the annotation in the JDK.\nThis is trying to be more lenient and permit collections of nullable type.\nAre you proposing that the stub file in general should not relax the signature of removeAll?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397835186", "createdAt": "2020-03-25T13:02:47Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+class ConcurrentSkipListSet {\n+    public boolean removeAll(Collection<?> c);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NjE0MQ=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0NTA3MA==", "bodyText": "Right, I'm proposing to match the annotated JDK. ConcurrentSkipListSet, even with a Comparator that permits null, has documentation on methods like remove and removeAll to suggest that they reject null. This is in contrast to TreeSet, which allows null queries if its Comparator does.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397845070", "createdAt": "2020-03-25T13:18:09Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+class ConcurrentSkipListSet {\n+    public boolean removeAll(Collection<?> c);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NjE0MQ=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NjM4Mg==", "bodyText": "Thanks.  This comment only applies to ConcurrentSkipListSet and not to other methods, so I will only change ConcurrentSkipListSet by removing these lines from the stub file.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397866382", "createdAt": "2020-03-25T13:48:07Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+class ConcurrentSkipListSet {\n+    public boolean removeAll(Collection<?> c);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NjE0MQ=="}, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY4MDQ0OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo1MToxOFrOF4Sl7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo1MToxOFrOF4Sl7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2OTE5Nw==", "bodyText": "I notice that you don't have this (and probably other classes?) in the annotated JDK currently. That seems perfectly fine -- the annotated JDK is known to not be 100% complete :) -- but this is one case in which the stub would be redundant with the annotated JDK but isn't yet.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r394569197", "createdAt": "2020-03-18T18:51:18Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,254 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// The affected methods are:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// Here are all the null-friendly classes (every instance permits null elements):\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Here are some exceptions: methods whose specification is ambiguous (says \"such that o.equals(e)\"\n+// or \"such that Objects.equals(o, e)\") but can be interpreted to say that null is a permitted\n+// value:\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public class ArrayList<E> extends AbstractList<E>\n+        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<? extends @Nullable Object> c);\n+    boolean addAll(Collection<? extends @Nullable E> c);\n+    boolean retainAll(Collection<? extends @Nullable Object> c);\n+}\n+\n+public interface Comparator<T> {\n+    int compare(@Nullable T o1, @Nullable T o2);\n+\n+}\n+\n+class ConcurrentSkipListSet {\n+    public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public class PriorityQueue<E> extends AbstractQueue<E>\n+    implements java.io.Serializable {\n+    public boolean remove(@Nullable Object o);\n+    public boolean contains(@Nullable Object o);\n+}\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);\n+    public boolean removeLastOccurrence(@Nullable Object o);\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public class ConcurrentLinkedQueue<E> extends AbstractQueue<E>\n+        implements Queue<E>, java.io.Serializable {\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public interface ConcurrentMap<K,V> extends Map<K,V> {\n+    @Nullable V putIfAbsent(@Nullable K key, @Nullable V value);\n+    boolean remove(@Nullable Object key, @Nullable Object value);\n+}\n+\n+public class ConcurrentSkipListSet<E>\n+    extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable {\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public class CopyOnWriteArrayList<E>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf4064922f913eca184dde4fae73af9511449a85"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzExOTUzOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/Map.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNjowMjoxNlrOF7iX0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNjowMjoxNlrOF7iX0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MzQ1OQ==", "bodyText": "You probably want to remove the big comment here now (or revise it if you want to continue to call out this policy on Map.get specifically).", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r397973459", "createdAt": "2020-03-25T16:02:16Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/Map.java", "diffHunk": "@@ -233,7 +233,7 @@\n     // collections).  Some other implementation do accept nulls and are so", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8846ffd9218e13ce9e2b7627198fc3182e00a597"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODEwNjc2OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/BlockingDeque.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDowMjoxNFrOF7sIFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDowMjoxNFrOF7sIFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzMzI2OQ==", "bodyText": "I don't think we want @Nullable on these 4 methods in BlockingDeque, nor on the 2 in BlockingQueue.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398133269", "createdAt": "2020-03-25T20:02:14Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/BlockingDeque.java", "diffHunk": "@@ -411,7 +411,7 @@ boolean offerLast(E e, long timeout, TimeUnit unit)\n      * @throws NullPointerException if the specified element is null\n      *         (<a href=\"../Collection.html#optional-restrictions\">optional</a>)\n      */\n-    boolean removeFirstOccurrence(Object o);\n+    boolean removeFirstOccurrence(@Nullable Object o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODEwOTI4OnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentSkipListSet.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDowMjo1MVrOF7sJhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDowMjo1MVrOF7sJhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEzMzYzNg==", "bodyText": "Similarly, I don't think we want @Nullable on contains and remove in ConcurrentSkipListSet.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398133636", "createdAt": "2020-03-25T20:02:51Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/ConcurrentSkipListSet.java", "diffHunk": "@@ -225,7 +225,7 @@ public ConcurrentSkipListSet(SortedSet<E> s) {\n      *         compared with the elements currently in this set\n      * @throws NullPointerException if the specified element is null\n      */\n-    @Pure public boolean contains(Object o) {\n+    @Pure public boolean contains(@Nullable Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODE4MDUyOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/concurrent/CopyOnWriteArrayList.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDoyMzo1MlrOF7s29Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOToxMToxM1rOF8Wa7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTI2OQ==", "bodyText": "Given how detailed the spec is about NullPointerException for removeAll and retainAll (and arguably even containsAll), I could see accepting collections with null elements. But it's a judgment call.\n(If you buy that, it would apply to CopyOnWriteArraySet, as well.)\nAlso, this prompted me to file #3197, which might be helpful as part of mounting an argument for Collection.contains and friends to always accept null.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398145269", "createdAt": "2020-03-25T20:23:52Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/CopyOnWriteArrayList.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group.  Adapted and released, under explicit permission,\n+ * from JDK ArrayList.java which carries the following copyright:\n+ *\n+ * Copyright 1997 by Sun Microsystems, Inc.,\n+ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.\n+ * All rights reserved.\n+ */\n+\n+package java.util.concurrent;\n+import java.util.AbstractList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.dataflow.qual.Pure;\n+import org.checkerframework.dataflow.qual.SideEffectFree;\n+import org.checkerframework.dataflow.qual.Pure;\n+\n+/**\n+ * A thread-safe variant of {@link java.util.ArrayList} in which all mutative\n+ * operations ({@code add}, {@code set}, and so on) are implemented by\n+ * making a fresh copy of the underlying array.\n+ *\n+ * <p>This is ordinarily too costly, but may be <em>more</em> efficient\n+ * than alternatives when traversal operations vastly outnumber\n+ * mutations, and is useful when you cannot or don't want to\n+ * synchronize traversals, yet need to preclude interference among\n+ * concurrent threads.  The \"snapshot\" style iterator method uses a\n+ * reference to the state of the array at the point that the iterator\n+ * was created. This array never changes during the lifetime of the\n+ * iterator, so interference is impossible and the iterator is\n+ * guaranteed not to throw {@code ConcurrentModificationException}.\n+ * The iterator will not reflect additions, removals, or changes to\n+ * the list since the iterator was created.  Element-changing\n+ * operations on iterators themselves ({@code remove}, {@code set}, and\n+ * {@code add}) are not supported. These methods throw\n+ * {@code UnsupportedOperationException}.\n+ *\n+ * <p>All elements are permitted, including {@code null}.\n+ *\n+ * <p>Memory consistency effects: As with other concurrent\n+ * collections, actions in a thread prior to placing an object into a\n+ * {@code CopyOnWriteArrayList}\n+ * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n+ * actions subsequent to the access or removal of that element from\n+ * the {@code CopyOnWriteArrayList} in another thread.\n+ *\n+ * <p>This class is a member of the\n+ * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n+ * Java Collections Framework</a>.\n+ *\n+ * @since 1.5\n+ * @author Doug Lea\n+ * @param <E> the type of elements held in this collection\n+ */\n+public class CopyOnWriteArrayList<E>\n+    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n+    private static final long serialVersionUID = 8673264195747942595L;\n+\n+    /** The lock protecting all mutators */\n+    final transient ReentrantLock lock = new ReentrantLock();\n+\n+    /** The array, accessed only via getArray/setArray. */\n+    private transient volatile Object[] array;\n+\n+    /**\n+     * Gets the array.  Non-private so as to also be accessible\n+     * from CopyOnWriteArraySet class.\n+     */\n+    final Object[] getArray() {\n+        return array;\n+    }\n+\n+    /**\n+     * Sets the array.\n+     */\n+    final void setArray(Object[] a) {\n+        array = a;\n+    }\n+\n+    /**\n+     * Creates an empty list.\n+     */\n+    public CopyOnWriteArrayList() {\n+        setArray(new Object[0]);\n+    }\n+\n+    /**\n+     * Creates a list containing the elements of the specified\n+     * collection, in the order they are returned by the collection's\n+     * iterator.\n+     *\n+     * @param c the collection of initially held elements\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public CopyOnWriteArrayList(Collection<? extends E> c) {\n+        Object[] elements;\n+        if (c.getClass() == CopyOnWriteArrayList.class)\n+            elements = ((CopyOnWriteArrayList<?>)c).getArray();\n+        else {\n+            elements = c.toArray();\n+            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n+            if (elements.getClass() != Object[].class)\n+                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n+        }\n+        setArray(elements);\n+    }\n+\n+    /**\n+     * Creates a list holding a copy of the given array.\n+     *\n+     * @param toCopyIn the array (a copy of this array is used as the\n+     *        internal array)\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public CopyOnWriteArrayList(E[] toCopyIn) {\n+        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     */\n+    @Pure\n+    public int size() {\n+        return getArray().length;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     */\n+    @Pure\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Tests for equality, coping with nulls.\n+     */\n+    private static boolean eq(Object o1, Object o2) {\n+        return (o1 == null) ? o2 == null : o1.equals(o2);\n+    }\n+\n+    /**\n+     * static version of indexOf, to allow repeated calls without\n+     * needing to re-acquire array each time.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @param fence one past last index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int indexOf(Object o, Object[] elements,\n+                               int index, int fence) {\n+        if (o == null) {\n+            for (int i = index; i < fence; i++)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i < fence; i++)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * static version of lastIndexOf.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int lastIndexOf(Object o, Object[] elements, int index) {\n+        if (o == null) {\n+            for (int i = index; i >= 0; i--)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i >= 0; i--)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     */\n+    public boolean contains(@Nullable Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length) >= 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOf(Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified element in\n+     * this list, searching forwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the lowest index {@code i} such that\n+     * <tt>(i&nbsp;&gt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching from\n+     * @return the index of the first occurrence of the element in\n+     *         this list at position {@code index} or later in the list;\n+     *         {@code -1} if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is negative\n+     */\n+    public int indexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return indexOf(e, elements, index, elements.length);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lastIndexOf(Object o) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(o, elements, elements.length - 1);\n+    }\n+\n+    /**\n+     * Returns the index of the last occurrence of the specified element in\n+     * this list, searching backwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the highest index {@code i} such that\n+     * <tt>(i&nbsp;&lt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching backwards from\n+     * @return the index of the last occurrence of the element at position\n+     *         less than or equal to {@code index} in this list;\n+     *         -1 if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is greater\n+     *         than or equal to the current size of this list\n+     */\n+    public int lastIndexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(e, elements, index);\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this list.  (The elements themselves\n+     * are not copied.)\n+     *\n+     * @return a clone of this list\n+     */\n+    public Object clone() {\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            CopyOnWriteArrayList<E> clone =\n+                (CopyOnWriteArrayList<E>) super.clone();\n+            clone.resetLock();\n+            return clone;\n+        } catch (CloneNotSupportedException e) {\n+            // this shouldn't happen, since we are Cloneable\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all the elements in this list\n+     */\n+    public Object[] toArray() {\n+        Object[] elements = getArray();\n+        return Arrays.copyOf(elements, elements.length);\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in\n+     * proper sequence (from first to last element); the runtime type of\n+     * the returned array is that of the specified array.  If the list fits\n+     * in the specified array, it is returned therein.  Otherwise, a new\n+     * array is allocated with the runtime type of the specified array and\n+     * the size of this list.\n+     *\n+     * <p>If this list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than this list), the element in\n+     * the array immediately following the end of the list is set to\n+     * {@code null}.  (This is useful in determining the length of this\n+     * list <i>only</i> if the caller knows that this list does not contain\n+     * any null elements.)\n+     *\n+     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n+     * array-based and collection-based APIs.  Further, this method allows\n+     * precise control over the runtime type of the output array, and may,\n+     * under certain circumstances, be used to save allocation costs.\n+     *\n+     * <p>Suppose {@code x} is a list known to contain only strings.\n+     * The following code can be used to dump the list into a newly\n+     * allocated array of {@code String}:\n+     *\n+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>\n+     *\n+     * Note that {@code toArray(new Object[0])} is identical in function to\n+     * {@code toArray()}.\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *          be stored, if it is big enough; otherwise, a new array of the\n+     *          same runtime type is allocated for this purpose.\n+     * @return an array containing all the elements in this list\n+     * @throws ArrayStoreException if the runtime type of the specified array\n+     *         is not a supertype of the runtime type of every element in\n+     *         this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T a[]) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        if (a.length < len)\n+            return (T[]) Arrays.copyOf(elements, len, a.getClass());\n+        else {\n+            System.arraycopy(elements, 0, a, 0, len);\n+            if (a.length > len)\n+                a[len] = null;\n+            return a;\n+        }\n+    }\n+\n+    // Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private E get(Object[] a, int index) {\n+        return (E) a[index];\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E get(int index) {\n+        return get(getArray(), index);\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E set(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            E oldValue = get(elements, index);\n+\n+            if (oldValue != element) {\n+                int len = elements.length;\n+                Object[] newElements = Arrays.copyOf(elements, len);\n+                newElements[index] = element;\n+                setArray(newElements);\n+            } else {\n+                // Not quite a no-op; ensures volatile write semantics\n+                setArray(elements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     */\n+    public boolean add(E e) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            Object[] newElements = Arrays.copyOf(elements, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public void add(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            if (index > len || index < 0)\n+                throw new IndexOutOfBoundsException(\"Index: \"+index+\n+                                                    \", Size: \"+len);\n+            Object[] newElements;\n+            int numMoved = len - index;\n+            if (numMoved == 0)\n+                newElements = Arrays.copyOf(elements, len + 1);\n+            else {\n+                newElements = new Object[len + 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index, newElements, index + 1,\n+                                 numMoved);\n+            }\n+            newElements[index] = element;\n+            setArray(newElements);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).  Returns the element that was removed from the list.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E remove(int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            E oldValue = get(elements, index);\n+            int numMoved = len - index - 1;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, len - 1));\n+            else {\n+                Object[] newElements = new Object[len - 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index + 1, newElements, index,\n+                                 numMoved);\n+                setArray(newElements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If this list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     */\n+    public boolean remove(@Nullable Object o) {\n+        Object[] snapshot = getArray();\n+        int index = indexOf(o, snapshot, 0, snapshot.length);\n+        return (index < 0) ? false : remove(o, snapshot, index);\n+    }\n+\n+    /**\n+     * A version of remove(Object) using the strong hint that given\n+     * recent snapshot contains o at the given index.\n+     */\n+    private boolean remove(Object o, Object[] snapshot, int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) findIndex: {\n+                int prefix = Math.min(index, len);\n+                for (int i = 0; i < prefix; i++) {\n+                    if (current[i] != snapshot[i] && eq(o, current[i])) {\n+                        index = i;\n+                        break findIndex;\n+                    }\n+                }\n+                if (index >= len)\n+                    return false;\n+                if (current[index] == o)\n+                    break findIndex;\n+                index = indexOf(o, current, index, len);\n+                if (index < 0)\n+                    return false;\n+            }\n+            Object[] newElements = new Object[len - 1];\n+            System.arraycopy(current, 0, newElements, 0, index);\n+            System.arraycopy(current, index + 1,\n+                             newElements, index,\n+                             len - index - 1);\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @param fromIndex index of first element to be removed\n+     * @param toIndex index after last element to be removed\n+     * @throws IndexOutOfBoundsException if fromIndex or toIndex out of range\n+     *         ({@code fromIndex < 0 || toIndex > size() || toIndex < fromIndex})\n+     */\n+    void removeRange(int fromIndex, int toIndex) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+\n+            if (fromIndex < 0 || toIndex > len || toIndex < fromIndex)\n+                throw new IndexOutOfBoundsException();\n+            int newlen = len - (toIndex - fromIndex);\n+            int numMoved = len - toIndex;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, newlen));\n+            else {\n+                Object[] newElements = new Object[newlen];\n+                System.arraycopy(elements, 0, newElements, 0, fromIndex);\n+                System.arraycopy(elements, toIndex, newElements,\n+                                 fromIndex, numMoved);\n+                setArray(newElements);\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the element, if not present.\n+     *\n+     * @param e element to be added to this list, if absent\n+     * @return {@code true} if the element was added\n+     */\n+    public boolean addIfAbsent(E e) {\n+        Object[] snapshot = getArray();\n+        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n+            addIfAbsent(e, snapshot);\n+    }\n+\n+    /**\n+     * A version of addIfAbsent using the strong hint that given\n+     * recent snapshot does not contain e.\n+     */\n+    private boolean addIfAbsent(E e, Object[] snapshot) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) {\n+                // Optimize for lost race to another addXXX operation\n+                int common = Math.min(snapshot.length, len);\n+                for (int i = 0; i < common; i++)\n+                    if (current[i] != snapshot[i] && eq(e, current[i]))\n+                        return false;\n+                if (indexOf(e, current, common, len) >= 0)\n+                        return false;\n+            }\n+            Object[] newElements = Arrays.copyOf(current, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains all of the elements of the\n+     * specified collection.\n+     *\n+     * @param c collection to be checked for containment in this list\n+     * @return {@code true} if this list contains all of the elements of the\n+     *         specified collection\n+     * @throws NullPointerException if the specified collection is null\n+     * @see #contains(Object)\n+     */\n+    public boolean containsAll(Collection<? extends @NonNull Object> c) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        for (Object e : c) {\n+            if (indexOf(e, elements, 0, len) < 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes from this list all of its elements that are contained in\n+     * the specified collection. This is a particularly expensive operation\n+     * in this class because of the need for an internal temporary array.\n+     *\n+     * @param c collection containing elements to be removed from this list\n+     * @return {@code true} if this list changed as a result of the call\n+     * @throws ClassCastException if the class of an element of this list\n+     *         is incompatible with the specified collection\n+     *         (<a href=\"../Collection.html#optional-restrictions\">optional</a>)\n+     * @throws NullPointerException if this list contains a null element and the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNzk4Mw==", "bodyText": "You are right (in #3197) that the current annotations are unsound.  Let's put that aside for the moment, because it requires a fix for the \"annotations on receiver type parameters are ignored\" problem.\nI think this needs to stand as is in the annotated JDK, conservatively requiring non-null element types (the second condition in #3197).  Our goal is that if the client code satisfies the annotations, then there is no possibility of a NullPointerException.\nThe fix in #3197 would be more precise.\nDoes that make sense?  Or am I missing something?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398717983", "createdAt": "2020-03-26T16:36:00Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/concurrent/CopyOnWriteArrayList.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group.  Adapted and released, under explicit permission,\n+ * from JDK ArrayList.java which carries the following copyright:\n+ *\n+ * Copyright 1997 by Sun Microsystems, Inc.,\n+ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.\n+ * All rights reserved.\n+ */\n+\n+package java.util.concurrent;\n+import java.util.AbstractList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.dataflow.qual.Pure;\n+import org.checkerframework.dataflow.qual.SideEffectFree;\n+import org.checkerframework.dataflow.qual.Pure;\n+\n+/**\n+ * A thread-safe variant of {@link java.util.ArrayList} in which all mutative\n+ * operations ({@code add}, {@code set}, and so on) are implemented by\n+ * making a fresh copy of the underlying array.\n+ *\n+ * <p>This is ordinarily too costly, but may be <em>more</em> efficient\n+ * than alternatives when traversal operations vastly outnumber\n+ * mutations, and is useful when you cannot or don't want to\n+ * synchronize traversals, yet need to preclude interference among\n+ * concurrent threads.  The \"snapshot\" style iterator method uses a\n+ * reference to the state of the array at the point that the iterator\n+ * was created. This array never changes during the lifetime of the\n+ * iterator, so interference is impossible and the iterator is\n+ * guaranteed not to throw {@code ConcurrentModificationException}.\n+ * The iterator will not reflect additions, removals, or changes to\n+ * the list since the iterator was created.  Element-changing\n+ * operations on iterators themselves ({@code remove}, {@code set}, and\n+ * {@code add}) are not supported. These methods throw\n+ * {@code UnsupportedOperationException}.\n+ *\n+ * <p>All elements are permitted, including {@code null}.\n+ *\n+ * <p>Memory consistency effects: As with other concurrent\n+ * collections, actions in a thread prior to placing an object into a\n+ * {@code CopyOnWriteArrayList}\n+ * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n+ * actions subsequent to the access or removal of that element from\n+ * the {@code CopyOnWriteArrayList} in another thread.\n+ *\n+ * <p>This class is a member of the\n+ * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n+ * Java Collections Framework</a>.\n+ *\n+ * @since 1.5\n+ * @author Doug Lea\n+ * @param <E> the type of elements held in this collection\n+ */\n+public class CopyOnWriteArrayList<E>\n+    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n+    private static final long serialVersionUID = 8673264195747942595L;\n+\n+    /** The lock protecting all mutators */\n+    final transient ReentrantLock lock = new ReentrantLock();\n+\n+    /** The array, accessed only via getArray/setArray. */\n+    private transient volatile Object[] array;\n+\n+    /**\n+     * Gets the array.  Non-private so as to also be accessible\n+     * from CopyOnWriteArraySet class.\n+     */\n+    final Object[] getArray() {\n+        return array;\n+    }\n+\n+    /**\n+     * Sets the array.\n+     */\n+    final void setArray(Object[] a) {\n+        array = a;\n+    }\n+\n+    /**\n+     * Creates an empty list.\n+     */\n+    public CopyOnWriteArrayList() {\n+        setArray(new Object[0]);\n+    }\n+\n+    /**\n+     * Creates a list containing the elements of the specified\n+     * collection, in the order they are returned by the collection's\n+     * iterator.\n+     *\n+     * @param c the collection of initially held elements\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public CopyOnWriteArrayList(Collection<? extends E> c) {\n+        Object[] elements;\n+        if (c.getClass() == CopyOnWriteArrayList.class)\n+            elements = ((CopyOnWriteArrayList<?>)c).getArray();\n+        else {\n+            elements = c.toArray();\n+            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n+            if (elements.getClass() != Object[].class)\n+                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n+        }\n+        setArray(elements);\n+    }\n+\n+    /**\n+     * Creates a list holding a copy of the given array.\n+     *\n+     * @param toCopyIn the array (a copy of this array is used as the\n+     *        internal array)\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public CopyOnWriteArrayList(E[] toCopyIn) {\n+        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     */\n+    @Pure\n+    public int size() {\n+        return getArray().length;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     */\n+    @Pure\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Tests for equality, coping with nulls.\n+     */\n+    private static boolean eq(Object o1, Object o2) {\n+        return (o1 == null) ? o2 == null : o1.equals(o2);\n+    }\n+\n+    /**\n+     * static version of indexOf, to allow repeated calls without\n+     * needing to re-acquire array each time.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @param fence one past last index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int indexOf(Object o, Object[] elements,\n+                               int index, int fence) {\n+        if (o == null) {\n+            for (int i = index; i < fence; i++)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i < fence; i++)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * static version of lastIndexOf.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int lastIndexOf(Object o, Object[] elements, int index) {\n+        if (o == null) {\n+            for (int i = index; i >= 0; i--)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i >= 0; i--)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     */\n+    public boolean contains(@Nullable Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length) >= 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOf(Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified element in\n+     * this list, searching forwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the lowest index {@code i} such that\n+     * <tt>(i&nbsp;&gt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching from\n+     * @return the index of the first occurrence of the element in\n+     *         this list at position {@code index} or later in the list;\n+     *         {@code -1} if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is negative\n+     */\n+    public int indexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return indexOf(e, elements, index, elements.length);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lastIndexOf(Object o) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(o, elements, elements.length - 1);\n+    }\n+\n+    /**\n+     * Returns the index of the last occurrence of the specified element in\n+     * this list, searching backwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the highest index {@code i} such that\n+     * <tt>(i&nbsp;&lt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching backwards from\n+     * @return the index of the last occurrence of the element at position\n+     *         less than or equal to {@code index} in this list;\n+     *         -1 if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is greater\n+     *         than or equal to the current size of this list\n+     */\n+    public int lastIndexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(e, elements, index);\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this list.  (The elements themselves\n+     * are not copied.)\n+     *\n+     * @return a clone of this list\n+     */\n+    public Object clone() {\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            CopyOnWriteArrayList<E> clone =\n+                (CopyOnWriteArrayList<E>) super.clone();\n+            clone.resetLock();\n+            return clone;\n+        } catch (CloneNotSupportedException e) {\n+            // this shouldn't happen, since we are Cloneable\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all the elements in this list\n+     */\n+    public Object[] toArray() {\n+        Object[] elements = getArray();\n+        return Arrays.copyOf(elements, elements.length);\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in\n+     * proper sequence (from first to last element); the runtime type of\n+     * the returned array is that of the specified array.  If the list fits\n+     * in the specified array, it is returned therein.  Otherwise, a new\n+     * array is allocated with the runtime type of the specified array and\n+     * the size of this list.\n+     *\n+     * <p>If this list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than this list), the element in\n+     * the array immediately following the end of the list is set to\n+     * {@code null}.  (This is useful in determining the length of this\n+     * list <i>only</i> if the caller knows that this list does not contain\n+     * any null elements.)\n+     *\n+     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n+     * array-based and collection-based APIs.  Further, this method allows\n+     * precise control over the runtime type of the output array, and may,\n+     * under certain circumstances, be used to save allocation costs.\n+     *\n+     * <p>Suppose {@code x} is a list known to contain only strings.\n+     * The following code can be used to dump the list into a newly\n+     * allocated array of {@code String}:\n+     *\n+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>\n+     *\n+     * Note that {@code toArray(new Object[0])} is identical in function to\n+     * {@code toArray()}.\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *          be stored, if it is big enough; otherwise, a new array of the\n+     *          same runtime type is allocated for this purpose.\n+     * @return an array containing all the elements in this list\n+     * @throws ArrayStoreException if the runtime type of the specified array\n+     *         is not a supertype of the runtime type of every element in\n+     *         this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T a[]) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        if (a.length < len)\n+            return (T[]) Arrays.copyOf(elements, len, a.getClass());\n+        else {\n+            System.arraycopy(elements, 0, a, 0, len);\n+            if (a.length > len)\n+                a[len] = null;\n+            return a;\n+        }\n+    }\n+\n+    // Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private E get(Object[] a, int index) {\n+        return (E) a[index];\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E get(int index) {\n+        return get(getArray(), index);\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E set(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            E oldValue = get(elements, index);\n+\n+            if (oldValue != element) {\n+                int len = elements.length;\n+                Object[] newElements = Arrays.copyOf(elements, len);\n+                newElements[index] = element;\n+                setArray(newElements);\n+            } else {\n+                // Not quite a no-op; ensures volatile write semantics\n+                setArray(elements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     */\n+    public boolean add(E e) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            Object[] newElements = Arrays.copyOf(elements, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public void add(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            if (index > len || index < 0)\n+                throw new IndexOutOfBoundsException(\"Index: \"+index+\n+                                                    \", Size: \"+len);\n+            Object[] newElements;\n+            int numMoved = len - index;\n+            if (numMoved == 0)\n+                newElements = Arrays.copyOf(elements, len + 1);\n+            else {\n+                newElements = new Object[len + 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index, newElements, index + 1,\n+                                 numMoved);\n+            }\n+            newElements[index] = element;\n+            setArray(newElements);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).  Returns the element that was removed from the list.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E remove(int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            E oldValue = get(elements, index);\n+            int numMoved = len - index - 1;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, len - 1));\n+            else {\n+                Object[] newElements = new Object[len - 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index + 1, newElements, index,\n+                                 numMoved);\n+                setArray(newElements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If this list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     */\n+    public boolean remove(@Nullable Object o) {\n+        Object[] snapshot = getArray();\n+        int index = indexOf(o, snapshot, 0, snapshot.length);\n+        return (index < 0) ? false : remove(o, snapshot, index);\n+    }\n+\n+    /**\n+     * A version of remove(Object) using the strong hint that given\n+     * recent snapshot contains o at the given index.\n+     */\n+    private boolean remove(Object o, Object[] snapshot, int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) findIndex: {\n+                int prefix = Math.min(index, len);\n+                for (int i = 0; i < prefix; i++) {\n+                    if (current[i] != snapshot[i] && eq(o, current[i])) {\n+                        index = i;\n+                        break findIndex;\n+                    }\n+                }\n+                if (index >= len)\n+                    return false;\n+                if (current[index] == o)\n+                    break findIndex;\n+                index = indexOf(o, current, index, len);\n+                if (index < 0)\n+                    return false;\n+            }\n+            Object[] newElements = new Object[len - 1];\n+            System.arraycopy(current, 0, newElements, 0, index);\n+            System.arraycopy(current, index + 1,\n+                             newElements, index,\n+                             len - index - 1);\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @param fromIndex index of first element to be removed\n+     * @param toIndex index after last element to be removed\n+     * @throws IndexOutOfBoundsException if fromIndex or toIndex out of range\n+     *         ({@code fromIndex < 0 || toIndex > size() || toIndex < fromIndex})\n+     */\n+    void removeRange(int fromIndex, int toIndex) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+\n+            if (fromIndex < 0 || toIndex > len || toIndex < fromIndex)\n+                throw new IndexOutOfBoundsException();\n+            int newlen = len - (toIndex - fromIndex);\n+            int numMoved = len - toIndex;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, newlen));\n+            else {\n+                Object[] newElements = new Object[newlen];\n+                System.arraycopy(elements, 0, newElements, 0, fromIndex);\n+                System.arraycopy(elements, toIndex, newElements,\n+                                 fromIndex, numMoved);\n+                setArray(newElements);\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the element, if not present.\n+     *\n+     * @param e element to be added to this list, if absent\n+     * @return {@code true} if the element was added\n+     */\n+    public boolean addIfAbsent(E e) {\n+        Object[] snapshot = getArray();\n+        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n+            addIfAbsent(e, snapshot);\n+    }\n+\n+    /**\n+     * A version of addIfAbsent using the strong hint that given\n+     * recent snapshot does not contain e.\n+     */\n+    private boolean addIfAbsent(E e, Object[] snapshot) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) {\n+                // Optimize for lost race to another addXXX operation\n+                int common = Math.min(snapshot.length, len);\n+                for (int i = 0; i < common; i++)\n+                    if (current[i] != snapshot[i] && eq(e, current[i]))\n+                        return false;\n+                if (indexOf(e, current, common, len) >= 0)\n+                        return false;\n+            }\n+            Object[] newElements = Arrays.copyOf(current, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains all of the elements of the\n+     * specified collection.\n+     *\n+     * @param c collection to be checked for containment in this list\n+     * @return {@code true} if this list contains all of the elements of the\n+     *         specified collection\n+     * @throws NullPointerException if the specified collection is null\n+     * @see #contains(Object)\n+     */\n+    public boolean containsAll(Collection<? extends @NonNull Object> c) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        for (Object e : c) {\n+            if (indexOf(e, elements, 0, len) < 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes from this list all of its elements that are contained in\n+     * the specified collection. This is a particularly expensive operation\n+     * in this class because of the need for an internal temporary array.\n+     *\n+     * @param c collection containing elements to be removed from this list\n+     * @return {@code true} if this list changed as a result of the call\n+     * @throws ClassCastException if the class of an element of this list\n+     *         is incompatible with the specified collection\n+     *         (<a href=\"../Collection.html#optional-restrictions\">optional</a>)\n+     * @throws NullPointerException if this list contains a null element and the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTI2OQ=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcyNjkzNw==", "bodyText": "Having thought about this more in #3197, I think the more conservative option is actually to require a nullable element type for the parameter. That ensures that copyOnWriteArraySet.removeAll(c) can safely call c.contains(null).\nBut I'm not sure if you want to go back and tweak a bunch of removeAll methods at this point, especially if you'd just be re-tweaking them after annotations on receiver type parameters start to work.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398726937", "createdAt": "2020-03-26T16:47:46Z", "author": {"login": "cpovirk"}, "path": "checker/jdk/nullness/src/java/util/concurrent/CopyOnWriteArrayList.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group.  Adapted and released, under explicit permission,\n+ * from JDK ArrayList.java which carries the following copyright:\n+ *\n+ * Copyright 1997 by Sun Microsystems, Inc.,\n+ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.\n+ * All rights reserved.\n+ */\n+\n+package java.util.concurrent;\n+import java.util.AbstractList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.dataflow.qual.Pure;\n+import org.checkerframework.dataflow.qual.SideEffectFree;\n+import org.checkerframework.dataflow.qual.Pure;\n+\n+/**\n+ * A thread-safe variant of {@link java.util.ArrayList} in which all mutative\n+ * operations ({@code add}, {@code set}, and so on) are implemented by\n+ * making a fresh copy of the underlying array.\n+ *\n+ * <p>This is ordinarily too costly, but may be <em>more</em> efficient\n+ * than alternatives when traversal operations vastly outnumber\n+ * mutations, and is useful when you cannot or don't want to\n+ * synchronize traversals, yet need to preclude interference among\n+ * concurrent threads.  The \"snapshot\" style iterator method uses a\n+ * reference to the state of the array at the point that the iterator\n+ * was created. This array never changes during the lifetime of the\n+ * iterator, so interference is impossible and the iterator is\n+ * guaranteed not to throw {@code ConcurrentModificationException}.\n+ * The iterator will not reflect additions, removals, or changes to\n+ * the list since the iterator was created.  Element-changing\n+ * operations on iterators themselves ({@code remove}, {@code set}, and\n+ * {@code add}) are not supported. These methods throw\n+ * {@code UnsupportedOperationException}.\n+ *\n+ * <p>All elements are permitted, including {@code null}.\n+ *\n+ * <p>Memory consistency effects: As with other concurrent\n+ * collections, actions in a thread prior to placing an object into a\n+ * {@code CopyOnWriteArrayList}\n+ * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n+ * actions subsequent to the access or removal of that element from\n+ * the {@code CopyOnWriteArrayList} in another thread.\n+ *\n+ * <p>This class is a member of the\n+ * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n+ * Java Collections Framework</a>.\n+ *\n+ * @since 1.5\n+ * @author Doug Lea\n+ * @param <E> the type of elements held in this collection\n+ */\n+public class CopyOnWriteArrayList<E>\n+    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n+    private static final long serialVersionUID = 8673264195747942595L;\n+\n+    /** The lock protecting all mutators */\n+    final transient ReentrantLock lock = new ReentrantLock();\n+\n+    /** The array, accessed only via getArray/setArray. */\n+    private transient volatile Object[] array;\n+\n+    /**\n+     * Gets the array.  Non-private so as to also be accessible\n+     * from CopyOnWriteArraySet class.\n+     */\n+    final Object[] getArray() {\n+        return array;\n+    }\n+\n+    /**\n+     * Sets the array.\n+     */\n+    final void setArray(Object[] a) {\n+        array = a;\n+    }\n+\n+    /**\n+     * Creates an empty list.\n+     */\n+    public CopyOnWriteArrayList() {\n+        setArray(new Object[0]);\n+    }\n+\n+    /**\n+     * Creates a list containing the elements of the specified\n+     * collection, in the order they are returned by the collection's\n+     * iterator.\n+     *\n+     * @param c the collection of initially held elements\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public CopyOnWriteArrayList(Collection<? extends E> c) {\n+        Object[] elements;\n+        if (c.getClass() == CopyOnWriteArrayList.class)\n+            elements = ((CopyOnWriteArrayList<?>)c).getArray();\n+        else {\n+            elements = c.toArray();\n+            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n+            if (elements.getClass() != Object[].class)\n+                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n+        }\n+        setArray(elements);\n+    }\n+\n+    /**\n+     * Creates a list holding a copy of the given array.\n+     *\n+     * @param toCopyIn the array (a copy of this array is used as the\n+     *        internal array)\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public CopyOnWriteArrayList(E[] toCopyIn) {\n+        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     */\n+    @Pure\n+    public int size() {\n+        return getArray().length;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     */\n+    @Pure\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Tests for equality, coping with nulls.\n+     */\n+    private static boolean eq(Object o1, Object o2) {\n+        return (o1 == null) ? o2 == null : o1.equals(o2);\n+    }\n+\n+    /**\n+     * static version of indexOf, to allow repeated calls without\n+     * needing to re-acquire array each time.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @param fence one past last index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int indexOf(Object o, Object[] elements,\n+                               int index, int fence) {\n+        if (o == null) {\n+            for (int i = index; i < fence; i++)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i < fence; i++)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * static version of lastIndexOf.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int lastIndexOf(Object o, Object[] elements, int index) {\n+        if (o == null) {\n+            for (int i = index; i >= 0; i--)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i >= 0; i--)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     */\n+    public boolean contains(@Nullable Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length) >= 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOf(Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified element in\n+     * this list, searching forwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the lowest index {@code i} such that\n+     * <tt>(i&nbsp;&gt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching from\n+     * @return the index of the first occurrence of the element in\n+     *         this list at position {@code index} or later in the list;\n+     *         {@code -1} if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is negative\n+     */\n+    public int indexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return indexOf(e, elements, index, elements.length);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lastIndexOf(Object o) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(o, elements, elements.length - 1);\n+    }\n+\n+    /**\n+     * Returns the index of the last occurrence of the specified element in\n+     * this list, searching backwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the highest index {@code i} such that\n+     * <tt>(i&nbsp;&lt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching backwards from\n+     * @return the index of the last occurrence of the element at position\n+     *         less than or equal to {@code index} in this list;\n+     *         -1 if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is greater\n+     *         than or equal to the current size of this list\n+     */\n+    public int lastIndexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(e, elements, index);\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this list.  (The elements themselves\n+     * are not copied.)\n+     *\n+     * @return a clone of this list\n+     */\n+    public Object clone() {\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            CopyOnWriteArrayList<E> clone =\n+                (CopyOnWriteArrayList<E>) super.clone();\n+            clone.resetLock();\n+            return clone;\n+        } catch (CloneNotSupportedException e) {\n+            // this shouldn't happen, since we are Cloneable\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all the elements in this list\n+     */\n+    public Object[] toArray() {\n+        Object[] elements = getArray();\n+        return Arrays.copyOf(elements, elements.length);\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in\n+     * proper sequence (from first to last element); the runtime type of\n+     * the returned array is that of the specified array.  If the list fits\n+     * in the specified array, it is returned therein.  Otherwise, a new\n+     * array is allocated with the runtime type of the specified array and\n+     * the size of this list.\n+     *\n+     * <p>If this list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than this list), the element in\n+     * the array immediately following the end of the list is set to\n+     * {@code null}.  (This is useful in determining the length of this\n+     * list <i>only</i> if the caller knows that this list does not contain\n+     * any null elements.)\n+     *\n+     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n+     * array-based and collection-based APIs.  Further, this method allows\n+     * precise control over the runtime type of the output array, and may,\n+     * under certain circumstances, be used to save allocation costs.\n+     *\n+     * <p>Suppose {@code x} is a list known to contain only strings.\n+     * The following code can be used to dump the list into a newly\n+     * allocated array of {@code String}:\n+     *\n+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>\n+     *\n+     * Note that {@code toArray(new Object[0])} is identical in function to\n+     * {@code toArray()}.\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *          be stored, if it is big enough; otherwise, a new array of the\n+     *          same runtime type is allocated for this purpose.\n+     * @return an array containing all the elements in this list\n+     * @throws ArrayStoreException if the runtime type of the specified array\n+     *         is not a supertype of the runtime type of every element in\n+     *         this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T a[]) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        if (a.length < len)\n+            return (T[]) Arrays.copyOf(elements, len, a.getClass());\n+        else {\n+            System.arraycopy(elements, 0, a, 0, len);\n+            if (a.length > len)\n+                a[len] = null;\n+            return a;\n+        }\n+    }\n+\n+    // Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private E get(Object[] a, int index) {\n+        return (E) a[index];\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E get(int index) {\n+        return get(getArray(), index);\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E set(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            E oldValue = get(elements, index);\n+\n+            if (oldValue != element) {\n+                int len = elements.length;\n+                Object[] newElements = Arrays.copyOf(elements, len);\n+                newElements[index] = element;\n+                setArray(newElements);\n+            } else {\n+                // Not quite a no-op; ensures volatile write semantics\n+                setArray(elements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     */\n+    public boolean add(E e) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            Object[] newElements = Arrays.copyOf(elements, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public void add(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            if (index > len || index < 0)\n+                throw new IndexOutOfBoundsException(\"Index: \"+index+\n+                                                    \", Size: \"+len);\n+            Object[] newElements;\n+            int numMoved = len - index;\n+            if (numMoved == 0)\n+                newElements = Arrays.copyOf(elements, len + 1);\n+            else {\n+                newElements = new Object[len + 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index, newElements, index + 1,\n+                                 numMoved);\n+            }\n+            newElements[index] = element;\n+            setArray(newElements);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).  Returns the element that was removed from the list.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E remove(int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            E oldValue = get(elements, index);\n+            int numMoved = len - index - 1;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, len - 1));\n+            else {\n+                Object[] newElements = new Object[len - 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index + 1, newElements, index,\n+                                 numMoved);\n+                setArray(newElements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If this list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     */\n+    public boolean remove(@Nullable Object o) {\n+        Object[] snapshot = getArray();\n+        int index = indexOf(o, snapshot, 0, snapshot.length);\n+        return (index < 0) ? false : remove(o, snapshot, index);\n+    }\n+\n+    /**\n+     * A version of remove(Object) using the strong hint that given\n+     * recent snapshot contains o at the given index.\n+     */\n+    private boolean remove(Object o, Object[] snapshot, int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) findIndex: {\n+                int prefix = Math.min(index, len);\n+                for (int i = 0; i < prefix; i++) {\n+                    if (current[i] != snapshot[i] && eq(o, current[i])) {\n+                        index = i;\n+                        break findIndex;\n+                    }\n+                }\n+                if (index >= len)\n+                    return false;\n+                if (current[index] == o)\n+                    break findIndex;\n+                index = indexOf(o, current, index, len);\n+                if (index < 0)\n+                    return false;\n+            }\n+            Object[] newElements = new Object[len - 1];\n+            System.arraycopy(current, 0, newElements, 0, index);\n+            System.arraycopy(current, index + 1,\n+                             newElements, index,\n+                             len - index - 1);\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @param fromIndex index of first element to be removed\n+     * @param toIndex index after last element to be removed\n+     * @throws IndexOutOfBoundsException if fromIndex or toIndex out of range\n+     *         ({@code fromIndex < 0 || toIndex > size() || toIndex < fromIndex})\n+     */\n+    void removeRange(int fromIndex, int toIndex) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+\n+            if (fromIndex < 0 || toIndex > len || toIndex < fromIndex)\n+                throw new IndexOutOfBoundsException();\n+            int newlen = len - (toIndex - fromIndex);\n+            int numMoved = len - toIndex;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, newlen));\n+            else {\n+                Object[] newElements = new Object[newlen];\n+                System.arraycopy(elements, 0, newElements, 0, fromIndex);\n+                System.arraycopy(elements, toIndex, newElements,\n+                                 fromIndex, numMoved);\n+                setArray(newElements);\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the element, if not present.\n+     *\n+     * @param e element to be added to this list, if absent\n+     * @return {@code true} if the element was added\n+     */\n+    public boolean addIfAbsent(E e) {\n+        Object[] snapshot = getArray();\n+        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n+            addIfAbsent(e, snapshot);\n+    }\n+\n+    /**\n+     * A version of addIfAbsent using the strong hint that given\n+     * recent snapshot does not contain e.\n+     */\n+    private boolean addIfAbsent(E e, Object[] snapshot) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) {\n+                // Optimize for lost race to another addXXX operation\n+                int common = Math.min(snapshot.length, len);\n+                for (int i = 0; i < common; i++)\n+                    if (current[i] != snapshot[i] && eq(e, current[i]))\n+                        return false;\n+                if (indexOf(e, current, common, len) >= 0)\n+                        return false;\n+            }\n+            Object[] newElements = Arrays.copyOf(current, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains all of the elements of the\n+     * specified collection.\n+     *\n+     * @param c collection to be checked for containment in this list\n+     * @return {@code true} if this list contains all of the elements of the\n+     *         specified collection\n+     * @throws NullPointerException if the specified collection is null\n+     * @see #contains(Object)\n+     */\n+    public boolean containsAll(Collection<? extends @NonNull Object> c) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        for (Object e : c) {\n+            if (indexOf(e, elements, 0, len) < 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes from this list all of its elements that are contained in\n+     * the specified collection. This is a particularly expensive operation\n+     * in this class because of the need for an internal temporary array.\n+     *\n+     * @param c collection containing elements to be removed from this list\n+     * @return {@code true} if this list changed as a result of the call\n+     * @throws ClassCastException if the class of an element of this list\n+     *         is incompatible with the specified collection\n+     *         (<a href=\"../Collection.html#optional-restrictions\">optional</a>)\n+     * @throws NullPointerException if this list contains a null element and the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTI2OQ=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgyNjIyMg==", "bodyText": "I would like to leave this until after annotations on receiver type arguments are no longer ignored.  Thanks for raising it, though.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398826222", "createdAt": "2020-03-26T19:11:13Z", "author": {"login": "mernst"}, "path": "checker/jdk/nullness/src/java/util/concurrent/CopyOnWriteArrayList.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+/*\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group.  Adapted and released, under explicit permission,\n+ * from JDK ArrayList.java which carries the following copyright:\n+ *\n+ * Copyright 1997 by Sun Microsystems, Inc.,\n+ * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.\n+ * All rights reserved.\n+ */\n+\n+package java.util.concurrent;\n+import java.util.AbstractList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.dataflow.qual.Pure;\n+import org.checkerframework.dataflow.qual.SideEffectFree;\n+import org.checkerframework.dataflow.qual.Pure;\n+\n+/**\n+ * A thread-safe variant of {@link java.util.ArrayList} in which all mutative\n+ * operations ({@code add}, {@code set}, and so on) are implemented by\n+ * making a fresh copy of the underlying array.\n+ *\n+ * <p>This is ordinarily too costly, but may be <em>more</em> efficient\n+ * than alternatives when traversal operations vastly outnumber\n+ * mutations, and is useful when you cannot or don't want to\n+ * synchronize traversals, yet need to preclude interference among\n+ * concurrent threads.  The \"snapshot\" style iterator method uses a\n+ * reference to the state of the array at the point that the iterator\n+ * was created. This array never changes during the lifetime of the\n+ * iterator, so interference is impossible and the iterator is\n+ * guaranteed not to throw {@code ConcurrentModificationException}.\n+ * The iterator will not reflect additions, removals, or changes to\n+ * the list since the iterator was created.  Element-changing\n+ * operations on iterators themselves ({@code remove}, {@code set}, and\n+ * {@code add}) are not supported. These methods throw\n+ * {@code UnsupportedOperationException}.\n+ *\n+ * <p>All elements are permitted, including {@code null}.\n+ *\n+ * <p>Memory consistency effects: As with other concurrent\n+ * collections, actions in a thread prior to placing an object into a\n+ * {@code CopyOnWriteArrayList}\n+ * <a href=\"package-summary.html#MemoryVisibility\"><i>happen-before</i></a>\n+ * actions subsequent to the access or removal of that element from\n+ * the {@code CopyOnWriteArrayList} in another thread.\n+ *\n+ * <p>This class is a member of the\n+ * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n+ * Java Collections Framework</a>.\n+ *\n+ * @since 1.5\n+ * @author Doug Lea\n+ * @param <E> the type of elements held in this collection\n+ */\n+public class CopyOnWriteArrayList<E>\n+    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n+    private static final long serialVersionUID = 8673264195747942595L;\n+\n+    /** The lock protecting all mutators */\n+    final transient ReentrantLock lock = new ReentrantLock();\n+\n+    /** The array, accessed only via getArray/setArray. */\n+    private transient volatile Object[] array;\n+\n+    /**\n+     * Gets the array.  Non-private so as to also be accessible\n+     * from CopyOnWriteArraySet class.\n+     */\n+    final Object[] getArray() {\n+        return array;\n+    }\n+\n+    /**\n+     * Sets the array.\n+     */\n+    final void setArray(Object[] a) {\n+        array = a;\n+    }\n+\n+    /**\n+     * Creates an empty list.\n+     */\n+    public CopyOnWriteArrayList() {\n+        setArray(new Object[0]);\n+    }\n+\n+    /**\n+     * Creates a list containing the elements of the specified\n+     * collection, in the order they are returned by the collection's\n+     * iterator.\n+     *\n+     * @param c the collection of initially held elements\n+     * @throws NullPointerException if the specified collection is null\n+     */\n+    public CopyOnWriteArrayList(Collection<? extends E> c) {\n+        Object[] elements;\n+        if (c.getClass() == CopyOnWriteArrayList.class)\n+            elements = ((CopyOnWriteArrayList<?>)c).getArray();\n+        else {\n+            elements = c.toArray();\n+            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n+            if (elements.getClass() != Object[].class)\n+                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n+        }\n+        setArray(elements);\n+    }\n+\n+    /**\n+     * Creates a list holding a copy of the given array.\n+     *\n+     * @param toCopyIn the array (a copy of this array is used as the\n+     *        internal array)\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public CopyOnWriteArrayList(E[] toCopyIn) {\n+        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n+    }\n+\n+    /**\n+     * Returns the number of elements in this list.\n+     *\n+     * @return the number of elements in this list\n+     */\n+    @Pure\n+    public int size() {\n+        return getArray().length;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains no elements.\n+     *\n+     * @return {@code true} if this list contains no elements\n+     */\n+    @Pure\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Tests for equality, coping with nulls.\n+     */\n+    private static boolean eq(Object o1, Object o2) {\n+        return (o1 == null) ? o2 == null : o1.equals(o2);\n+    }\n+\n+    /**\n+     * static version of indexOf, to allow repeated calls without\n+     * needing to re-acquire array each time.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @param fence one past last index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int indexOf(Object o, Object[] elements,\n+                               int index, int fence) {\n+        if (o == null) {\n+            for (int i = index; i < fence; i++)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i < fence; i++)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * static version of lastIndexOf.\n+     * @param o element to search for\n+     * @param elements the array\n+     * @param index first index to search\n+     * @return index of element, or -1 if absent\n+     */\n+    private static int lastIndexOf(Object o, Object[] elements, int index) {\n+        if (o == null) {\n+            for (int i = index; i >= 0; i--)\n+                if (elements[i] == null)\n+                    return i;\n+        } else {\n+            for (int i = index; i >= 0; i--)\n+                if (o.equals(elements[i]))\n+                    return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains the specified element.\n+     * More formally, returns {@code true} if and only if this list contains\n+     * at least one element {@code e} such that\n+     * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.\n+     *\n+     * @param o element whose presence in this list is to be tested\n+     * @return {@code true} if this list contains the specified element\n+     */\n+    public boolean contains(@Nullable Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length) >= 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int indexOf(Object o) {\n+        Object[] elements = getArray();\n+        return indexOf(o, elements, 0, elements.length);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified element in\n+     * this list, searching forwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the lowest index {@code i} such that\n+     * <tt>(i&nbsp;&gt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching from\n+     * @return the index of the first occurrence of the element in\n+     *         this list at position {@code index} or later in the list;\n+     *         {@code -1} if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is negative\n+     */\n+    public int indexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return indexOf(e, elements, index, elements.length);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lastIndexOf(Object o) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(o, elements, elements.length - 1);\n+    }\n+\n+    /**\n+     * Returns the index of the last occurrence of the specified element in\n+     * this list, searching backwards from {@code index}, or returns -1 if\n+     * the element is not found.\n+     * More formally, returns the highest index {@code i} such that\n+     * <tt>(i&nbsp;&lt;=&nbsp;index&nbsp;&amp;&amp;&nbsp;(e==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;e.equals(get(i))))</tt>,\n+     * or -1 if there is no such index.\n+     *\n+     * @param e element to search for\n+     * @param index index to start searching backwards from\n+     * @return the index of the last occurrence of the element at position\n+     *         less than or equal to {@code index} in this list;\n+     *         -1 if the element is not found.\n+     * @throws IndexOutOfBoundsException if the specified index is greater\n+     *         than or equal to the current size of this list\n+     */\n+    public int lastIndexOf(E e, int index) {\n+        Object[] elements = getArray();\n+        return lastIndexOf(e, elements, index);\n+    }\n+\n+    /**\n+     * Returns a shallow copy of this list.  (The elements themselves\n+     * are not copied.)\n+     *\n+     * @return a clone of this list\n+     */\n+    public Object clone() {\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            CopyOnWriteArrayList<E> clone =\n+                (CopyOnWriteArrayList<E>) super.clone();\n+            clone.resetLock();\n+            return clone;\n+        } catch (CloneNotSupportedException e) {\n+            // this shouldn't happen, since we are Cloneable\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list\n+     * in proper sequence (from first to last element).\n+     *\n+     * <p>The returned array will be \"safe\" in that no references to it are\n+     * maintained by this list.  (In other words, this method must allocate\n+     * a new array).  The caller is thus free to modify the returned array.\n+     *\n+     * <p>This method acts as bridge between array-based and collection-based\n+     * APIs.\n+     *\n+     * @return an array containing all the elements in this list\n+     */\n+    public Object[] toArray() {\n+        Object[] elements = getArray();\n+        return Arrays.copyOf(elements, elements.length);\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this list in\n+     * proper sequence (from first to last element); the runtime type of\n+     * the returned array is that of the specified array.  If the list fits\n+     * in the specified array, it is returned therein.  Otherwise, a new\n+     * array is allocated with the runtime type of the specified array and\n+     * the size of this list.\n+     *\n+     * <p>If this list fits in the specified array with room to spare\n+     * (i.e., the array has more elements than this list), the element in\n+     * the array immediately following the end of the list is set to\n+     * {@code null}.  (This is useful in determining the length of this\n+     * list <i>only</i> if the caller knows that this list does not contain\n+     * any null elements.)\n+     *\n+     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n+     * array-based and collection-based APIs.  Further, this method allows\n+     * precise control over the runtime type of the output array, and may,\n+     * under certain circumstances, be used to save allocation costs.\n+     *\n+     * <p>Suppose {@code x} is a list known to contain only strings.\n+     * The following code can be used to dump the list into a newly\n+     * allocated array of {@code String}:\n+     *\n+     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>\n+     *\n+     * Note that {@code toArray(new Object[0])} is identical in function to\n+     * {@code toArray()}.\n+     *\n+     * @param a the array into which the elements of the list are to\n+     *          be stored, if it is big enough; otherwise, a new array of the\n+     *          same runtime type is allocated for this purpose.\n+     * @return an array containing all the elements in this list\n+     * @throws ArrayStoreException if the runtime type of the specified array\n+     *         is not a supertype of the runtime type of every element in\n+     *         this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T a[]) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        if (a.length < len)\n+            return (T[]) Arrays.copyOf(elements, len, a.getClass());\n+        else {\n+            System.arraycopy(elements, 0, a, 0, len);\n+            if (a.length > len)\n+                a[len] = null;\n+            return a;\n+        }\n+    }\n+\n+    // Positional Access Operations\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private E get(Object[] a, int index) {\n+        return (E) a[index];\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E get(int index) {\n+        return get(getArray(), index);\n+    }\n+\n+    /**\n+     * Replaces the element at the specified position in this list with the\n+     * specified element.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E set(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            E oldValue = get(elements, index);\n+\n+            if (oldValue != element) {\n+                int len = elements.length;\n+                Object[] newElements = Arrays.copyOf(elements, len);\n+                newElements[index] = element;\n+                setArray(newElements);\n+            } else {\n+                // Not quite a no-op; ensures volatile write semantics\n+                setArray(elements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param e element to be appended to this list\n+     * @return {@code true} (as specified by {@link Collection#add})\n+     */\n+    public boolean add(E e) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            Object[] newElements = Arrays.copyOf(elements, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position in this\n+     * list. Shifts the element currently at that position (if any) and\n+     * any subsequent elements to the right (adds one to their indices).\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public void add(int index, E element) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            if (index > len || index < 0)\n+                throw new IndexOutOfBoundsException(\"Index: \"+index+\n+                                                    \", Size: \"+len);\n+            Object[] newElements;\n+            int numMoved = len - index;\n+            if (numMoved == 0)\n+                newElements = Arrays.copyOf(elements, len + 1);\n+            else {\n+                newElements = new Object[len + 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index, newElements, index + 1,\n+                                 numMoved);\n+            }\n+            newElements[index] = element;\n+            setArray(newElements);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified position in this list.\n+     * Shifts any subsequent elements to the left (subtracts one from their\n+     * indices).  Returns the element that was removed from the list.\n+     *\n+     * @throws IndexOutOfBoundsException {@inheritDoc}\n+     */\n+    public E remove(int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+            E oldValue = get(elements, index);\n+            int numMoved = len - index - 1;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, len - 1));\n+            else {\n+                Object[] newElements = new Object[len - 1];\n+                System.arraycopy(elements, 0, newElements, 0, index);\n+                System.arraycopy(elements, index + 1, newElements, index,\n+                                 numMoved);\n+                setArray(newElements);\n+            }\n+            return oldValue;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes the first occurrence of the specified element from this list,\n+     * if it is present.  If this list does not contain the element, it is\n+     * unchanged.  More formally, removes the element with the lowest index\n+     * {@code i} such that\n+     * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>\n+     * (if such an element exists).  Returns {@code true} if this list\n+     * contained the specified element (or equivalently, if this list\n+     * changed as a result of the call).\n+     *\n+     * @param o element to be removed from this list, if present\n+     * @return {@code true} if this list contained the specified element\n+     */\n+    public boolean remove(@Nullable Object o) {\n+        Object[] snapshot = getArray();\n+        int index = indexOf(o, snapshot, 0, snapshot.length);\n+        return (index < 0) ? false : remove(o, snapshot, index);\n+    }\n+\n+    /**\n+     * A version of remove(Object) using the strong hint that given\n+     * recent snapshot contains o at the given index.\n+     */\n+    private boolean remove(Object o, Object[] snapshot, int index) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) findIndex: {\n+                int prefix = Math.min(index, len);\n+                for (int i = 0; i < prefix; i++) {\n+                    if (current[i] != snapshot[i] && eq(o, current[i])) {\n+                        index = i;\n+                        break findIndex;\n+                    }\n+                }\n+                if (index >= len)\n+                    return false;\n+                if (current[index] == o)\n+                    break findIndex;\n+                index = indexOf(o, current, index, len);\n+                if (index < 0)\n+                    return false;\n+            }\n+            Object[] newElements = new Object[len - 1];\n+            System.arraycopy(current, 0, newElements, 0, index);\n+            System.arraycopy(current, index + 1,\n+                             newElements, index,\n+                             len - index - 1);\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Removes from this list all of the elements whose index is between\n+     * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.\n+     * Shifts any succeeding elements to the left (reduces their index).\n+     * This call shortens the list by {@code (toIndex - fromIndex)} elements.\n+     * (If {@code toIndex==fromIndex}, this operation has no effect.)\n+     *\n+     * @param fromIndex index of first element to be removed\n+     * @param toIndex index after last element to be removed\n+     * @throws IndexOutOfBoundsException if fromIndex or toIndex out of range\n+     *         ({@code fromIndex < 0 || toIndex > size() || toIndex < fromIndex})\n+     */\n+    void removeRange(int fromIndex, int toIndex) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] elements = getArray();\n+            int len = elements.length;\n+\n+            if (fromIndex < 0 || toIndex > len || toIndex < fromIndex)\n+                throw new IndexOutOfBoundsException();\n+            int newlen = len - (toIndex - fromIndex);\n+            int numMoved = len - toIndex;\n+            if (numMoved == 0)\n+                setArray(Arrays.copyOf(elements, newlen));\n+            else {\n+                Object[] newElements = new Object[newlen];\n+                System.arraycopy(elements, 0, newElements, 0, fromIndex);\n+                System.arraycopy(elements, toIndex, newElements,\n+                                 fromIndex, numMoved);\n+                setArray(newElements);\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Appends the element, if not present.\n+     *\n+     * @param e element to be added to this list, if absent\n+     * @return {@code true} if the element was added\n+     */\n+    public boolean addIfAbsent(E e) {\n+        Object[] snapshot = getArray();\n+        return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :\n+            addIfAbsent(e, snapshot);\n+    }\n+\n+    /**\n+     * A version of addIfAbsent using the strong hint that given\n+     * recent snapshot does not contain e.\n+     */\n+    private boolean addIfAbsent(E e, Object[] snapshot) {\n+        final ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            Object[] current = getArray();\n+            int len = current.length;\n+            if (snapshot != current) {\n+                // Optimize for lost race to another addXXX operation\n+                int common = Math.min(snapshot.length, len);\n+                for (int i = 0; i < common; i++)\n+                    if (current[i] != snapshot[i] && eq(e, current[i]))\n+                        return false;\n+                if (indexOf(e, current, common, len) >= 0)\n+                        return false;\n+            }\n+            Object[] newElements = Arrays.copyOf(current, len + 1);\n+            newElements[len] = e;\n+            setArray(newElements);\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Returns {@code true} if this list contains all of the elements of the\n+     * specified collection.\n+     *\n+     * @param c collection to be checked for containment in this list\n+     * @return {@code true} if this list contains all of the elements of the\n+     *         specified collection\n+     * @throws NullPointerException if the specified collection is null\n+     * @see #contains(Object)\n+     */\n+    public boolean containsAll(Collection<? extends @NonNull Object> c) {\n+        Object[] elements = getArray();\n+        int len = elements.length;\n+        for (Object e : c) {\n+            if (indexOf(e, elements, 0, len) < 0)\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes from this list all of its elements that are contained in\n+     * the specified collection. This is a particularly expensive operation\n+     * in this class because of the need for an internal temporary array.\n+     *\n+     * @param c collection containing elements to be removed from this list\n+     * @return {@code true} if this list changed as a result of the call\n+     * @throws ClassCastException if the class of an element of this list\n+     *         is incompatible with the specified collection\n+     *         (<a href=\"../Collection.html#optional-restrictions\">optional</a>)\n+     * @throws NullPointerException if this list contains a null element and the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTI2OQ=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 684}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODI2ODg0OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDo0OTowNVrOF7tu6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxOTowNDowOVrOF8WKgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1OTU5Mg==", "bodyText": "Both of these are documented to always reject nulls.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398159592", "createdAt": "2020-03-25T20:49:05Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIxNzk3Nw==", "bodyText": "The .astub file is documented as\n// This file relaxes the specifications for the following methods:\n...\nremoveFirstOccurrence(Object)\n...\n\nIt sounds like you would like to change that to,\n\"This file relaxes the specifications for the following methods when they are documented to possibly throw NPE, but does not change the specifications when they are documented to definitely throw NPE.\"\nIs that correct?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398217977", "createdAt": "2020-03-25T22:49:37Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1OTU5Mg=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODczNTcwOA==", "bodyText": "Yes, that's how I was thinking of it. I think that's most the useful approach for people who want to compromise safety, since it permits all potentially safe calls but no definitely unsafe calls. Plus, I think we are currently in an intermediate state, since we don't relax signatures for other classes like ConcurrentHashMap when we know some of their methods always reject null.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398735708", "createdAt": "2020-03-26T16:59:18Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1OTU5Mg=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgyMjAxOQ==", "bodyText": "I agree that's better.  I will change the meaning of this pull request, as documented in that file.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398822019", "createdAt": "2020-03-26T19:04:09Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1OTU5Mg=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODI4NDE0OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQyMDo1MzowNVrOF7t4MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMDo1ODo1MlrOF8aKiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MTk2OQ==", "bodyText": "If you don't want to permit null in CopyOnWriteArrayList.containsAll+removeAll+retainAll in the annotated JDK, then you could do it here.\nI haven't grepped through to find all classes that override those methods to see which others might benefit from similar changes; I just happened to notice this one.)", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398161969", "createdAt": "2020-03-25T20:53:05Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);\n+    public boolean removeLastOccurrence(@Nullable Object o);\n+}\n+\n+public interface ConcurrentMap<K,V> extends Map<K,V> {\n+    @Nullable V putIfAbsent(@Nullable K key, @Nullable V value);\n+    boolean remove(@Nullable Object key, @Nullable Object value);\n+}\n+\n+public class ConcurrentSkipListSet<E>\n+    extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable {\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public class CopyOnWriteArrayList<E>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2Nzc0MA==", "bodyText": "You're generally postponing work on removeAll and retainAll, but you could consider handling containsAll now if you wanted.\nI think that's the only thought I have left!", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398867740", "createdAt": "2020-03-26T20:23:45Z", "author": {"login": "cpovirk"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);\n+    public boolean removeLastOccurrence(@Nullable Object o);\n+}\n+\n+public interface ConcurrentMap<K,V> extends Map<K,V> {\n+    @Nullable V putIfAbsent(@Nullable K key, @Nullable V value);\n+    boolean remove(@Nullable Object key, @Nullable Object value);\n+}\n+\n+public class ConcurrentSkipListSet<E>\n+    extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable {\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public class CopyOnWriteArrayList<E>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MTk2OQ=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NzU2Mw==", "bodyText": "I added removeAll and retainAll to the stub file (maximally permissively), but I'm deferring work on them in the annotated JDK.  I made containsAll more permissive, either in the annotated JDK or in the stub file, depending on the specification.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r398887563", "createdAt": "2020-03-26T20:58:52Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/collection-object-parameters-may-be-null.astub", "diffHunk": "@@ -0,0 +1,215 @@\n+// This file is a workaround for https://tinyurl.com/cfissue/1326 .\n+// For documentation, see\n+// https://checkerframework.org/manual/#collection-object-parameters-may-be-null .\n+\n+// This file relaxes the specifications for the following methods:\n+// containsAll(Collection)\n+// containsKey(Object)\n+// contains(Object)\n+// containsValue(Object)\n+// get(Object)\n+// getOrDefault(Object, V)\n+// indexOf(Object)\n+// lastIndexOf(Object)\n+// removeAll(Collection)\n+// removeFirstOccurrence(Object)\n+// removeLastOccurrence(Object )\n+// remove(Object)\n+// remove(Object, Object)\n+// retainAll(Collection)\n+\n+// The following exceptions don't need to appear in this file, because their specifications in the\n+// annotated JDK already permit null.\n+//\n+// Here are all the null-friendly classes (every instance permits null elements).\n+//\n+// Lists:\n+//   ArrayList\n+//   LinkedList\n+//   Vector\n+//     Stack\n+// Maps:\n+//   HashMap\n+//     LinkedHashMap\n+//     PrinterStateReasons\n+//   IdentityHashMap\n+//   WeakHashMap\n+// Sets:\n+//   HashSet\n+//     JobStateReasons\n+//     LinkedHashSet\n+//\n+// Here are some methods whose specification is ambiguous: says \"such that o.equals(e)\" or \"such\n+// that Objects.equals(o, e)\".  The annotated JDK interprets this to say that null is a permitted\n+// value.\n+//\n+//   ArrayBlockingQueue\n+//   ArrayDeque\n+//   BlockingDeque\n+//   BlockingQueue\n+//   ConcurrentLinkedDeque\n+//   ConcurrentLinkedQueue\n+//   ConcurrentSkipListSet\n+//   CopyOnWriteArrayList\n+//   CopyOnWriteArraySet\n+//   LinkedBlockingDeque\n+//   LinkedBlockingQueue\n+//   LinkedTransferQueue\n+//   PriorityBlockingQueue\n+//   PriorityQueue\n+//     contains\n+//     remove\n+//\n+//   ArrayDeque\n+//   BlockingDeque\n+//     removeFirstOccurrence\n+//     removeLastOccurrence\n+//\n+//   Collections\n+//     frequency\n+//\n+// Special cases:\n+//   EnumMap:\n+//     \"Attempts to insert a null key will throw NullPointerException. Attempts to test for the\n+//     presence of a null key or to remove one will, however, function properly. Null values are\n+//     permitted.\"\n+//\n+// Many additional method implementations are null-safe, but the specification does not guarantee\n+// that all overriding implementations in subclasses will be.\n+\n+\n+package java.util;\n+\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+class AbstractCollection {\n+    @Pure public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n+    public int indexOf(@Nullable Object o);\n+    public int lastIndexOf(@Nullable Object o);\n+}\n+\n+class AbstractMap {\n+    public boolean containsValue(@Nullable Object value);\n+    public boolean containsKey(@Nullable Object key);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+class AbstractSet {\n+  public boolean removeAll(Collection<?> c);\n+}\n+\n+public interface Collection<E> extends Iterable<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+}\n+\n+public interface Deque<E> extends Queue<E> {\n+    boolean removeFirstOccurrence(@Nullable Object o);\n+    boolean removeLastOccurrence(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean contains(@Nullable Object o);\n+}\n+\n+public interface List<E> extends Collection<E> {\n+    boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    boolean containsAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    int indexOf(@Nullable Object o);\n+    int lastIndexOf(@Nullable Object o);\n+}\n+\n+public interface Map<K, V> {\n+    boolean containsKey(@Nullable Object key);\n+    boolean containsValue(@Nullable Object value);\n+    @Nullable V get(@Nullable Object key);\n+    @Nullable V remove(@Nullable Object key);\n+    default V getOrDefault(@Nullable Object key, V defaultValue);\n+    default boolean remove(@Nullable Object key, @Nullable Object value);\n+    }\n+\n+public interface Set<E> extends Collection<E> {\n+    @Pure boolean contains(@Nullable Object o);\n+    boolean remove(@Nullable Object o);\n+    @Pure boolean containsAll(Collection<?> c);\n+    boolean retainAll(Collection<?> c);\n+    boolean removeAll(Collection<?> c);\n+}\n+\n+class SynchronousQueue {\n+    @Pure public boolean containsAll(Collection<?> c);\n+    public boolean removeAll(Collection<?> c);\n+    public boolean retainAll(Collection<?> c);\n+}\n+\n+public class TreeMap<K,V>\n+    extends AbstractMap<K,V>\n+    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n+{\n+    public boolean containsKey(@Nullable Object key);\n+    public boolean containsValue(@Nullable Object value);\n+    public @Nullable V get(@Nullable Object key);\n+    public @Nullable V remove(@Nullable Object key);\n+}\n+\n+public class TreeSet<E> extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable\n+{\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+class Vector {\n+    public synchronized boolean containsAll(Collection<?> c);\n+    public synchronized boolean removeAll(Collection<?> c);\n+    public synchronized boolean retainAll(Collection<?> c);\n+}\n+\n+package java.util.concurrent;\n+\n+public class ConcurrentLinkedDeque<E>\n+    extends AbstractCollection<E>\n+    implements Deque<E>, java.io.Serializable {\n+    public boolean removeFirstOccurrence(@Nullable Object o);\n+    public boolean removeLastOccurrence(@Nullable Object o);\n+}\n+\n+public interface ConcurrentMap<K,V> extends Map<K,V> {\n+    @Nullable V putIfAbsent(@Nullable K key, @Nullable V value);\n+    boolean remove(@Nullable Object key, @Nullable Object value);\n+}\n+\n+public class ConcurrentSkipListSet<E>\n+    extends AbstractSet<E>\n+    implements NavigableSet<E>, Cloneable, java.io.Serializable {\n+    public boolean contains(@Nullable Object o);\n+    public boolean remove(@Nullable Object o);\n+}\n+\n+public class CopyOnWriteArrayList<E>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MTk2OQ=="}, "originalCommit": {"oid": "fa96a42c2ed747f8f8e87eadbce7386fd8ae7f89"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTkzMDYzOnYy", "diffSide": "RIGHT", "path": "changelog.txt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo0ODowNFrOF83HLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo0ODowNFrOF83HLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2MTgzOA==", "bodyText": "Maybe add Nullness Checker: or something, to make it clear which checkers are affected by this.", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r399361838", "createdAt": "2020-03-27T15:48:04Z", "author": {"login": "wmdietl"}, "path": "changelog.txt", "diffHunk": "@@ -4,6 +4,10 @@ Renamings:\n   -AuseDefaultsForUncheckedCode to -AuseConservativeDefaultsForUncheckedCode\n     The old name works temporarily but will be removed in a future release.\n \n+For collection methods with `Object` formal parameter type, such as contains,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c86c102ad6b548d41b868cbb25f78e55d6450"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTk2OTAxOnYy", "diffSide": "RIGHT", "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo1Njo0OFrOF83fPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo1NzoxOVrOF83ghg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2Nzk5Nw==", "bodyText": "It's a bit odd that the @NonNull is made explicit here (and before in the wildcard bounds).\nNonNull is the default here and not used for non-Object parameter types.\nDo you want these explicit? If so, maybe add a note in the README about this convention?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r399367997", "createdAt": "2020-03-27T15:56:48Z", "author": {"login": "wmdietl"}, "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "diffHunk": "@@ -181,7 +182,7 @@ public E remove(int index) {\n      * @throws NullPointerException {@inheritDoc}\n      */\n     @Pure\n-    public int indexOf(@Nullable Object o) {\n+    public int indexOf(@NonNull Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c86c102ad6b548d41b868cbb25f78e55d6450"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2ODMyNg==", "bodyText": "Note that you didn't make NonNull explicit in AbstractMap below...", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r399368326", "createdAt": "2020-03-27T15:57:19Z", "author": {"login": "wmdietl"}, "path": "checker/jdk/nullness/src/java/util/AbstractList.java", "diffHunk": "@@ -181,7 +182,7 @@ public E remove(int index) {\n      * @throws NullPointerException {@inheritDoc}\n      */\n     @Pure\n-    public int indexOf(@Nullable Object o) {\n+    public int indexOf(@NonNull Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2Nzk5Nw=="}, "originalCommit": {"oid": "da0c86c102ad6b548d41b868cbb25f78e55d6450"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NjAwMjA3OnYy", "diffSide": "RIGHT", "path": "checker/tests/nullness/WeakHasherMapNullable.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDoxMlrOF83zgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNDoxMlrOF83zgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzE4NA==", "bodyText": "Why import all these annotations, even though they aren't used?\nWhy not import @Pure, which is used?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r399373184", "createdAt": "2020-03-27T16:04:12Z", "author": {"login": "wmdietl"}, "path": "checker/tests/nullness/WeakHasherMapNullable.java", "diffHunk": "@@ -0,0 +1,20 @@\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import org.checkerframework.checker.initialization.qual.*;\n+import org.checkerframework.checker.nullness.qual.*;\n+import org.checkerframework.checker.regex.qual.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c86c102ad6b548d41b868cbb25f78e55d6450"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NjAxNDU5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNzoyNlrOF837hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjowNzoyNlrOF837hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NTIzOQ==", "bodyText": "Not clear how this is related to this PR?", "url": "https://github.com/typetools/checker-framework/pull/3063#discussion_r399375239", "createdAt": "2020-03-27T16:07:26Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -2491,11 +2491,16 @@ private void printGitProperties() {\n         }\n         gitPropertiesPrinted = true;\n \n-        try (InputStream in = getClass().getResourceAsStream(\"/git.properties\");\n-                BufferedReader reader = new BufferedReader(new InputStreamReader(in)); ) {\n-            String line;\n-            while ((line = reader.readLine()) != null) {\n-                System.out.println(line);\n+        try (InputStream in = getClass().getResourceAsStream(\"/git.properties\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0c86c102ad6b548d41b868cbb25f78e55d6450"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1848, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}