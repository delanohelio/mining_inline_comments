{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0ODc2NDU1", "number": 3490, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNDo1MzoyMlrOEQ43EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzozNjowMlrOETQcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTQ0MjczOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNDo1MzoyMlrOG1SpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNDo1MzoyMlrOG1SpbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzMzIyOA==", "bodyText": "Nit: I prefer giving the variables the more specific type rather than casting at the use -- that is, move these casts to lines 1175-1178.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r458533228", "createdAt": "2020-07-22T04:53:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1172,10 +1172,17 @@ protected void performFlowAnalysis(ClassTree classTree) {\n \n                 while (!lambdaQueue.isEmpty()) {\n                     Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\n+                    Tree enclosingMethod =\n+                            TreeUtils.enclosingOfKind(getPath(lambdaPair.first), Kind.METHOD);\n+                    Tree enclosingClass =\n+                            TreeUtils.enclosingOfKind(getPath(enclosingMethod), Kind.CLASS);\n                     analyze(\n                             queue,\n                             lambdaQueue,\n-                            new CFGLambda(lambdaPair.first),\n+                            new CFGLambda(\n+                                    lambdaPair.first,\n+                                    (ClassTree) enclosingClass,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15726e2f635ba9f99e6cf9f375fa6e8032b862c8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM1ODc4OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjo1NjoxNVrOG2eSVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjo1NjoxNVrOG2eSVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MjUwMA==", "bodyText": "For consistency, I would use the same variable names as in the other two cases, that is clsName and methodName.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459772500", "createdAt": "2020-07-23T22:56:15Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "diffHunk": "@@ -193,6 +194,28 @@ protected String dotOutputFileName(UnderlyingAST ast) {\n             srcLoc.append(\")::\");\n             srcLoc.append(((JCTree) cfgMethod.getMethod()).pos);\n             srcLoc.append(\">\");\n+        } else if (ast.getKind() == UnderlyingAST.Kind.LAMBDA) {\n+            CFGLambda cfgLambda = (CFGLambda) ast;\n+            String enclosingClassName = cfgLambda.getEnclosingClass().getSimpleName().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM2NTc2OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMjo1OToyMVrOG2eWYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQyMDo1OTo0M1rOG4epHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MzUzNw==", "bodyText": "Possibly for a separate PR: what happens for an overloaded method name? The computation of outFile doesn't seem to include parameters in the METHOD case.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459773537", "createdAt": "2020-07-23T22:59:21Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "diffHunk": "@@ -193,6 +194,28 @@ protected String dotOutputFileName(UnderlyingAST ast) {\n             srcLoc.append(\")::\");\n             srcLoc.append(((JCTree) cfgMethod.getMethod()).pos);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NDMxOA==", "bodyText": "Get it. I will have another look.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r460294318", "createdAt": "2020-07-24T21:23:30Z", "author": {"login": "xingweitian"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "diffHunk": "@@ -193,6 +194,28 @@ protected String dotOutputFileName(UnderlyingAST ast) {\n             srcLoc.append(\")::\");\n             srcLoc.append(((JCTree) cfgMethod.getMethod()).pos);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MzUzNw=="}, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3NTQ4Nw==", "bodyText": "I have opened a new PR to solve this: #3521", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r461875487", "createdAt": "2020-07-28T20:59:43Z", "author": {"login": "xingweitian"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "diffHunk": "@@ -193,6 +194,28 @@ protected String dotOutputFileName(UnderlyingAST ast) {\n             srcLoc.append(\")::\");\n             srcLoc.append(((JCTree) cfgMethod.getMethod()).pos);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3MzUzNw=="}, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM2OTI1OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowMDo1N1rOG2eYaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowMDo1N1rOG2eYaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDA1OQ==", "bodyText": "Maybe the hashCode isn't necessary here - in ARBITRARY_CODE it's also not included.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459774059", "createdAt": "2020-07-23T23:00:57Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/DOTCFGVisualizer.java", "diffHunk": "@@ -193,6 +194,28 @@ protected String dotOutputFileName(UnderlyingAST ast) {\n             srcLoc.append(\")::\");\n             srcLoc.append(((JCTree) cfgMethod.getMethod()).pos);\n             srcLoc.append(\">\");\n+        } else if (ast.getKind() == UnderlyingAST.Kind.LAMBDA) {\n+            CFGLambda cfgLambda = (CFGLambda) ast;\n+            String enclosingClassName = cfgLambda.getEnclosingClass().getSimpleName().toString();\n+            String enclosingMethodName = cfgLambda.getEnclosingMethod().getName().toString();\n+            int hashCode = cfgLambda.getCode().hashCode();\n+            outFile.append(enclosingClassName);\n+            outFile.append(\"-\");\n+            outFile.append(enclosingMethodName);\n+            outFile.append(\"-\");\n+            outFile.append(hashCode);\n+\n+            srcLoc.append(\"<\");\n+            srcLoc.append(enclosingClassName);\n+            srcLoc.append(\"::\");\n+            srcLoc.append(enclosingMethodName);\n+            srcLoc.append(\"(\");\n+            srcLoc.append(cfgLambda.getEnclosingMethod().getParameters());\n+            srcLoc.append(\")::\");\n+            srcLoc.append(hashCode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM3MDY1OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/UnderlyingAST.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowMTozOVrOG2eZPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowMTozOVrOG2eZPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NDI2OQ==", "bodyText": "I would use the same field and method names as in CFGMethod.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459774269", "createdAt": "2020-07-23T23:01:39Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/UnderlyingAST.java", "diffHunk": "@@ -75,22 +75,62 @@ public String toString() {\n     /** If the underlying AST is a lambda. */\n     public static class CFGLambda extends UnderlyingAST {\n \n+        /** The lambda expression. */\n         private final LambdaExpressionTree lambda;\n \n-        public CFGLambda(LambdaExpressionTree lambda) {\n+        /** The enclosing class of the lambda. */\n+        private final ClassTree enclosingClass;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM3OTE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowNTozM1rOG2eeCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowNTozM1rOG2eeCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NTQ5OQ==", "bodyText": "I'm wondering whether this could just be classTree.\n(I'm also wondering what the difference between ct and classTree is and whether this code should use ct instead...)", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459775499", "createdAt": "2020-07-23T23:05:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1172,10 +1172,17 @@ protected void performFlowAnalysis(ClassTree classTree) {\n \n                 while (!lambdaQueue.isEmpty()) {\n                     Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\n+                    MethodTree enclosingMethod =\n+                            (MethodTree)\n+                                    TreeUtils.enclosingOfKind(\n+                                            getPath(lambdaPair.first), Kind.METHOD);\n+                    ClassTree enclosingClass =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTM4MzA3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMzowNzowMFrOG2egIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMTozNjo1MFrOG2-aeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NjAzNA==", "bodyText": "Possible alternative to think about: change Queue<Pair<LambdaExpressionTree, Store>> lambdaQueue to also contain the MethodTree within which the lambda occurred.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r459776034", "createdAt": "2020-07-23T23:07:00Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1172,10 +1172,17 @@ protected void performFlowAnalysis(ClassTree classTree) {\n \n                 while (!lambdaQueue.isEmpty()) {\n                     Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\n+                    MethodTree enclosingMethod =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODg3NA==", "bodyText": "I am not quite sure which one is better... It seems that we still need to compute the enclosing method if we change lambdaQueue. Does the current solution good enough?", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r460298874", "createdAt": "2020-07-24T21:36:50Z", "author": {"login": "xingweitian"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1172,10 +1172,17 @@ protected void performFlowAnalysis(ClassTree classTree) {\n \n                 while (!lambdaQueue.isEmpty()) {\n                     Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\n+                    MethodTree enclosingMethod =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc3NjAzNA=="}, "originalCommit": {"oid": "a69bd2d358b3275989bccea01fa773a7baff2f24"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NjI3ODQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzozNjowMlrOG44vQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMzozNjowMlrOG44vQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwMzA0Mw==", "bodyText": "Can you use classTree instead of ct? And open an issue that we should look into which one of the two we should be using here. It is definitely a bit odd to use both within the same expression.", "url": "https://github.com/typetools/checker-framework/pull/3490#discussion_r462303043", "createdAt": "2020-07-29T13:36:02Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1172,10 +1172,14 @@ protected void performFlowAnalysis(ClassTree classTree) {\n \n                 while (!lambdaQueue.isEmpty()) {\n                     Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\n+                    MethodTree mt =\n+                            (MethodTree)\n+                                    TreeUtils.enclosingOfKind(\n+                                            getPath(lambdaPair.first), Kind.METHOD);\n                     analyze(\n                             queue,\n                             lambdaQueue,\n-                            new CFGLambda(lambdaPair.first),\n+                            new CFGLambda(lambdaPair.first, ct, mt),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "419388b2d820bb48761dba1eb12206fd94fba51b"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1574, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}