{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1NTU1NDI0", "number": 3977, "reviewThreads": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODoxMjo1MFrOFHl5Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMjoyNjoxMlrOFfUo-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA1MjM0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODoxMjo1MFrOIJGP9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODoxMjo1MFrOIJGP9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxMDQ4NA==", "bodyText": "Removed from where?\nAlso, many clients ignore the return value.  Is that OK?  Is ignoring the return value OK exactly when the last argument is null?  Or maybe when isParsingStubFile is false:?\nShould a similar note be added to processCallableDeclaration?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546410484", "createdAt": "2020-12-20T18:12:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "diffHunk": "@@ -623,34 +705,46 @@ private void processPackage(PackageDeclaration packDecl) {\n      * @param typeDecl the type declaration to process\n      * @param outertypeName the name of the containing class, when processing a nested class;\n      *     otherwise null\n+     * @param classTree the tree corresponding to typeDecl if processing an ajava file, null\n+     *     otherwise\n+     * @return a list of types variables for {@code typeDecl}. These should be removed after", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd1833e01b021bd138ae881565dcb4b500018439"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA1NTQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODoxNjowMlrOIJGRXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODoxNjowMlrOIJGRXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxMDg0NA==", "bodyText": "What is \"this\" in \"does this correctly\"?  Can you add a brief description of what this code does?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546410844", "createdAt": "2020-12-20T18:16:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -682,6 +763,37 @@ public void setRoot(@Nullable CompilationUnitTree root) {\n             // contents won't change between compilation units.\n             // elementCache.clear();\n         }\n+\n+        if (root != null && checker.hasOption(\"ajava\")) {\n+            // TODO: This relies on the toString implementations of MemberSelectTree and\n+            // IdentifierTree. This could be turned into its own method that does this correctly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd1833e01b021bd138ae881565dcb4b500018439"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA2ODA2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AjavaUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODozMDoyM1rOIJGXKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODozMDoyM1rOIJGXKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxMjMyOQ==", "bodyText": "This method does not seem specific to JavaParser.  I would put it in ElementUtils.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546412329", "createdAt": "2020-12-20T18:30:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AjavaUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import java.util.Optional;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/** A utility class for working with javac and JavaParser representations of a source file. */\n+public class AjavaUtils {\n+    /**\n+     * Returns the path to the source file containing {@code element}\n+     *\n+     * @param element the type element to look at\n+     * @return path to the source file containing {@code element}\n+     */\n+    public static String getSourceFilePath(TypeElement element) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA3MDU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AjavaUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODozMzo0N1rOIJGYXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODozMzo0N1rOIJGYXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxMjYzNw==", "bodyText": "For any method or class that is an operation just over JavaParser objects, I suggest putting them in a new JavaParserUtil class.\nThat would include this methad and also ClearAnnotationVisitor and StringLiteralConcatenateVisitor.\nThat would not include AnnotationConversion and AnnotationTransferVisitor, because they walk two data structures in tandem.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546412637", "createdAt": "2020-12-20T18:33:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AjavaUtils.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import java.util.Optional;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/** A utility class for working with javac and JavaParser representations of a source file. */\n+public class AjavaUtils {\n+    /**\n+     * Returns the path to the source file containing {@code element}\n+     *\n+     * @param element the type element to look at\n+     * @return path to the source file containing {@code element}\n+     */\n+    public static String getSourceFilePath(TypeElement element) {\n+        return ((ClassSymbol) element).sourcefile.toUri().getPath();\n+    }\n+\n+    /**\n+     * Given the compilation unit node for a source file, returns the top level type definition with\n+     * the given name.\n+     *\n+     * @param root compilation unit to search\n+     * @param name name of a top level type declaration in {@code root}\n+     * @return a top level type declaration in {@code root} named {@code name}\n+     */\n+    public static TypeDeclaration<?> getTypeDeclarationByName(CompilationUnit root, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA4MzMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODo0NzoyMFrOIJGeEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxMDoyMDo0NVrOIMobKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxNDA5Ng==", "bodyText": "You don't need to list them here, but can you say how to find, in the source code below, all the trees that shouldn't be matched with a JavaParser node?  Is it just a search for the string \"javac\"?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546414096", "createdAt": "2020-12-20T18:47:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * Visitor that stores each visited tree that should match with some JavaParser node if the same\n+ * Java file was parsed with both. The primary purpose is to test the {@link\n+ * JointJavacJavaParserVisitor} class when the -AcheckJavaParserVisitor flag is used. That classes\n+ * traverses a javac tree and JavaParser AST simultaneously, so the trees this class stores can be\n+ * used to test if the entirety of the javac tree was visited.\n+ *\n+ * <p>Adds these trees to a set during traversal. Many trees shouldn't be matched with a JavaParser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDExNjEzOA==", "bodyText": "I don't quite understand what you mean. The class as a whole contains the instructions for how to find trees that shouldn't be matched with a JavaParser node. These exceptions occur at each call to trees.remove and when some visit method is overriden and a child is not visited. In that case the entirety of the child's subtree tree shouldn't be matched to JavaParser nodes. As far as I'm aware, all such exceptions are accompanied by a comment.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r550116138", "createdAt": "2020-12-30T10:20:45Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * Visitor that stores each visited tree that should match with some JavaParser node if the same\n+ * Java file was parsed with both. The primary purpose is to test the {@link\n+ * JointJavacJavaParserVisitor} class when the -AcheckJavaParserVisitor flag is used. That classes\n+ * traverses a javac tree and JavaParser AST simultaneously, so the trees this class stores can be\n+ * used to test if the entirety of the javac tree was visited.\n+ *\n+ * <p>Adds these trees to a set during traversal. Many trees shouldn't be matched with a JavaParser", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxNDA5Ng=="}, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNTA4NzU5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/StringLiteralConcatenateVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQxODo1Mjo0OVrOIJGgHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yN1QyMjo0MDoxMFrOILu1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxNDYyMw==", "bodyText": "By experimentation, I verified that javac returns the literal string \"ab\" for this code:\n    return (\"a\") + (\"b\");\nPlease make this implementation handle parenthesization, and add a test.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r546414623", "createdAt": "2020-12-20T18:52:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/StringLiteralConcatenateVisitor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+/**\n+ * A visitor that combines added String literals to their concatenation. For example, the expression\n+ * {@code \"a\" + \"b\"} becomes {@code \"ab\"}. This occurs even if when reading from left to right that\n+ * the two string literals are not added directly. For example, in the expression {@code 1 + \"a\" +\n+ * \"b\"} we might imagine that {@code 1 + \"a\"} is evaluated and then {@code \"b\"} is added.\n+ * Regardless, this is transformed into {@code 1 + \"ab\"}.\n+ */\n+public class StringLiteralConcatenateVisitor extends VoidVisitorAdapter<Void> {\n+    @Override\n+    public void visit(BinaryExpr node, Void p) {\n+        super.visit(node, p);\n+        if (node.getOperator() == BinaryExpr.Operator.PLUS\n+                && node.getRight().isStringLiteralExpr()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE3MjQ5Nw==", "bodyText": "I observed that optimization in the generated bytecode.  But @jwaataja does not observe that in the AST.  So nothing needs to be done here (except maybe add a comment explaining why this code does not look within parentheses).", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r549172497", "createdAt": "2020-12-27T22:40:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/StringLiteralConcatenateVisitor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+\n+/**\n+ * A visitor that combines added String literals to their concatenation. For example, the expression\n+ * {@code \"a\" + \"b\"} becomes {@code \"ab\"}. This occurs even if when reading from left to right that\n+ * the two string literals are not added directly. For example, in the expression {@code 1 + \"a\" +\n+ * \"b\"} we might imagine that {@code 1 + \"a\"} is evaluated and then {@code \"b\"} is added.\n+ * Regardless, this is transformed into {@code 1 + \"ab\"}.\n+ */\n+public class StringLiteralConcatenateVisitor extends VoidVisitorAdapter<Void> {\n+    @Override\n+    public void visit(BinaryExpr node, Void p) {\n+        super.visit(node, p);\n+        if (node.getOperator() == BinaryExpr.Operator.PLUS\n+                && node.getRight().isStringLiteralExpr()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQxNDYyMw=="}, "originalCommit": {"oid": "8b1ef68e7a7217c771e3976256a607891f625196"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDQ2MDQ4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1MjoyN1rOIN5IYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1MjoyN1rOIN5IYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQzODQzMw==", "bodyText": "If this println is executed, the method still returns normally.  Is what gets returned sensible?  Should this throw an exception instead?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551438433", "createdAt": "2021-01-04T16:52:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.JavaParser;\n+import com.github.javaparser.ParseResult;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.ArrayInitializerExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.CharLiteralExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.AnnotationValueVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Methods for converting a {@code AnnotationMirror} into a JavaParser {@code AnnotationExpr},\n+ * namely {@code annotationMirrorToAnnotationExpr}.\n+ */\n+public class AnnotationConversion {\n+    /**\n+     * Converts an AnnotationMirror into a JavaParser {@code AnnotationExpr}.\n+     *\n+     * @param annotation annotation to convert\n+     * @return a JavaParser {@code AnnotationExpr} representing the same annotation with the same\n+     *     element values. The converted annotation will contain the annotation's fully qualified\n+     *     name.\n+     */\n+    public static AnnotationExpr annotationMirrorToAnnotationExpr(AnnotationMirror annotation) {\n+        Map<? extends ExecutableElement, ? extends AnnotationValue> values =\n+                annotation.getElementValues();\n+        Name name = createQualifiedName(AnnotationUtils.annotationName(annotation));\n+        if (values.isEmpty()) {\n+            return new MarkerAnnotationExpr(name);\n+        }\n+\n+        NodeList<MemberValuePair> convertedValues = convertAnnotationValues(values);\n+        if (convertedValues.size() == 1) {\n+            return new SingleMemberAnnotationExpr(name, convertedValues.get(0).getValue());\n+        }\n+\n+        return new NormalAnnotationExpr(name, convertedValues);\n+    }\n+\n+    /**\n+     * Converts a mapping of annotation elements to their values to a list of key-value pairs\n+     * containing the JavaParser representations of the same values.\n+     *\n+     * @param values mapping of element values from an {@code AnnotationMirror}\n+     * @return a list of the key-value pairs in {@code values} converted to their JavaParser\n+     *     representations\n+     */\n+    private static NodeList<MemberValuePair> convertAnnotationValues(\n+            Map<? extends ExecutableElement, ? extends AnnotationValue> values) {\n+        NodeList<MemberValuePair> convertedValues = new NodeList<>();\n+        AnnotationValueConverterVisitor converter = new AnnotationValueConverterVisitor();\n+        for (ExecutableElement valueName : values.keySet()) {\n+            AnnotationValue value = values.get(valueName);\n+            convertedValues.add(\n+                    new MemberValuePair(\n+                            valueName.getSimpleName().toString(), value.accept(converter, null)));\n+        }\n+\n+        return convertedValues;\n+    }\n+\n+    /**\n+     * Given a fully qualified name, creates a JavaParser {@code Name} structure representing the\n+     * same name.\n+     *\n+     * @param name the fully qualified name to convert\n+     * @return a JavaParser {@code Name} holding {@code name}\n+     */\n+    private static Name createQualifiedName(String name) {\n+        String[] components = name.split(\"\\\\.\");\n+        Name result = new Name(components[0]);\n+        for (int i = 1; i < components.length; i++) {\n+            result = new Name(result, components[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * A visitor that converts annotation values from an {@code AnnotationMirror} to a JavaParser\n+     * node that can appear in an {@code AnnotationExpr}.\n+     */\n+    private static class AnnotationValueConverterVisitor\n+            implements AnnotationValueVisitor<Expression, Void> {\n+        @Override\n+        public Expression visit(AnnotationValue value, Void p) {\n+            throw new BugInCF(\"Unknown annotation value type: \" + value);\n+        }\n+\n+        @Override\n+        public Expression visitAnnotation(AnnotationMirror value, Void p) {\n+            return AnnotationConversion.annotationMirrorToAnnotationExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitArray(List<? extends AnnotationValue> value, Void p) {\n+            NodeList<Expression> valueExpressions = new NodeList<>();\n+            for (AnnotationValue arrayValue : value) {\n+                valueExpressions.add(arrayValue.accept(this, null));\n+            }\n+\n+            return new ArrayInitializerExpr(valueExpressions);\n+        }\n+\n+        @Override\n+        public Expression visitBoolean(boolean value, Void p) {\n+            return new BooleanLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitByte(byte value, Void p) {\n+            // Annotation byte values are automatically cast to the correct type, so using an\n+            // integer\n+            // literal here works.\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitChar(char value, Void p) {\n+            return new CharLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitDouble(double value, Void p) {\n+            return new DoubleLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitEnumConstant(VariableElement value, Void p) {\n+            // The enclosing element of an enum constant is the enum type itself.\n+            TypeElement enumElt = (TypeElement) value.getEnclosingElement();\n+            String[] components = enumElt.getQualifiedName().toString().split(\"\\\\.\");\n+            Expression enumName = new NameExpr(components[0]);\n+            for (int i = 1; i < components.length; i++) {\n+                enumName = new FieldAccessExpr(enumName, components[i]);\n+            }\n+\n+            return new FieldAccessExpr(enumName, value.getSimpleName().toString());\n+        }\n+\n+        @Override\n+        public Expression visitFloat(float value, Void p) {\n+            return new DoubleLiteralExpr(value + \"f\");\n+        }\n+\n+        @Override\n+        public Expression visitInt(int value, Void p) {\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitLong(long value, Void p) {\n+            if (value < 0) {\n+                return new UnaryExpr(\n+                        new LongLiteralExpr(Long.toString(-value)), UnaryExpr.Operator.MINUS);\n+            }\n+\n+            return new LongLiteralExpr(Long.toString(value));\n+        }\n+\n+        @Override\n+        public Expression visitShort(short value, Void p) {\n+            // Annotation short values are automatically cast to the correct type, so using an\n+            // integer\n+            // literal here works.\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitString(String value, Void p) {\n+            return new StringLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitType(TypeMirror value, Void p) {\n+            if (value.getKind() != TypeKind.DECLARED) {\n+                throw new BugInCF(\"Unexpected type for class expression: \" + value);\n+            }\n+\n+            DeclaredType type = (DeclaredType) value;\n+            ParseResult<ClassOrInterfaceType> parseResult =\n+                    new JavaParser()\n+                            .parseClassOrInterfaceType(\n+                                    TypesUtils.getQualifiedName(type).toString());\n+            if (!parseResult.isSuccessful()) {\n+                System.out.println(\"Invalid class or interface name: \" + value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDQ2MTgyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1Mjo0OVrOIN5JMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNjo1Mjo0OVrOIN5JMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQzODY0MQ==", "bodyText": "This should also check that the element's name is \"value\".  If the element's name is not \"value\", then a NormalAnnotationExpr must be created.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551438641", "createdAt": "2021-01-04T16:52:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.JavaParser;\n+import com.github.javaparser.ParseResult;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.ArrayInitializerExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.CharLiteralExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.AnnotationValueVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Methods for converting a {@code AnnotationMirror} into a JavaParser {@code AnnotationExpr},\n+ * namely {@code annotationMirrorToAnnotationExpr}.\n+ */\n+public class AnnotationConversion {\n+    /**\n+     * Converts an AnnotationMirror into a JavaParser {@code AnnotationExpr}.\n+     *\n+     * @param annotation annotation to convert\n+     * @return a JavaParser {@code AnnotationExpr} representing the same annotation with the same\n+     *     element values. The converted annotation will contain the annotation's fully qualified\n+     *     name.\n+     */\n+    public static AnnotationExpr annotationMirrorToAnnotationExpr(AnnotationMirror annotation) {\n+        Map<? extends ExecutableElement, ? extends AnnotationValue> values =\n+                annotation.getElementValues();\n+        Name name = createQualifiedName(AnnotationUtils.annotationName(annotation));\n+        if (values.isEmpty()) {\n+            return new MarkerAnnotationExpr(name);\n+        }\n+\n+        NodeList<MemberValuePair> convertedValues = convertAnnotationValues(values);\n+        if (convertedValues.size() == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDUzMjc4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxMTozNlrOIN508A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxMTozNlrOIN508A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0OTg0MA==", "bodyText": "Make the actor clear in the first sentence:  it's the programmer.\nAlso, what does javac do in this case?  The second sentence mentions JavaParser.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551449840", "createdAt": "2021-01-04T17:11:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * Visitor that stores each visited tree that should match with some JavaParser node if the same\n+ * Java file was parsed with both. The primary purpose is to test the {@link\n+ * JointJavacJavaParserVisitor} class when the -AcheckJavaParserVisitor flag is used. That class\n+ * traverses a javac tree and JavaParser AST simultaneously, so the trees this class stores can be\n+ * used to test if the entirety of the javac tree was visited.\n+ *\n+ * <p>Adds these trees to a set during traversal. Many trees shouldn't be matched with a JavaParser\n+ * node because there isn't a corresponding JavaParser node. These trees are excluded.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees;\n+\n+    /** Constructs a visitor with no stored trees. */\n+    public ExpectedTreesVisitor() {\n+        trees = new HashSet<>();\n+    }\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        try {\n+            java.io.InputStream in = tree.getSourceFile().openInputStream();\n+            com.github.javaparser.ast.CompilationUnit compilationUnit = StaticJavaParser.parse(in);\n+            HasVarTypeVisitor varVisitor = new HasVarTypeVisitor();\n+            varVisitor.visit(compilationUnit, null);\n+            // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+            // inserted type has no corresponding javac tree. There is no way of knowing if the\n+            // inserted tree is synthetic or not. The only sound solution would be to not add types\n+            // on the left hand side of an assignment. This would severely decrease the usefulness\n+            // of the -AcheckJavaParserVisitor check. Instead, we simply don't run the check at all\n+            // on files that contain \"var\".\n+            if (!varVisitor.hasVarType) {\n+                return super.visitCompilationUnit(tree, p);\n+            }\n+        } catch (IOException e) {\n+            throw new BugInCF(\"Unable to read source file for compilation unit\", e);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree tree, Void p) {\n+        // Skip annotations because ajava files are not required to have the same annotations as\n+        // their corresponding java files.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree tree, Void p) {\n+        defaultAction(tree);\n+        visit(tree.getModifiers(), p);\n+        visit(tree.getTypeParameters(), p);\n+        visit(tree.getExtendsClause(), p);\n+        visit(tree.getImplementsClause(), p);\n+        if (tree.getKind() == Kind.ENUM) {\n+            // Enum constants expand to a VariableTree like\n+            // public static final MY_ENUM_CONSTANT = new MyEnum(args ...)\n+            // The constructor invocation in the initializer has no corresponding JavaParser node,\n+            // this removes those invocations. It doesn't remove any trees that should be matched to\n+            // a JavaParser node because it's illegal to explicitly construct an instance of an\n+            // enum.\n+            for (Tree member : tree.getMembers()) {\n+                member.accept(this, p);\n+                if (member.getKind() != Kind.VARIABLE) {\n+                    continue;\n+                }\n+\n+                VariableTree variable = (VariableTree) member;\n+                ExpressionTree initializer = variable.getInitializer();\n+                if (initializer == null || initializer.getKind() != Kind.NEW_CLASS) {\n+                    continue;\n+                }\n+\n+                NewClassTree constructor = (NewClassTree) initializer;\n+                if (constructor.getIdentifier().getKind() != Kind.IDENTIFIER) {\n+                    continue;\n+                }\n+\n+                IdentifierTree name = (IdentifierTree) constructor.getIdentifier();\n+                if (name.getName().contentEquals(tree.getSimpleName())) {\n+                    trees.remove(variable.getType());\n+                    trees.remove(constructor);\n+                    trees.remove(constructor.getIdentifier());\n+                }\n+            }\n+        } else {\n+            visit(tree.getMembers(), p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree tree, Void p) {\n+        // Javac inserts calls to super() at the start of constructors with no this or super call.\n+        // These don't have matching JavaParser nodes.\n+        if (JointJavacJavaParserVisitor.isDefaultSuperConstructorCall(tree)) {\n+            return null;\n+        }\n+\n+        // Whereas synthetic constructors should be skipped entirely, regular super() and this()\n+        // should\n+        // still be added. However, in JavaParser there's no matching expression statement\n+        // surrounding these, so remove the expression statement itself.\n+        Void result = super.visitExpressionStatement(tree, p);\n+        if (tree.getExpression().getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationTree invocation = (MethodInvocationTree) tree.getExpression();\n+            if (invocation.getMethodSelect().getKind() == Kind.IDENTIFIER) {\n+                IdentifierTree identifier = (IdentifierTree) invocation.getMethodSelect();\n+                if (identifier.getName().contentEquals(\"this\")\n+                        || identifier.getName().contentEquals(\"super\")) {\n+                    trees.remove(tree);\n+                    trees.remove(identifier);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree tree, Void p) {\n+        // Javac nests a for loop's updates in expression statements but JavaParser stores the\n+        // statements directly, so remove the expression statements.\n+        Void result = super.visitForLoop(tree, p);\n+        for (StatementTree initializer : tree.getInitializer()) {\n+            trees.remove(initializer);\n+        }\n+\n+        for (ExpressionStatementTree update : tree.getUpdate()) {\n+            trees.remove(update);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitSwitch(SwitchTree tree, Void p) {\n+        super.visitSwitch(tree, p);\n+        // javac surrounds switch expression in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitSynchronized(SynchronizedTree tree, Void p) {\n+        super.visitSynchronized(tree, p);\n+        // javac surrounds synchronized expressions in a ParenthesizedTree but JavaParser does not,\n+        // so don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree tree, Void p) {\n+        // In an if statement, javac stores the condition as a parenthesized expression, which has\n+        // no corresponding JavaParserNode, so remove the parenthesized expression, but not its\n+        // child.\n+        Void result = super.visitIf(tree, p);\n+        trees.remove(tree.getCondition());\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree tree, Void p) {\n+        // Javac stores an import like a.* as a member select, but JavaParser just stores \"a\", so\n+        // don't add the whole member select in that case.\n+        if (tree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT) {\n+            MemberSelectTree memberSelect = (MemberSelectTree) tree.getQualifiedIdentifier();\n+            if (memberSelect.getIdentifier().contentEquals(\"*\")) {\n+                memberSelect.getExpression().accept(this, p);\n+                return null;\n+            }\n+        }\n+\n+        return super.visitImport(tree, p);\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree tree, Void p) {\n+        // Synthetic default constructors don't have matching JavaParser nodes. Conservatively skip\n+        // no argument constructor calls, even if they may not be synthetic.\n+        if (JointJavacJavaParserVisitor.isNoArgumentConstructor(tree)) {\n+            return null;\n+        }\n+\n+        Void result = super.visitMethod(tree, p);\n+        // A varargs parameter like String... is converted to String[], where the array type doesn't\n+        // have a corresponding JavaParser node. Conservatively skip the array type (but not the\n+        // component type) if it's the last argument.\n+        if (!tree.getParameters().isEmpty()) {\n+            VariableTree last = tree.getParameters().get(tree.getParameters().size() - 1);\n+            if (last.getType().getKind() == Kind.ARRAY_TYPE) {\n+                trees.remove(last.getType());\n+            }\n+\n+            if (last.getType().getKind() == Kind.ANNOTATED_TYPE) {\n+                AnnotatedTypeTree annotatedType = (AnnotatedTypeTree) last.getType();\n+                if (annotatedType.getUnderlyingType().getKind() == Kind.ARRAY_TYPE) {\n+                    trees.remove(annotatedType);\n+                    trees.remove(annotatedType.getUnderlyingType());\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree tree, Void p) {\n+        Void result = super.visitMethodInvocation(tree, p);\n+        // In a method invocation like myObject.myMethod(), the method invocation stores\n+        // myObject.myMethod as its own MemberSelectTree which has no corresponding JavaParserNode.\n+        if (tree.getMethodSelect().getKind() == Kind.MEMBER_SELECT) {\n+            trees.remove(tree.getMethodSelect());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitModifiers(ModifiersTree tree, Void p) {\n+        // Don't add ModifierTrees or children because they have no corresponding JavaParser node.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewArray(NewArrayTree tree, Void p) {\n+        // Skip array initialization because it's not implemented yet.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewClass(NewClassTree tree, Void p) {\n+        defaultAction(tree);\n+\n+        if (tree.getEnclosingExpression() != null) {\n+            tree.getEnclosingExpression().accept(this, p);\n+        }\n+\n+        tree.getIdentifier().accept(this, p);\n+        for (Tree typeArgument : tree.getTypeArguments()) {\n+            typeArgument.accept(this, p);\n+        }\n+\n+        for (Tree arg : tree.getTypeArguments()) {\n+            arg.accept(this, p);\n+        }\n+\n+        if (tree.getClassBody() == null) {\n+            return null;\n+        }\n+\n+        // Anonymous class bodies require special handling. There isn't a corresponding JavaParser\n+        // node, and synthetic constructors must be skipped.\n+        ClassTree body = tree.getClassBody();\n+        visit(body.getModifiers(), p);\n+        visit(body.getTypeParameters(), p);\n+        visit(body.getImplementsClause(), p);\n+        for (Tree member : body.getMembers()) {\n+            // Constructors cannot be declared in an anonymous class, so don't add them.\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    continue;\n+                }\n+            }\n+\n+            member.accept(this, p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree tree, Void p) {\n+        for (VariableTree parameter : tree.getParameters()) {\n+            // Parameter types might not be specified for lambdas. When not specified, JavaParser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU0NTQ0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxNTowOFrOIN58qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwOTo1Njo0OFrOISnwjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MTgxNw==", "bodyText": "Once hasVarType is true, there is no need to do any more visiting.\n(For efficiency, it would even be possible to shortcut, such as by throwing an exception that could be caught by the static hasVarType method that I added, and then you also wouldn't need the variable.  You could skip this optimization if you find it gross.)", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551451817", "createdAt": "2021-01-04T17:15:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * Visitor that stores each visited tree that should match with some JavaParser node if the same\n+ * Java file was parsed with both. The primary purpose is to test the {@link\n+ * JointJavacJavaParserVisitor} class when the -AcheckJavaParserVisitor flag is used. That class\n+ * traverses a javac tree and JavaParser AST simultaneously, so the trees this class stores can be\n+ * used to test if the entirety of the javac tree was visited.\n+ *\n+ * <p>Adds these trees to a set during traversal. Many trees shouldn't be matched with a JavaParser\n+ * node because there isn't a corresponding JavaParser node. These trees are excluded.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees;\n+\n+    /** Constructs a visitor with no stored trees. */\n+    public ExpectedTreesVisitor() {\n+        trees = new HashSet<>();\n+    }\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        try {\n+            java.io.InputStream in = tree.getSourceFile().openInputStream();\n+            com.github.javaparser.ast.CompilationUnit compilationUnit = StaticJavaParser.parse(in);\n+            HasVarTypeVisitor varVisitor = new HasVarTypeVisitor();\n+            varVisitor.visit(compilationUnit, null);\n+            // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+            // inserted type has no corresponding javac tree. There is no way of knowing if the\n+            // inserted tree is synthetic or not. The only sound solution would be to not add types\n+            // on the left hand side of an assignment. This would severely decrease the usefulness\n+            // of the -AcheckJavaParserVisitor check. Instead, we simply don't run the check at all\n+            // on files that contain \"var\".\n+            if (!varVisitor.hasVarType) {\n+                return super.visitCompilationUnit(tree, p);\n+            }\n+        } catch (IOException e) {\n+            throw new BugInCF(\"Unable to read source file for compilation unit\", e);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree tree, Void p) {\n+        // Skip annotations because ajava files are not required to have the same annotations as\n+        // their corresponding java files.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree tree, Void p) {\n+        defaultAction(tree);\n+        visit(tree.getModifiers(), p);\n+        visit(tree.getTypeParameters(), p);\n+        visit(tree.getExtendsClause(), p);\n+        visit(tree.getImplementsClause(), p);\n+        if (tree.getKind() == Kind.ENUM) {\n+            // Enum constants expand to a VariableTree like\n+            // public static final MY_ENUM_CONSTANT = new MyEnum(args ...)\n+            // The constructor invocation in the initializer has no corresponding JavaParser node,\n+            // this removes those invocations. It doesn't remove any trees that should be matched to\n+            // a JavaParser node because it's illegal to explicitly construct an instance of an\n+            // enum.\n+            for (Tree member : tree.getMembers()) {\n+                member.accept(this, p);\n+                if (member.getKind() != Kind.VARIABLE) {\n+                    continue;\n+                }\n+\n+                VariableTree variable = (VariableTree) member;\n+                ExpressionTree initializer = variable.getInitializer();\n+                if (initializer == null || initializer.getKind() != Kind.NEW_CLASS) {\n+                    continue;\n+                }\n+\n+                NewClassTree constructor = (NewClassTree) initializer;\n+                if (constructor.getIdentifier().getKind() != Kind.IDENTIFIER) {\n+                    continue;\n+                }\n+\n+                IdentifierTree name = (IdentifierTree) constructor.getIdentifier();\n+                if (name.getName().contentEquals(tree.getSimpleName())) {\n+                    trees.remove(variable.getType());\n+                    trees.remove(constructor);\n+                    trees.remove(constructor.getIdentifier());\n+                }\n+            }\n+        } else {\n+            visit(tree.getMembers(), p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree tree, Void p) {\n+        // Javac inserts calls to super() at the start of constructors with no this or super call.\n+        // These don't have matching JavaParser nodes.\n+        if (JointJavacJavaParserVisitor.isDefaultSuperConstructorCall(tree)) {\n+            return null;\n+        }\n+\n+        // Whereas synthetic constructors should be skipped entirely, regular super() and this()\n+        // should\n+        // still be added. However, in JavaParser there's no matching expression statement\n+        // surrounding these, so remove the expression statement itself.\n+        Void result = super.visitExpressionStatement(tree, p);\n+        if (tree.getExpression().getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationTree invocation = (MethodInvocationTree) tree.getExpression();\n+            if (invocation.getMethodSelect().getKind() == Kind.IDENTIFIER) {\n+                IdentifierTree identifier = (IdentifierTree) invocation.getMethodSelect();\n+                if (identifier.getName().contentEquals(\"this\")\n+                        || identifier.getName().contentEquals(\"super\")) {\n+                    trees.remove(tree);\n+                    trees.remove(identifier);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree tree, Void p) {\n+        // Javac nests a for loop's updates in expression statements but JavaParser stores the\n+        // statements directly, so remove the expression statements.\n+        Void result = super.visitForLoop(tree, p);\n+        for (StatementTree initializer : tree.getInitializer()) {\n+            trees.remove(initializer);\n+        }\n+\n+        for (ExpressionStatementTree update : tree.getUpdate()) {\n+            trees.remove(update);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitSwitch(SwitchTree tree, Void p) {\n+        super.visitSwitch(tree, p);\n+        // javac surrounds switch expression in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitSynchronized(SynchronizedTree tree, Void p) {\n+        super.visitSynchronized(tree, p);\n+        // javac surrounds synchronized expressions in a ParenthesizedTree but JavaParser does not,\n+        // so don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree tree, Void p) {\n+        // In an if statement, javac stores the condition as a parenthesized expression, which has\n+        // no corresponding JavaParserNode, so remove the parenthesized expression, but not its\n+        // child.\n+        Void result = super.visitIf(tree, p);\n+        trees.remove(tree.getCondition());\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree tree, Void p) {\n+        // Javac stores an import like a.* as a member select, but JavaParser just stores \"a\", so\n+        // don't add the whole member select in that case.\n+        if (tree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT) {\n+            MemberSelectTree memberSelect = (MemberSelectTree) tree.getQualifiedIdentifier();\n+            if (memberSelect.getIdentifier().contentEquals(\"*\")) {\n+                memberSelect.getExpression().accept(this, p);\n+                return null;\n+            }\n+        }\n+\n+        return super.visitImport(tree, p);\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree tree, Void p) {\n+        // Synthetic default constructors don't have matching JavaParser nodes. Conservatively skip\n+        // no argument constructor calls, even if they may not be synthetic.\n+        if (JointJavacJavaParserVisitor.isNoArgumentConstructor(tree)) {\n+            return null;\n+        }\n+\n+        Void result = super.visitMethod(tree, p);\n+        // A varargs parameter like String... is converted to String[], where the array type doesn't\n+        // have a corresponding JavaParser node. Conservatively skip the array type (but not the\n+        // component type) if it's the last argument.\n+        if (!tree.getParameters().isEmpty()) {\n+            VariableTree last = tree.getParameters().get(tree.getParameters().size() - 1);\n+            if (last.getType().getKind() == Kind.ARRAY_TYPE) {\n+                trees.remove(last.getType());\n+            }\n+\n+            if (last.getType().getKind() == Kind.ANNOTATED_TYPE) {\n+                AnnotatedTypeTree annotatedType = (AnnotatedTypeTree) last.getType();\n+                if (annotatedType.getUnderlyingType().getKind() == Kind.ARRAY_TYPE) {\n+                    trees.remove(annotatedType);\n+                    trees.remove(annotatedType.getUnderlyingType());\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree tree, Void p) {\n+        Void result = super.visitMethodInvocation(tree, p);\n+        // In a method invocation like myObject.myMethod(), the method invocation stores\n+        // myObject.myMethod as its own MemberSelectTree which has no corresponding JavaParserNode.\n+        if (tree.getMethodSelect().getKind() == Kind.MEMBER_SELECT) {\n+            trees.remove(tree.getMethodSelect());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitModifiers(ModifiersTree tree, Void p) {\n+        // Don't add ModifierTrees or children because they have no corresponding JavaParser node.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewArray(NewArrayTree tree, Void p) {\n+        // Skip array initialization because it's not implemented yet.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewClass(NewClassTree tree, Void p) {\n+        defaultAction(tree);\n+\n+        if (tree.getEnclosingExpression() != null) {\n+            tree.getEnclosingExpression().accept(this, p);\n+        }\n+\n+        tree.getIdentifier().accept(this, p);\n+        for (Tree typeArgument : tree.getTypeArguments()) {\n+            typeArgument.accept(this, p);\n+        }\n+\n+        for (Tree arg : tree.getTypeArguments()) {\n+            arg.accept(this, p);\n+        }\n+\n+        if (tree.getClassBody() == null) {\n+            return null;\n+        }\n+\n+        // Anonymous class bodies require special handling. There isn't a corresponding JavaParser\n+        // node, and synthetic constructors must be skipped.\n+        ClassTree body = tree.getClassBody();\n+        visit(body.getModifiers(), p);\n+        visit(body.getTypeParameters(), p);\n+        visit(body.getImplementsClause(), p);\n+        for (Tree member : body.getMembers()) {\n+            // Constructors cannot be declared in an anonymous class, so don't add them.\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    continue;\n+                }\n+            }\n+\n+            member.accept(this, p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree tree, Void p) {\n+        for (VariableTree parameter : tree.getParameters()) {\n+            // Parameter types might not be specified for lambdas. When not specified, JavaParser\n+            // uses UnknownType. Conservatively, don't add parameter types for lambda expressions.\n+            visit(parameter.getModifiers(), p);\n+            visit(parameter.getNameExpression(), p);\n+            assert parameter.getInitializer() == null;\n+        }\n+\n+        visit(tree.getBody(), p);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitWhileLoop(WhileLoopTree tree, Void p) {\n+        super.visitWhileLoop(tree, p);\n+        // javac surrounds while loop conditions in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getCondition());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree tree, Void p) {\n+        super.visitDoWhileLoop(tree, p);\n+        // javac surrounds while loop conditions in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getCondition());\n+        return null;\n+    }\n+\n+    /**\n+     * Calls the correct visit method for {@code tree} if {@code tree} is non-null.\n+     *\n+     * @param tree the tree to visit\n+     * @param p secondary parameter to the visitor\n+     */\n+    private void visit(@Nullable Tree tree, Void p) {\n+        if (tree != null) {\n+            tree.accept(this, p);\n+        }\n+    }\n+\n+    /**\n+     * If {@code trees} is non-null, visits each non-null tree in {@code trees} in order.\n+     *\n+     * @param trees the list of trees to visit\n+     * @param p secondary parameter to the visitor\n+     */\n+    private void visit(@Nullable List<? extends @Nullable Tree> trees, Void p) {\n+        if (trees == null) {\n+            return;\n+        }\n+\n+        for (Tree tree : trees) {\n+            visit(tree, p);\n+        }\n+    }\n+\n+    /** Visitor that records whether it has visited a \"var\" keyword. */\n+    private static class HasVarTypeVisitor extends VoidVisitorAdapter<Void> {\n+        /** Whether a \"var\" keyword has been visited. */\n+        public boolean hasVarType;\n+\n+        /** Constructs a visitor that hasn't yet recorded visiting a \"var\" keyword. */\n+        public HasVarTypeVisitor() {\n+            hasVarType = false;\n+        }\n+\n+        @Override\n+        public void visit(ClassOrInterfaceType node, Void p) {\n+            if (node.getName().asString().equals(\"var\")) {\n+                hasVarType = true;\n+            }\n+\n+            super.visit(node, p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM5NjY4NA==", "bodyText": "This class is only used by the testing framework, and this would only be an optimization if the file actually uses var, which doesn't occur often in the tests as far as I know.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r556396684", "createdAt": "2021-01-13T09:56:48Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * Visitor that stores each visited tree that should match with some JavaParser node if the same\n+ * Java file was parsed with both. The primary purpose is to test the {@link\n+ * JointJavacJavaParserVisitor} class when the -AcheckJavaParserVisitor flag is used. That class\n+ * traverses a javac tree and JavaParser AST simultaneously, so the trees this class stores can be\n+ * used to test if the entirety of the javac tree was visited.\n+ *\n+ * <p>Adds these trees to a set during traversal. Many trees shouldn't be matched with a JavaParser\n+ * node because there isn't a corresponding JavaParser node. These trees are excluded.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees;\n+\n+    /** Constructs a visitor with no stored trees. */\n+    public ExpectedTreesVisitor() {\n+        trees = new HashSet<>();\n+    }\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        try {\n+            java.io.InputStream in = tree.getSourceFile().openInputStream();\n+            com.github.javaparser.ast.CompilationUnit compilationUnit = StaticJavaParser.parse(in);\n+            HasVarTypeVisitor varVisitor = new HasVarTypeVisitor();\n+            varVisitor.visit(compilationUnit, null);\n+            // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+            // inserted type has no corresponding javac tree. There is no way of knowing if the\n+            // inserted tree is synthetic or not. The only sound solution would be to not add types\n+            // on the left hand side of an assignment. This would severely decrease the usefulness\n+            // of the -AcheckJavaParserVisitor check. Instead, we simply don't run the check at all\n+            // on files that contain \"var\".\n+            if (!varVisitor.hasVarType) {\n+                return super.visitCompilationUnit(tree, p);\n+            }\n+        } catch (IOException e) {\n+            throw new BugInCF(\"Unable to read source file for compilation unit\", e);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree tree, Void p) {\n+        // Skip annotations because ajava files are not required to have the same annotations as\n+        // their corresponding java files.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree tree, Void p) {\n+        defaultAction(tree);\n+        visit(tree.getModifiers(), p);\n+        visit(tree.getTypeParameters(), p);\n+        visit(tree.getExtendsClause(), p);\n+        visit(tree.getImplementsClause(), p);\n+        if (tree.getKind() == Kind.ENUM) {\n+            // Enum constants expand to a VariableTree like\n+            // public static final MY_ENUM_CONSTANT = new MyEnum(args ...)\n+            // The constructor invocation in the initializer has no corresponding JavaParser node,\n+            // this removes those invocations. It doesn't remove any trees that should be matched to\n+            // a JavaParser node because it's illegal to explicitly construct an instance of an\n+            // enum.\n+            for (Tree member : tree.getMembers()) {\n+                member.accept(this, p);\n+                if (member.getKind() != Kind.VARIABLE) {\n+                    continue;\n+                }\n+\n+                VariableTree variable = (VariableTree) member;\n+                ExpressionTree initializer = variable.getInitializer();\n+                if (initializer == null || initializer.getKind() != Kind.NEW_CLASS) {\n+                    continue;\n+                }\n+\n+                NewClassTree constructor = (NewClassTree) initializer;\n+                if (constructor.getIdentifier().getKind() != Kind.IDENTIFIER) {\n+                    continue;\n+                }\n+\n+                IdentifierTree name = (IdentifierTree) constructor.getIdentifier();\n+                if (name.getName().contentEquals(tree.getSimpleName())) {\n+                    trees.remove(variable.getType());\n+                    trees.remove(constructor);\n+                    trees.remove(constructor.getIdentifier());\n+                }\n+            }\n+        } else {\n+            visit(tree.getMembers(), p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree tree, Void p) {\n+        // Javac inserts calls to super() at the start of constructors with no this or super call.\n+        // These don't have matching JavaParser nodes.\n+        if (JointJavacJavaParserVisitor.isDefaultSuperConstructorCall(tree)) {\n+            return null;\n+        }\n+\n+        // Whereas synthetic constructors should be skipped entirely, regular super() and this()\n+        // should\n+        // still be added. However, in JavaParser there's no matching expression statement\n+        // surrounding these, so remove the expression statement itself.\n+        Void result = super.visitExpressionStatement(tree, p);\n+        if (tree.getExpression().getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationTree invocation = (MethodInvocationTree) tree.getExpression();\n+            if (invocation.getMethodSelect().getKind() == Kind.IDENTIFIER) {\n+                IdentifierTree identifier = (IdentifierTree) invocation.getMethodSelect();\n+                if (identifier.getName().contentEquals(\"this\")\n+                        || identifier.getName().contentEquals(\"super\")) {\n+                    trees.remove(tree);\n+                    trees.remove(identifier);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree tree, Void p) {\n+        // Javac nests a for loop's updates in expression statements but JavaParser stores the\n+        // statements directly, so remove the expression statements.\n+        Void result = super.visitForLoop(tree, p);\n+        for (StatementTree initializer : tree.getInitializer()) {\n+            trees.remove(initializer);\n+        }\n+\n+        for (ExpressionStatementTree update : tree.getUpdate()) {\n+            trees.remove(update);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitSwitch(SwitchTree tree, Void p) {\n+        super.visitSwitch(tree, p);\n+        // javac surrounds switch expression in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitSynchronized(SynchronizedTree tree, Void p) {\n+        super.visitSynchronized(tree, p);\n+        // javac surrounds synchronized expressions in a ParenthesizedTree but JavaParser does not,\n+        // so don't check the condition tree.\n+        trees.remove(tree.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree tree, Void p) {\n+        // In an if statement, javac stores the condition as a parenthesized expression, which has\n+        // no corresponding JavaParserNode, so remove the parenthesized expression, but not its\n+        // child.\n+        Void result = super.visitIf(tree, p);\n+        trees.remove(tree.getCondition());\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree tree, Void p) {\n+        // Javac stores an import like a.* as a member select, but JavaParser just stores \"a\", so\n+        // don't add the whole member select in that case.\n+        if (tree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT) {\n+            MemberSelectTree memberSelect = (MemberSelectTree) tree.getQualifiedIdentifier();\n+            if (memberSelect.getIdentifier().contentEquals(\"*\")) {\n+                memberSelect.getExpression().accept(this, p);\n+                return null;\n+            }\n+        }\n+\n+        return super.visitImport(tree, p);\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree tree, Void p) {\n+        // Synthetic default constructors don't have matching JavaParser nodes. Conservatively skip\n+        // no argument constructor calls, even if they may not be synthetic.\n+        if (JointJavacJavaParserVisitor.isNoArgumentConstructor(tree)) {\n+            return null;\n+        }\n+\n+        Void result = super.visitMethod(tree, p);\n+        // A varargs parameter like String... is converted to String[], where the array type doesn't\n+        // have a corresponding JavaParser node. Conservatively skip the array type (but not the\n+        // component type) if it's the last argument.\n+        if (!tree.getParameters().isEmpty()) {\n+            VariableTree last = tree.getParameters().get(tree.getParameters().size() - 1);\n+            if (last.getType().getKind() == Kind.ARRAY_TYPE) {\n+                trees.remove(last.getType());\n+            }\n+\n+            if (last.getType().getKind() == Kind.ANNOTATED_TYPE) {\n+                AnnotatedTypeTree annotatedType = (AnnotatedTypeTree) last.getType();\n+                if (annotatedType.getUnderlyingType().getKind() == Kind.ARRAY_TYPE) {\n+                    trees.remove(annotatedType);\n+                    trees.remove(annotatedType.getUnderlyingType());\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree tree, Void p) {\n+        Void result = super.visitMethodInvocation(tree, p);\n+        // In a method invocation like myObject.myMethod(), the method invocation stores\n+        // myObject.myMethod as its own MemberSelectTree which has no corresponding JavaParserNode.\n+        if (tree.getMethodSelect().getKind() == Kind.MEMBER_SELECT) {\n+            trees.remove(tree.getMethodSelect());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public Void visitModifiers(ModifiersTree tree, Void p) {\n+        // Don't add ModifierTrees or children because they have no corresponding JavaParser node.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewArray(NewArrayTree tree, Void p) {\n+        // Skip array initialization because it's not implemented yet.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewClass(NewClassTree tree, Void p) {\n+        defaultAction(tree);\n+\n+        if (tree.getEnclosingExpression() != null) {\n+            tree.getEnclosingExpression().accept(this, p);\n+        }\n+\n+        tree.getIdentifier().accept(this, p);\n+        for (Tree typeArgument : tree.getTypeArguments()) {\n+            typeArgument.accept(this, p);\n+        }\n+\n+        for (Tree arg : tree.getTypeArguments()) {\n+            arg.accept(this, p);\n+        }\n+\n+        if (tree.getClassBody() == null) {\n+            return null;\n+        }\n+\n+        // Anonymous class bodies require special handling. There isn't a corresponding JavaParser\n+        // node, and synthetic constructors must be skipped.\n+        ClassTree body = tree.getClassBody();\n+        visit(body.getModifiers(), p);\n+        visit(body.getTypeParameters(), p);\n+        visit(body.getImplementsClause(), p);\n+        for (Tree member : body.getMembers()) {\n+            // Constructors cannot be declared in an anonymous class, so don't add them.\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    continue;\n+                }\n+            }\n+\n+            member.accept(this, p);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree tree, Void p) {\n+        for (VariableTree parameter : tree.getParameters()) {\n+            // Parameter types might not be specified for lambdas. When not specified, JavaParser\n+            // uses UnknownType. Conservatively, don't add parameter types for lambda expressions.\n+            visit(parameter.getModifiers(), p);\n+            visit(parameter.getNameExpression(), p);\n+            assert parameter.getInitializer() == null;\n+        }\n+\n+        visit(tree.getBody(), p);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitWhileLoop(WhileLoopTree tree, Void p) {\n+        super.visitWhileLoop(tree, p);\n+        // javac surrounds while loop conditions in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getCondition());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree tree, Void p) {\n+        super.visitDoWhileLoop(tree, p);\n+        // javac surrounds while loop conditions in a ParenthesizedTree but JavaParser does not, so\n+        // don't check the condition tree.\n+        trees.remove(tree.getCondition());\n+        return null;\n+    }\n+\n+    /**\n+     * Calls the correct visit method for {@code tree} if {@code tree} is non-null.\n+     *\n+     * @param tree the tree to visit\n+     * @param p secondary parameter to the visitor\n+     */\n+    private void visit(@Nullable Tree tree, Void p) {\n+        if (tree != null) {\n+            tree.accept(this, p);\n+        }\n+    }\n+\n+    /**\n+     * If {@code trees} is non-null, visits each non-null tree in {@code trees} in order.\n+     *\n+     * @param trees the list of trees to visit\n+     * @param p secondary parameter to the visitor\n+     */\n+    private void visit(@Nullable List<? extends @Nullable Tree> trees, Void p) {\n+        if (trees == null) {\n+            return;\n+        }\n+\n+        for (Tree tree : trees) {\n+            visit(tree, p);\n+        }\n+    }\n+\n+    /** Visitor that records whether it has visited a \"var\" keyword. */\n+    private static class HasVarTypeVisitor extends VoidVisitorAdapter<Void> {\n+        /** Whether a \"var\" keyword has been visited. */\n+        public boolean hasVarType;\n+\n+        /** Constructs a visitor that hasn't yet recorded visiting a \"var\" keyword. */\n+        public HasVarTypeVisitor() {\n+            hasVarType = false;\n+        }\n+\n+        @Override\n+        public void visit(ClassOrInterfaceType node, Void p) {\n+            if (node.getName().asString().equals(\"var\")) {\n+                hasVarType = true;\n+            }\n+\n+            super.visit(node, p);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MTgxNw=="}, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU1MTE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxNjozMFrOIN5_yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxNjozMFrOIN5_yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MjYxOQ==", "bodyText": "Should \"might be\" be \"is\"?  If not, under what circumstance is the statement about storage true?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551452619", "createdAt": "2021-01-04T17:16:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU1NDg5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxNzozMFrOIN6CEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxNzozMFrOIN6CEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MzIwMQ==", "bodyText": "I suggest that you also assert that the element name is \"value\".", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551453201", "createdAt": "2021-01-04T17:17:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU2MDU3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxOTowMVrOIN6Faw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoxOTowMVrOIN6Faw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1NDA1OQ==", "bodyText": "Here and elsewhere, you could drop the boolean and just test whether javacStatement is null.  That would be a bit shorter.  But you can leave this code as is if you prefer.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551454059", "createdAt": "2021-01-04T17:19:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU3NDAzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyMzoyNFrOIN6OZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyMzoyNFrOIN6OZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1NjM1Ng==", "bodyText": "Should it be an error if these are not equal?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551456356", "createdAt": "2021-01-04T17:23:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU4MDk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyNToyMFrOIN6Sbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyNToyMFrOIN6Sbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1NzM5MA==", "bodyText": "Why is this a while loop rather than an if test?  I think there can be at most one initializer to remove.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551457390", "createdAt": "2021-01-04T17:25:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 610}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU4NDQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyNjoyNVrOIN6Uow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyNjoyNVrOIN6Uow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1Nzk1NQ==", "bodyText": "I'm confused by this comment.  Should it be \"the expression than the expression statement itself.\"?  In any event, please clarify.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551457955", "createdAt": "2021-01-04T17:26:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 778}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU5MTYxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyODozM1rOIN6Y9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzoyODozM1rOIN6Y9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1OTA2Mg==", "bodyText": "This seems to visit a javac expression and a JavaParser statement, which seems wrong to me because they are different kinds of AST nodes.  Perhaps clarifying the comment will resolve my confusion.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551459062", "createdAt": "2021-01-04T17:28:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            update.getExpression().accept(this, javaParserIter.next());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 823}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU5NzAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMDowOVrOIN6cQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QxMDozNDozNVrOISpNOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1OTkwNA==", "bodyText": "Minor:  I would find it easier to read the code if variables like node were prefixed by javaParser or javac.  In this case, a clearer name would be javaParserLambdaExpr.  (Do you prefer the generic node so all method bodies use the same variable name for the downcasted variable?)", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551459904", "createdAt": "2021-01-04T17:30:09Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            update.getExpression().accept(this, javaParserIter.next());\n+        }\n+\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIdentifier(IdentifierTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceType) {\n+            processIdentifier(javacTree, (ClassOrInterfaceType) javaParserNode);\n+        } else if (javaParserNode instanceof Name) {\n+            processIdentifier(javacTree, (Name) javaParserNode);\n+        } else if (javaParserNode instanceof NameExpr) {\n+            processIdentifier(javacTree, (NameExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SimpleName) {\n+            processIdentifier(javacTree, (SimpleName) javaParserNode);\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            processIdentifier(javacTree, (ThisExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            processIdentifier(javacTree, (SuperExpr) javaParserNode);\n+        } else if (javaParserNode instanceof TypeExpr) {\n+            // This occurs in a member reference like MyClass::myMember. The MyClass is wrapped in a\n+            // TypeExpr.\n+            javacTree.accept(this, ((TypeExpr) javaParserNode).getType());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IfStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IfStmt.class);\n+        }\n+\n+        IfStmt node = (IfStmt) javaParserNode;\n+        processIf(javacTree, node);\n+        assert javacTree.getCondition().getKind() == Kind.PARENTHESIZED;\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getThenStatement().accept(this, node.getThenStmt());\n+        assert (javacTree.getElseStatement() != null) == node.getElseStmt().isPresent();\n+        if (javacTree.getElseStatement() != null) {\n+            javacTree.getElseStatement().accept(this, node.getElseStmt().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ImportDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ImportDeclaration.class);\n+        }\n+\n+        ImportDeclaration node = (ImportDeclaration) javaParserNode;\n+        processImport(javacTree, node);\n+        // In javac trees, a name like a.* is stored as a member select, but JavaParser just stores\n+        // a and records that the name ends in an asterisk.\n+        if (node.isAsterisk()) {\n+            assert javacTree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT;\n+            MemberSelectTree identifier = (MemberSelectTree) javacTree.getQualifiedIdentifier();\n+            identifier.getExpression().accept(this, node.getName());\n+        } else {\n+            javacTree.getQualifiedIdentifier().accept(this, node.getName());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitInstanceOf(InstanceOfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof InstanceOfExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, InstanceOfExpr.class);\n+        }\n+\n+        InstanceOfExpr node = (InstanceOfExpr) javaParserNode;\n+        processInstanceOf(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        javacTree.getType().accept(this, node.getType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIntersectionType(IntersectionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IntersectionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IntersectionType.class);\n+        }\n+\n+        IntersectionType node = (IntersectionType) javaParserNode;\n+        processIntersectionType(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLabeledStatement(LabeledStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LabeledStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LabeledStmt.class);\n+        }\n+\n+        LabeledStmt node = (LabeledStmt) javaParserNode;\n+        processLabeledStatement(javacTree, node);\n+        javacTree.getStatement().accept(this, node.getStatement());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LambdaExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LambdaExpr.class);\n+        }\n+\n+        LambdaExpr node = (LambdaExpr) javaParserNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 939}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQyMDQwOA==", "bodyText": "Yes, I prefer that name because it can be used in every method, and the name javaParserNode is already used for the parameter type.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r556420408", "createdAt": "2021-01-13T10:34:35Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            update.getExpression().accept(this, javaParserIter.next());\n+        }\n+\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIdentifier(IdentifierTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceType) {\n+            processIdentifier(javacTree, (ClassOrInterfaceType) javaParserNode);\n+        } else if (javaParserNode instanceof Name) {\n+            processIdentifier(javacTree, (Name) javaParserNode);\n+        } else if (javaParserNode instanceof NameExpr) {\n+            processIdentifier(javacTree, (NameExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SimpleName) {\n+            processIdentifier(javacTree, (SimpleName) javaParserNode);\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            processIdentifier(javacTree, (ThisExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            processIdentifier(javacTree, (SuperExpr) javaParserNode);\n+        } else if (javaParserNode instanceof TypeExpr) {\n+            // This occurs in a member reference like MyClass::myMember. The MyClass is wrapped in a\n+            // TypeExpr.\n+            javacTree.accept(this, ((TypeExpr) javaParserNode).getType());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IfStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IfStmt.class);\n+        }\n+\n+        IfStmt node = (IfStmt) javaParserNode;\n+        processIf(javacTree, node);\n+        assert javacTree.getCondition().getKind() == Kind.PARENTHESIZED;\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getThenStatement().accept(this, node.getThenStmt());\n+        assert (javacTree.getElseStatement() != null) == node.getElseStmt().isPresent();\n+        if (javacTree.getElseStatement() != null) {\n+            javacTree.getElseStatement().accept(this, node.getElseStmt().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ImportDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ImportDeclaration.class);\n+        }\n+\n+        ImportDeclaration node = (ImportDeclaration) javaParserNode;\n+        processImport(javacTree, node);\n+        // In javac trees, a name like a.* is stored as a member select, but JavaParser just stores\n+        // a and records that the name ends in an asterisk.\n+        if (node.isAsterisk()) {\n+            assert javacTree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT;\n+            MemberSelectTree identifier = (MemberSelectTree) javacTree.getQualifiedIdentifier();\n+            identifier.getExpression().accept(this, node.getName());\n+        } else {\n+            javacTree.getQualifiedIdentifier().accept(this, node.getName());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitInstanceOf(InstanceOfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof InstanceOfExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, InstanceOfExpr.class);\n+        }\n+\n+        InstanceOfExpr node = (InstanceOfExpr) javaParserNode;\n+        processInstanceOf(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        javacTree.getType().accept(this, node.getType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIntersectionType(IntersectionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IntersectionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IntersectionType.class);\n+        }\n+\n+        IntersectionType node = (IntersectionType) javaParserNode;\n+        processIntersectionType(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLabeledStatement(LabeledStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LabeledStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LabeledStmt.class);\n+        }\n+\n+        LabeledStmt node = (LabeledStmt) javaParserNode;\n+        processLabeledStatement(javacTree, node);\n+        javacTree.getStatement().accept(this, node.getStatement());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LambdaExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LambdaExpr.class);\n+        }\n+\n+        LambdaExpr node = (LambdaExpr) javaParserNode;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1OTkwNA=="}, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 939}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDU5ODI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMDozNFrOIN6dDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMDozNFrOIN6dDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MDExMQ==", "bodyText": "Does \"the list\" refer to a javac or JavaParser data structure?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551460111", "createdAt": "2021-01-04T17:30:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            update.getExpression().accept(this, javaParserIter.next());\n+        }\n+\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIdentifier(IdentifierTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceType) {\n+            processIdentifier(javacTree, (ClassOrInterfaceType) javaParserNode);\n+        } else if (javaParserNode instanceof Name) {\n+            processIdentifier(javacTree, (Name) javaParserNode);\n+        } else if (javaParserNode instanceof NameExpr) {\n+            processIdentifier(javacTree, (NameExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SimpleName) {\n+            processIdentifier(javacTree, (SimpleName) javaParserNode);\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            processIdentifier(javacTree, (ThisExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            processIdentifier(javacTree, (SuperExpr) javaParserNode);\n+        } else if (javaParserNode instanceof TypeExpr) {\n+            // This occurs in a member reference like MyClass::myMember. The MyClass is wrapped in a\n+            // TypeExpr.\n+            javacTree.accept(this, ((TypeExpr) javaParserNode).getType());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IfStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IfStmt.class);\n+        }\n+\n+        IfStmt node = (IfStmt) javaParserNode;\n+        processIf(javacTree, node);\n+        assert javacTree.getCondition().getKind() == Kind.PARENTHESIZED;\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getThenStatement().accept(this, node.getThenStmt());\n+        assert (javacTree.getElseStatement() != null) == node.getElseStmt().isPresent();\n+        if (javacTree.getElseStatement() != null) {\n+            javacTree.getElseStatement().accept(this, node.getElseStmt().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ImportDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ImportDeclaration.class);\n+        }\n+\n+        ImportDeclaration node = (ImportDeclaration) javaParserNode;\n+        processImport(javacTree, node);\n+        // In javac trees, a name like a.* is stored as a member select, but JavaParser just stores\n+        // a and records that the name ends in an asterisk.\n+        if (node.isAsterisk()) {\n+            assert javacTree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT;\n+            MemberSelectTree identifier = (MemberSelectTree) javacTree.getQualifiedIdentifier();\n+            identifier.getExpression().accept(this, node.getName());\n+        } else {\n+            javacTree.getQualifiedIdentifier().accept(this, node.getName());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitInstanceOf(InstanceOfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof InstanceOfExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, InstanceOfExpr.class);\n+        }\n+\n+        InstanceOfExpr node = (InstanceOfExpr) javaParserNode;\n+        processInstanceOf(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        javacTree.getType().accept(this, node.getType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIntersectionType(IntersectionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IntersectionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IntersectionType.class);\n+        }\n+\n+        IntersectionType node = (IntersectionType) javaParserNode;\n+        processIntersectionType(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLabeledStatement(LabeledStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LabeledStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LabeledStmt.class);\n+        }\n+\n+        LabeledStmt node = (LabeledStmt) javaParserNode;\n+        processLabeledStatement(javacTree, node);\n+        javacTree.getStatement().accept(this, node.getStatement());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LambdaExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LambdaExpr.class);\n+        }\n+\n+        LambdaExpr node = (LambdaExpr) javaParserNode;\n+        processLambdaExpression(javacTree, node);\n+        visitLists(javacTree.getParameters(), node.getParameters());\n+        switch (javacTree.getBodyKind()) {\n+            case EXPRESSION:\n+                assert node.getBody() instanceof ExpressionStmt;\n+                ExpressionStmt body = (ExpressionStmt) node.getBody();\n+                javacTree.getBody().accept(this, body.getExpression());\n+                break;\n+            case STATEMENT:\n+                javacTree.getBody().accept(this, node.getBody());\n+                break;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLiteral(LiteralTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof LiteralExpr) {\n+            processLiteral(javacTree, (LiteralExpr) javaParserNode);\n+        } else if (javaParserNode instanceof UnaryExpr) {\n+            // Occurs for negative literals such as -7.\n+            processLiteral(javacTree, (UnaryExpr) javaParserNode);\n+        } else if (javaParserNode instanceof BinaryExpr) {\n+            // Occurs for expression like \"a\" + \"b\" where javac compresses them to \"ab\" but\n+            // JavaParser doesn't.\n+            processLiteral(javacTree, (BinaryExpr) javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberReference(MemberReferenceTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof MethodReferenceExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, MethodReferenceExpr.class);\n+        }\n+\n+        MethodReferenceExpr node = (MethodReferenceExpr) javaParserNode;\n+        processMemberReference(javacTree, node);\n+        if (node.getScope().isTypeExpr()) {\n+            javacTree.getQualifierExpression().accept(this, node.getScope().asTypeExpr().getType());\n+        } else {\n+            javacTree.getQualifierExpression().accept(this, node.getScope());\n+        }\n+\n+        assert (javacTree.getTypeArguments() != null) == node.getTypeArguments().isPresent();\n+        if (javacTree.getTypeArguments() != null) {\n+            visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberSelect(MemberSelectTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof FieldAccessExpr) {\n+            FieldAccessExpr node = (FieldAccessExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getScope());\n+        } else if (javaParserNode instanceof Name) {\n+            Name node = (Name) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getQualifier().isPresent();\n+            javacTree.getExpression().accept(this, node.getQualifier().get());\n+        } else if (javaParserNode instanceof ClassOrInterfaceType) {\n+            ClassOrInterfaceType node = (ClassOrInterfaceType) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getScope().isPresent();\n+            javacTree.getExpression().accept(this, node.getScope().get());\n+        } else if (javaParserNode instanceof ClassExpr) {\n+            ClassExpr node = (ClassExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getType());\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            ThisExpr node = (ThisExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            SuperExpr node = (SuperExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof MethodDeclaration) {\n+            visitMethodForMethodDeclaration(javacTree, (MethodDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof ConstructorDeclaration) {\n+            visitMethodForConstructorDeclaration(\n+                    javacTree, (ConstructorDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof AnnotationMemberDeclaration) {\n+            visitMethodForAnnotationMemberDeclaration(\n+                    javacTree, (AnnotationMemberDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        throwUnexpectedNodeType(javacTree, javaParserNode);\n+        return null;\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * MethodDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser method declaration\n+     */\n+    private void visitMethodForMethodDeclaration(\n+            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        // TODO: Handle modifiers. In javac this is a ModifiersTree but in JavaParser it's a list of\n+        // modifiers. This is a problem because a ModifiersTree has separate accessors to\n+        // annotations and other modifiers, so the order doesn't match. It might be that for\n+        // JavaParser, the annotations and other modifiers are also accessed separately.\n+        javacTree.getReturnType().accept(this, javaParserNode.getType());\n+        // Unlike other constructs, the list is non-null even if no type parameters are present.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 1071}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDYwMDk0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMToyNlrOIN6euA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzozMToyNlrOIN6euA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MDUzNg==", "bodyText": "Can you remove \"even\" here?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r551460536", "createdAt": "2021-01-04T17:31:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2382 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode it may be matched to this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") might be stored the\n+        // same as @MyAnno(value=\"myArg\") which has a single element argument list with an\n+        // assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statememt, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        return !invocation.isThis() && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            if (javacTree.getTypeParameters().size() == node.getTypeParameters().size()) {\n+                visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+            }\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        while (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the expression will be a MethodTree, which would be better to match with\n+            // the statement than the expression statement itself.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            update.getExpression().accept(this, javaParserIter.next());\n+        }\n+\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIdentifier(IdentifierTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceType) {\n+            processIdentifier(javacTree, (ClassOrInterfaceType) javaParserNode);\n+        } else if (javaParserNode instanceof Name) {\n+            processIdentifier(javacTree, (Name) javaParserNode);\n+        } else if (javaParserNode instanceof NameExpr) {\n+            processIdentifier(javacTree, (NameExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SimpleName) {\n+            processIdentifier(javacTree, (SimpleName) javaParserNode);\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            processIdentifier(javacTree, (ThisExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            processIdentifier(javacTree, (SuperExpr) javaParserNode);\n+        } else if (javaParserNode instanceof TypeExpr) {\n+            // This occurs in a member reference like MyClass::myMember. The MyClass is wrapped in a\n+            // TypeExpr.\n+            javacTree.accept(this, ((TypeExpr) javaParserNode).getType());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IfStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IfStmt.class);\n+        }\n+\n+        IfStmt node = (IfStmt) javaParserNode;\n+        processIf(javacTree, node);\n+        assert javacTree.getCondition().getKind() == Kind.PARENTHESIZED;\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getThenStatement().accept(this, node.getThenStmt());\n+        assert (javacTree.getElseStatement() != null) == node.getElseStmt().isPresent();\n+        if (javacTree.getElseStatement() != null) {\n+            javacTree.getElseStatement().accept(this, node.getElseStmt().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ImportDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ImportDeclaration.class);\n+        }\n+\n+        ImportDeclaration node = (ImportDeclaration) javaParserNode;\n+        processImport(javacTree, node);\n+        // In javac trees, a name like a.* is stored as a member select, but JavaParser just stores\n+        // a and records that the name ends in an asterisk.\n+        if (node.isAsterisk()) {\n+            assert javacTree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT;\n+            MemberSelectTree identifier = (MemberSelectTree) javacTree.getQualifiedIdentifier();\n+            identifier.getExpression().accept(this, node.getName());\n+        } else {\n+            javacTree.getQualifiedIdentifier().accept(this, node.getName());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitInstanceOf(InstanceOfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof InstanceOfExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, InstanceOfExpr.class);\n+        }\n+\n+        InstanceOfExpr node = (InstanceOfExpr) javaParserNode;\n+        processInstanceOf(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        javacTree.getType().accept(this, node.getType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIntersectionType(IntersectionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IntersectionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IntersectionType.class);\n+        }\n+\n+        IntersectionType node = (IntersectionType) javaParserNode;\n+        processIntersectionType(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLabeledStatement(LabeledStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LabeledStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LabeledStmt.class);\n+        }\n+\n+        LabeledStmt node = (LabeledStmt) javaParserNode;\n+        processLabeledStatement(javacTree, node);\n+        javacTree.getStatement().accept(this, node.getStatement());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LambdaExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LambdaExpr.class);\n+        }\n+\n+        LambdaExpr node = (LambdaExpr) javaParserNode;\n+        processLambdaExpression(javacTree, node);\n+        visitLists(javacTree.getParameters(), node.getParameters());\n+        switch (javacTree.getBodyKind()) {\n+            case EXPRESSION:\n+                assert node.getBody() instanceof ExpressionStmt;\n+                ExpressionStmt body = (ExpressionStmt) node.getBody();\n+                javacTree.getBody().accept(this, body.getExpression());\n+                break;\n+            case STATEMENT:\n+                javacTree.getBody().accept(this, node.getBody());\n+                break;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLiteral(LiteralTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof LiteralExpr) {\n+            processLiteral(javacTree, (LiteralExpr) javaParserNode);\n+        } else if (javaParserNode instanceof UnaryExpr) {\n+            // Occurs for negative literals such as -7.\n+            processLiteral(javacTree, (UnaryExpr) javaParserNode);\n+        } else if (javaParserNode instanceof BinaryExpr) {\n+            // Occurs for expression like \"a\" + \"b\" where javac compresses them to \"ab\" but\n+            // JavaParser doesn't.\n+            processLiteral(javacTree, (BinaryExpr) javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberReference(MemberReferenceTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof MethodReferenceExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, MethodReferenceExpr.class);\n+        }\n+\n+        MethodReferenceExpr node = (MethodReferenceExpr) javaParserNode;\n+        processMemberReference(javacTree, node);\n+        if (node.getScope().isTypeExpr()) {\n+            javacTree.getQualifierExpression().accept(this, node.getScope().asTypeExpr().getType());\n+        } else {\n+            javacTree.getQualifierExpression().accept(this, node.getScope());\n+        }\n+\n+        assert (javacTree.getTypeArguments() != null) == node.getTypeArguments().isPresent();\n+        if (javacTree.getTypeArguments() != null) {\n+            visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberSelect(MemberSelectTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof FieldAccessExpr) {\n+            FieldAccessExpr node = (FieldAccessExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getScope());\n+        } else if (javaParserNode instanceof Name) {\n+            Name node = (Name) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getQualifier().isPresent();\n+            javacTree.getExpression().accept(this, node.getQualifier().get());\n+        } else if (javaParserNode instanceof ClassOrInterfaceType) {\n+            ClassOrInterfaceType node = (ClassOrInterfaceType) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getScope().isPresent();\n+            javacTree.getExpression().accept(this, node.getScope().get());\n+        } else if (javaParserNode instanceof ClassExpr) {\n+            ClassExpr node = (ClassExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getType());\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            ThisExpr node = (ThisExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            SuperExpr node = (SuperExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof MethodDeclaration) {\n+            visitMethodForMethodDeclaration(javacTree, (MethodDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof ConstructorDeclaration) {\n+            visitMethodForConstructorDeclaration(\n+                    javacTree, (ConstructorDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof AnnotationMemberDeclaration) {\n+            visitMethodForAnnotationMemberDeclaration(\n+                    javacTree, (AnnotationMemberDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        throwUnexpectedNodeType(javacTree, javaParserNode);\n+        return null;\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * MethodDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser method declaration\n+     */\n+    private void visitMethodForMethodDeclaration(\n+            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        // TODO: Handle modifiers. In javac this is a ModifiersTree but in JavaParser it's a list of\n+        // modifiers. This is a problem because a ModifiersTree has separate accessors to\n+        // annotations and other modifiers, so the order doesn't match. It might be that for\n+        // JavaParser, the annotations and other modifiers are also accessed separately.\n+        javacTree.getReturnType().accept(this, javaParserNode.getType());\n+        // Unlike other constructs, the list is non-null even if no type parameters are present.\n+        visitLists(javacTree.getTypeParameters(), javaParserNode.getTypeParameters());\n+        if (javacTree.getReceiverParameter() != null\n+                && javaParserNode.getReceiverParameter().isPresent()) {\n+            javacTree\n+                    .getReceiverParameter()\n+                    .accept(this, javaParserNode.getReceiverParameter().get());\n+        }\n+\n+        visitLists(javacTree.getParameters(), javaParserNode.getParameters());\n+\n+        visitLists(javacTree.getThrows(), javaParserNode.getThrownExceptions());\n+        assert (javacTree.getBody() != null) == javaParserNode.getBody().isPresent();\n+        if (javacTree.getBody() != null) {\n+            javacTree.getBody().accept(this, javaParserNode.getBody().get());\n+        }\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * ConstructorDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser constructor declaration\n+     */\n+    private void visitMethodForConstructorDeclaration(\n+            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        visitLists(javacTree.getTypeParameters(), javaParserNode.getTypeParameters());\n+        assert (javacTree.getReceiverParameter() != null)\n+                == javaParserNode.getReceiverParameter().isPresent();\n+        if (javacTree.getReceiverParameter() != null) {\n+            javacTree\n+                    .getReceiverParameter()\n+                    .accept(this, javaParserNode.getReceiverParameter().get());\n+        }\n+\n+        visitLists(javacTree.getParameters(), javaParserNode.getParameters());\n+        visitLists(javacTree.getThrows(), javaParserNode.getThrownExceptions());\n+        javacTree.getBody().accept(this, javaParserNode.getBody());\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * AnnotationMemberDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser annotation member declaration\n+     */\n+    private void visitMethodForAnnotationMemberDeclaration(\n+            MethodTree javacTree, AnnotationMemberDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        javacTree.getReturnType().accept(this, javaParserNode.getType());\n+        assert (javacTree.getDefaultValue() != null)\n+                == javaParserNode.getDefaultValue().isPresent();\n+        if (javacTree.getDefaultValue() != null) {\n+            javacTree.getDefaultValue().accept(this, javaParserNode.getDefaultValue().get());\n+        }\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof MethodCallExpr) {\n+            MethodCallExpr node = (MethodCallExpr) javaParserNode;\n+            processMethodInvocation(javacTree, node);\n+            // In javac, the type arguments will be empty even if no type arguments are specified,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5311f1115c5dc93396f25231f599e8ddcbc0b4cb"}, "originalPosition": 1136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNDYxNTM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMDoxNzowN1rOIls-5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMDoxNzowN1rOIls-5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQwNTIyMg==", "bodyText": "I think this loop should process assignment.getVariable() and argIter.next().getName(), or at minumum assert that they have the same name.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576405222", "createdAt": "2021-02-15T20:17:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNDc2NTcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToyMDoxM1rOIluUAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToxNzoyN1rOInG6WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNzAwOA==", "bodyText": "There is similar code in processStatements and visitClassMembers.  Can it be abstracted out into a helper method?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576427008", "createdAt": "2021-02-15T21:20:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzM4OTY1MA==", "bodyText": "The particular logic and methods called in each case are different, so abstracting out would probably complicate the code more than necessary. The code to advance the iterators was repetitive, so I've introduced a class LookaheadIterator to make it easier to read.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577389650", "createdAt": "2021-02-17T07:48:39Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNzAwOA=="}, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg3ODYxNw==", "bodyText": "Rather than defining your own LookaheadIterator, how about using Guava's PeekingIterator which I think provides the same functionality?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577878617", "createdAt": "2021-02-17T19:17:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNzAwOA=="}, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNDc2NjQ0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToyMDoyM1rOIluUjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToyMDoyM1rOIluUjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNzE0OA==", "bodyText": "There is similar code in processStatements and visitClassMembers.  Can it be abstracted out into a helper method?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576427148", "createdAt": "2021-02-15T21:20:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        boolean isSuper = !invocation.isThis();\n+        return isSuper && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 551}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNDc3NzAyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToyMzoyOFrOIlubig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToyMzoyOFrOIlubig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyODkzOA==", "bodyText": "Please clarify \"these specific constructs\".", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576428938", "createdAt": "2021-02-15T21:23:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        boolean isSuper = !invocation.isThis();\n+        return isSuper && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        if (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                }\n+            }\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 659}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNTEwMTAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQwMDowMTo1NVrOIlxUDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQwMDowMTo1NVrOIlxUDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQ3NjE3NA==", "bodyText": "Could you write a comment about what is happening here?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576476174", "createdAt": "2021-02-16T00:01:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/JointJavacJavaParserVisitor.java", "diffHunk": "@@ -0,0 +1,2386 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.ImportDeclaration;\n+import com.github.javaparser.ast.Node;\n+import com.github.javaparser.ast.PackageDeclaration;\n+import com.github.javaparser.ast.body.AnnotationDeclaration;\n+import com.github.javaparser.ast.body.AnnotationMemberDeclaration;\n+import com.github.javaparser.ast.body.BodyDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumConstantDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.InitializerDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.Parameter;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ArrayAccessExpr;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.CastExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.ConditionalExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.InstanceOfExpr;\n+import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.LiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.MethodReferenceExpr;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.SuperExpr;\n+import com.github.javaparser.ast.expr.ThisExpr;\n+import com.github.javaparser.ast.expr.TypeExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.modules.ModuleDeclaration;\n+import com.github.javaparser.ast.modules.ModuleExportsDirective;\n+import com.github.javaparser.ast.modules.ModuleOpensDirective;\n+import com.github.javaparser.ast.modules.ModuleProvidesDirective;\n+import com.github.javaparser.ast.modules.ModuleRequiresDirective;\n+import com.github.javaparser.ast.modules.ModuleUsesDirective;\n+import com.github.javaparser.ast.nodeTypes.NodeWithAnnotations;\n+import com.github.javaparser.ast.stmt.AssertStmt;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.BreakStmt;\n+import com.github.javaparser.ast.stmt.CatchClause;\n+import com.github.javaparser.ast.stmt.ContinueStmt;\n+import com.github.javaparser.ast.stmt.DoStmt;\n+import com.github.javaparser.ast.stmt.EmptyStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.ForEachStmt;\n+import com.github.javaparser.ast.stmt.ForStmt;\n+import com.github.javaparser.ast.stmt.IfStmt;\n+import com.github.javaparser.ast.stmt.LabeledStmt;\n+import com.github.javaparser.ast.stmt.LocalClassDeclarationStmt;\n+import com.github.javaparser.ast.stmt.ReturnStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import com.github.javaparser.ast.stmt.SwitchEntry;\n+import com.github.javaparser.ast.stmt.SwitchStmt;\n+import com.github.javaparser.ast.stmt.SynchronizedStmt;\n+import com.github.javaparser.ast.stmt.ThrowStmt;\n+import com.github.javaparser.ast.stmt.TryStmt;\n+import com.github.javaparser.ast.stmt.WhileStmt;\n+import com.github.javaparser.ast.type.ArrayType;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.IntersectionType;\n+import com.github.javaparser.ast.type.PrimitiveType;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.type.UnionType;\n+import com.github.javaparser.ast.type.VoidType;\n+import com.github.javaparser.ast.type.WildcardType;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ArrayAccessTree;\n+import com.sun.source.tree.ArrayTypeTree;\n+import com.sun.source.tree.AssertTree;\n+import com.sun.source.tree.AssignmentTree;\n+import com.sun.source.tree.BinaryTree;\n+import com.sun.source.tree.BlockTree;\n+import com.sun.source.tree.BreakTree;\n+import com.sun.source.tree.CaseTree;\n+import com.sun.source.tree.CatchTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.CompoundAssignmentTree;\n+import com.sun.source.tree.ConditionalExpressionTree;\n+import com.sun.source.tree.ContinueTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.EmptyStatementTree;\n+import com.sun.source.tree.EnhancedForLoopTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.tree.ExportsTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.InstanceOfTree;\n+import com.sun.source.tree.IntersectionTypeTree;\n+import com.sun.source.tree.LabeledStatementTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.ModuleTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.OpensTree;\n+import com.sun.source.tree.PackageTree;\n+import com.sun.source.tree.ParameterizedTypeTree;\n+import com.sun.source.tree.ParenthesizedTree;\n+import com.sun.source.tree.PrimitiveTypeTree;\n+import com.sun.source.tree.ProvidesTree;\n+import com.sun.source.tree.RequiresTree;\n+import com.sun.source.tree.ReturnTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.ThrowTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.TreeVisitor;\n+import com.sun.source.tree.TryTree;\n+import com.sun.source.tree.TypeCastTree;\n+import com.sun.source.tree.TypeParameterTree;\n+import com.sun.source.tree.UnaryTree;\n+import com.sun.source.tree.UnionTypeTree;\n+import com.sun.source.tree.UsesTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import com.sun.source.tree.WildcardTree;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A visitor that processes javac trees and JavaParser nodes simultaneously, matching corresponding\n+ * nodes.\n+ *\n+ * <p>By default, visits all children of a javac tree along with corresponding JavaParser nodes. The\n+ * JavaParser node corresponding to a javac tree is always passed as the secondary parameter to the\n+ * {@code visit} methods.\n+ *\n+ * <p>To perform an action on a particular tree type, override one of the methods starting with\n+ * \"process\". For each javac tree type JavacType, and for each possible JavaParser node type\n+ * JavaParserNode that it may be matched to, this class contains a method {@code\n+ * processJavacType(JavacTypeTree javacTree, JavaParserNode javaParserNode)}. These are named after\n+ * the visit methods in {@code com.sun.source.tree.TreeVisitor}, but for each javac tree type there\n+ * may be multiple process methods for each possible node type it could be matched to.\n+ *\n+ * <p>The {@code process} methods are called in pre-order. That is, process methods for a parent are\n+ * called before its children.\n+ */\n+public abstract class JointJavacJavaParserVisitor implements TreeVisitor<Void, Node> {\n+    @Override\n+    public Void visitAnnotation(AnnotationTree javacTree, Node javaParserNode) {\n+        // javac stores annotation arguments as assignments, so @MyAnno(\"myArg\") is stored the same\n+        // as @MyAnno(value=\"myArg\") which has a single element argument list with an assignment.\n+        if (javaParserNode instanceof MarkerAnnotationExpr) {\n+            processAnnotation(javacTree, (MarkerAnnotationExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SingleMemberAnnotationExpr) {\n+            SingleMemberAnnotationExpr node = (SingleMemberAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == 1;\n+            ExpressionTree value = javacTree.getArguments().get(0);\n+            assert value instanceof AssignmentTree;\n+            AssignmentTree assignment = (AssignmentTree) value;\n+            assert assignment.getVariable().getKind() == Kind.IDENTIFIER;\n+            assert ((IdentifierTree) assignment.getVariable()).getName().contentEquals(\"value\");\n+            assignment.getExpression().accept(this, node.getMemberValue());\n+        } else if (javaParserNode instanceof NormalAnnotationExpr) {\n+            NormalAnnotationExpr node = (NormalAnnotationExpr) javaParserNode;\n+            processAnnotation(javacTree, node);\n+            assert javacTree.getArguments().size() == node.getPairs().size();\n+            Iterator<MemberValuePair> argIter = node.getPairs().iterator();\n+            for (ExpressionTree arg : javacTree.getArguments()) {\n+                assert arg instanceof AssignmentTree;\n+                AssignmentTree assignment = (AssignmentTree) arg;\n+                assignment.getExpression().accept(this, argIter.next().getValue());\n+            }\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAnnotatedType(AnnotatedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof NodeWithAnnotations)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, NodeWithAnnotations.class);\n+        }\n+\n+        processAnnotatedType(javacTree, javaParserNode);\n+        javacTree.getUnderlyingType().accept(this, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayAccess(ArrayAccessTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayAccessExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayAccessExpr.class);\n+        }\n+\n+        ArrayAccessExpr node = (ArrayAccessExpr) javaParserNode;\n+        processArrayAccess(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getName());\n+        javacTree.getIndex().accept(this, node.getIndex());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitArrayType(ArrayTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ArrayType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ArrayType.class);\n+        }\n+\n+        ArrayType node = (ArrayType) javaParserNode;\n+        processArrayType(javacTree, node);\n+        javacTree.getType().accept(this, node.getComponentType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssert(AssertTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssertStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssertStmt.class);\n+        }\n+\n+        AssertStmt node = (AssertStmt) javaParserNode;\n+        processAssert(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCheck());\n+        ExpressionTree detail = javacTree.getDetail();\n+        assert (detail != null) == node.getMessage().isPresent();\n+        if (detail != null) {\n+            detail.accept(this, node.getMessage().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitAssignment(AssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBinary(BinaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BinaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BinaryExpr.class);\n+        }\n+\n+        BinaryExpr node = (BinaryExpr) javaParserNode;\n+        processBinary(javacTree, node);\n+        javacTree.getLeftOperand().accept(this, node.getLeft());\n+        javacTree.getRightOperand().accept(this, node.getRight());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitBlock(BlockTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof InitializerDeclaration) {\n+            return javacTree.accept(this, ((InitializerDeclaration) javaParserNode).getBody());\n+        }\n+\n+        if (!(javaParserNode instanceof BlockStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BlockStmt.class);\n+        }\n+\n+        BlockStmt node = (BlockStmt) javaParserNode;\n+        processBlock(javacTree, node);\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    /**\n+     * Given a matching sequence of statements for a block, visits each javac statement with its\n+     * corresponding JavaParser statement, excluding synthetic javac trees like no-argument\n+     * constructors.\n+     *\n+     * @param javacStatements sequence of javac trees for statements\n+     * @param javaParserStatements sequence of JavaParser statements representing the same block as\n+     *     {@code javacStatements}\n+     */\n+    private void processStatements(\n+            Iterable<? extends StatementTree> javacStatements,\n+            Iterable<Statement> javaParserStatements) {\n+        Iterator<? extends StatementTree> javacIter = javacStatements.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        StatementTree javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+        Iterator<Statement> javaParserIter = javaParserStatements.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        Statement javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip synthetic javac super() calls by checking if the JavaParser statement matches.\n+            if (hasNextJavac\n+                    && isDefaultSuperConstructorCall(javacStatement)\n+                    && (!hasNextJavaParser\n+                            || !isDefaultSuperConstructorCall(javaParserStatement))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacStatement = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like \"int i = 0, j = 0\" is expanded as two sibling VariableTree\n+            // instances. In javaParser this is one VariableDeclarationExpr with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser\n+                    && javaParserStatement.isExpressionStmt()\n+                    && javaParserStatement\n+                            .asExpressionStmt()\n+                            .getExpression()\n+                            .isVariableDeclarationExpr()) {\n+                for (VariableDeclarator decl :\n+                        javaParserStatement\n+                                .asExpressionStmt()\n+                                .getExpression()\n+                                .asVariableDeclarationExpr()\n+                                .getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacStatement.getKind() == Kind.VARIABLE;\n+                    javacStatement.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacStatement = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacStatement.accept(this, javaParserStatement);\n+            hasNextJavac = javacIter.hasNext();\n+            javacStatement = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserStatement = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is a method invocation named \"super\" with no arguments, false\n+     *     otherwise\n+     */\n+    public static boolean isDefaultSuperConstructorCall(StatementTree statement) {\n+        if (statement.getKind() != Kind.EXPRESSION_STATEMENT) {\n+            return false;\n+        }\n+\n+        ExpressionStatementTree expressionStatement = (ExpressionStatementTree) statement;\n+        if (expressionStatement.getExpression().getKind() != Kind.METHOD_INVOCATION) {\n+            return false;\n+        }\n+\n+        MethodInvocationTree invocation =\n+                (MethodInvocationTree) expressionStatement.getExpression();\n+        if (invocation.getMethodSelect().getKind() != Kind.IDENTIFIER) {\n+            return false;\n+        }\n+\n+        if (!((IdentifierTree) invocation.getMethodSelect()).getName().contentEquals(\"super\")) {\n+            return false;\n+        }\n+\n+        return invocation.getArguments().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether a statement represents a method call {@code super()}.\n+     *\n+     * @param statement the statement to check\n+     * @return true if statement is an explicit super constructor invocation with no arguments,\n+     *     false otherwise\n+     */\n+    private boolean isDefaultSuperConstructorCall(Statement statement) {\n+        if (!statement.isExplicitConstructorInvocationStmt()) {\n+            return false;\n+        }\n+\n+        ExplicitConstructorInvocationStmt invocation =\n+                statement.asExplicitConstructorInvocationStmt();\n+        boolean isSuper = !invocation.isThis();\n+        return isSuper && invocation.getArguments().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitBreak(BreakTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof BreakStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, BreakStmt.class);\n+        }\n+\n+        processBreak(javacTree, (BreakStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCase(CaseTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchEntry)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchEntry.class);\n+        }\n+\n+        SwitchEntry node = (SwitchEntry) javaParserNode;\n+        processCase(javacTree, node);\n+        // The expression is null if and only if the case is the default case.\n+        // Java 12 introduced multiple label cases, but expressions should contain at most one\n+        // element for Java 11 and below.\n+        List<Expression> expressions = node.getLabels();\n+        if (javacTree.getExpression() == null) {\n+            assert expressions.isEmpty();\n+        } else {\n+            assert expressions.size() == 1;\n+            javacTree.getExpression().accept(this, expressions.get(0));\n+        }\n+\n+        processStatements(javacTree.getStatements(), node.getStatements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCatch(CatchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CatchClause)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CatchClause.class);\n+        }\n+\n+        CatchClause node = (CatchClause) javaParserNode;\n+        processCatch(javacTree, node);\n+        javacTree.getParameter().accept(this, node.getParameter());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitClass(ClassTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceDeclaration) {\n+            ClassOrInterfaceDeclaration node = (ClassOrInterfaceDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getTypeParameters(), node.getTypeParameters());\n+\n+            if (javacTree.getKind() == Kind.CLASS) {\n+                if (javacTree.getExtendsClause() == null) {\n+                    assert node.getExtendedTypes().isEmpty();\n+                } else {\n+                    assert node.getExtendedTypes().size() == 1;\n+                    javacTree.getExtendsClause().accept(this, node.getExtendedTypes().get(0));\n+                }\n+\n+                visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            } else if (javacTree.getKind() == Kind.INTERFACE) {\n+                visitLists(javacTree.getImplementsClause(), node.getExtendedTypes());\n+            }\n+\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof AnnotationDeclaration) {\n+            AnnotationDeclaration node = (AnnotationDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitClassMembers(javacTree.getMembers(), node.getMembers());\n+        } else if (javaParserNode instanceof LocalClassDeclarationStmt) {\n+            javacTree.accept(\n+                    this, ((LocalClassDeclarationStmt) javaParserNode).getClassDeclaration());\n+        } else if (javaParserNode instanceof EnumDeclaration) {\n+            EnumDeclaration node = (EnumDeclaration) javaParserNode;\n+            processClass(javacTree, node);\n+            visitLists(javacTree.getImplementsClause(), node.getImplementedTypes());\n+            // In an enum declaration, the enum constants are expanded as constant variable members\n+            // whereas in JavaParser they're stored as one object, need to match them.\n+            assert javacTree.getKind() == Kind.ENUM;\n+            List<Tree> javacMembers = new ArrayList<>(javacTree.getMembers());\n+            // If there are any constants in this enum, then they will show up as the first members\n+            // of the javac tree, except for possibly a synthetic constructor. Thus, in this case\n+            // any member before the first variable instance should be discarded.\n+            if (!node.getEntries().isEmpty()) {\n+                while (!javacMembers.isEmpty() && javacMembers.get(0).getKind() != Kind.VARIABLE) {\n+                    javacMembers.remove(0);\n+                }\n+            }\n+\n+            for (EnumConstantDeclaration entry : node.getEntries()) {\n+                assert !javacMembers.isEmpty();\n+                javacMembers.get(0).accept(this, entry);\n+                javacMembers.remove(0);\n+            }\n+\n+            visitClassMembers(javacMembers, node.getMembers());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Given a list of class members for javac and JavaParser, visits each javac member with its\n+     * corresponding JavaParser member. Skips synthetic javac members.\n+     *\n+     * @param javacMembers a list of trees forming the members of a javac {@code ClassTree}\n+     * @param javaParserMembers a list of nodes forming the members of a JavaParser {@code\n+     *     ClassOrInterfaceDeclaration} or {@code ObjectCreationExpr} with an anonymous class body\n+     *     that corresponds to {@code javacMembers}\n+     */\n+    private void visitClassMembers(\n+            List<? extends Tree> javacMembers, List<BodyDeclaration<?>> javaParserMembers) {\n+        Iterator<? extends Tree> javacIter = javacMembers.iterator();\n+        boolean hasNextJavac = javacIter.hasNext();\n+        Tree javacMember = hasNextJavac ? javacIter.next() : null;\n+        Iterator<BodyDeclaration<?>> javaParserIter = javaParserMembers.iterator();\n+        boolean hasNextJavaParser = javaParserIter.hasNext();\n+        BodyDeclaration<?> javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        while (hasNextJavac || hasNextJavaParser) {\n+            // Skip javac's synthetic no-argument constructors.\n+            if (hasNextJavac\n+                    && isNoArgumentConstructor(javacMember)\n+                    && (!hasNextJavaParser || !isNoArgumentConstructor(javaParserMember))) {\n+                hasNextJavac = javacIter.hasNext();\n+                javacMember = hasNextJavac ? javacIter.next() : null;\n+                continue;\n+            }\n+\n+            // In javac, a line like int i = 0, j = 0 is expanded as two sibling VariableTree\n+            // instances. In JavaParser this is one FieldDeclaration with two nested\n+            // VariableDeclarators. Match the declarators with the VariableTrees.\n+            if (hasNextJavaParser && javaParserMember.isFieldDeclaration()) {\n+                for (VariableDeclarator decl :\n+                        javaParserMember.asFieldDeclaration().getVariables()) {\n+                    assert hasNextJavac;\n+                    assert javacMember.getKind() == Kind.VARIABLE;\n+                    javacMember.accept(this, decl);\n+                    hasNextJavac = javacIter.hasNext();\n+                    javacMember = hasNextJavac ? javacIter.next() : null;\n+                }\n+\n+                hasNextJavaParser = javaParserIter.hasNext();\n+                javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+                continue;\n+            }\n+\n+            assert hasNextJavac;\n+            assert hasNextJavaParser;\n+            javacMember.accept(this, javaParserMember);\n+\n+            hasNextJavac = javacIter.hasNext();\n+            javacMember = hasNextJavac ? javacIter.next() : null;\n+\n+            hasNextJavaParser = javaParserIter.hasNext();\n+            javaParserMember = hasNextJavaParser ? javaParserIter.next() : null;\n+        }\n+\n+        assert !hasNextJavac;\n+        assert !hasNextJavaParser;\n+    }\n+\n+    /**\n+     * Visits the the members of an anonymous class body.\n+     *\n+     * <p>In normal classes, javac inserts a synthetic no-argument constructor if no constructor is\n+     * explicitly defined, which is skipped when visiting members. Anonymous class bodies may\n+     * introduce constructors that take arguments if the constructor invocation that created them\n+     * was passed arguments. For example, if {@code MyClass} has a constructor taking a single\n+     * integer argument, then writing {@code new MyClass(5) { }} expands to the javac tree\n+     *\n+     * <pre>{@code\n+     * new MyClass(5) {\n+     *     (int arg) {\n+     *         super(arg);\n+     *     }\n+     * }\n+     * }</pre>\n+     *\n+     * <p>This method skips these synthetic constructors.\n+     *\n+     * @param javacBody body of an anonymous class body\n+     * @param javaParserMembers list of members for the anonymous class body of an {@code\n+     *     ObjectCreationExpr}\n+     */\n+    public void visitAnonymouClassBody(\n+            ClassTree javacBody, List<BodyDeclaration<?>> javaParserMembers) {\n+        List<Tree> members = new ArrayList<>(javacBody.getMembers());\n+        if (!members.isEmpty()) {\n+            Tree member = members.get(0);\n+            if (member.getKind() == Kind.METHOD) {\n+                MethodTree methodTree = (MethodTree) member;\n+                if (methodTree.getName().contentEquals(\"<init>\")) {\n+                    members.remove(0);\n+                }\n+            }\n+        }\n+\n+        visitClassMembers(members, javaParserMembers);\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the tree to check\n+     * @return true if {@code member} is a method declaration with name {@code <init>} that takes no\n+     *     arguments, false otherwise.\n+     */\n+    public static boolean isNoArgumentConstructor(Tree member) {\n+        if (member.getKind() != Kind.METHOD) {\n+            return false;\n+        }\n+\n+        MethodTree methodTree = (MethodTree) member;\n+        return methodTree.getName().contentEquals(\"<init>\") && methodTree.getParameters().isEmpty();\n+    }\n+\n+    /**\n+     * Returns whether {@code member} is a constructor declaration that takes no arguments.\n+     *\n+     * @param member the body declaration to check\n+     * @return true if {@code member} is a constructor declaration that takes no arguments.\n+     */\n+    private boolean isNoArgumentConstructor(BodyDeclaration<?> member) {\n+        return member.isConstructorDeclaration()\n+                && member.asConstructorDeclaration().getParameters().isEmpty();\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CompilationUnit)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CompilationUnit.class);\n+        }\n+\n+        CompilationUnit node = (CompilationUnit) javaParserNode;\n+        processCompilationUnit(javacTree, node);\n+        // TODO: A CompilationUnitTree could also be a package-info.java file. Currently skipping\n+        // descending into these specific constructs such as getPackageAnnotations, because they\n+        // probably won't be useful and TreeScanner also skips them. Should we process them?\n+        assert (javacTree.getPackage() != null) == node.getPackageDeclaration().isPresent();\n+        if (javacTree.getPackage() != null) {\n+            javacTree.getPackage().accept(this, node.getPackageDeclaration().get());\n+        }\n+\n+        visitLists(javacTree.getImports(), node.getImports());\n+        visitLists(javacTree.getTypeDecls(), node.getTypes());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitCompoundAssignment(CompoundAssignmentTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof AssignExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, AssignExpr.class);\n+        }\n+\n+        AssignExpr node = (AssignExpr) javaParserNode;\n+        processCompoundAssignment(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getTarget());\n+        javacTree.getExpression().accept(this, node.getValue());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConditionalExpression(\n+            ConditionalExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ConditionalExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ConditionalExpr.class);\n+        }\n+\n+        ConditionalExpr node = (ConditionalExpr) javaParserNode;\n+        processConditionalExpression(javacTree, node);\n+        javacTree.getCondition().accept(this, node.getCondition());\n+        javacTree.getTrueExpression().accept(this, node.getThenExpr());\n+        javacTree.getFalseExpression().accept(this, node.getElseExpr());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitContinue(ContinueTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ContinueStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ContinueStmt.class);\n+        }\n+\n+        processContinue(javacTree, (ContinueStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitDoWhileLoop(DoWhileLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof DoStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, DoStmt.class);\n+        }\n+\n+        DoStmt node = (DoStmt) javaParserNode;\n+        processDoWhileLoop(javacTree, node);\n+        // In javac the condition is parenthesized but not in JavaParser.\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEmptyStatement(EmptyStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EmptyStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EmptyStmt.class);\n+        }\n+\n+        processEmptyStatement(javacTree, (EmptyStmt) javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitEnhancedForLoop(EnhancedForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForEachStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForEachStmt.class);\n+        }\n+\n+        ForEachStmt node = (ForEachStmt) javaParserNode;\n+        processEnhancedForLoop(javacTree, node);\n+        javacTree.getVariable().accept(this, node.getVariableDeclarator());\n+        javacTree.getExpression().accept(this, node.getIterable());\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitErroneous(ErroneousTree javacTree, Node javaParserNode) {\n+        // An erroneous tree is a malformed expression, so skip.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExports(ExportsTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleExportsDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleExportsDirective.class);\n+        }\n+\n+        ModuleExportsDirective node = (ModuleExportsDirective) javaParserNode;\n+        processExports(javacTree, node);\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitExpressionStatement(ExpressionStatementTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ExpressionStmt) {\n+            ExpressionStmt node = (ExpressionStmt) javaParserNode;\n+            processExpressionStatemen(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getExpression());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            // In this case the javac expression will be a MethodTree. Since JavaParser doesn't\n+            // surround explicit constructor invocations in an expression statement, we match\n+            // javaParserNode to the javac expression rather than the javac expression statement.\n+            javacTree.getExpression().accept(this, javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitForLoop(ForLoopTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ForStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ForStmt.class);\n+        }\n+\n+        ForStmt node = (ForStmt) javaParserNode;\n+        processForLoop(javacTree, node);\n+        Iterator<? extends StatementTree> javacIter = javacTree.getInitializer().iterator();\n+        for (Expression initializer : node.getInitialization()) {\n+            if (initializer.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        initializer.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else if (initializer.isAssignExpr()) {\n+                ExpressionStatementTree statement = (ExpressionStatementTree) javacIter.next();\n+                statement.getExpression().accept(this, initializer);\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, initializer);\n+            }\n+        }\n+\n+        assert !javacIter.hasNext();\n+        assert (javacTree.getCondition() != null) == node.getCompare().isPresent();\n+        if (javacTree.getCondition() != null) {\n+            javacTree.getCondition().accept(this, node.getCompare().get());\n+        }\n+\n+        // Javac stores a list of expression statements and JavaParser stores a list of statements,\n+        // the javac statements must be unwrapped.\n+        assert javacTree.getUpdate().size() == node.getUpdate().size();\n+        Iterator<Expression> javaParserIter = node.getUpdate().iterator();\n+        for (ExpressionStatementTree update : javacTree.getUpdate()) {\n+            // Match the inner javac expression with the JavaParser expression.\n+            update.getExpression().accept(this, javaParserIter.next());\n+        }\n+\n+        javacTree.getStatement().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIdentifier(IdentifierTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof ClassOrInterfaceType) {\n+            processIdentifier(javacTree, (ClassOrInterfaceType) javaParserNode);\n+        } else if (javaParserNode instanceof Name) {\n+            processIdentifier(javacTree, (Name) javaParserNode);\n+        } else if (javaParserNode instanceof NameExpr) {\n+            processIdentifier(javacTree, (NameExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SimpleName) {\n+            processIdentifier(javacTree, (SimpleName) javaParserNode);\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            processIdentifier(javacTree, (ThisExpr) javaParserNode);\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            processIdentifier(javacTree, (SuperExpr) javaParserNode);\n+        } else if (javaParserNode instanceof TypeExpr) {\n+            // This occurs in a member reference like MyClass::myMember. The MyClass is wrapped in a\n+            // TypeExpr.\n+            javacTree.accept(this, ((TypeExpr) javaParserNode).getType());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIf(IfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IfStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IfStmt.class);\n+        }\n+\n+        IfStmt node = (IfStmt) javaParserNode;\n+        processIf(javacTree, node);\n+        assert javacTree.getCondition().getKind() == Kind.PARENTHESIZED;\n+        ParenthesizedTree condition = (ParenthesizedTree) javacTree.getCondition();\n+        condition.getExpression().accept(this, node.getCondition());\n+        javacTree.getThenStatement().accept(this, node.getThenStmt());\n+        assert (javacTree.getElseStatement() != null) == node.getElseStmt().isPresent();\n+        if (javacTree.getElseStatement() != null) {\n+            javacTree.getElseStatement().accept(this, node.getElseStmt().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitImport(ImportTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ImportDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ImportDeclaration.class);\n+        }\n+\n+        ImportDeclaration node = (ImportDeclaration) javaParserNode;\n+        processImport(javacTree, node);\n+        // In javac trees, a name like a.* is stored as a member select, but JavaParser just stores\n+        // a and records that the name ends in an asterisk.\n+        if (node.isAsterisk()) {\n+            assert javacTree.getQualifiedIdentifier().getKind() == Kind.MEMBER_SELECT;\n+            MemberSelectTree identifier = (MemberSelectTree) javacTree.getQualifiedIdentifier();\n+            identifier.getExpression().accept(this, node.getName());\n+        } else {\n+            javacTree.getQualifiedIdentifier().accept(this, node.getName());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitInstanceOf(InstanceOfTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof InstanceOfExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, InstanceOfExpr.class);\n+        }\n+\n+        InstanceOfExpr node = (InstanceOfExpr) javaParserNode;\n+        processInstanceOf(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        javacTree.getType().accept(this, node.getType());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitIntersectionType(IntersectionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof IntersectionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, IntersectionType.class);\n+        }\n+\n+        IntersectionType node = (IntersectionType) javaParserNode;\n+        processIntersectionType(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLabeledStatement(LabeledStatementTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LabeledStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LabeledStmt.class);\n+        }\n+\n+        LabeledStmt node = (LabeledStmt) javaParserNode;\n+        processLabeledStatement(javacTree, node);\n+        javacTree.getStatement().accept(this, node.getStatement());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLambdaExpression(LambdaExpressionTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof LambdaExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, LambdaExpr.class);\n+        }\n+\n+        LambdaExpr node = (LambdaExpr) javaParserNode;\n+        processLambdaExpression(javacTree, node);\n+        visitLists(javacTree.getParameters(), node.getParameters());\n+        switch (javacTree.getBodyKind()) {\n+            case EXPRESSION:\n+                assert node.getBody() instanceof ExpressionStmt;\n+                ExpressionStmt body = (ExpressionStmt) node.getBody();\n+                javacTree.getBody().accept(this, body.getExpression());\n+                break;\n+            case STATEMENT:\n+                javacTree.getBody().accept(this, node.getBody());\n+                break;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitLiteral(LiteralTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof LiteralExpr) {\n+            processLiteral(javacTree, (LiteralExpr) javaParserNode);\n+        } else if (javaParserNode instanceof UnaryExpr) {\n+            // Occurs for negative literals such as -7.\n+            processLiteral(javacTree, (UnaryExpr) javaParserNode);\n+        } else if (javaParserNode instanceof BinaryExpr) {\n+            // Occurs for expression like \"a\" + \"b\" where javac compresses them to \"ab\" but\n+            // JavaParser doesn't.\n+            processLiteral(javacTree, (BinaryExpr) javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberReference(MemberReferenceTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof MethodReferenceExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, MethodReferenceExpr.class);\n+        }\n+\n+        MethodReferenceExpr node = (MethodReferenceExpr) javaParserNode;\n+        processMemberReference(javacTree, node);\n+        if (node.getScope().isTypeExpr()) {\n+            javacTree.getQualifierExpression().accept(this, node.getScope().asTypeExpr().getType());\n+        } else {\n+            javacTree.getQualifierExpression().accept(this, node.getScope());\n+        }\n+\n+        assert (javacTree.getTypeArguments() != null) == node.getTypeArguments().isPresent();\n+        if (javacTree.getTypeArguments() != null) {\n+            visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMemberSelect(MemberSelectTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof FieldAccessExpr) {\n+            FieldAccessExpr node = (FieldAccessExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getScope());\n+        } else if (javaParserNode instanceof Name) {\n+            Name node = (Name) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getQualifier().isPresent();\n+            javacTree.getExpression().accept(this, node.getQualifier().get());\n+        } else if (javaParserNode instanceof ClassOrInterfaceType) {\n+            ClassOrInterfaceType node = (ClassOrInterfaceType) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getScope().isPresent();\n+            javacTree.getExpression().accept(this, node.getScope().get());\n+        } else if (javaParserNode instanceof ClassExpr) {\n+            ClassExpr node = (ClassExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            javacTree.getExpression().accept(this, node.getType());\n+        } else if (javaParserNode instanceof ThisExpr) {\n+            ThisExpr node = (ThisExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else if (javaParserNode instanceof SuperExpr) {\n+            SuperExpr node = (SuperExpr) javaParserNode;\n+            processMemberSelect(javacTree, node);\n+            assert node.getTypeName().isPresent();\n+            javacTree.getExpression().accept(this, node.getTypeName().get());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof MethodDeclaration) {\n+            visitMethodForMethodDeclaration(javacTree, (MethodDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof ConstructorDeclaration) {\n+            visitMethodForConstructorDeclaration(\n+                    javacTree, (ConstructorDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        if (javaParserNode instanceof AnnotationMemberDeclaration) {\n+            visitMethodForAnnotationMemberDeclaration(\n+                    javacTree, (AnnotationMemberDeclaration) javaParserNode);\n+            return null;\n+        }\n+\n+        throwUnexpectedNodeType(javacTree, javaParserNode);\n+        return null;\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * MethodDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser method declaration\n+     */\n+    private void visitMethodForMethodDeclaration(\n+            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        // TODO: Handle modifiers. In javac this is a ModifiersTree but in JavaParser it's a list of\n+        // modifiers. This is a problem because a ModifiersTree has separate accessors to\n+        // annotations and other modifiers, so the order doesn't match. It might be that for\n+        // JavaParser, the annotations and other modifiers are also accessed separately.\n+        javacTree.getReturnType().accept(this, javaParserNode.getType());\n+        // Unlike other constructs, the javac list is non-null even if no type parameters are\n+        // present.\n+        visitLists(javacTree.getTypeParameters(), javaParserNode.getTypeParameters());\n+        if (javacTree.getReceiverParameter() != null\n+                && javaParserNode.getReceiverParameter().isPresent()) {\n+            javacTree\n+                    .getReceiverParameter()\n+                    .accept(this, javaParserNode.getReceiverParameter().get());\n+        }\n+\n+        visitLists(javacTree.getParameters(), javaParserNode.getParameters());\n+\n+        visitLists(javacTree.getThrows(), javaParserNode.getThrownExceptions());\n+        assert (javacTree.getBody() != null) == javaParserNode.getBody().isPresent();\n+        if (javacTree.getBody() != null) {\n+            javacTree.getBody().accept(this, javaParserNode.getBody().get());\n+        }\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * ConstructorDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser constructor declaration\n+     */\n+    private void visitMethodForConstructorDeclaration(\n+            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        visitLists(javacTree.getTypeParameters(), javaParserNode.getTypeParameters());\n+        assert (javacTree.getReceiverParameter() != null)\n+                == javaParserNode.getReceiverParameter().isPresent();\n+        if (javacTree.getReceiverParameter() != null) {\n+            javacTree\n+                    .getReceiverParameter()\n+                    .accept(this, javaParserNode.getReceiverParameter().get());\n+        }\n+\n+        visitLists(javacTree.getParameters(), javaParserNode.getParameters());\n+        visitLists(javacTree.getThrows(), javaParserNode.getThrownExceptions());\n+        javacTree.getBody().accept(this, javaParserNode.getBody());\n+    }\n+\n+    /**\n+     * Visits a method declaration in the case where the matched JavaParser node was a {@code\n+     * AnnotationMemberDeclaration}.\n+     *\n+     * @param javacTree method declaration to visit\n+     * @param javaParserNode corresponding JavaParser annotation member declaration\n+     */\n+    private void visitMethodForAnnotationMemberDeclaration(\n+            MethodTree javacTree, AnnotationMemberDeclaration javaParserNode) {\n+        processMethod(javacTree, javaParserNode);\n+        javacTree.getReturnType().accept(this, javaParserNode.getType());\n+        assert (javacTree.getDefaultValue() != null)\n+                == javaParserNode.getDefaultValue().isPresent();\n+        if (javacTree.getDefaultValue() != null) {\n+            javacTree.getDefaultValue().accept(this, javaParserNode.getDefaultValue().get());\n+        }\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof MethodCallExpr) {\n+            MethodCallExpr node = (MethodCallExpr) javaParserNode;\n+            processMethodInvocation(javacTree, node);\n+            // In javac, the type arguments will be empty if no type arguments are specified, but in\n+            // JavaParser the type arguments will have the none Optional value.\n+            assert javacTree.getTypeArguments().isEmpty() != node.getTypeArguments().isPresent();\n+            if (!javacTree.getTypeArguments().isEmpty()) {\n+                visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+            }\n+\n+            // In JavaParser, the method name itself and receiver are stored as fields of the\n+            // invocation itself, but in javac they might be combined into one MemberSelectTree.\n+            // That member select may also be a single IdentifierTree if no receiver was written.\n+            // This requires one layer of unnesting.\n+            ExpressionTree methodSelect = javacTree.getMethodSelect();\n+            if (methodSelect.getKind() == Kind.IDENTIFIER) {\n+                methodSelect.accept(this, node.getName());\n+            } else if (methodSelect.getKind() == Kind.MEMBER_SELECT) {\n+                MemberSelectTree selection = (MemberSelectTree) methodSelect;\n+                assert node.getScope().isPresent();\n+                selection.getExpression().accept(this, node.getScope().get());\n+            } else {\n+                throw new BugInCF(\"Unexpected method selection type: %s\", methodSelect);\n+            }\n+\n+            visitLists(javacTree.getArguments(), node.getArguments());\n+        } else if (javaParserNode instanceof ExplicitConstructorInvocationStmt) {\n+            ExplicitConstructorInvocationStmt node =\n+                    (ExplicitConstructorInvocationStmt) javaParserNode;\n+            processMethodInvocation(javacTree, node);\n+            assert javacTree.getTypeArguments().isEmpty() != node.getTypeArguments().isPresent();\n+            if (!javacTree.getTypeArguments().isEmpty()) {\n+                visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+            }\n+\n+            visitLists(javacTree.getArguments(), node.getArguments());\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitModifiers(ModifiersTree arg0, Node arg1) {\n+        // TODO How to handle this? I don't think there's a corresponding JavaParser class, maybe\n+        // the NodeWithModifiers interface?\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitModule(ModuleTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleDeclaration.class);\n+        }\n+\n+        ModuleDeclaration node = (ModuleDeclaration) javaParserNode;\n+        processModule(javacTree, node);\n+        javacTree.getName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewArray(NewArrayTree javacTree, Node javaParserNode) {\n+        // TODO: Implement this.\n+        //\n+        // Some notes:\n+        // - javacTree.getAnnotations() seems to always return empty, any annotations on the base\n+        // type seem to go on the type itself in javacTree.getType(). The JavaParser version doesn't\n+        // even have a corresponding getAnnotations method.\n+        // - When there are no initializers, both systems use similar representations. The\n+        // dimensions line up.\n+        // - When there is an initializer, they differ greatly for multi-dimensional arrays. Javac\n+        // turns an expression like new int[][]{{1, 2}, {3, 4}} into a single NewArray tree with\n+        // type int[] and two initializer elements {1, 2} and {3, 4}. However, for each of the\n+        // sub-initializers, it creates an implicit NewArray tree with a null component type.\n+        // JavaParser keeps the whole expression as one ArrayCreationExpr with multiple dimensions\n+        // and the initializer stored in special ArrayInitializerExpr type.\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitNewClass(NewClassTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ObjectCreationExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ObjectCreationExpr.class);\n+        }\n+\n+        ObjectCreationExpr node = (ObjectCreationExpr) javaParserNode;\n+        processNewClass(javacTree, node);\n+        // When using Java 11 javac, an expression like this.new MyInnerClass() would store \"this\"\n+        // as the enclosing expression. In Java 8 javac, this would be stored as new\n+        // MyInnerClass(this).  So, we only traverse the enclosing expression if present in both.\n+        if (javacTree.getEnclosingExpression() != null && node.getScope().isPresent()) {\n+            javacTree.getEnclosingExpression().accept(this, node.getScope().get());\n+        }\n+\n+        javacTree.getIdentifier().accept(this, node.getType());\n+        if (javacTree.getTypeArguments().isEmpty()) {\n+            assert !node.getTypeArguments().isPresent();\n+        } else {\n+            assert node.getTypeArguments().isPresent();\n+            visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+        }\n+\n+        // Remove synthetic javac argument. When using Java 11, an expression like this.new\n+        // MyInnerClass() would store \"this\" as the enclosing expression. In Java 8, this would be\n+        // stored as new MyInnerClass(this). So, for the argument lists to match, we may have to\n+        // remove the first argument.\n+        List<? extends ExpressionTree> javacArgs = new ArrayList<>(javacTree.getArguments());\n+        if (javacArgs.size() > node.getArguments().size()) {\n+            javacArgs.remove(0);\n+        }\n+\n+        visitLists(javacArgs, node.getArguments());\n+        assert (javacTree.getClassBody() != null) == node.getAnonymousClassBody().isPresent();\n+        if (javacTree.getClassBody() != null) {\n+            visitAnonymouClassBody(javacTree.getClassBody(), node.getAnonymousClassBody().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitOpens(OpensTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleOpensDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleOpensDirective.class);\n+        }\n+\n+        ModuleOpensDirective node = (ModuleOpensDirective) javaParserNode;\n+        processOpens(javacTree, node);\n+        javacTree.getPackageName().accept(this, node.getName());\n+        visitLists(javacTree.getModuleNames(), node.getModuleNames());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitOther(Tree javacTree, Node javaParserNode) {\n+        processOther(javacTree, javaParserNode);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitPackage(PackageTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof PackageDeclaration)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, PackageDeclaration.class);\n+        }\n+\n+        PackageDeclaration node = (PackageDeclaration) javaParserNode;\n+        processPackage(javacTree, node);\n+        // visitLists(javacTree.getAnnotations(), node.getAnnotations());\n+        javacTree.getPackageName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitParameterizedType(ParameterizedTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ClassOrInterfaceType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ClassOrInterfaceType.class);\n+        }\n+\n+        ClassOrInterfaceType node = (ClassOrInterfaceType) javaParserNode;\n+        processParameterizedType(javacTree, node);\n+        javacTree.getType().accept(this, node);\n+        // TODO: In a parameterized type, will the first branch ever run?\n+        if (javacTree.getTypeArguments().isEmpty()) {\n+            assert !node.getTypeArguments().isPresent() || node.getTypeArguments().get().isEmpty();\n+        } else {\n+            assert node.getTypeArguments().isPresent();\n+            visitLists(javacTree.getTypeArguments(), node.getTypeArguments().get());\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitParenthesized(ParenthesizedTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof EnclosedExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, EnclosedExpr.class);\n+        }\n+\n+        EnclosedExpr node = (EnclosedExpr) javaParserNode;\n+        processParenthesized(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getInner());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitPrimitiveType(PrimitiveTypeTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof PrimitiveType) {\n+            processPrimitiveType(javacTree, (PrimitiveType) javaParserNode);\n+        } else if (javaParserNode instanceof VoidType) {\n+            processPrimitiveType(javacTree, (VoidType) javaParserNode);\n+        } else {\n+            throwUnexpectedNodeType(javacTree, javaParserNode);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitProvides(ProvidesTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleProvidesDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleProvidesDirective.class);\n+        }\n+\n+        ModuleProvidesDirective node = (ModuleProvidesDirective) javaParserNode;\n+        processProvides(javacTree, node);\n+        javacTree.getServiceName().accept(this, node.getName());\n+        visitLists(javacTree.getImplementationNames(), node.getWith());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitRequires(RequiresTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleRequiresDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleRequiresDirective.class);\n+        }\n+\n+        ModuleRequiresDirective node = (ModuleRequiresDirective) javaParserNode;\n+        processRequires(javacTree, node);\n+        javacTree.getModuleName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitReturn(ReturnTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ReturnStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ReturnStmt.class);\n+        }\n+\n+        ReturnStmt node = (ReturnStmt) javaParserNode;\n+        processReturn(javacTree, node);\n+        assert (javacTree.getExpression() != null) == node.getExpression().isPresent();\n+        if (javacTree.getExpression() != null) {\n+            javacTree.getExpression().accept(this, node.getExpression().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitSwitch(SwitchTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SwitchStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SwitchStmt.class);\n+        }\n+\n+        SwitchStmt node = (SwitchStmt) javaParserNode;\n+        processSwitch(javacTree, node);\n+        // Switch expressions are always parenthesized in javac but never in JavaParser.\n+        ParenthesizedTree expression = (ParenthesizedTree) javacTree.getExpression();\n+        expression.getExpression().accept(this, node.getSelector());\n+        visitLists(javacTree.getCases(), node.getEntries());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitSynchronized(SynchronizedTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof SynchronizedStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, SynchronizedStmt.class);\n+        }\n+\n+        SynchronizedStmt node = (SynchronizedStmt) javaParserNode;\n+        processSynchronized(javacTree, node);\n+        ((ParenthesizedTree) javacTree.getExpression())\n+                .getExpression()\n+                .accept(this, node.getExpression());\n+        javacTree.getBlock().accept(this, node.getBody());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitThrow(ThrowTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ThrowStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ThrowStmt.class);\n+        }\n+\n+        ThrowStmt node = (ThrowStmt) javaParserNode;\n+        processThrow(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTry(TryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof TryStmt)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, TryStmt.class);\n+        }\n+\n+        TryStmt node = (TryStmt) javaParserNode;\n+        processTry(javacTree, node);\n+        Iterator<? extends Tree> javacIter = javacTree.getResources().iterator();\n+        for (Expression resource : node.getResources()) {\n+            if (resource.isVariableDeclarationExpr()) {\n+                for (VariableDeclarator declarator :\n+                        resource.asVariableDeclarationExpr().getVariables()) {\n+                    assert javacIter.hasNext();\n+                    javacIter.next().accept(this, declarator);\n+                }\n+            } else {\n+                assert javacIter.hasNext();\n+                javacIter.next().accept(this, resource);\n+            }\n+        }\n+\n+        javacTree.getBlock().accept(this, node.getTryBlock());\n+        visitLists(javacTree.getCatches(), node.getCatchClauses());\n+        assert (javacTree.getFinallyBlock() != null) == node.getFinallyBlock().isPresent();\n+        if (javacTree.getFinallyBlock() != null) {\n+            javacTree.getFinallyBlock().accept(this, node.getFinallyBlock().get());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypeCast(TypeCastTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof CastExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, CastExpr.class);\n+        }\n+\n+        CastExpr node = (CastExpr) javaParserNode;\n+        processTypeCast(javacTree, node);\n+        javacTree.getType().accept(this, node.getType());\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypeParameter(TypeParameterTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof TypeParameter)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, TypeParameter.class);\n+        }\n+\n+        TypeParameter node = (TypeParameter) javaParserNode;\n+        processTypeParameter(javacTree, node);\n+        visitLists(javacTree.getBounds(), node.getTypeBound());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitUnary(UnaryTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof UnaryExpr)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, UnaryExpr.class);\n+        }\n+\n+        UnaryExpr node = (UnaryExpr) javaParserNode;\n+        processUnary(javacTree, node);\n+        javacTree.getExpression().accept(this, node.getExpression());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitUnionType(UnionTypeTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof UnionType)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, UnionType.class);\n+        }\n+\n+        UnionType node = (UnionType) javaParserNode;\n+        processUnionType(javacTree, node);\n+        visitLists(javacTree.getTypeAlternatives(), node.getElements());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitUses(UsesTree javacTree, Node javaParserNode) {\n+        if (!(javaParserNode instanceof ModuleUsesDirective)) {\n+            throwUnexpectedNodeType(javacTree, javaParserNode, ModuleUsesDirective.class);\n+        }\n+\n+        ModuleUsesDirective node = (ModuleUsesDirective) javaParserNode;\n+        processUses(javacTree, node);\n+        javacTree.getServiceName().accept(this, node.getName());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(VariableTree javacTree, Node javaParserNode) {\n+        if (javaParserNode instanceof VariableDeclarator) {\n+            VariableDeclarator node = (VariableDeclarator) javaParserNode;\n+            processVariable(javacTree, node);\n+            if (!node.getType().isVarType()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12c98fd4c7a8725b8c812d3038143ad028f526a9"}, "originalPosition": 1512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNzk0MTc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyMDo0N1rOImLfuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyMDo0N1rOImLfuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkwNTE0NQ==", "bodyText": "The name of this class is not very evocative.  Can you give it a name that is more expressive?  I was thinking something like ParseAnnotation because it does what a parser does -- creates an AST.  Or something like ConvertAnnotationMirrorToAnnotationExpr.\nIf you can't think of a better name, the current one isn't terrible, because the method name annotationMirrorToAnnotationExpr is descriptive.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576905145", "createdAt": "2021-02-16T15:20:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.JavaParser;\n+import com.github.javaparser.ParseResult;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.ArrayInitializerExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.CharLiteralExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.AnnotationValueVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Methods for converting a {@code AnnotationMirror} into a JavaParser {@code AnnotationExpr},\n+ * namely {@code annotationMirrorToAnnotationExpr}.\n+ */\n+public class AnnotationConversion {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNzk1NTIxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyMzoyN1rOImLoIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyMzoyN1rOImLoIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkwNzI5Ng==", "bodyText": "Can you add a comment about why this case is a bug?  Or is it just not implemented yet?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576907296", "createdAt": "2021-02-16T15:23:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.JavaParser;\n+import com.github.javaparser.ParseResult;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.ArrayInitializerExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.CharLiteralExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.AnnotationValueVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Methods for converting a {@code AnnotationMirror} into a JavaParser {@code AnnotationExpr},\n+ * namely {@code annotationMirrorToAnnotationExpr}.\n+ */\n+public class AnnotationConversion {\n+    /**\n+     * Converts an AnnotationMirror into a JavaParser {@code AnnotationExpr}.\n+     *\n+     * @param annotation the annotation to convert\n+     * @return a JavaParser {@code AnnotationExpr} representing the same annotation with the same\n+     *     element values. The converted annotation will contain the annotation's fully qualified\n+     *     name.\n+     */\n+    public static AnnotationExpr annotationMirrorToAnnotationExpr(AnnotationMirror annotation) {\n+        Map<? extends ExecutableElement, ? extends AnnotationValue> values =\n+                annotation.getElementValues();\n+        Name name = createQualifiedName(AnnotationUtils.annotationName(annotation));\n+        if (values.isEmpty()) {\n+            return new MarkerAnnotationExpr(name);\n+        }\n+\n+        NodeList<MemberValuePair> convertedValues = convertAnnotationValues(values);\n+        if (convertedValues.size() == 1\n+                && convertedValues.get(0).getName().asString().equals(\"value\")) {\n+            return new SingleMemberAnnotationExpr(name, convertedValues.get(0).getValue());\n+        }\n+\n+        return new NormalAnnotationExpr(name, convertedValues);\n+    }\n+\n+    /**\n+     * Converts a mapping of (annotation element &rarr; value) into a list of key-value pairs\n+     * containing the JavaParser representations of the same values.\n+     *\n+     * @param values mapping of element values from an {@code AnnotationMirror}\n+     * @return a list of the key-value pairs in {@code values} converted to their JavaParser\n+     *     representations\n+     */\n+    private static NodeList<MemberValuePair> convertAnnotationValues(\n+            Map<? extends ExecutableElement, ? extends AnnotationValue> values) {\n+        NodeList<MemberValuePair> convertedValues = new NodeList<>();\n+        AnnotationValueConverterVisitor converter = new AnnotationValueConverterVisitor();\n+        for (ExecutableElement valueName : values.keySet()) {\n+            AnnotationValue value = values.get(valueName);\n+            convertedValues.add(\n+                    new MemberValuePair(\n+                            valueName.getSimpleName().toString(), value.accept(converter, null)));\n+        }\n+\n+        return convertedValues;\n+    }\n+\n+    /**\n+     * Given a fully qualified name, creates a JavaParser {@code Name} structure representing the\n+     * same name.\n+     *\n+     * @param name the fully qualified name to convert\n+     * @return a JavaParser {@code Name} holding {@code name}\n+     */\n+    private static Name createQualifiedName(String name) {\n+        String[] components = name.split(\"\\\\.\");\n+        Name result = new Name(components[0]);\n+        for (int i = 1; i < components.length; i++) {\n+            result = new Name(result, components[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * A visitor that converts annotation values from an {@code AnnotationMirror} to a JavaParser\n+     * node that can appear in an {@code AnnotationExpr}.\n+     */\n+    private static class AnnotationValueConverterVisitor\n+            implements AnnotationValueVisitor<Expression, Void> {\n+        @Override\n+        public Expression visit(AnnotationValue value, Void p) {\n+            throw new BugInCF(\"Unknown annotation value type: \" + value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzNzk1OTAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyNDoxMVrOImLqbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNToyNDoxMVrOImLqbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkwNzg4Ng==", "bodyText": "Why does this instantiate a new JavaParser rather than using StaticJavaParser?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576907886", "createdAt": "2021-02-16T15:24:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/AnnotationConversion.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.JavaParser;\n+import com.github.javaparser.ParseResult;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.AnnotationExpr;\n+import com.github.javaparser.ast.expr.ArrayInitializerExpr;\n+import com.github.javaparser.ast.expr.BooleanLiteralExpr;\n+import com.github.javaparser.ast.expr.CharLiteralExpr;\n+import com.github.javaparser.ast.expr.ClassExpr;\n+import com.github.javaparser.ast.expr.DoubleLiteralExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.FieldAccessExpr;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.LongLiteralExpr;\n+import com.github.javaparser.ast.expr.MarkerAnnotationExpr;\n+import com.github.javaparser.ast.expr.MemberValuePair;\n+import com.github.javaparser.ast.expr.Name;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.NormalAnnotationExpr;\n+import com.github.javaparser.ast.expr.SingleMemberAnnotationExpr;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.AnnotationValue;\n+import javax.lang.model.element.AnnotationValueVisitor;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Methods for converting a {@code AnnotationMirror} into a JavaParser {@code AnnotationExpr},\n+ * namely {@code annotationMirrorToAnnotationExpr}.\n+ */\n+public class AnnotationConversion {\n+    /**\n+     * Converts an AnnotationMirror into a JavaParser {@code AnnotationExpr}.\n+     *\n+     * @param annotation the annotation to convert\n+     * @return a JavaParser {@code AnnotationExpr} representing the same annotation with the same\n+     *     element values. The converted annotation will contain the annotation's fully qualified\n+     *     name.\n+     */\n+    public static AnnotationExpr annotationMirrorToAnnotationExpr(AnnotationMirror annotation) {\n+        Map<? extends ExecutableElement, ? extends AnnotationValue> values =\n+                annotation.getElementValues();\n+        Name name = createQualifiedName(AnnotationUtils.annotationName(annotation));\n+        if (values.isEmpty()) {\n+            return new MarkerAnnotationExpr(name);\n+        }\n+\n+        NodeList<MemberValuePair> convertedValues = convertAnnotationValues(values);\n+        if (convertedValues.size() == 1\n+                && convertedValues.get(0).getName().asString().equals(\"value\")) {\n+            return new SingleMemberAnnotationExpr(name, convertedValues.get(0).getValue());\n+        }\n+\n+        return new NormalAnnotationExpr(name, convertedValues);\n+    }\n+\n+    /**\n+     * Converts a mapping of (annotation element &rarr; value) into a list of key-value pairs\n+     * containing the JavaParser representations of the same values.\n+     *\n+     * @param values mapping of element values from an {@code AnnotationMirror}\n+     * @return a list of the key-value pairs in {@code values} converted to their JavaParser\n+     *     representations\n+     */\n+    private static NodeList<MemberValuePair> convertAnnotationValues(\n+            Map<? extends ExecutableElement, ? extends AnnotationValue> values) {\n+        NodeList<MemberValuePair> convertedValues = new NodeList<>();\n+        AnnotationValueConverterVisitor converter = new AnnotationValueConverterVisitor();\n+        for (ExecutableElement valueName : values.keySet()) {\n+            AnnotationValue value = values.get(valueName);\n+            convertedValues.add(\n+                    new MemberValuePair(\n+                            valueName.getSimpleName().toString(), value.accept(converter, null)));\n+        }\n+\n+        return convertedValues;\n+    }\n+\n+    /**\n+     * Given a fully qualified name, creates a JavaParser {@code Name} structure representing the\n+     * same name.\n+     *\n+     * @param name the fully qualified name to convert\n+     * @return a JavaParser {@code Name} holding {@code name}\n+     */\n+    private static Name createQualifiedName(String name) {\n+        String[] components = name.split(\"\\\\.\");\n+        Name result = new Name(components[0]);\n+        for (int i = 1; i < components.length; i++) {\n+            result = new Name(result, components[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * A visitor that converts annotation values from an {@code AnnotationMirror} to a JavaParser\n+     * node that can appear in an {@code AnnotationExpr}.\n+     */\n+    private static class AnnotationValueConverterVisitor\n+            implements AnnotationValueVisitor<Expression, Void> {\n+        @Override\n+        public Expression visit(AnnotationValue value, Void p) {\n+            throw new BugInCF(\"Unknown annotation value type: \" + value);\n+        }\n+\n+        @Override\n+        public Expression visitAnnotation(AnnotationMirror value, Void p) {\n+            return AnnotationConversion.annotationMirrorToAnnotationExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitArray(List<? extends AnnotationValue> value, Void p) {\n+            NodeList<Expression> valueExpressions = new NodeList<>();\n+            for (AnnotationValue arrayValue : value) {\n+                valueExpressions.add(arrayValue.accept(this, null));\n+            }\n+\n+            return new ArrayInitializerExpr(valueExpressions);\n+        }\n+\n+        @Override\n+        public Expression visitBoolean(boolean value, Void p) {\n+            return new BooleanLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitByte(byte value, Void p) {\n+            // Annotation byte values are automatically cast to the correct type, so using an\n+            // integer\n+            // literal here works.\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitChar(char value, Void p) {\n+            return new CharLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitDouble(double value, Void p) {\n+            return new DoubleLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitEnumConstant(VariableElement value, Void p) {\n+            // The enclosing element of an enum constant is the enum type itself.\n+            TypeElement enumElt = (TypeElement) value.getEnclosingElement();\n+            String[] components = enumElt.getQualifiedName().toString().split(\"\\\\.\");\n+            Expression enumName = new NameExpr(components[0]);\n+            for (int i = 1; i < components.length; i++) {\n+                enumName = new FieldAccessExpr(enumName, components[i]);\n+            }\n+\n+            return new FieldAccessExpr(enumName, value.getSimpleName().toString());\n+        }\n+\n+        @Override\n+        public Expression visitFloat(float value, Void p) {\n+            return new DoubleLiteralExpr(value + \"f\");\n+        }\n+\n+        @Override\n+        public Expression visitInt(int value, Void p) {\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitLong(long value, Void p) {\n+            if (value < 0) {\n+                return new UnaryExpr(\n+                        new LongLiteralExpr(Long.toString(-value)), UnaryExpr.Operator.MINUS);\n+            }\n+\n+            return new LongLiteralExpr(Long.toString(value));\n+        }\n+\n+        @Override\n+        public Expression visitShort(short value, Void p) {\n+            // Annotation short values are automatically cast to the correct type, so using an\n+            // integer\n+            // literal here works.\n+            return toIntegerLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitString(String value, Void p) {\n+            return new StringLiteralExpr(value);\n+        }\n+\n+        @Override\n+        public Expression visitType(TypeMirror value, Void p) {\n+            if (value.getKind() != TypeKind.DECLARED) {\n+                throw new BugInCF(\"Unexpected type for class expression: \" + value);\n+            }\n+\n+            DeclaredType type = (DeclaredType) value;\n+            ParseResult<ClassOrInterfaceType> parseResult =\n+                    new JavaParser()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA0MDkyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0MDoyN1rOImMcrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQyMToyMzo0MFrOIrVq1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMDc0OA==", "bodyText": "What is #shouldIgnore?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576920748", "createdAt": "2021-02-16T15:40:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjMxNDcxMQ==", "bodyText": "It's only relevant to the Scenes implementation, I've removed it here.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r582314711", "createdAt": "2021-02-24T21:23:40Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMDc0OA=="}, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA0NTMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0MToyMVrOImMfbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0MToyMVrOImMfbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMTQ1Mg==", "bodyText": "Should there be an assertion that the two == expressions evaluate to the same truth value?  If not, please explain when they differ.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576921452", "createdAt": "2021-02-16T15:41:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA1MjQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0Mjo1MVrOImMjzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQyMTozMDo1OVrOIrV76A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMjU3Mw==", "bodyText": "The return type is void, so what is done with the created wrapper?  I think it's stored in classToAnnos (and maybe more is done in createWrappersForClass), but classToAnnos is a private variable.  Please write the Javadoc in terms of the public abstractions.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576922573", "createdAt": "2021-02-16T15:42:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjMxOTA4MA==", "bodyText": "You're right in that it stores everything in classToAnnos.\n\nPlease write the Javadoc in terms of the public abstractions.\n\nThis is a private method, so I think it's fine to mention the private fields here.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r582319080", "createdAt": "2021-02-24T21:30:59Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMjU3Mw=="}, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA1NjQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0Mzo0MlrOImMmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0Mzo0MlrOImMmXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyMzIzMQ==", "bodyText": "Similarly to the above, where is this stored, and why does this method say \"creates and stores\" whereas the above just said \"create\"?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576923231", "createdAt": "2021-02-16T15:43:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA3MTE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo0NjoyNVrOImMvFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQyMjoxNDo0MlrOIrXbqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyNTQ2MA==", "bodyText": "Should this method handle enum constants?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576925460", "createdAt": "2021-02-16T15:46:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 465}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjM0MzU5NQ==", "bodyText": "We would only add enum constants if we did inference on them, which we're not doing for now.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r582343595", "createdAt": "2021-02-24T22:14:42Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyNTQ2MA=="}, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 465}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA5NDMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo1MDo0M1rOImM9OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQyMTo0NTozNlrOIrWcqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyOTA4MQ==", "bodyText": "Is this testing whether the method declaration is from source code?  Why is this test necessary?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576929081", "createdAt": "2021-02-16T15:50:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String fieldName = javacTree.getName().toString();\n+                        if (!enclosingClass.fields.containsKey(fieldName)) {\n+                            enclosingClass.fields.put(fieldName, new FieldAnnos(javaParserNode));\n+                        }\n+                    }\n+                };\n+        visitor.visitClass(javacClass, javaParserClass);\n+    }\n+\n+    /**\n+     * Calls {@link #addSourceFile(String)} for the file containing the given element.\n+     *\n+     * @param element element for the source file to add\n+     * @return path of the file containing {@code element}\n+     */\n+    private String addClassesForElement(Element element) {\n+        if (!ElementUtils.isElementFromSourceCode(element)) {\n+            throw new BugInCF(\"Adding source file for non-source element: \" + element);\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        if (classToAnnos.containsKey(ElementUtils.getBinaryName(toplevelClass))) {\n+            return path;\n+        }\n+\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        ClassTree toplevelClassTree =\n+                (ClassTree) atypeFactory.declarationFromElement(toplevelClass);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+        return path;\n+    }\n+\n+    /**\n+     * Returns the top-level class that contains {@code element}.\n+     *\n+     * @param element the element whose enclosing class to find\n+     * @return an element for a class containing {@code element} that isn't contained in another\n+     *     class\n+     */\n+    private static TypeElement toplevelEnclosingClass(Element element) {\n+        TypeElement result = ElementUtils.enclosingTypeElement(element);\n+        if (result == null) {\n+            return (TypeElement) element;\n+        }\n+\n+        TypeElement enclosing = ElementUtils.strictEnclosingTypeElement(result);\n+        while (enclosing != null) {\n+            result = enclosing;\n+            enclosing = ElementUtils.strictEnclosingTypeElement(enclosing);\n+        }\n+\n+        return result;\n+    }\n+\n+    ///\n+    /// Writing to a file\n+    ///\n+\n+    // The prepare*ForWriting hooks are needed in addition to the postProcessClassTree hook because\n+    // a scene may be modifed and written at any time, including before or after\n+    // postProcessClassTree is called.\n+\n+    /**\n+     * Side-effects the compilation unit annotations to make any desired changes before writing to a\n+     * file.\n+     *\n+     * @param compilationUnitAnnos the compilation unit annotations to modify\n+     */\n+    public void prepareCompilationUnitForWriting(CompilationUnitAnnos compilationUnitAnnos) {\n+        for (ClassOrInterfaceAnnos type : compilationUnitAnnos.types) {\n+            prepareClassForWriting(type);\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the class annotations to make any desired changes before writing to a file.\n+     *\n+     * @param classAnnos the class annotations to modify\n+     */\n+    public void prepareClassForWriting(ClassOrInterfaceAnnos classAnnos) {\n+        for (Map.Entry<String, CallableDeclarationAnnos> methodEntry :\n+                classAnnos.callableDeclarations.entrySet()) {\n+            prepareMethodForWriting(methodEntry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the method or constructor annotations to make any desired changes before writing\n+     * to a file.\n+     *\n+     * @param methodAnnos the method or constructor annotations to modify\n+     */\n+    public void prepareMethodForWriting(CallableDeclarationAnnos methodAnnos) {\n+        atypeFactory.prepareMethodForWriting(methodAnnos);\n+    }\n+\n+    @Override\n+    public void writeResultsToFile(OutputFormat outputFormat, BaseTypeChecker checker) {\n+        if (outputFormat != OutputFormat.AJAVA) {\n+            throw new BugInCF(\"WholeProgramInferenceJavaParser used with format \" + outputFormat);\n+        }\n+\n+        File outputDir = new File(AJAVA_FILES_PATH);\n+        if (!outputDir.exists()) {\n+            outputDir.mkdirs();\n+        }\n+\n+        for (String path : modifiedFiles) {\n+            CompilationUnitAnnos root = sourceToAnnos.get(path);\n+            prepareCompilationUnitForWriting(root);\n+            root.transferAnnotations();\n+            String packageDir = AJAVA_FILES_PATH;\n+            if (root.declaration.getPackageDeclaration().isPresent()) {\n+                packageDir +=\n+                        File.separator\n+                                + root.declaration\n+                                        .getPackageDeclaration()\n+                                        .get()\n+                                        .getNameAsString()\n+                                        .replaceAll(\"\\\\.\", File.separator);\n+            }\n+\n+            File packageDirFile = new File(packageDir);\n+            if (!packageDirFile.exists()) {\n+                packageDirFile.mkdirs();\n+            }\n+\n+            String name = new File(path).getName();\n+            if (name.endsWith(\".java\")) {\n+                name = name.substring(0, name.length() - \".java\".length());\n+            }\n+\n+            name += \"-\" + checker.getClass().getCanonicalName() + \".ajava\";\n+            String outputPath = packageDir + File.separator + name;\n+            try {\n+                FileWriter writer = new FileWriter(outputPath);\n+\n+                // JavaParser can output using lexical preserving printing, which writes the file\n+                // such that its formatting is close to the original source file it was parsed from\n+                // as possible. Currently, this feature is very buggy and crashes when adding\n+                // annotations in certain locations. This implementation could be used instead if\n+                // it's fixed in JavaParser.\n+                // LexicalPreservingPrinter.print(root.declaration, writer);\n+\n+                PrettyPrinter prettyPrinter = new PrettyPrinter(new PrettyPrinterConfiguration());\n+                writer.write(prettyPrinter.print(root.declaration));\n+                writer.close();\n+            } catch (IOException e) {\n+                throw new BugInCF(\"Error while writing ajava file\", e);\n+            }\n+        }\n+\n+        modifiedFiles.clear();\n+    }\n+\n+    /**\n+     * Adds an explicit receiver type to a JavaParser method declaration.\n+     *\n+     * @param methodDeclaration declaration to add a receiver to\n+     */\n+    private static void addExplicitReceiver(MethodDeclaration methodDeclaration) {\n+        if (methodDeclaration.getReceiverParameter().isPresent()) {\n+            return;\n+        }\n+\n+        if (!methodDeclaration.getParentNode().isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 638}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjMyNzQ2Nw==", "bodyText": "I'm not aware of any cases where the parent node wouldn't be present. I'll remove the check and see if it still works.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r582327467", "createdAt": "2021-02-24T21:45:36Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String fieldName = javacTree.getName().toString();\n+                        if (!enclosingClass.fields.containsKey(fieldName)) {\n+                            enclosingClass.fields.put(fieldName, new FieldAnnos(javaParserNode));\n+                        }\n+                    }\n+                };\n+        visitor.visitClass(javacClass, javaParserClass);\n+    }\n+\n+    /**\n+     * Calls {@link #addSourceFile(String)} for the file containing the given element.\n+     *\n+     * @param element element for the source file to add\n+     * @return path of the file containing {@code element}\n+     */\n+    private String addClassesForElement(Element element) {\n+        if (!ElementUtils.isElementFromSourceCode(element)) {\n+            throw new BugInCF(\"Adding source file for non-source element: \" + element);\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        if (classToAnnos.containsKey(ElementUtils.getBinaryName(toplevelClass))) {\n+            return path;\n+        }\n+\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        ClassTree toplevelClassTree =\n+                (ClassTree) atypeFactory.declarationFromElement(toplevelClass);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+        return path;\n+    }\n+\n+    /**\n+     * Returns the top-level class that contains {@code element}.\n+     *\n+     * @param element the element whose enclosing class to find\n+     * @return an element for a class containing {@code element} that isn't contained in another\n+     *     class\n+     */\n+    private static TypeElement toplevelEnclosingClass(Element element) {\n+        TypeElement result = ElementUtils.enclosingTypeElement(element);\n+        if (result == null) {\n+            return (TypeElement) element;\n+        }\n+\n+        TypeElement enclosing = ElementUtils.strictEnclosingTypeElement(result);\n+        while (enclosing != null) {\n+            result = enclosing;\n+            enclosing = ElementUtils.strictEnclosingTypeElement(enclosing);\n+        }\n+\n+        return result;\n+    }\n+\n+    ///\n+    /// Writing to a file\n+    ///\n+\n+    // The prepare*ForWriting hooks are needed in addition to the postProcessClassTree hook because\n+    // a scene may be modifed and written at any time, including before or after\n+    // postProcessClassTree is called.\n+\n+    /**\n+     * Side-effects the compilation unit annotations to make any desired changes before writing to a\n+     * file.\n+     *\n+     * @param compilationUnitAnnos the compilation unit annotations to modify\n+     */\n+    public void prepareCompilationUnitForWriting(CompilationUnitAnnos compilationUnitAnnos) {\n+        for (ClassOrInterfaceAnnos type : compilationUnitAnnos.types) {\n+            prepareClassForWriting(type);\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the class annotations to make any desired changes before writing to a file.\n+     *\n+     * @param classAnnos the class annotations to modify\n+     */\n+    public void prepareClassForWriting(ClassOrInterfaceAnnos classAnnos) {\n+        for (Map.Entry<String, CallableDeclarationAnnos> methodEntry :\n+                classAnnos.callableDeclarations.entrySet()) {\n+            prepareMethodForWriting(methodEntry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the method or constructor annotations to make any desired changes before writing\n+     * to a file.\n+     *\n+     * @param methodAnnos the method or constructor annotations to modify\n+     */\n+    public void prepareMethodForWriting(CallableDeclarationAnnos methodAnnos) {\n+        atypeFactory.prepareMethodForWriting(methodAnnos);\n+    }\n+\n+    @Override\n+    public void writeResultsToFile(OutputFormat outputFormat, BaseTypeChecker checker) {\n+        if (outputFormat != OutputFormat.AJAVA) {\n+            throw new BugInCF(\"WholeProgramInferenceJavaParser used with format \" + outputFormat);\n+        }\n+\n+        File outputDir = new File(AJAVA_FILES_PATH);\n+        if (!outputDir.exists()) {\n+            outputDir.mkdirs();\n+        }\n+\n+        for (String path : modifiedFiles) {\n+            CompilationUnitAnnos root = sourceToAnnos.get(path);\n+            prepareCompilationUnitForWriting(root);\n+            root.transferAnnotations();\n+            String packageDir = AJAVA_FILES_PATH;\n+            if (root.declaration.getPackageDeclaration().isPresent()) {\n+                packageDir +=\n+                        File.separator\n+                                + root.declaration\n+                                        .getPackageDeclaration()\n+                                        .get()\n+                                        .getNameAsString()\n+                                        .replaceAll(\"\\\\.\", File.separator);\n+            }\n+\n+            File packageDirFile = new File(packageDir);\n+            if (!packageDirFile.exists()) {\n+                packageDirFile.mkdirs();\n+            }\n+\n+            String name = new File(path).getName();\n+            if (name.endsWith(\".java\")) {\n+                name = name.substring(0, name.length() - \".java\".length());\n+            }\n+\n+            name += \"-\" + checker.getClass().getCanonicalName() + \".ajava\";\n+            String outputPath = packageDir + File.separator + name;\n+            try {\n+                FileWriter writer = new FileWriter(outputPath);\n+\n+                // JavaParser can output using lexical preserving printing, which writes the file\n+                // such that its formatting is close to the original source file it was parsed from\n+                // as possible. Currently, this feature is very buggy and crashes when adding\n+                // annotations in certain locations. This implementation could be used instead if\n+                // it's fixed in JavaParser.\n+                // LexicalPreservingPrinter.print(root.declaration, writer);\n+\n+                PrettyPrinter prettyPrinter = new PrettyPrinter(new PrettyPrinterConfiguration());\n+                writer.write(prettyPrinter.print(root.declaration));\n+                writer.close();\n+            } catch (IOException e) {\n+                throw new BugInCF(\"Error while writing ajava file\", e);\n+            }\n+        }\n+\n+        modifiedFiles.clear();\n+    }\n+\n+    /**\n+     * Adds an explicit receiver type to a JavaParser method declaration.\n+     *\n+     * @param methodDeclaration declaration to add a receiver to\n+     */\n+    private static void addExplicitReceiver(MethodDeclaration methodDeclaration) {\n+        if (methodDeclaration.getReceiverParameter().isPresent()) {\n+            return;\n+        }\n+\n+        if (!methodDeclaration.getParentNode().isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyOTA4MQ=="}, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 638}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODA5ODc1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo1MTo0MlrOImNAEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNTo1MTo0MlrOImNAEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjkyOTgxMA==", "bodyText": "This is a poor variable name, since it isn't a declaration.  (I realize it's the same variable name as used in some similar classes, but I still think it should be changed here.)", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r576929810", "createdAt": "2021-02-16T15:51:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String fieldName = javacTree.getName().toString();\n+                        if (!enclosingClass.fields.containsKey(fieldName)) {\n+                            enclosingClass.fields.put(fieldName, new FieldAnnos(javaParserNode));\n+                        }\n+                    }\n+                };\n+        visitor.visitClass(javacClass, javaParserClass);\n+    }\n+\n+    /**\n+     * Calls {@link #addSourceFile(String)} for the file containing the given element.\n+     *\n+     * @param element element for the source file to add\n+     * @return path of the file containing {@code element}\n+     */\n+    private String addClassesForElement(Element element) {\n+        if (!ElementUtils.isElementFromSourceCode(element)) {\n+            throw new BugInCF(\"Adding source file for non-source element: \" + element);\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        if (classToAnnos.containsKey(ElementUtils.getBinaryName(toplevelClass))) {\n+            return path;\n+        }\n+\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        ClassTree toplevelClassTree =\n+                (ClassTree) atypeFactory.declarationFromElement(toplevelClass);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+        return path;\n+    }\n+\n+    /**\n+     * Returns the top-level class that contains {@code element}.\n+     *\n+     * @param element the element whose enclosing class to find\n+     * @return an element for a class containing {@code element} that isn't contained in another\n+     *     class\n+     */\n+    private static TypeElement toplevelEnclosingClass(Element element) {\n+        TypeElement result = ElementUtils.enclosingTypeElement(element);\n+        if (result == null) {\n+            return (TypeElement) element;\n+        }\n+\n+        TypeElement enclosing = ElementUtils.strictEnclosingTypeElement(result);\n+        while (enclosing != null) {\n+            result = enclosing;\n+            enclosing = ElementUtils.strictEnclosingTypeElement(enclosing);\n+        }\n+\n+        return result;\n+    }\n+\n+    ///\n+    /// Writing to a file\n+    ///\n+\n+    // The prepare*ForWriting hooks are needed in addition to the postProcessClassTree hook because\n+    // a scene may be modifed and written at any time, including before or after\n+    // postProcessClassTree is called.\n+\n+    /**\n+     * Side-effects the compilation unit annotations to make any desired changes before writing to a\n+     * file.\n+     *\n+     * @param compilationUnitAnnos the compilation unit annotations to modify\n+     */\n+    public void prepareCompilationUnitForWriting(CompilationUnitAnnos compilationUnitAnnos) {\n+        for (ClassOrInterfaceAnnos type : compilationUnitAnnos.types) {\n+            prepareClassForWriting(type);\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the class annotations to make any desired changes before writing to a file.\n+     *\n+     * @param classAnnos the class annotations to modify\n+     */\n+    public void prepareClassForWriting(ClassOrInterfaceAnnos classAnnos) {\n+        for (Map.Entry<String, CallableDeclarationAnnos> methodEntry :\n+                classAnnos.callableDeclarations.entrySet()) {\n+            prepareMethodForWriting(methodEntry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the method or constructor annotations to make any desired changes before writing\n+     * to a file.\n+     *\n+     * @param methodAnnos the method or constructor annotations to modify\n+     */\n+    public void prepareMethodForWriting(CallableDeclarationAnnos methodAnnos) {\n+        atypeFactory.prepareMethodForWriting(methodAnnos);\n+    }\n+\n+    @Override\n+    public void writeResultsToFile(OutputFormat outputFormat, BaseTypeChecker checker) {\n+        if (outputFormat != OutputFormat.AJAVA) {\n+            throw new BugInCF(\"WholeProgramInferenceJavaParser used with format \" + outputFormat);\n+        }\n+\n+        File outputDir = new File(AJAVA_FILES_PATH);\n+        if (!outputDir.exists()) {\n+            outputDir.mkdirs();\n+        }\n+\n+        for (String path : modifiedFiles) {\n+            CompilationUnitAnnos root = sourceToAnnos.get(path);\n+            prepareCompilationUnitForWriting(root);\n+            root.transferAnnotations();\n+            String packageDir = AJAVA_FILES_PATH;\n+            if (root.declaration.getPackageDeclaration().isPresent()) {\n+                packageDir +=\n+                        File.separator\n+                                + root.declaration\n+                                        .getPackageDeclaration()\n+                                        .get()\n+                                        .getNameAsString()\n+                                        .replaceAll(\"\\\\.\", File.separator);\n+            }\n+\n+            File packageDirFile = new File(packageDir);\n+            if (!packageDirFile.exists()) {\n+                packageDirFile.mkdirs();\n+            }\n+\n+            String name = new File(path).getName();\n+            if (name.endsWith(\".java\")) {\n+                name = name.substring(0, name.length() - \".java\".length());\n+            }\n+\n+            name += \"-\" + checker.getClass().getCanonicalName() + \".ajava\";\n+            String outputPath = packageDir + File.separator + name;\n+            try {\n+                FileWriter writer = new FileWriter(outputPath);\n+\n+                // JavaParser can output using lexical preserving printing, which writes the file\n+                // such that its formatting is close to the original source file it was parsed from\n+                // as possible. Currently, this feature is very buggy and crashes when adding\n+                // annotations in certain locations. This implementation could be used instead if\n+                // it's fixed in JavaParser.\n+                // LexicalPreservingPrinter.print(root.declaration, writer);\n+\n+                PrettyPrinter prettyPrinter = new PrettyPrinter(new PrettyPrinterConfiguration());\n+                writer.write(prettyPrinter.print(root.declaration));\n+                writer.close();\n+            } catch (IOException e) {\n+                throw new BugInCF(\"Error while writing ajava file\", e);\n+            }\n+        }\n+\n+        modifiedFiles.clear();\n+    }\n+\n+    /**\n+     * Adds an explicit receiver type to a JavaParser method declaration.\n+     *\n+     * @param methodDeclaration declaration to add a receiver to\n+     */\n+    private static void addExplicitReceiver(MethodDeclaration methodDeclaration) {\n+        if (methodDeclaration.getReceiverParameter().isPresent()) {\n+            return;\n+        }\n+\n+        if (!methodDeclaration.getParentNode().isPresent()) {\n+            return;\n+        }\n+\n+        com.github.javaparser.ast.Node parent = methodDeclaration.getParentNode().get();\n+        if (!(parent instanceof TypeDeclaration)) {\n+            return;\n+        }\n+\n+        TypeDeclaration<?> parentDecl = (TypeDeclaration<?>) parent;\n+        ClassOrInterfaceType receiver = new ClassOrInterfaceType();\n+        receiver.setName(parentDecl.getName());\n+        if (parentDecl.isClassOrInterfaceDeclaration()) {\n+            ClassOrInterfaceDeclaration parentClassDecl =\n+                    parentDecl.asClassOrInterfaceDeclaration();\n+            if (!parentClassDecl.getTypeParameters().isEmpty()) {\n+                NodeList<Type> typeArgs = new NodeList<>();\n+                for (TypeParameter typeParam : parentClassDecl.getTypeParameters()) {\n+                    ClassOrInterfaceType typeArg = new ClassOrInterfaceType();\n+                    typeArg.setName(typeParam.getNameAsString());\n+                    typeArgs.add(typeArg);\n+                }\n+\n+                receiver.setTypeArguments(typeArgs);\n+            }\n+        }\n+\n+        methodDeclaration.setReceiverParameter(new ReceiverParameter(receiver, \"this\"));\n+    }\n+\n+    /**\n+     * Transfers all annotations for {@code annotatedType} and its nested types to {@code target},\n+     * which is the JavaParser node representing the same type. Does nothing if {@code\n+     * annotatedType} is null.\n+     *\n+     * @param annotatedType type to transfer annotations from\n+     * @param target the JavaParser type to transfer annotation to, must represent the same type as\n+     *     {@code annotatedType}\n+     */\n+    private static void transferAnnotations(\n+            @Nullable AnnotatedTypeMirror annotatedType, Type target) {\n+        if (annotatedType == null) {\n+            return;\n+        }\n+\n+        target.accept(new AnnotationTransferVisitor(), annotatedType);\n+    }\n+\n+    ///\n+    /// Storing annotations\n+    ///\n+\n+    /**\n+     * Stores the JavaParser node for a compilation unit and the list of wrappers for the classes\n+     * and interfaces in that compilation unit.\n+     */\n+    private static class CompilationUnitAnnos {\n+        /** Compilation unit being wrapped. */\n+        public CompilationUnit declaration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 696}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzODYyNDk0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceImplementation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNzo0MToyNlrOImSEdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQxNzo0MToyNlrOImSEdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzAxMjg1NQ==", "bodyText": "What is the relationship of this sentence to the following one?  Please clarify or merge them.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577012855", "createdAt": "2021-02-16T17:41:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceImplementation.java", "diffHunk": "@@ -36,34 +32,26 @@\n import org.checkerframework.framework.qual.TypeUseLocation;\n import org.checkerframework.framework.type.AnnotatedTypeFactory;\n import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedDeclaredType;\n import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedNullType;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedTypeVariable;\n import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n import org.checkerframework.framework.util.AnnotatedTypes;\n import org.checkerframework.framework.util.dependenttypes.DependentTypesHelper;\n import org.checkerframework.javacutil.BugInCF;\n import org.checkerframework.javacutil.ElementUtils;\n import org.checkerframework.javacutil.TreeUtils;\n-import org.checkerframework.javacutil.TypeAnnotationUtils;\n-import scenelib.annotations.el.AClass;\n-import scenelib.annotations.el.AField;\n-import scenelib.annotations.el.AMethod;\n-import scenelib.annotations.el.AScene;\n-import scenelib.annotations.el.ATypeElement;\n-import scenelib.annotations.util.JVMNames;\n \n /**\n- * WholeProgramInferenceScenes is an implementation of {@link\n- * org.checkerframework.common.wholeprograminference.WholeProgramInference}.\n- *\n- * <p>Its file format is .jaif files.\n+ * This is the primary implementation of {@link\n+ * org.checkerframework.common.wholeprograminference.WholeProgramInference}. It uses an instance of\n+ * {@link WholeProgramInferenceStorage} to store annotations and to create output files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0MDE5NTkwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToxNDozMlrOImg60g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToxNDozMlrOImg60g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI1NjE0Ng==", "bodyText": "When does that happen?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577256146", "createdAt": "2021-02-17T01:14:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceJavaParserStorage.java", "diffHunk": "@@ -0,0 +1,1076 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.CallableDeclaration;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.body.EnumDeclaration;\n+import com.github.javaparser.ast.body.MethodDeclaration;\n+import com.github.javaparser.ast.body.ReceiverParameter;\n+import com.github.javaparser.ast.body.TypeDeclaration;\n+import com.github.javaparser.ast.body.VariableDeclarator;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.Type;\n+import com.github.javaparser.ast.type.TypeParameter;\n+import com.github.javaparser.ast.visitor.CloneVisitor;\n+import com.github.javaparser.printer.PrettyPrinter;\n+import com.github.javaparser.printer.PrettyPrinterConfiguration;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.signature.qual.BinaryName;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.wholeprograminference.WholeProgramInference.OutputFormat;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.ajava.AnnotationConversion;\n+import org.checkerframework.framework.ajava.AnnotationTransferVisitor;\n+import org.checkerframework.framework.ajava.DefaultJointVisitor;\n+import org.checkerframework.framework.ajava.JavaParserUtils;\n+import org.checkerframework.framework.ajava.JointJavacJavaParserVisitor;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;\n+import org.checkerframework.framework.type.GenericAnnotatedTypeFactory;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import scenelib.annotations.util.JVMNames;\n+\n+/**\n+ * This is an implementation of {@link WholeProgramInferenceStorage} that stores annotations\n+ * directly with the JavaParser node corresponding to the annotation's location. It outputs ajava\n+ * files.\n+ */\n+public class WholeProgramInferenceJavaParserStorage\n+        implements WholeProgramInferenceStorage<AnnotatedTypeMirror> {\n+\n+    /** The type factory associated with this. */\n+    protected final AnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Directory where .ajava files will be written to and read from. This directory is relative to\n+     * where the javac command is executed.\n+     */\n+    public static final String AJAVA_FILES_PATH =\n+            \"build\" + File.separator + \"whole-program-inference\" + File.separator;\n+\n+    /**\n+     * Maps from binary class name to the wrapper containing the class. Contains all classes in Java\n+     * source files containing an Element for which an annotation has been inferred.\n+     */\n+    private Map<@BinaryName String, ClassOrInterfaceAnnos> classToAnnos;\n+\n+    /**\n+     * Files containing classes for which an annotation has been inferred since the last time files\n+     * were written to disk.\n+     */\n+    private Set<String> modifiedFiles;\n+\n+    /** Mapping from source file to the wrapper for the compilation unit parsed from that file. */\n+    private Map<String, CompilationUnitAnnos> sourceToAnnos;\n+\n+    /**\n+     * Constructs a new {@code WholeProgramInferenceJavaParser} that has not yet inferred any\n+     * annotations.\n+     *\n+     * @param atypeFactory the associated type factory\n+     */\n+    public WholeProgramInferenceJavaParserStorage(AnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+        classToAnnos = new HashMap<>();\n+        modifiedFiles = new HashSet<>();\n+        sourceToAnnos = new HashMap<>();\n+    }\n+\n+    @Override\n+    public String getFileForElement(Element elt) {\n+        return addClassesForElement(elt);\n+    }\n+\n+    @Override\n+    public void setFileModified(String path) {\n+        modifiedFiles.add(path);\n+    }\n+\n+    ///\n+    /// Reading stored annotations\n+    ///\n+\n+    @Override\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt) {\n+        return getMethodAnnos(methodElt) != null;\n+    }\n+\n+    /**\n+     * Get the annotations for a method or constructor.\n+     *\n+     * @param methodElt the method or constructor\n+     * @return the annotations for a method or constructor\n+     */\n+    private CallableDeclarationAnnos getMethodAnnos(ExecutableElement methodElt) {\n+        String className = ElementUtils.getEnclosingClassName(methodElt);\n+        // Read in classes for the element.\n+        getFileForElement(methodElt);\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        CallableDeclarationAnnos methodAnnos =\n+                classAnnos.callableDeclarations.get(JVMNames.getJVMMethodSignature(methodElt));\n+        return methodAnnos;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getParameterType(paramATM, i, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReceiverType(paramATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        return methodAnnos.getReturnType(atm, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory) {\n+        ClassSymbol enclosingClass = ((VarSymbol) element).enclClass();\n+        // Read in classes for the element.\n+        getFileForElement(element);\n+        @SuppressWarnings(\"signature\") // https://tinyurl.com/cfissue/3094\n+        @BinaryName String className = enclosingClass.flatname.toString();\n+        ClassOrInterfaceAnnos classAnnos = classToAnnos.get(className);\n+        return classAnnos.fields.get(fieldName).getType(lhsATM, atypeFactory);\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        switch (preOrPost) {\n+            case BEFORE:\n+                return getPreconditionsForField(methodElement, fieldElement, atypeFactory);\n+            case AFTER:\n+                return getPostconditionsForField(methodElement, fieldElement, atypeFactory);\n+            default:\n+                throw new BugInCF(\"Unexpected \" + preOrPost);\n+        }\n+    }\n+\n+    /**\n+     * Returns the precondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the precondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPreconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPreconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    /**\n+     * Returns the postcondition annotations for a field.\n+     *\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the postcondition annotations for a field\n+     */\n+    private AnnotatedTypeMirror getPostconditionsForField(\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory) {\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElement);\n+        return methodAnnos.getPostconditionsForField(fieldElement, atypeFactory);\n+    }\n+\n+    @Override\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno) {\n+\n+        CallableDeclarationAnnos methodAnnos = getMethodAnnos(methodElt);\n+        if (methodAnnos.declarationAnnotations == null) {\n+            methodAnnos.declarationAnnotations = new LinkedHashSet<AnnotationMirror>();\n+        }\n+\n+        boolean isNewAnnotation = methodAnnos.declarationAnnotations.add(anno);\n+        if (isNewAnnotation) {\n+            modifiedFiles.add(getFileForElement(methodElt));\n+        }\n+        return isNewAnnotation;\n+    }\n+\n+    @Override\n+    public AnnotatedTypeMirror atmFromStorageLocation(\n+            TypeMirror typeMirror, AnnotatedTypeMirror storageLocation) {\n+        return storageLocation;\n+    }\n+\n+    @Override\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            AnnotatedTypeMirror typeToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated) {\n+        // Clears only the annotations that are supported by atypeFactory.\n+        // The others stay intact.\n+        Set<AnnotationMirror> annosToRemove = AnnotationUtils.createAnnotationSet();\n+        for (AnnotationMirror anno : typeToUpdate.getAnnotations()) {\n+            if (atypeFactory.isSupportedQualifier(anno)) {\n+                annosToRemove.add(anno);\n+            }\n+        }\n+\n+        // This method may be called consecutive times to modify the same AnnotatedTypeMirror.\n+        // Each time it is called, the AnnotatedTypeMirror has a better type\n+        // estimate for the modified AnnotatedTypeMirror. Therefore, it is not a problem to remove\n+        // all annotations before inserting the new annotations.\n+        typeToUpdate.removeAnnotations(annosToRemove);\n+\n+        // Only update the AnnotatedTypeMirror if there are no explicit annotations\n+        if (curATM.getExplicitAnnotations().isEmpty() || !ignoreIfAnnotated) {\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        } else if (curATM.getKind() == TypeKind.TYPEVAR) {\n+            // getExplicitAnnotations will be non-empty for type vars whose bounds are explicitly\n+            // annotated.  So instead, only insert the annotation if there is not primary annotation\n+            // of the same hierarchy.  #shouldIgnore prevent annotations that are subtypes of type\n+            // vars upper bound from being inserted.\n+            for (AnnotationMirror am : newATM.getAnnotations()) {\n+                if (curATM.getAnnotationInHierarchy(am) != null) {\n+                    // Don't insert if the type is already has a primary annotation\n+                    // in the same hierarchy.\n+                    break;\n+                }\n+\n+                typeToUpdate.addAnnotation(am);\n+            }\n+        }\n+\n+        // Recursively update compound type and type variable type if they exist.\n+        if (newATM.getKind() == TypeKind.ARRAY && curATM.getKind() == TypeKind.ARRAY) {\n+            AnnotatedArrayType newAAT = (AnnotatedArrayType) newATM;\n+            AnnotatedArrayType oldAAT = (AnnotatedArrayType) curATM;\n+            AnnotatedArrayType aatToUpdate = (AnnotatedArrayType) typeToUpdate;\n+            updateStorageLocationFromAtm(\n+                    newAAT.getComponentType(),\n+                    oldAAT.getComponentType(),\n+                    aatToUpdate.getComponentType(),\n+                    defLoc,\n+                    ignoreIfAnnotated);\n+        }\n+    }\n+\n+    ///\n+    /// Reading in files\n+    ///\n+\n+    @Override\n+    public void preprocessClassTree(ClassTree classTree) {\n+        addClassTree(classTree);\n+    }\n+\n+    /**\n+     * Reads in the source file containing {@code tree} and creates a wrapper around {@code tree}.\n+     *\n+     * @param tree tree for class to add\n+     */\n+    private void addClassTree(ClassTree tree) {\n+        TypeElement element = TreeUtils.elementFromDeclaration(tree);\n+        String className = ElementUtils.getBinaryName(element);\n+        if (classToAnnos.containsKey(className)) {\n+            return;\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        ClassTree toplevelClassTree = atypeFactory.getTreeUtils().getTree(toplevelClass);\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+    }\n+\n+    /**\n+     * Reads in the file at {@code path} and creates and stores a wrapper around its compilation\n+     * unit.\n+     *\n+     * @param path path to source file to read\n+     */\n+    private void addSourceFile(String path) {\n+        if (sourceToAnnos.containsKey(path)) {\n+            return;\n+        }\n+\n+        try {\n+            CompilationUnit root = StaticJavaParser.parse(new File(path));\n+            JavaParserUtils.concatenateAddedStringLiterals(root);\n+            CompilationUnitAnnos sourceAnnos = new CompilationUnitAnnos(root);\n+            sourceToAnnos.put(path, sourceAnnos);\n+        } catch (FileNotFoundException e) {\n+            throw new BugInCF(\"Failed to read java file: \" + path, e);\n+        }\n+    }\n+\n+    /**\n+     * Given a javac tree and JavaParser node representing the same class, creates wrappers around\n+     * all the classes, fields, and methods in that class.\n+     *\n+     * @param javacClass javac tree for class\n+     * @param javaParserClass JavaParser node corresponding to the same class as {@code javacClass}\n+     * @param sourceAnnos compilation unit wrapper to add new wrappers to\n+     */\n+    private void createWrappersForClass(\n+            ClassTree javacClass,\n+            TypeDeclaration<?> javaParserClass,\n+            CompilationUnitAnnos sourceAnnos) {\n+        JointJavacJavaParserVisitor visitor =\n+                new DefaultJointVisitor() {\n+                    @Override\n+                    public void processClass(\n+                            ClassTree javacTree, ClassOrInterfaceDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processClass(ClassTree javacTree, EnumDeclaration javaParserNode) {\n+                        addClass(javacTree);\n+                    }\n+\n+                    @Override\n+                    public void processNewClass(\n+                            NewClassTree javacTree, ObjectCreationExpr javaParserNode) {\n+                        if (javacTree.getClassBody() != null) {\n+                            addClass(javacTree.getClassBody());\n+                        }\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around the class for {@code tree} and stores it.\n+                     *\n+                     * @param tree tree to add\n+                     */\n+                    private void addClass(ClassTree tree) {\n+                        TypeElement classElt = TreeUtils.elementFromDeclaration(tree);\n+                        String className = ElementUtils.getBinaryName(classElt);\n+                        ClassOrInterfaceAnnos typeWrapper = new ClassOrInterfaceAnnos();\n+                        if (!classToAnnos.containsKey(className)) {\n+                            classToAnnos.put(className, typeWrapper);\n+                        }\n+\n+                        sourceAnnos.types.add(typeWrapper);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, MethodDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    @Override\n+                    public void processMethod(\n+                            MethodTree javacTree, ConstructorDeclaration javaParserNode) {\n+                        addCallableDeclaration(javacTree, javaParserNode);\n+                    }\n+\n+                    /**\n+                     * Creates a wrapper around {@code javacTree} with the corresponding declaration\n+                     * {@code javaParserNode} and stores it.\n+                     *\n+                     * @param javacTree javac tree for declaration to add\n+                     * @param javaParserNode JavaParser node for the same class as {@code javacTree}\n+                     */\n+                    private void addCallableDeclaration(\n+                            MethodTree javacTree, CallableDeclaration<?> javaParserNode) {\n+                        ExecutableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String executableName = JVMNames.getJVMMethodSignature(javacTree);\n+                        if (!enclosingClass.callableDeclarations.containsKey(executableName)) {\n+                            enclosingClass.callableDeclarations.put(\n+                                    executableName, new CallableDeclarationAnnos(javaParserNode));\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void processVariable(\n+                            VariableTree javacTree, VariableDeclarator javaParserNode) {\n+                        // This seems to occur when javacTree is a local variable in the second\n+                        // class located in a source file. If this check returns false, then the\n+                        // below call to TreeUtils.elementFromDeclaration causes a crash.\n+                        if (TreeUtils.elementFromTree(javacTree) == null) {\n+                            return;\n+                        }\n+\n+                        VariableElement elt = TreeUtils.elementFromDeclaration(javacTree);\n+                        if (!elt.getKind().isField()) {\n+                            return;\n+                        }\n+\n+                        String className = ElementUtils.getEnclosingClassName(elt);\n+                        ClassOrInterfaceAnnos enclosingClass = classToAnnos.get(className);\n+                        String fieldName = javacTree.getName().toString();\n+                        if (!enclosingClass.fields.containsKey(fieldName)) {\n+                            enclosingClass.fields.put(fieldName, new FieldAnnos(javaParserNode));\n+                        }\n+                    }\n+                };\n+        visitor.visitClass(javacClass, javaParserClass);\n+    }\n+\n+    /**\n+     * Calls {@link #addSourceFile(String)} for the file containing the given element.\n+     *\n+     * @param element element for the source file to add\n+     * @return path of the file containing {@code element}\n+     */\n+    private String addClassesForElement(Element element) {\n+        if (!ElementUtils.isElementFromSourceCode(element)) {\n+            throw new BugInCF(\"Adding source file for non-source element: \" + element);\n+        }\n+\n+        TypeElement toplevelClass = toplevelEnclosingClass(element);\n+        String path = ElementUtils.getSourceFilePath(toplevelClass);\n+        if (classToAnnos.containsKey(ElementUtils.getBinaryName(toplevelClass))) {\n+            return path;\n+        }\n+\n+        addSourceFile(path);\n+        CompilationUnitAnnos sourceAnnos = sourceToAnnos.get(path);\n+        ClassTree toplevelClassTree =\n+                (ClassTree) atypeFactory.declarationFromElement(toplevelClass);\n+        TypeDeclaration<?> javaParserNode =\n+                sourceAnnos.getClassOrInterfaceDeclarationByName(\n+                        toplevelClass.getSimpleName().toString());\n+        createWrappersForClass(toplevelClassTree, javaParserNode, sourceAnnos);\n+        return path;\n+    }\n+\n+    /**\n+     * Returns the top-level class that contains {@code element}.\n+     *\n+     * @param element the element whose enclosing class to find\n+     * @return an element for a class containing {@code element} that isn't contained in another\n+     *     class\n+     */\n+    private static TypeElement toplevelEnclosingClass(Element element) {\n+        TypeElement result = ElementUtils.enclosingTypeElement(element);\n+        if (result == null) {\n+            return (TypeElement) element;\n+        }\n+\n+        TypeElement enclosing = ElementUtils.strictEnclosingTypeElement(result);\n+        while (enclosing != null) {\n+            result = enclosing;\n+            enclosing = ElementUtils.strictEnclosingTypeElement(enclosing);\n+        }\n+\n+        return result;\n+    }\n+\n+    ///\n+    /// Writing to a file\n+    ///\n+\n+    // The prepare*ForWriting hooks are needed in addition to the postProcessClassTree hook because\n+    // a scene may be modifed and written at any time, including before or after\n+    // postProcessClassTree is called.\n+\n+    /**\n+     * Side-effects the compilation unit annotations to make any desired changes before writing to a\n+     * file.\n+     *\n+     * @param compilationUnitAnnos the compilation unit annotations to modify\n+     */\n+    public void prepareCompilationUnitForWriting(CompilationUnitAnnos compilationUnitAnnos) {\n+        for (ClassOrInterfaceAnnos type : compilationUnitAnnos.types) {\n+            prepareClassForWriting(type);\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the class annotations to make any desired changes before writing to a file.\n+     *\n+     * @param classAnnos the class annotations to modify\n+     */\n+    public void prepareClassForWriting(ClassOrInterfaceAnnos classAnnos) {\n+        for (Map.Entry<String, CallableDeclarationAnnos> methodEntry :\n+                classAnnos.callableDeclarations.entrySet()) {\n+            prepareMethodForWriting(methodEntry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Side-effects the method or constructor annotations to make any desired changes before writing\n+     * to a file.\n+     *\n+     * @param methodAnnos the method or constructor annotations to modify\n+     */\n+    public void prepareMethodForWriting(CallableDeclarationAnnos methodAnnos) {\n+        atypeFactory.prepareMethodForWriting(methodAnnos);\n+    }\n+\n+    @Override\n+    public void writeResultsToFile(OutputFormat outputFormat, BaseTypeChecker checker) {\n+        if (outputFormat != OutputFormat.AJAVA) {\n+            throw new BugInCF(\"WholeProgramInferenceJavaParser used with format \" + outputFormat);\n+        }\n+\n+        File outputDir = new File(AJAVA_FILES_PATH);\n+        if (!outputDir.exists()) {\n+            outputDir.mkdirs();\n+        }\n+\n+        for (String path : modifiedFiles) {\n+            CompilationUnitAnnos root = sourceToAnnos.get(path);\n+            prepareCompilationUnitForWriting(root);\n+            root.transferAnnotations();\n+            String packageDir = AJAVA_FILES_PATH;\n+            if (root.declaration.getPackageDeclaration().isPresent()) {\n+                packageDir +=\n+                        File.separator\n+                                + root.declaration\n+                                        .getPackageDeclaration()\n+                                        .get()\n+                                        .getNameAsString()\n+                                        .replaceAll(\"\\\\.\", File.separator);\n+            }\n+\n+            File packageDirFile = new File(packageDir);\n+            if (!packageDirFile.exists()) {\n+                packageDirFile.mkdirs();\n+            }\n+\n+            String name = new File(path).getName();\n+            if (name.endsWith(\".java\")) {\n+                name = name.substring(0, name.length() - \".java\".length());\n+            }\n+\n+            name += \"-\" + checker.getClass().getCanonicalName() + \".ajava\";\n+            String outputPath = packageDir + File.separator + name;\n+            try {\n+                FileWriter writer = new FileWriter(outputPath);\n+\n+                // JavaParser can output using lexical preserving printing, which writes the file\n+                // such that its formatting is close to the original source file it was parsed from\n+                // as possible. Currently, this feature is very buggy and crashes when adding\n+                // annotations in certain locations. This implementation could be used instead if\n+                // it's fixed in JavaParser.\n+                // LexicalPreservingPrinter.print(root.declaration, writer);\n+\n+                PrettyPrinter prettyPrinter = new PrettyPrinter(new PrettyPrinterConfiguration());\n+                writer.write(prettyPrinter.print(root.declaration));\n+                writer.close();\n+            } catch (IOException e) {\n+                throw new BugInCF(\"Error while writing ajava file\", e);\n+            }\n+        }\n+\n+        modifiedFiles.clear();\n+    }\n+\n+    /**\n+     * Adds an explicit receiver type to a JavaParser method declaration.\n+     *\n+     * @param methodDeclaration declaration to add a receiver to\n+     */\n+    private static void addExplicitReceiver(MethodDeclaration methodDeclaration) {\n+        if (methodDeclaration.getReceiverParameter().isPresent()) {\n+            return;\n+        }\n+\n+        if (!methodDeclaration.getParentNode().isPresent()) {\n+            return;\n+        }\n+\n+        com.github.javaparser.ast.Node parent = methodDeclaration.getParentNode().get();\n+        if (!(parent instanceof TypeDeclaration)) {\n+            return;\n+        }\n+\n+        TypeDeclaration<?> parentDecl = (TypeDeclaration<?>) parent;\n+        ClassOrInterfaceType receiver = new ClassOrInterfaceType();\n+        receiver.setName(parentDecl.getName());\n+        if (parentDecl.isClassOrInterfaceDeclaration()) {\n+            ClassOrInterfaceDeclaration parentClassDecl =\n+                    parentDecl.asClassOrInterfaceDeclaration();\n+            if (!parentClassDecl.getTypeParameters().isEmpty()) {\n+                NodeList<Type> typeArgs = new NodeList<>();\n+                for (TypeParameter typeParam : parentClassDecl.getTypeParameters()) {\n+                    ClassOrInterfaceType typeArg = new ClassOrInterfaceType();\n+                    typeArg.setName(typeParam.getNameAsString());\n+                    typeArgs.add(typeArg);\n+                }\n+\n+                receiver.setTypeArguments(typeArgs);\n+            }\n+        }\n+\n+        methodDeclaration.setReceiverParameter(new ReceiverParameter(receiver, \"this\"));\n+    }\n+\n+    /**\n+     * Transfers all annotations for {@code annotatedType} and its nested types to {@code target},\n+     * which is the JavaParser node representing the same type. Does nothing if {@code\n+     * annotatedType} is null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 671}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0MDIwMTY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceStorage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToxNTo0N1rOImg-Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQyMTo1NDozOFrOIrWwVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI1NzAzMQ==", "bodyText": "Should \"Elements\" be capitalized here?  Does it just mean syntactic constructs, or does it mean the Element class?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577257031", "createdAt": "2021-02-17T01:15:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceStorage.java", "diffHunk": "@@ -0,0 +1,197 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.sun.source.tree.ClassTree;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * Stores annotations from whole program inference. For a given location such as a field or method,\n+ * an object can be obtained containing the inferred annotations for that object.\n+ *\n+ * <p>Also writes stored annotations to storage files. The specific format depends on the\n+ * implementation.\n+ *\n+ * @param <T> the type used by the storage to store annotations. The methods {@link\n+ *     #atmFromStorageLocation} and {@link #updateStorageLocationFromAtm} can be used to manipulate\n+ *     a storage location.\n+ */\n+public interface WholeProgramInferenceStorage<T> {\n+    /**\n+     * Returns the file corresponding to the given element. This may side-effect the storage to load\n+     * the file if it hasn't been read yet.\n+     *\n+     * @param elt an element\n+     * @return the path to the file where inference results for the element will be written\n+     */\n+    public String getFileForElement(Element elt);\n+\n+    /**\n+     * Given an Element in a compilation unit that has already been read into storage, returns\n+     * whether there exists a stored method matching {@code elt}.\n+     *\n+     * <p>An implementation is permitted to return false if {@code elt} represents a method that was\n+     * synthetically added by javac, such as zero-argument constructors or valueOf(String) methods\n+     * for enum types.\n+     *\n+     * @param methodElt a method or constructor Element\n+     * @return true if the storage has a method corresponding to {@code elt}, false otherwise\n+     */\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt);\n+\n+    /**\n+     * Get the annotations for a formal parameter type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param i the parameter index (0-based)\n+     * @param paramATM the parameter type\n+     * @param ve the parameter variable\n+     * @param atypeFactory the type factory\n+     * @return the annotations for a formal parameter type\n+     */\n+    public T getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for the receiver type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param paramATM the receiver type\n+     * @param atypeFactory the type factory\n+     * @return the annotations for the receiver type\n+     */\n+    public T getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for the return type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param atm the return type\n+     * @param atypeFactory the type factory\n+     * @return the annotations for the return type\n+     */\n+    public T getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for a field type.\n+     *\n+     * @param element the element for the field\n+     * @param fieldName the simple field name\n+     * @param lhsATM the field type\n+     * @param atypeFactory the annotated type factory\n+     * @return the annotations for a field type\n+     */\n+    public T getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Returns the pre- or postcondition annotations for a field.\n+     *\n+     * @param preOrPost whether to get the precondition or postcondition\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the pre- or postcondition annotations for a field\n+     */\n+    public T getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Updates a method to add a declaration annotation.\n+     *\n+     * @param methodElt the method to annotate\n+     * @param anno the declaration annotation to add to the method\n+     * @return true if {@code anno} is a new declaration annotation for {@code methodElt}, false\n+     *     otherwise\n+     */\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno);\n+\n+    /**\n+     * Obtain the type from a storage location.\n+     *\n+     * @param typeMirror the underlying type for the result\n+     * @param storageLocation the storage location from which to obtain annotations\n+     * @return an annotated type mirror with underlying type {@code typeMirror} and annotations from\n+     *     {@code storageLocation}\n+     */\n+    public AnnotatedTypeMirror atmFromStorageLocation(TypeMirror typeMirror, T storageLocation);\n+\n+    /**\n+     * Updates a storage location to have the annotations of the given {@code AnnotatedTypeMirror}.\n+     * Annotations in the original set that should be ignored are not added to the resulting set. If\n+     * {@code ignoreIfAnnotated} is true, doesn't add annotations for locations with explicit\n+     * annotations in source code.\n+     *\n+     * <p>This method removes from the storage location all annotations supported by the\n+     * AnnotatedTypeFactory before inserting new ones. It is assumed that every time this method is\n+     * called, the new {@code AnnotatedTypeMirror} has a better type estimate for the given\n+     * location. Therefore, it is not a problem to remove all annotations before inserting the new\n+     * annotations.\n+     *\n+     * @param newATM the type whose annotations will be added to the {@code AnnotatedTypeMirror}\n+     * @param curATM the annotations currently stored at the location, used to check if the element\n+     *     which will be updated has explicit annotations in source code\n+     * @param storageLocationToUpdate the storage location which will be updated\n+     * @param defLoc the location where the annotation will be added\n+     * @param ignoreIfAnnotated if true, don't update any type that is explicitly annotated in the\n+     *     source code\n+     */\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            T storageLocationToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated);\n+\n+    /**\n+     * Writes the inferred results to a file. Ideally, it should be called at the end of the\n+     * type-checking process. In practice, it is called after each class, because we don't know\n+     * which class will be the last one in the type-checking process.\n+     *\n+     * @param outputFormat the file format in which to write the results\n+     * @param checker the checker from which this method is called, for naming stub files\n+     */\n+    public void writeResultsToFile(\n+            WholeProgramInference.OutputFormat outputFormat, BaseTypeChecker checker);\n+\n+    /**\n+     * Indicates that inferred annotations for the file at {@code path} have changed since last\n+     * written. This causes output files for {@code path} to be written out next time {@link\n+     * #writeResultsToFile} is called.\n+     *\n+     * @param path path to the file with annotations that have been modified\n+     */\n+    public void setFileModified(String path);\n+\n+    /**\n+     * Performs any preparation required for inference on Elements of a class. Should be called on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjMzMjUwMw==", "bodyText": "I think currently we only infer things for constructs with an Element, but that might change in the future so I'll remove the capitalization.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r582332503", "createdAt": "2021-02-24T21:54:38Z", "author": {"login": "jwaataja"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceStorage.java", "diffHunk": "@@ -0,0 +1,197 @@\n+package org.checkerframework.common.wholeprograminference;\n+\n+import com.sun.source.tree.ClassTree;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.dataflow.analysis.Analysis;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * Stores annotations from whole program inference. For a given location such as a field or method,\n+ * an object can be obtained containing the inferred annotations for that object.\n+ *\n+ * <p>Also writes stored annotations to storage files. The specific format depends on the\n+ * implementation.\n+ *\n+ * @param <T> the type used by the storage to store annotations. The methods {@link\n+ *     #atmFromStorageLocation} and {@link #updateStorageLocationFromAtm} can be used to manipulate\n+ *     a storage location.\n+ */\n+public interface WholeProgramInferenceStorage<T> {\n+    /**\n+     * Returns the file corresponding to the given element. This may side-effect the storage to load\n+     * the file if it hasn't been read yet.\n+     *\n+     * @param elt an element\n+     * @return the path to the file where inference results for the element will be written\n+     */\n+    public String getFileForElement(Element elt);\n+\n+    /**\n+     * Given an Element in a compilation unit that has already been read into storage, returns\n+     * whether there exists a stored method matching {@code elt}.\n+     *\n+     * <p>An implementation is permitted to return false if {@code elt} represents a method that was\n+     * synthetically added by javac, such as zero-argument constructors or valueOf(String) methods\n+     * for enum types.\n+     *\n+     * @param methodElt a method or constructor Element\n+     * @return true if the storage has a method corresponding to {@code elt}, false otherwise\n+     */\n+    public boolean hasStorageLocationForMethod(ExecutableElement methodElt);\n+\n+    /**\n+     * Get the annotations for a formal parameter type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param i the parameter index (0-based)\n+     * @param paramATM the parameter type\n+     * @param ve the parameter variable\n+     * @param atypeFactory the type factory\n+     * @return the annotations for a formal parameter type\n+     */\n+    public T getParameterAnnotations(\n+            ExecutableElement methodElt,\n+            int i,\n+            AnnotatedTypeMirror paramATM,\n+            VariableElement ve,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for the receiver type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param paramATM the receiver type\n+     * @param atypeFactory the type factory\n+     * @return the annotations for the receiver type\n+     */\n+    public T getReceiverAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror paramATM,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for the return type.\n+     *\n+     * @param methodElt the method or constructor Element\n+     * @param atm the return type\n+     * @param atypeFactory the type factory\n+     * @return the annotations for the return type\n+     */\n+    public T getReturnAnnotations(\n+            ExecutableElement methodElt,\n+            AnnotatedTypeMirror atm,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Get the annotations for a field type.\n+     *\n+     * @param element the element for the field\n+     * @param fieldName the simple field name\n+     * @param lhsATM the field type\n+     * @param atypeFactory the annotated type factory\n+     * @return the annotations for a field type\n+     */\n+    public T getFieldAnnotations(\n+            Element element,\n+            String fieldName,\n+            AnnotatedTypeMirror lhsATM,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Returns the pre- or postcondition annotations for a field.\n+     *\n+     * @param preOrPost whether to get the precondition or postcondition\n+     * @param methodElement the method\n+     * @param fieldElement the field\n+     * @param atypeFactory the type factory\n+     * @return the pre- or postcondition annotations for a field\n+     */\n+    public T getPreOrPostconditionsForField(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElement,\n+            VariableElement fieldElement,\n+            AnnotatedTypeFactory atypeFactory);\n+\n+    /**\n+     * Updates a method to add a declaration annotation.\n+     *\n+     * @param methodElt the method to annotate\n+     * @param anno the declaration annotation to add to the method\n+     * @return true if {@code anno} is a new declaration annotation for {@code methodElt}, false\n+     *     otherwise\n+     */\n+    public boolean addMethodDeclarationAnnotation(\n+            ExecutableElement methodElt, AnnotationMirror anno);\n+\n+    /**\n+     * Obtain the type from a storage location.\n+     *\n+     * @param typeMirror the underlying type for the result\n+     * @param storageLocation the storage location from which to obtain annotations\n+     * @return an annotated type mirror with underlying type {@code typeMirror} and annotations from\n+     *     {@code storageLocation}\n+     */\n+    public AnnotatedTypeMirror atmFromStorageLocation(TypeMirror typeMirror, T storageLocation);\n+\n+    /**\n+     * Updates a storage location to have the annotations of the given {@code AnnotatedTypeMirror}.\n+     * Annotations in the original set that should be ignored are not added to the resulting set. If\n+     * {@code ignoreIfAnnotated} is true, doesn't add annotations for locations with explicit\n+     * annotations in source code.\n+     *\n+     * <p>This method removes from the storage location all annotations supported by the\n+     * AnnotatedTypeFactory before inserting new ones. It is assumed that every time this method is\n+     * called, the new {@code AnnotatedTypeMirror} has a better type estimate for the given\n+     * location. Therefore, it is not a problem to remove all annotations before inserting the new\n+     * annotations.\n+     *\n+     * @param newATM the type whose annotations will be added to the {@code AnnotatedTypeMirror}\n+     * @param curATM the annotations currently stored at the location, used to check if the element\n+     *     which will be updated has explicit annotations in source code\n+     * @param storageLocationToUpdate the storage location which will be updated\n+     * @param defLoc the location where the annotation will be added\n+     * @param ignoreIfAnnotated if true, don't update any type that is explicitly annotated in the\n+     *     source code\n+     */\n+    public void updateStorageLocationFromAtm(\n+            AnnotatedTypeMirror newATM,\n+            AnnotatedTypeMirror curATM,\n+            T storageLocationToUpdate,\n+            TypeUseLocation defLoc,\n+            boolean ignoreIfAnnotated);\n+\n+    /**\n+     * Writes the inferred results to a file. Ideally, it should be called at the end of the\n+     * type-checking process. In practice, it is called after each class, because we don't know\n+     * which class will be the last one in the type-checking process.\n+     *\n+     * @param outputFormat the file format in which to write the results\n+     * @param checker the checker from which this method is called, for naming stub files\n+     */\n+    public void writeResultsToFile(\n+            WholeProgramInference.OutputFormat outputFormat, BaseTypeChecker checker);\n+\n+    /**\n+     * Indicates that inferred annotations for the file at {@code path} have changed since last\n+     * written. This causes output files for {@code path} to be written out next time {@link\n+     * #writeResultsToFile} is called.\n+     *\n+     * @param path path to the file with annotations that have been modified\n+     */\n+    public void setFileModified(String path);\n+\n+    /**\n+     * Performs any preparation required for inference on Elements of a class. Should be called on", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI1NzAzMQ=="}, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0MDIyMjI0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToyNDo0NlrOImhKWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToyNDo0NlrOImhKWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI2MDEyMg==", "bodyText": "What actor would not add types?  I think you mean this class would not add it to trees, but I am not sure.  Please clarify.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577260122", "createdAt": "2021-02-17T01:24:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,421 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * After this visitor visits a tree, {@link #getTrees} returns all the trees that should match with\n+ * some JavaParser node Some trees shouldn't be matched with a JavaParser node because there isn't a\n+ * corresponding JavaParser node. These trees are excluded.\n+ *\n+ * <p>The primary purpose is to test the {@link JointJavacJavaParserVisitor} class when the\n+ * -AcheckJavaParserVisitor flag is used. That class traverses a javac tree and JavaParser AST\n+ * simultaneously, so the trees this class stores can be used to test if the entirety of the javac\n+ * tree was visited.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees = new HashSet<>();\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+        // inserted type has no corresponding javac tree. There is no way of knowing if the\n+        // inserted tree is synthetic or not. The only sound solution would be to not add types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4844ec65c5095b5764923e94aacabc9f9924ff2a"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0MDIyNTA4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToyNTo1OFrOImhMCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QwMToyNTo1OFrOImhMCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzI2MDU1NQ==", "bodyText": "This class does not do checks; rather, it collects.  Please update the comment.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577260555", "createdAt": "2021-02-17T01:25:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * After this visitor visits a tree, {@link #getTrees} returns all the trees that should match with\n+ * some JavaParser node. Some trees shouldn't be matched with a JavaParser node because there isn't\n+ * a corresponding JavaParser node. These trees are excluded.\n+ *\n+ * <p>The primary purpose is to test the {@link JointJavacJavaParserVisitor} class when the\n+ * -AcheckJavaParserVisitor flag is used. That class traverses a javac tree and JavaParser AST\n+ * simultaneously, so the trees this class stores can be used to test if the entirety of the javac\n+ * tree was visited.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees = new HashSet<>();\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+        // inserted type has no corresponding javac tree. There is no way of knowing if the\n+        // inserted tree is synthetic or not. The only sound solution would be to not add types\n+        // on the left hand side of an assignment. This would severely decrease the usefulness\n+        // of the -AcheckJavaParserVisitor check. Instead, we simply don't run the check at all", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcf4174619a804995e6ef5879c9f46fb2423f26"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDAyMTI0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxODozNToyMFrOInFJlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxODozNToyMFrOInFJlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg0OTc0OQ==", "bodyText": "Can you check whether it has a position?  For example:\nimport com.sun.tools.javac.util.Position;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\npublic static boolean isVarDecl(VariableTree varTree) {\n    return ((JCExpression)varTree.getType()).pos == Position.NOPOS;\n}", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577849749", "createdAt": "2021-02-17T18:35:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * After this visitor visits a tree, {@link #getTrees} returns all the trees that should match with\n+ * some JavaParser node. Some trees shouldn't be matched with a JavaParser node because there isn't\n+ * a corresponding JavaParser node. These trees are excluded.\n+ *\n+ * <p>The primary purpose is to test the {@link JointJavacJavaParserVisitor} class when the\n+ * -AcheckJavaParserVisitor flag is used. That class traverses a javac tree and JavaParser AST\n+ * simultaneously, so the trees this class stores can be used to test if the entirety of the javac\n+ * tree was visited.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees = new HashSet<>();\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+        // inserted type has no corresponding javac tree. There is no way of knowing if the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "389d1b798820469068c99ebdeb3945f2d0c61176"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDAyNjMzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxODozNjowM1rOInFNPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxODozNjowM1rOInFNPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg1MDY4Nw==", "bodyText": "Do you mean \"no corresponding JavaParser tree\"?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577850687", "createdAt": "2021-02-17T18:36:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/ajava/ExpectedTreesVisitor.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package org.checkerframework.framework.ajava;\n+\n+import com.github.javaparser.StaticJavaParser;\n+import com.github.javaparser.ast.type.ClassOrInterfaceType;\n+import com.github.javaparser.ast.type.VarType;\n+import com.github.javaparser.ast.visitor.VoidVisitorAdapter;\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.DoWhileLoopTree;\n+import com.sun.source.tree.ExpressionStatementTree;\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.ForLoopTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.IfTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.NewArrayTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.StatementTree;\n+import com.sun.source.tree.SwitchTree;\n+import com.sun.source.tree.SynchronizedTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.tree.WhileLoopTree;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * After this visitor visits a tree, {@link #getTrees} returns all the trees that should match with\n+ * some JavaParser node. Some trees shouldn't be matched with a JavaParser node because there isn't\n+ * a corresponding JavaParser node. These trees are excluded.\n+ *\n+ * <p>The primary purpose is to test the {@link JointJavacJavaParserVisitor} class when the\n+ * -AcheckJavaParserVisitor flag is used. That class traverses a javac tree and JavaParser AST\n+ * simultaneously, so the trees this class stores can be used to test if the entirety of the javac\n+ * tree was visited.\n+ */\n+public class ExpectedTreesVisitor extends TreeScannerWithDefaults {\n+    /** The set of trees that should be matched to a JavaParser node when visiting both. */\n+    private Set<Tree> trees = new HashSet<>();\n+\n+    /**\n+     * Returns the visited trees that should match to some JavaParser node.\n+     *\n+     * @return the visited trees that should match to some JavaParser node\n+     */\n+    public Set<Tree> getTrees() {\n+        return trees;\n+    }\n+\n+    /**\n+     * Records that {@code tree} should have a corresponding JavaParser node.\n+     *\n+     * @param tree the tree to record\n+     */\n+    @Override\n+    public void defaultAction(Tree tree) {\n+        trees.add(tree);\n+    }\n+\n+    @Override\n+    public Void visitCompilationUnit(CompilationUnitTree tree, Void p) {\n+        // When using the \"var\" keyword, javac replaces it with the correct type, meaning the\n+        // inserted type has no corresponding javac tree. There is no way of knowing if the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "389d1b798820469068c99ebdeb3945f2d0c61176"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI1Mjc4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozMDo0NFrOInHazA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozMDo0NFrOInHazA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4NjkyNA==", "bodyText": "Does \"a visitor\" specifically mean AjavaParserVisitor?  If possible, be specific.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577886924", "createdAt": "2021-02-17T19:30:44Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "diffHunk": "@@ -622,37 +696,55 @@ private void processPackage(PackageDeclaration packDecl) {\n     /**\n      * Process a type declaration: copy its annotations to {@code #annotationFileAnnos}.\n      *\n+     * <p>This method stores the declaration's type parameters in {@link #typeParameters}. When\n+     * processing an ajava file, where traversal is handled externaly by a visitor, these type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI2NDExOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozMzo1MVrOInHh_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozMzo1MVrOInHh_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4ODc2NA==", "bodyText": "From the documentation and the name of this class, I thought it was an abstract base class intended to be subclassed.  Can you be specific about what processing it does, and give it a better name?  This seems to do special processing for constructs that can declare type variables (classes, methods), but I'm not sure why it overrides visitVariable.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577888764", "createdAt": "2021-02-17T19:33:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/stub/AnnotationFileParser.java", "diffHunk": "@@ -2432,6 +2536,66 @@ private void stubDebug(String warning) {\n         }\n     }\n \n+    /**\n+     * Walks the javac tree for a file, processing the JavaParser node for each program element it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI3MDE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNTozMVrOInHlvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNTozMVrOInHlvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4OTcyNg==", "bodyText": "Should the documentation of these two fields mention that they only store public elements?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577889726", "createdAt": "2021-02-17T19:35:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -233,6 +243,16 @@\n     /** Parses stub files and stores annotations from stub files. */\n     public final AnnotationFileElementTypes stubTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI3MzcyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNjoyNVrOInHn8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNjoyNVrOInHn8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg5MDI5MQ==", "bodyText": "Should \"processing a file\" be \"processing an ajava file\"?  Or does this mean \"if the Checker Framework is type-checking a .java file, stores annotations read from an ajava file for that class, if one exists\"?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577890291", "createdAt": "2021-02-17T19:36:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -233,6 +243,16 @@\n     /** Parses stub files and stores annotations from stub files. */\n     public final AnnotationFileElementTypes stubTypes;\n \n+    /** Parses ajava files and stores annotations from ajava files. */\n+    public final AnnotationFileElementTypes ajavaTypes;\n+\n+    /**\n+     * If processing a file, stores any annotations read from an ajava file for that class. Unlike", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI3NjE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNzowOFrOInHphA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozNzowOFrOInHphA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg5MDY5Mg==", "bodyText": "Would it be cleaner to check the variable wpiOutputFormat here rather than calling getOption and String.equals?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577890692", "createdAt": "2021-02-17T19:37:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -480,13 +502,24 @@ public AnnotatedTypeFactory(BaseTypeChecker checker) {\n                 case \"jaifs\":\n                     wpiOutputFormat = WholeProgramInference.OutputFormat.JAIF;\n                     break;\n+                case \"ajava\":\n+                    wpiOutputFormat = WholeProgramInference.OutputFormat.AJAVA;\n+                    break;\n                 default:\n                     throw new UserError(\n                             \"Bad argument -Ainfer=\"\n                                     + inferArg\n                                     + \" should be one of: -Ainfer=jaifs, -Ainfer=stubs\");\n             }\n-            wholeProgramInference = new WholeProgramInferenceScenes(this);\n+            if (checker.getOption(\"infer\").equals(\"ajava\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDI4NTI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozOToxM1rOInHu3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTozOToxM1rOInHu3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg5MjA2Mw==", "bodyText": "At first I thought this comment was explaining when shouldCheckVisitor is true.  But it is actually talking about a different boolean value.  What is the relationship between them, and why are both needed?  That is, why can't shouldCheckeVisitor be set according to -AcheckJavaParserVisitor?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577892063", "createdAt": "2021-02-17T19:39:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -670,6 +703,58 @@ protected void initializeReflectionResolution() {\n      * @param root the new compilation unit to use\n      */\n     public void setRoot(@Nullable CompilationUnitTree root) {\n+        setRoot(root, /*shouldCheckVisitor=*/ true);\n+    }\n+\n+    /**\n+     * Set the CompilationUnitTree that should be used.\n+     *\n+     * @param root the new compilation unit to use\n+     * @param shouldCheckVisitor if true, run the visitor that verifies that the javac tree can be\n+     *     visited with its corresponding JavaParser AST. The check only occurs if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDMxOTcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTo0Nzo0NFrOInIDSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOTo0Nzo0NFrOInIDSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg5NzI4OQ==", "bodyText": "This code block appears identically 3 times.  Please abstract it out into a method.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r577897289", "createdAt": "2021-02-17T19:47:44Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3562,6 +3703,34 @@ private AnnotationMirror getDeclAnnotation(\n             }\n         }\n \n+        if (!ajavaTypes.isParsing()) {\n+\n+            // Retrieving annotations from ajava files.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71259ff4a2e91a378b8b001d24b3b95f9d1d955e"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4Mjk1MjAzOnYy", "diffSide": "RIGHT", "path": "docs/manual/annotating-libraries.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1MDowN1rOIsxJFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1MDowN1rOIsxJFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzgxMzM5OA==", "bodyText": "How do you know if an ajava file is also source code? Do their names match? Or is it there contentes?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583813398", "createdAt": "2021-02-26T17:50:07Z", "author": {"login": "smillst"}, "path": "docs/manual/annotating-libraries.tex", "diffHunk": "@@ -844,6 +844,58 @@\n in the version of the library you are using.\n \n \n+\\sectionAndLabel{Ajava Files}{ajava-files}\n+\n+Like stub files, ajava files store annotations that can be read by the\n+Checker Framework.  Ajava files are mostly used as\n+the output of whole program inference and not for annotating libraries.\n+\n+\n+\\subsectionAndLabel{Using an Ajava File}{ajava-using}\n+\n+The \\code{-Aajava} command-line argument works like \\code{-Astubs} (see\n+Section~\\ref{stub-using}). It takes a colon-separated list of\n+files and directories containing ajava files, which end in the \\code{.ajava}\n+extension.\n+\n+For example:\n+\n+\\begin{myxsmall}\n+\\begin{Verbatim}\n+  javac -processor org.checkerframework.checker.interning.InterningChecker \\\n+    -Aajava=path/to/String.ajava:ajavadir MyFile.java MyOtherFile.java ...\n+\\end{Verbatim}\n+\\end{myxsmall}\n+\n+\n+\\subsectionAndLabel{Contents of an Ajava file}{ajava-contents}\n+\n+An ajava file must contain valid Java source code. Annotations in that code are\n+read. When reading an ajava file for a file that also exists as source code, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4Mjk2Nzc1OnYy", "diffSide": "RIGHT", "path": "docs/manual/annotating-libraries.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1NDozMlrOIsxTZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1NDozMlrOIsxTZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzgxNjAzOA==", "bodyText": "What about replacing this paragraph with:\nAjava files are valid Java source files whose annotations can be read and used by the Checker Framework.  They are similar to stub files, but annotations in anonymous  and local classes are also read and used.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583816038", "createdAt": "2021-02-26T17:54:32Z", "author": {"login": "smillst"}, "path": "docs/manual/annotating-libraries.tex", "diffHunk": "@@ -844,6 +844,58 @@\n in the version of the library you are using.\n \n \n+\\sectionAndLabel{Ajava Files}{ajava-files}\n+\n+Like stub files, ajava files store annotations that can be read by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4Mjk3Mjk5OnYy", "diffSide": "RIGHT", "path": "docs/manual/annotating-libraries.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1NTo0OFrOIsxWcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQxNzo1NTo0OFrOIsxWcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzgxNjgxNw==", "bodyText": "myMethod() looks like a method call.  It should be void myMethod()", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583816817", "createdAt": "2021-02-26T17:55:48Z", "author": {"login": "smillst"}, "path": "docs/manual/annotating-libraries.tex", "diffHunk": "@@ -844,6 +844,58 @@\n in the version of the library you are using.\n \n \n+\\sectionAndLabel{Ajava Files}{ajava-files}\n+\n+Like stub files, ajava files store annotations that can be read by the\n+Checker Framework.  Ajava files are mostly used as\n+the output of whole program inference and not for annotating libraries.\n+\n+\n+\\subsectionAndLabel{Using an Ajava File}{ajava-using}\n+\n+The \\code{-Aajava} command-line argument works like \\code{-Astubs} (see\n+Section~\\ref{stub-using}). It takes a colon-separated list of\n+files and directories containing ajava files, which end in the \\code{.ajava}\n+extension.\n+\n+For example:\n+\n+\\begin{myxsmall}\n+\\begin{Verbatim}\n+  javac -processor org.checkerframework.checker.interning.InterningChecker \\\n+    -Aajava=path/to/String.ajava:ajavadir MyFile.java MyOtherFile.java ...\n+\\end{Verbatim}\n+\\end{myxsmall}\n+\n+\n+\\subsectionAndLabel{Contents of an Ajava file}{ajava-contents}\n+\n+An ajava file must contain valid Java source code. Annotations in that code are\n+read. When reading an ajava file for a file that also exists as source code, the\n+ajava file and source file must match exactly with the following exceptions:\n+\\begin{itemize}\n+  \\item The two may differ in annotations.\n+  \\item The ajava file may have explicit receivers where the source file\n+    doesn't. If a source file has a method declaration \\code{myMethod()},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4MzQ4NTIzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDoyNDoyMFrOIs2RlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDoyNDoyMFrOIs2RlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzg5NzQ5Mw==", "bodyText": "The information in this comment belongs in the manual.  (The comment can stay here, too.)", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583897493", "createdAt": "2021-02-26T20:24:20Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -693,6 +781,49 @@ public void setRoot(@Nullable CompilationUnitTree root) {\n             // contents won't change between compilation units.\n             // elementCache.clear();\n         }\n+\n+        if (root != null && checker.hasOption(\"ajava\")) {\n+            // Search for an ajava file with annotations for the current source file and the current\n+            // checker. It will be in the directory specified by the \"ajava\" option in a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4MzUwNTg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMDozN1rOIs2eCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMDozN1rOIs2eCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkwMDY4MA==", "bodyText": "This method needs to be renamed and the documentation update to include ajava files.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583900680", "createdAt": "2021-02-26T20:30:37Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3427,6 +3574,7 @@ private static final boolean validType(TypeMirror type) {\n      */\n     protected void parseStubFiles() {\n         stubTypes.parseStubFiles();\n+        ajavaTypes.parseAjavaFiles();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4MzUwOTY1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMTo0MFrOIs2gQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMTo0MFrOIs2gQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkwMTI0OQ==", "bodyText": "The Javadoc here is out-of-date.  This method works for types from stub files and ajava files. It should be renamed, too.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583901249", "createdAt": "2021-02-26T20:31:40Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -1300,11 +1446,12 @@ private AnnotatedTypeMirror mergeStubsIntoType(@Nullable AnnotatedTypeMirror typ\n      *\n      * @param type the type to apply stub types to\n      * @param elt the element from which to read stub types\n+     * @param source storage for current annotation file annotations\n      * @return the type, side-effected to add the stub types\n      */\n     protected AnnotatedTypeMirror mergeStubsIntoType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4MzUxMTk1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMjoxOVrOIs2hlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozMjoxOVrOIs2hlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkwMTU4OQ==", "bodyText": "The Javadoc here is out-of-date.  This method works for types from stub files and ajava files. It should be renamed, too.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583901589", "createdAt": "2021-02-26T20:32:19Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -1287,11 +1431,13 @@ private final AnnotatedTypeMirror fromMember(Tree tree) {\n      *\n      * @param type the type to apply annotation file types to\n      * @param tree the tree from which to read annotation file types\n+     * @param source storage for current annotation file annotations\n      * @return the given type, side-effected to add the annotation file types\n      */\n-    private AnnotatedTypeMirror mergeStubsIntoType(@Nullable AnnotatedTypeMirror type, Tree tree) {\n+    private AnnotatedTypeMirror mergeStubsIntoType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4MzUyODk5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozNzozOVrOIs2r5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMDozNzozOVrOIs2r5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzkwNDIzMA==", "bodyText": "The Javadoc of fromMember needs to be updated.  The returned types also contain annotation explicitly written in ajava or stub files.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583904230", "createdAt": "2021-02-26T20:37:39Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -1264,11 +1403,16 @@ private final AnnotatedTypeMirror fromMember(Tree tree) {\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5cbcb7fe279ed15f3e1a81bf6e33818969ac37"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY4Mzg4MzQ0OnYy", "diffSide": "RIGHT", "path": "docs/manual/annotating-libraries.tex", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMjoyNjoxMlrOIs5-fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNlQyMjozMDoxOVrOIs6Hiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk1ODE0Mg==", "bodyText": "Should  https://checkerframework.org/manual/#whole-program-inference be updated to reference the new file format?", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583958142", "createdAt": "2021-02-26T22:26:12Z", "author": {"login": "smillst"}, "path": "docs/manual/annotating-libraries.tex", "diffHunk": "@@ -844,6 +844,69 @@\n in the version of the library you are using.\n \n \n+\\sectionAndLabel{Ajava Files}{ajava-files}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9a4c7fd55483b5d6a7b1b62a2251ad6d2cb94ff"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk2MDQ1OQ==", "bodyText": "Currently, the wpi.sh and wpi-many.sh scripts only support stub files. It should be easy to update them to use ajava files, but that can be done separately after this pull request.", "url": "https://github.com/typetools/checker-framework/pull/3977#discussion_r583960459", "createdAt": "2021-02-26T22:30:19Z", "author": {"login": "jwaataja"}, "path": "docs/manual/annotating-libraries.tex", "diffHunk": "@@ -844,6 +844,69 @@\n in the version of the library you are using.\n \n \n+\\sectionAndLabel{Ajava Files}{ajava-files}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mzk1ODE0Mg=="}, "originalCommit": {"oid": "d9a4c7fd55483b5d6a7b1b62a2251ad6d2cb94ff"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 847, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}