{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5MDAxMzYw", "number": 4014, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0NTowOFrOFFQTsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNTowOFrOFH9-1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDU0Mzg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/SceneToStubWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0NTowOFrOIFrmTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDowNjoxOVrOIGdz9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyODEwOQ==", "bodyText": "You could pass the AnnotatedTypeFactory instead of the checker.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542828109", "createdAt": "2020-12-14T21:45:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/SceneToStubWriter.java", "diffHunk": "@@ -706,7 +723,11 @@ private static void printClass(\n             printWriter.println();\n             for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n                 printMethodDeclaration(\n-                        methodEntry.getValue(), innermostClassname, printWriter, indentLevel);\n+                        methodEntry.getValue(),\n+                        innermostClassname,\n+                        printWriter,\n+                        indentLevel,\n+                        checker.getTypeFactory());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MDgwNQ==", "bodyText": "This does pass the AnnotatedTypeFactory.\nAre you suggesting that the containing method printClass could have its formal parameter list changed, so it takes an AnnotatedTypeFactory rather than a checker?  The changes in #4025 require the checker rather than the type factory.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543650805", "createdAt": "2020-12-15T20:06:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/SceneToStubWriter.java", "diffHunk": "@@ -706,7 +723,11 @@ private static void printClass(\n             printWriter.println();\n             for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n                 printMethodDeclaration(\n-                        methodEntry.getValue(), innermostClassname, printWriter, indentLevel);\n+                        methodEntry.getValue(),\n+                        innermostClassname,\n+                        printWriter,\n+                        indentLevel,\n+                        checker.getTypeFactory());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyODEwOQ=="}, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDU1MTk1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenesStorage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0NjoyOFrOIFrriA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo0NjoyOFrOIFrriA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyOTQ0OA==", "bodyText": "You added a formal parameter, so is this fixed?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542829448", "createdAt": "2020-12-14T21:46:28Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenesStorage.java", "diffHunk": "@@ -488,8 +494,10 @@ private void updateTypeElementFromATM(\n             typeToUpdate.tlAnnotationsHere.removeAll(annosToRemove);\n         }\n \n+        // PROBLEM:  This causes pre- and post-conditions to be ignored, though they might be\n+        // stronger.  Add a formal parameter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDU5MTIxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMTo1MjoxOFrOIFsDwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQyMTo0NToyMlrOIIzpFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzNTY1MA==", "bodyText": "Instead of passing in the checker, could you add the contracts to the AMethod before writing out the scene, reusing the code below?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542835650", "createdAt": "2020-12-14T21:52:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -144,9 +150,23 @@ public void writeToFile(\n             try {\n                 switch (outputFormat) {\n                     case STUB:\n-                        SceneToStubWriter.write(this, filepath);\n+                        SceneToStubWriter.write(this, filepath, checker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwNTYyMg==", "bodyText": "The checker is still needed for @AnnotatedFor annotations, but I can use the same code to compute the contracts in both places.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546105622", "createdAt": "2020-12-18T21:45:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -144,9 +150,23 @@ public void writeToFile(\n             try {\n                 switch (outputFormat) {\n                     case STUB:\n-                        SceneToStubWriter.write(this, filepath);\n+                        SceneToStubWriter.write(this, filepath, checker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzNTY1MA=="}, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTY0NjUxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODoyOTowOFrOIGZx7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODoyOTowOFrOIGZx7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NDc0OQ==", "bodyText": "This checks if the field is declared in the current class, but it doesn't make sure that the receiver of the field access is this.  (For static fields, you don't have to check.)", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543584749", "createdAt": "2020-12-15T18:29:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTY1NjAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozMToyMFrOIGZ3kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozMToyMFrOIGZ3kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NjE5NA==", "bodyText": "Instead of looping through all the field accesses in the store above, could you just add an else branch here that does the same thing as the code above?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543586194", "createdAt": "2020-12-15T18:31:20Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {\n+                continue;\n+            }\n+\n+            AnnotatedTypeMirror atm = convertCFAbstractValueToAnnotatedTypeMirror(v, fieldType);\n+            adjustForUpdateNonField(atm);\n+\n+            AField afield = vivifyAndAddTypeMirrorToContract(amethod, preOrPost, fieldElement);\n+\n+            updateAnnotationSetInScene(\n+                    afield.type, TypeUseLocation.FIELD, atm, fieldType, jaifPath, false);\n+        }\n+\n+        // Process fields that are not in the store.\n+        TypeElement containingClass = (TypeElement) methodElt.getEnclosingElement();\n+        ThisReference thisReference = new ThisReference(containingClass.asType());\n+        ClassName classNameReceiver = new ClassName(containingClass.asType());\n+        for (VariableElement fieldElement :\n+                ElementFilter.fieldsIn(containingClass.getEnclosedElements())) {\n+            FieldAccess fa =\n+                    new FieldAccess(\n+                            (ElementUtils.isStatic(fieldElement)\n+                                    ? classNameReceiver\n+                                    : thisReference),\n+                            fieldElement.asType(),\n+                            fieldElement);\n+            if (store.getFieldValue(fa) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTY4Mjg3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozNzoyN1rOIGaHIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozNzoyN1rOIGaHIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDE3Ng==", "bodyText": "It's not clear what \"all the below\" is referring to.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590176", "createdAt": "2020-12-15T18:37:27Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTY4NjQ0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozODoxOFrOIGaJQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODozODoxOFrOIGaJQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDcyMQ==", "bodyText": "I think this is done? Or should precondition be postcondition?", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590721", "createdAt": "2020-12-15T18:38:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.\n+\n+    /**\n+     * Return the string representation of postcondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        return result;\n+    }\n+\n+    // TODO: Implement this here in this class, reading @PreconditionAnnotation meta-annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTcxMTQyOnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo0MzozMlrOIGaYeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxODo0MzozMlrOIGaYeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDYxNw==", "bodyText": "There's another version of this method org.checkerframework.javacutil.TypeAnnotationUtils#unannotatedType.  It makes more sense to have this method in TypesUtils.  Or at least that's where I always look for it first.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543594617", "createdAt": "2020-12-15T18:43:32Z", "author": {"login": "smillst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -893,4 +894,24 @@ public static TypeMirror substitute(\n                 com.sun.tools.javac.util.List.from(newP),\n                 com.sun.tools.javac.util.List.from(newT));\n     }\n+\n+    // This method is necessary because Type.stripMetadata does no work for primitive types.\n+    /**\n+     * Returns a copy of a type without annotations. May return tm itself if it has no annotations.\n+     *\n+     * @param tm a TypeMirror\n+     * @return a copy of the given type without annotations\n+     */\n+    public static TypeMirror unannotatedType(TypeMirror tm) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk2Nzg0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoxOToyOVrOIJpCBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxNDozNjoyMFrOIJ9SIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDM1OQ==", "bodyText": "I think we avoid statically importing methods/fields.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980359", "createdAt": "2020-12-21T23:19:29Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -1,19 +1,24 @@\n package org.checkerframework.common.wholeprograminference.scenelib;\n \n+import static org.plumelib.util.CollectionsPlume.mapList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxMjE2MQ==", "bodyText": "If this is not statically imported, then the call is little shorter than the verbose stream version.  I propose to make an exception for this method.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r547312161", "createdAt": "2020-12-22T14:36:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -1,19 +1,24 @@\n package org.checkerframework.common.wholeprograminference.scenelib;\n \n+import static org.plumelib.util.CollectionsPlume.mapList;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDM1OQ=="}, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk2OTk4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoyMDozOFrOIJpDWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoyMDozOFrOIJpDWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDY5OQ==", "bodyText": "This for loop is now duplicated above.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980699", "createdAt": "2020-12-21T23:20:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -139,14 +144,48 @@ public void writeToFile(\n                 throw new BugInCF(\"Unhandled outputFormat \" + outputFormat);\n         }\n         new File(filepath).delete();\n+        // Only write non-empty scenes into files.\n         if (!scene.isEmpty()) {\n-            // Only write non-empty scenes into files.\n             try {\n+                for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {\n+                    AClass aClass = classEntry.getValue();\n+                    for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n+                        AMethod aMethod = methodEntry.getValue();\n+                        List<AnnotationMirror> contractAnnotationMirrors =\n+                                checker.getTypeFactory().getContractAnnotations(aMethod);\n+                        List<Annotation> contractAnnotations =\n+                                mapList(\n+                                        AnnotationConverter::annotationMirrorToAnnotation,\n+                                        contractAnnotationMirrors);\n+                        aMethod.contracts = contractAnnotations;\n+                    }\n+                }\n+\n                 switch (outputFormat) {\n                     case STUB:\n+                        // For stub files, pass in the checker to compute contracts on the fly;\n+                        // precomputing yields incorrect annotations, most likely due to nested\n+                        // classes.\n                         SceneToStubWriter.write(this, filepath, checker);\n                         break;\n                     case JAIF:\n+                        // For .jaif files, precompute contracts because the Annotation File\n+                        // Utilities knows nothing about (and cannot depend on) the Checker\n+                        // Framework.\n+                        for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk4MDA2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoyNTo1NlrOIJpJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzoyNTo1NlrOIJpJOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MjIwMA==", "bodyText": "More static imports.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546982200", "createdAt": "2020-12-21T23:25:56Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1,5 +1,9 @@\n package org.checkerframework.framework.type;\n \n+import static org.checkerframework.dataflow.analysis.Analysis.BeforeOrAfter.AFTER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk5NjcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDowNFrOIJpSiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDowNFrOIJpSiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDU4NQ==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984585", "createdAt": "2020-12-21T23:34:04Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk5NzkwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDozOVrOIJpTMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDozOVrOIJpTMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDc1Mw==", "bodyText": "This can be replaced with result.sort(Ordering.usingToString()); if you like.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984753", "createdAt": "2020-12-21T23:34:39Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk5ODI0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDo1OVrOIJpTbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNDo1OVrOIJpTbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDgxNQ==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984815", "createdAt": "2020-12-21T23:34:59Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzODk5ODYxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNTowOFrOIJpTpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMzozNTowOFrOIJpTpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDg3MA==", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984870", "createdAt": "2020-12-21T23:35:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(\n+            VariableElement elt, AField f, List<AnnotationMirror> preconds) {\n+        return getPreOrPostconditionAnnotation(elt, f, AFTER, preconds);\n+    }\n+\n+    /**\n+     * Helper method for {@link #getPreconditionAnnotation} and {@link #getPostconditionAnnotation}.\n+     *\n+     * <p>Returns an {@code @EnsuresQualifier} or {@code @EnsuresQualifier} annotation for the given\n+     * field. Returns null if none can be created, because the qualifier has elements/arguments,\n+     * which {@code @EnsuresQualifier} and {@code @RequiresQualifier} do not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preOrPost whether to return preconditions or postconditions\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions; non-null exactly when {@code preOrPost} is {@code AFTER}\n+     * @return a postcondition annotation for the element, or null if none is appropriate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7c8699a9b41fea3716994d8339837978502c254"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 857, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}