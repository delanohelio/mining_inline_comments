{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NzQyNDY1", "number": 3583, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MToxMFrOEXYJHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1NDozNVrOEXYNYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTQ4MjUyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MToxMFrOG_IxUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MToxMFrOG_IxUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzE2OQ==", "bodyText": "\"For example\" sounds like it is following up on a previous point, but I think here it might be introducing a new point.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857169", "createdAt": "2020-08-11T20:51:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTQ4NTE1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MjowMVrOG_IzCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1MjowMVrOG_IzCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1NzYwOA==", "bodyText": "Are they stored on the same node (that is, both are stored on the node for Inner)?  If so, I would say that.  If not, the fact that they apply to different types may not be so surprising.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857608", "createdAt": "2020-08-11T20:52:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTQ4NzI4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1Mjo0MVrOG_I0YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1Mjo0MVrOG_I0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1Nzk1Mw==", "bodyText": "I don't understand why this comment is attached to the curly brace rather than on a separate line.  Can you clarify why?", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468857953", "createdAt": "2020-08-11T20:52:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/TypeFromMemberVisitor.java", "diffHunk": "@@ -26,17 +30,52 @@\n \n     @Override\n     public AnnotatedTypeMirror visitVariable(VariableTree node, AnnotatedTypeFactory f) {\n+        Element elt = TreeUtils.elementFromDeclaration(node);\n+\n         // Create the ATM and add non-primary annotations\n-        // (node.getType() does not include primary annotations, those are in\n-        // node.getModifier()\n+        // (node.getType() does not include the annotation before the type, so those\n+        // are added to the type below).\n         AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(f, node.getType());\n \n-        // Add primary annotations\n+        // Handle any annotations in node.getModifiers().\n+        List<AnnotationMirror> modifierAnnos;\n         List<? extends AnnotationTree> annoTrees = node.getModifiers().getAnnotations();\n         if (annoTrees != null && !annoTrees.isEmpty()) {\n-            List<AnnotationMirror> annos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+            modifierAnnos = TreeUtils.annotationsFromTypeAnnotationTrees(annoTrees);\n+        } else {\n+            modifierAnnos = new ArrayList<>();\n+        }\n+\n+        if (result.getKind() == TypeKind.DECLARED\n+                &&\n+                // Annotations on enum constants are not in the TypeMirror and always apply to the\n+                // innermost type, so handle them in the else block.\n+                elt.getKind() != ElementKind.ENUM_CONSTANT) {\n+\n+            // Decode the annotations from the type mirror because the annotations are already in\n+            // the correct place for enclosing types. For example, @Tainted Outer.Inner and @Tainted\n+            // Inner. For both types @Tainted is stored in node.getModifiers(), but they apply to\n+            // different types.\n+            AnnotatedDeclaredType annotatedDeclaredType = (AnnotatedDeclaredType) result;\n+            // The underlying type of result does not have all annotations, but the TypeMirror of\n+            // node.getType() does.\n+            DeclaredType declaredType = (DeclaredType) TreeUtils.typeOf(node.getType());\n+            AnnotatedTypes.applyAnnotationsFromDeclaredType(annotatedDeclaredType, declaredType);\n+\n+            // Handle declaration annotations\n+            for (AnnotationMirror anno : modifierAnnos) {\n+                if (AnnotationUtils.isDeclarationAnnotation(anno)) {\n+                    // This does not treat Checker Framework compatqual annotations differently,\n+                    // because it's not clear whether the annotation should apply to the outermost\n+                    // enclosing type or the innermost.\n+                    result.addAnnotation(anno);\n+                } // If anno is not a declaration annotation, it should have been applied in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTQ5MzQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1NDozNVrOG_I4YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo1NDozNVrOG_I4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1ODk3Ng==", "bodyText": "Maybe state explictly that this includes both declaration and type annotations.", "url": "https://github.com/typetools/checker-framework/pull/3583#discussion_r468858976", "createdAt": "2020-08-11T20:54:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -1444,4 +1445,25 @@ public static void copyOnlyExplicitConstructorAnnotations(\n             }\n         }\n     }\n+\n+    /**\n+     * Add all the annotations in {@code declaredType} to {@code annotatedDeclaredType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff082138822dbf5f4da04c8b41bf0c5ce23b4260"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1000, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}