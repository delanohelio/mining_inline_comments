{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MDcwNzcy", "number": 3927, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNToyMFrOE8e8tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzowMjoxM1rOE8-x_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODU3MDc5OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNToyMFrOH4oRKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjo0MDoxOVrOH4pkDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0MjA1OQ==", "bodyText": "I don't see an invocation of this method and no other read access of the field. I must be missing something.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529142059", "createdAt": "2020-11-24T02:15:20Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "diffHunk": "@@ -76,6 +96,28 @@ public TreePath getTreePath() {\n         return treePath;\n     }\n \n+    /**\n+     * If this MethodInvocationNode is a node for an {@link Iterator#next()} desugared from an\n+     * enhanced for loop, then return the expression in the for loop, e.g., {@code iter} in {@code\n+     * for(Object o: iter}. Otherwise, return null.\n+     *\n+     * @return the iter expression, or null if this is not a {@link Iterator#next()} from an\n+     *     enhanced for loop\n+     */\n+    public @Nullable ExpressionTree getIterExpression() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c669a57caf71e1298cfaff417e7ce5788126def9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2MzI3OA==", "bodyText": "I failed to copy those files changes to this PR.  I've done so now, thanks for pointing this out!", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529163278", "createdAt": "2020-11-24T02:40:19Z", "author": {"login": "smillst"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "diffHunk": "@@ -76,6 +96,28 @@ public TreePath getTreePath() {\n         return treePath;\n     }\n \n+    /**\n+     * If this MethodInvocationNode is a node for an {@link Iterator#next()} desugared from an\n+     * enhanced for loop, then return the expression in the for loop, e.g., {@code iter} in {@code\n+     * for(Object o: iter}. Otherwise, return null.\n+     *\n+     * @return the iter expression, or null if this is not a {@link Iterator#next()} from an\n+     *     enhanced for loop\n+     */\n+    public @Nullable ExpressionTree getIterExpression() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0MjA1OQ=="}, "originalCommit": {"oid": "c669a57caf71e1298cfaff417e7ce5788126def9"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODU3NDEwOnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNjowMlrOH4oTnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNjowMlrOH4oTnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0MjY4NQ==", "bodyText": "I would expand the Iter part to make clear it stands for Iterator.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529142685", "createdAt": "2020-11-24T02:16:02Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "diffHunk": "@@ -76,6 +96,28 @@ public TreePath getTreePath() {\n         return treePath;\n     }\n \n+    /**\n+     * If this MethodInvocationNode is a node for an {@link Iterator#next()} desugared from an\n+     * enhanced for loop, then return the expression in the for loop, e.g., {@code iter} in {@code\n+     * for(Object o: iter}. Otherwise, return null.\n+     *\n+     * @return the iter expression, or null if this is not a {@link Iterator#next()} from an\n+     *     enhanced for loop\n+     */\n+    public @Nullable ExpressionTree getIterExpression() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c669a57caf71e1298cfaff417e7ce5788126def9"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODU3ODc0OnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/builder/CFGTranslationPhaseOne.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNjo1NFrOH4oXDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMjoxNjo1NFrOH4oXDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE0MzU2NQ==", "bodyText": "Can you add a comment why this second call is necessary? I would have expected the expression to be equal to nextCallNode, on which setIterExpression was already called.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529143565", "createdAt": "2020-11-24T02:16:54Z", "author": {"login": "wmdietl"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/builder/CFGTranslationPhaseOne.java", "diffHunk": "@@ -2426,10 +2426,16 @@ public Node visitEnhancedForLoop(EnhancedForLoopTree tree, Void p) {\n             MethodInvocationNode nextCallNode =\n                     new MethodInvocationNode(\n                             nextCall, nextAccessNode, Collections.emptyList(), getCurrentPath());\n+            // If the type of iteratorVariable is a capture, its type tree may be missing\n+            // annotations, so save the expression in the node so that the full type can be found\n+            // later.\n+            nextCallNode.setIterExpression(expression);\n             nextCallNode.setInSource(false);\n             extendWithNode(nextCallNode);\n \n-            translateAssignment(variable, new LocalVariableNode(variable), nextCall);\n+            AssignmentNode assignNode =\n+                    translateAssignment(variable, new LocalVariableNode(variable), nextCall);\n+            ((MethodInvocationNode) assignNode.getExpression()).setIterExpression(expression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c669a57caf71e1298cfaff417e7ce5788126def9"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzExOTMyOnYy", "diffSide": "LEFT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDo1Mjo0MFrOH5UuaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMDo1Mjo0MFrOH5UuaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3MDQ0MA==", "bodyText": "AnnotatedTypes.getIteratedType is not longer called.  The Checker Framework still compiles if I delete it.  I think it should be removed.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529870440", "createdAt": "2020-11-24T20:52:40Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -1393,10 +1393,7 @@ public Void visitAssignment(AssignmentTree node, Void p) {\n     @Override\n     public Void visitEnhancedForLoop(EnhancedForLoopTree node, Void p) {\n         AnnotatedTypeMirror var = atypeFactory.getAnnotatedTypeLhs(node.getVariable());\n-        AnnotatedTypeMirror iterableType = atypeFactory.getAnnotatedType(node.getExpression());\n-        AnnotatedTypeMirror iteratedType =\n-                AnnotatedTypes.getIteratedType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1d2db9da072d579d4ee91e40c4d923f6580cc38"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE2NzYxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNjo1MlrOH5VLNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNjo1MlrOH5VLNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NzgxMw==", "bodyText": "I realize the terminology existed before this pull request, but I find \"iterated type\" confusing because it's new, nonstandard jargon.  Consider renaming the methods, such as to getIteratorElementType.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529877813", "createdAt": "2020-11-24T21:06:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratedType(ExpressionTree expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE2OTk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNzozM1rOH5VMkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowNzozM1rOH5VMkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3ODE2Mw==", "bodyText": "It pains me to see this re-computed on every call.  I would save it in a field.  Can you do that with iterableElmType too?", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529878163", "createdAt": "2020-11-24T21:07:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratedType(ExpressionTree expression) {\n+        return getIteratedType(expression, getAnnotatedType(expression));\n+    }\n+\n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @param iterableType the type of the expression\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    protected AnnotatedTypeMirror getIteratedType(\n+            ExpressionTree expression, AnnotatedTypeMirror iterableType) {\n+        switch (iterableType.getKind()) {\n+            case ARRAY:\n+                return ((AnnotatedArrayType) iterableType).getComponentType();\n+            case WILDCARD:\n+                return getIteratedType(\n+                        expression,\n+                        ((AnnotatedWildcardType) iterableType).getExtendsBound().deepCopy());\n+            case TYPEVAR:\n+                return getIteratedType(\n+                        expression, ((AnnotatedTypeVariable) iterableType).getUpperBound());\n+            case DECLARED:\n+                TypeElement iterableElement =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzE3NDMzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTowODo1N1rOH5VPRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozOTozOVrOH5WNbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3ODg1NQ==", "bodyText": "Please add a test case and reference that test case from this comment.  Or, if the comment is obviated by other changes such as the addition of the MethodInvocationNode.iteratorExpression field, delete the comment.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529878855", "createdAt": "2020-11-24T21:08:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratedType(ExpressionTree expression) {\n+        return getIteratedType(expression, getAnnotatedType(expression));\n+    }\n+\n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @param iterableType the type of the expression\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    protected AnnotatedTypeMirror getIteratedType(\n+            ExpressionTree expression, AnnotatedTypeMirror iterableType) {\n+        switch (iterableType.getKind()) {\n+            case ARRAY:\n+                return ((AnnotatedArrayType) iterableType).getComponentType();\n+            case WILDCARD:\n+                return getIteratedType(\n+                        expression,\n+                        ((AnnotatedWildcardType) iterableType).getExtendsBound().deepCopy());\n+            case TYPEVAR:\n+                return getIteratedType(\n+                        expression, ((AnnotatedTypeVariable) iterableType).getUpperBound());\n+            case DECLARED:\n+                TypeElement iterableElement =\n+                        ElementUtils.getTypeElement(processingEnv, Iterable.class);\n+                AnnotatedDeclaredType iterableElmType = getAnnotatedType(iterableElement);\n+                AnnotatedDeclaredType dt =\n+                        AnnotatedTypes.asSuper(this, iterableType, iterableElmType);\n+                if (dt.getTypeArguments().isEmpty()) {\n+                    TypeElement e = ElementUtils.getTypeElement(processingEnv, Object.class);\n+                    return getAnnotatedType(e);\n+                } else {\n+                    return dt.getTypeArguments().get(0);\n+                }\n+\n+                // TODO: Properly desugar Iterator.next(). The below doesn't work because", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NDQ5MQ==", "bodyText": "This code is only need if an annotated JDK has annotations on Iterator#next. None of our current checkers have such an annotation, so I can't added a test case for any of the current checkers.  Do you want me to add a test checker that has such an annotation?", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529884491", "createdAt": "2020-11-24T21:19:29Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratedType(ExpressionTree expression) {\n+        return getIteratedType(expression, getAnnotatedType(expression));\n+    }\n+\n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @param iterableType the type of the expression\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    protected AnnotatedTypeMirror getIteratedType(\n+            ExpressionTree expression, AnnotatedTypeMirror iterableType) {\n+        switch (iterableType.getKind()) {\n+            case ARRAY:\n+                return ((AnnotatedArrayType) iterableType).getComponentType();\n+            case WILDCARD:\n+                return getIteratedType(\n+                        expression,\n+                        ((AnnotatedWildcardType) iterableType).getExtendsBound().deepCopy());\n+            case TYPEVAR:\n+                return getIteratedType(\n+                        expression, ((AnnotatedTypeVariable) iterableType).getUpperBound());\n+            case DECLARED:\n+                TypeElement iterableElement =\n+                        ElementUtils.getTypeElement(processingEnv, Iterable.class);\n+                AnnotatedDeclaredType iterableElmType = getAnnotatedType(iterableElement);\n+                AnnotatedDeclaredType dt =\n+                        AnnotatedTypes.asSuper(this, iterableType, iterableElmType);\n+                if (dt.getTypeArguments().isEmpty()) {\n+                    TypeElement e = ElementUtils.getTypeElement(processingEnv, Object.class);\n+                    return getAnnotatedType(e);\n+                } else {\n+                    return dt.getTypeArguments().get(0);\n+                }\n+\n+                // TODO: Properly desugar Iterator.next(). The below doesn't work because", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3ODg1NQ=="}, "originalCommit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDc2Nw==", "bodyText": "Thanks for the clarification.  I think it's enough to add a comment explaining what you said here:\n\nThis code is only need if an annotated JDK has annotations on Iterator#next.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529894767", "createdAt": "2020-11-24T21:39:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratedType(ExpressionTree expression) {\n+        return getIteratedType(expression, getAnnotatedType(expression));\n+    }\n+\n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @param iterableType the type of the expression\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    protected AnnotatedTypeMirror getIteratedType(\n+            ExpressionTree expression, AnnotatedTypeMirror iterableType) {\n+        switch (iterableType.getKind()) {\n+            case ARRAY:\n+                return ((AnnotatedArrayType) iterableType).getComponentType();\n+            case WILDCARD:\n+                return getIteratedType(\n+                        expression,\n+                        ((AnnotatedWildcardType) iterableType).getExtendsBound().deepCopy());\n+            case TYPEVAR:\n+                return getIteratedType(\n+                        expression, ((AnnotatedTypeVariable) iterableType).getUpperBound());\n+            case DECLARED:\n+                TypeElement iterableElement =\n+                        ElementUtils.getTypeElement(processingEnv, Iterable.class);\n+                AnnotatedDeclaredType iterableElmType = getAnnotatedType(iterableElement);\n+                AnnotatedDeclaredType dt =\n+                        AnnotatedTypes.asSuper(this, iterableType, iterableElmType);\n+                if (dt.getTypeArguments().isEmpty()) {\n+                    TypeElement e = ElementUtils.getTypeElement(processingEnv, Object.class);\n+                    return getAnnotatedType(e);\n+                } else {\n+                    return dt.getTypeArguments().get(0);\n+                }\n+\n+                // TODO: Properly desugar Iterator.next(). The below doesn't work because", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3ODg1NQ=="}, "originalCommit": {"oid": "e346b8bf3c6cfe046a707fab572d6e3ad02757d5"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzIyNTEyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMToyMjo0NVrOH5VsNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMTozODo0N1rOH5WLkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjI2Mw==", "bodyText": "@mernst I find the use of iterator here confusing.  If not an array, the expression must implement Iterable not Iterator.  I think you mean iterator as in an expression that can appear in a for each loop, but it's not clear.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529886263", "createdAt": "2020-11-24T21:22:45Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be087ec007db5e9ccdf9c16c627ccf97fc980c8f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5NDI5MQ==", "bodyText": "You are right:  that should have been iterable, not iterator.  Can you change that and make any other documentation improvements that you find needful?", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529894291", "createdAt": "2020-11-24T21:38:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2061,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of the given iterator. This is usually the type of {@code", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjI2Mw=="}, "originalCommit": {"oid": "be087ec007db5e9ccdf9c16c627ccf97fc980c8f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzU0NTEwOnYy", "diffSide": "RIGHT", "path": "changelog.txt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoyNDoyNFrOH5Y1BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoyNzo1N1rOH5ZEFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkzNzY2OQ==", "bodyText": "Should this be #getIteratorElementType...?", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529937669", "createdAt": "2020-11-24T22:24:24Z", "author": {"login": "wmdietl"}, "path": "changelog.txt", "diffHunk": "@@ -34,6 +34,9 @@ Removed a formal parameter from methods in `BaseTypeVisitor`:\n \n In Analysis.runAnalysisFor(), changed boolean parameter to enum BeforeOrAfter.\n \n+Removed org.checkerframework.framework.util.AnnotatedTypes#getIteratedType; use\n+AnnotatedTypeFactory#getIteratedType(ExpressionTree) instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbbc698721887123059960d79d0c4dc66210478a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0MTUyNA==", "bodyText": "Yes, thanks!", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529941524", "createdAt": "2020-11-24T22:27:57Z", "author": {"login": "smillst"}, "path": "changelog.txt", "diffHunk": "@@ -34,6 +34,9 @@ Removed a formal parameter from methods in `BaseTypeVisitor`:\n \n In Analysis.runAnalysisFor(), changed boolean parameter to enum BeforeOrAfter.\n \n+Removed org.checkerframework.framework.util.AnnotatedTypes#getIteratedType; use\n+AnnotatedTypeFactory#getIteratedType(ExpressionTree) instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkzNzY2OQ=="}, "originalCommit": {"oid": "dbbc698721887123059960d79d0c4dc66210478a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzU3MzYxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjoyODo1NFrOH5ZHqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjozMToyOVrOH5ZSKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0MjQ0MA==", "bodyText": "Should this be getIterableElementType?  That indicates the type of the argument more precisely.  I'm OK with the current name, too.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529942440", "createdAt": "2020-11-24T22:28:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2069,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of {@code expression}. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratorElementType(ExpressionTree expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "638a9bcec861e1165dcae57ed8dda7173b8e7a24"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0NTEyOA==", "bodyText": "Yes, I made that change.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529945128", "createdAt": "2020-11-24T22:31:29Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2061,6 +2069,75 @@ protected void adaptGetClassReturnTypeToReceiver(\n         classWildcardArg.setExtendsBound(newBound);\n     }\n \n+    /**\n+     * Return the element type of {@code expression}. This is usually the type of {@code\n+     * expression.itertor().next()}. If {@code expression} is an array, it is the component type of\n+     * the array.\n+     *\n+     * @param expression an expression whose type is an array or implements {@link Iterable}\n+     * @return the type of {@code expression.itertor().next()} or if {@code expression} is an array,\n+     *     the component type of the array.\n+     */\n+    public AnnotatedTypeMirror getIteratorElementType(ExpressionTree expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0MjQ0MA=="}, "originalCommit": {"oid": "638a9bcec861e1165dcae57ed8dda7173b8e7a24"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzc2MDYxOnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/builder/CFGTranslationPhaseOne.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1ODowNVrOH5a_xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMjo1ODowNVrOH5a_xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MzE4OA==", "bodyText": "Should this be \"Iterable\" rather than \"Iterator\"?  (The same comment applies elsewhere in the pull request.)", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529973188", "createdAt": "2020-11-24T22:58:05Z", "author": {"login": "mernst"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/builder/CFGTranslationPhaseOne.java", "diffHunk": "@@ -2426,10 +2426,18 @@ public Node visitEnhancedForLoop(EnhancedForLoopTree tree, Void p) {\n             MethodInvocationNode nextCallNode =\n                     new MethodInvocationNode(\n                             nextCall, nextAccessNode, Collections.emptyList(), getCurrentPath());\n+            // If the type of iteratorVariable is a capture, its type tree may be missing\n+            // annotations, so save the expression in the node so that the full type can be found\n+            // later.\n+            nextCallNode.setIteratorExpression(expression);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcf5612f49f2123beed9c1be432190e424b9176"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzc4NjIyOnYy", "diffSide": "RIGHT", "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzowMjoxM1rOH5bQeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzowMjoxM1rOH5bQeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NzQ2Ng==", "bodyText": "Can you make \"iter expression\" more descriptive?  Even changing it to a term that is used elsewhere in the code would be better, I think.", "url": "https://github.com/typetools/checker-framework/pull/3927#discussion_r529977466", "createdAt": "2020-11-24T23:02:13Z", "author": {"login": "mernst"}, "path": "dataflow/src/main/java/org/checkerframework/dataflow/cfg/node/MethodInvocationNode.java", "diffHunk": "@@ -76,6 +96,28 @@ public TreePath getTreePath() {\n         return treePath;\n     }\n \n+    /**\n+     * If this MethodInvocationNode is a node for an {@link Iterator#next()} desugared from an\n+     * enhanced for loop, then return the expression in the for loop, e.g., {@code iter} in {@code\n+     * for(Object o: iter}. Otherwise, return null.\n+     *\n+     * @return the iter expression, or null if this is not a {@link Iterator#next()} from an\n+     *     enhanced for loop\n+     */\n+    public @Nullable ExpressionTree getIteratorExpression() {\n+        return iteratorExpression;\n+    }\n+\n+    /**\n+     * Set the iter expression.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bcf5612f49f2123beed9c1be432190e424b9176"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 958, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}