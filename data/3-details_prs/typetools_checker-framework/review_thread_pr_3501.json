{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzI0OTc3", "number": 3501, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNToyODoyM1rOER3gUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozMToxOVrOER3kmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MTcwNjQwOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/signedness/SignednessAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNToyODoyM1rOG2z1kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNToyODoyM1rOG2z1kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyNTU4NQ==", "bodyText": "This should be !AnnotationUtils.areSameByName(superAnno, SIGNEDNESS_BOTTOM).", "url": "https://github.com/typetools/checker-framework/pull/3501#discussion_r460125585", "createdAt": "2020-07-24T15:28:23Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/signedness/SignednessAnnotatedTypeFactory.java", "diffHunk": "@@ -239,4 +251,140 @@ public Void visitCompoundAssignment(CompoundAssignmentTree tree, AnnotatedTypeMi\n             return null;\n         }\n     }\n+\n+    @Override\n+    protected TypeHierarchy createTypeHierarchy() {\n+        return new SignednessTypeHierarchy(\n+                checker,\n+                getQualifierHierarchy(),\n+                checker.getBooleanOption(\"ignoreRawTypeArguments\", true),\n+                checker.hasOption(\"invariantArrays\"));\n+    }\n+\n+    /**\n+     * The type hierarchy for the signedness type system. If A is narrower (fewer bits) than B, then\n+     * A with any qualifier is a subtype of @SignedPositive B.\n+     */\n+    protected class SignednessTypeHierarchy extends DefaultTypeHierarchy {\n+\n+        /**\n+         * Create a new SignednessTypeHierarchy.\n+         *\n+         * @param checker the checker\n+         * @param qualifierHierarchy the qualifier hierarchy\n+         * @param ignoreRawTypes from -AignoreRawTypes\n+         * @param invariantArrayComponents from -AinvariantArrays\n+         */\n+        public SignednessTypeHierarchy(\n+                BaseTypeChecker checker,\n+                QualifierHierarchy qualifierHierarchy,\n+                boolean ignoreRawTypes,\n+                boolean invariantArrayComponents) {\n+            super(checker, qualifierHierarchy, ignoreRawTypes, invariantArrayComponents);\n+        }\n+\n+        @Override\n+        public Boolean visitPrimitive_Primitive(\n+                AnnotatedPrimitiveType subtype, AnnotatedPrimitiveType supertype, Void p) {\n+\n+            boolean superResult = super.visitPrimitive_Primitive(subtype, supertype, p);\n+            if (superResult) {\n+                return true;\n+            }\n+\n+            PrimitiveType subPrimitive = subtype.getUnderlyingType();\n+            PrimitiveType superPrimitive = supertype.getUnderlyingType();\n+            if (isNarrowerIntegral(subPrimitive, superPrimitive)) {\n+                // AnnotationMirror subAnno = subtype.getAnnotationInHierarchy(UNKNOWN_SIGNEDNESS);\n+                AnnotationMirror superAnno = supertype.getAnnotationInHierarchy(UNKNOWN_SIGNEDNESS);\n+                if (!superAnno.equals(SIGNEDNESS_BOTTOM)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ce7b42a8cb02978438b5849aaf11c8617eac39"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MTcxNzM4OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/signedness/SignednessAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozMToxOVrOG2z8Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTozMToxOVrOG2z8Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyNzI4Ng==", "bodyText": "Maybe delete this?", "url": "https://github.com/typetools/checker-framework/pull/3501#discussion_r460127286", "createdAt": "2020-07-24T15:31:19Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/signedness/SignednessAnnotatedTypeFactory.java", "diffHunk": "@@ -239,4 +251,140 @@ public Void visitCompoundAssignment(CompoundAssignmentTree tree, AnnotatedTypeMi\n             return null;\n         }\n     }\n+\n+    @Override\n+    protected TypeHierarchy createTypeHierarchy() {\n+        return new SignednessTypeHierarchy(\n+                checker,\n+                getQualifierHierarchy(),\n+                checker.getBooleanOption(\"ignoreRawTypeArguments\", true),\n+                checker.hasOption(\"invariantArrays\"));\n+    }\n+\n+    /**\n+     * The type hierarchy for the signedness type system. If A is narrower (fewer bits) than B, then\n+     * A with any qualifier is a subtype of @SignedPositive B.\n+     */\n+    protected class SignednessTypeHierarchy extends DefaultTypeHierarchy {\n+\n+        /**\n+         * Create a new SignednessTypeHierarchy.\n+         *\n+         * @param checker the checker\n+         * @param qualifierHierarchy the qualifier hierarchy\n+         * @param ignoreRawTypes from -AignoreRawTypes\n+         * @param invariantArrayComponents from -AinvariantArrays\n+         */\n+        public SignednessTypeHierarchy(\n+                BaseTypeChecker checker,\n+                QualifierHierarchy qualifierHierarchy,\n+                boolean ignoreRawTypes,\n+                boolean invariantArrayComponents) {\n+            super(checker, qualifierHierarchy, ignoreRawTypes, invariantArrayComponents);\n+        }\n+\n+        @Override\n+        public Boolean visitPrimitive_Primitive(\n+                AnnotatedPrimitiveType subtype, AnnotatedPrimitiveType supertype, Void p) {\n+\n+            boolean superResult = super.visitPrimitive_Primitive(subtype, supertype, p);\n+            if (superResult) {\n+                return true;\n+            }\n+\n+            PrimitiveType subPrimitive = subtype.getUnderlyingType();\n+            PrimitiveType superPrimitive = supertype.getUnderlyingType();\n+            if (isNarrowerIntegral(subPrimitive, superPrimitive)) {\n+                // AnnotationMirror subAnno = subtype.getAnnotationInHierarchy(UNKNOWN_SIGNEDNESS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35ce7b42a8cb02978438b5849aaf11c8617eac39"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1578, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}