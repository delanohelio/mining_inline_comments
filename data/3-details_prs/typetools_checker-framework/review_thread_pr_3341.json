{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0ODg5NDgz", "number": 3341, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMToxMFrOEB0FBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMToxMFrOEB0FBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzM3Mjg1OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/SystemGetPropertyHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMToxMFrOGd44TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMToxMFrOGd44TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MzgwNQ==", "bodyText": "Errors should be reported in the visitor rather than the annotated type factory.", "url": "https://github.com/typetools/checker-framework/pull/3341#discussion_r433993805", "createdAt": "2020-06-02T16:01:10Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/SystemGetPropertyHandler.java", "diffHunk": "@@ -71,27 +91,78 @@\n                             \"user.home\",\n                             \"user.dir\"));\n \n+    /**\n+     * Creates a SystemGetPropertyHandler.\n+     *\n+     * @param env the processing environment\n+     * @param factory the factory for constructing and looking up types\n+     * @param checker the checker for issuing errors\n+     */\n     public SystemGetPropertyHandler(\n-            ProcessingEnvironment env, NullnessAnnotatedTypeFactory factory) {\n+            ProcessingEnvironment env,\n+            NullnessAnnotatedTypeFactory factory,\n+            BaseTypeChecker checker) {\n+        this.permitClearProperty =\n+                checker.getLintOption(\n+                        NullnessChecker.LINT_PERMITCLEARPROPERTY,\n+                        NullnessChecker.LINT_DEFAULT_PERMITCLEARPROPERTY);\n         this.env = env;\n         this.factory = factory;\n+        this.checker = checker;\n \n         systemGetProperty =\n                 TreeUtils.getMethod(java.lang.System.class.getName(), \"getProperty\", 1, env);\n+        systemSetProperty =\n+                TreeUtils.getMethod(java.lang.System.class.getName(), \"setProperty\", 2, env);\n+        systemClearProperty =\n+                TreeUtils.getMethod(java.lang.System.class.getName(), \"clearProperty\", 1, env);\n+        systemSetProperties =\n+                TreeUtils.getMethod(java.lang.System.class.getName(), \"setProperties\", 1, env);\n     }\n \n+    /**\n+     * If the first argument of a method call is a literal, return it; otherwise return null.\n+     *\n+     * @param tree a method invocation whose first formal parameter is of String type\n+     * @return the first argument if it is a literal, otherwise null\n+     */\n+    private static @Nullable String literalFirstArgument(MethodInvocationTree tree) {\n+        List<? extends ExpressionTree> args = tree.getArguments();\n+        assert args.size() > 0;\n+        ExpressionTree arg = args.get(0);\n+        if (arg.getKind() == Tree.Kind.STRING_LITERAL) {\n+            String literal = (String) ((LiteralTree) arg).getValue();\n+            return literal;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Apply rules regarding System.getProperty and related methods.\n+     *\n+     * @param tree a method invocation\n+     * @param method the method being invoked\n+     */\n     public void handle(MethodInvocationTree tree, AnnotatedExecutableType method) {\n-        if (TreeUtils.isMethodInvocation(tree, systemGetProperty, env)) {\n-            List<? extends ExpressionTree> args = tree.getArguments();\n-            assert args.size() == 1;\n-            ExpressionTree arg = args.get(0);\n-            if (arg.getKind() == Tree.Kind.STRING_LITERAL) {\n-                String literal = (String) ((LiteralTree) arg).getValue();\n-                if (predefinedSystemProperties.contains(literal)) {\n-                    AnnotatedTypeMirror type = method.getReturnType();\n-                    type.replaceAnnotation(factory.NONNULL);\n-                }\n+        if (permitClearProperty) {\n+            return;\n+        }\n+        if (TreeUtils.isMethodInvocation(tree, systemGetProperty, env)\n+                || TreeUtils.isMethodInvocation(tree, systemSetProperty, env)) {\n+            String literal = literalFirstArgument(tree);\n+            if (literal != null && predefinedSystemProperties.contains(literal)) {\n+                AnnotatedTypeMirror type = method.getReturnType();\n+                type.replaceAnnotation(factory.NONNULL);\n             }\n         }\n+        if (TreeUtils.isMethodInvocation(tree, systemClearProperty, env)) {\n+            String literal = literalFirstArgument(tree);\n+            if (literal == null || predefinedSystemProperties.contains(literal)) {\n+                checker.reportError(tree, \"clear.system.property\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "763073867f627d038cb1536958dd9fd39a0213d7"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1674, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}