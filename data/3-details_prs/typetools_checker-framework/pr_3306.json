{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2OTk2OTAz", "number": 3306, "title": "Add a generic accumulation checker", "bodyText": "This PR builds on #3199 (Returns Receiver Checker) by adding a generic checker that implements a basic general version of accumulation analysis, as described in our paper \"Verifying Object Construction\" (ICSE 2020).\nA simple checker that implements a simplified version of the called methods type system described in the paper is included for testing.\nThis PR is the first step in what will be a series to generalize the implementation from the paper and make it re-usable.", "createdAt": "2020-05-12T22:06:03Z", "url": "https://github.com/typetools/checker-framework/pull/3306", "merged": true, "mergeCommit": {"oid": "7ffdd6c6b534c912a55936ff80bbc8409e752d55"}, "closed": true, "closedAt": "2020-06-17T19:20:13Z", "author": {"login": "kelloggm"}, "timelineItems": {"totalCount": 117, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcpb243AH2gAyNDE2OTk2OTAzOjUyYWJjMjEwNjk4MzM0NTYyZmU4OWMxZDZmMWZiYTM2YjE4NTkzNWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsNuOEAH2gAyNDE2OTk2OTAzOjJiZTNmZjlkOGUzNmE4N2Q5YzQyZGFkOTkzNzllMTZlNWE0NDAwMmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/52abc210698334562fe89c1d6f1fba36b185935d", "committedDate": "2020-06-09T02:44:22Z", "message": "Edits from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "196d0c35adc7624f835edb8cddf0c209fed6433d", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/196d0c35adc7624f835edb8cddf0c209fed6433d", "committedDate": "2020-06-09T16:41:30Z", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c70776e018626fd8ca7a08618fab22cb52f5e423", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/c70776e018626fd8ca7a08618fab22cb52f5e423", "committedDate": "2020-06-09T16:44:34Z", "message": "fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzUyMDU4", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-426752058", "createdAt": "2020-06-09T02:45:28Z", "commit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjo0NToyOFrOGg25Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjo1MDozN1rOGg2-aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzAzOQ==", "bodyText": "Is there a test case that shows this halting at a non-receiver-returning method invocation?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107039", "createdAt": "2020-06-09T02:45:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzE3NA==", "bodyText": "Could you add this test case?  Probably there will be a comment saying the code is safe and the checker currently issues a false positive warning.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107174", "createdAt": "2020-06-09T02:45:59Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzQxMQ==", "bodyText": "The reason that a.b().c() gets updated is different from why the other two expressions get updated.  I think that is worth calling out in the example.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437107411", "createdAt": "2020-06-09T02:46:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMwOQ==", "bodyText": "Please add a test case for this.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108309", "createdAt": "2020-06-09T02:50:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMyMQ==", "bodyText": "invokedMethod is not a method.  It's a call.  Therefore, the name is confusing.  It's also confusing that although methodInvocationNode and invokedMethod represent the same thing (just as different types), their names do not reflect this relationship.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108321", "createdAt": "2020-06-09T02:50:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODMzMQ==", "bodyText": "Please document the relationship between these variables.  It isn't obvious from the code.\nCan you convert any of them from loop-carried dependencies into local variables within the loop?  If you can reduce the number of variables that the loop maintains, the loop will be easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r437108331", "createdAt": "2020-06-09T02:50:37Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called on\n+     * {@code foo} directly.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba894ccb05b1311e461b5aac9c5dd30b22471716", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/ba894ccb05b1311e461b5aac9c5dd30b22471716", "committedDate": "2020-06-15T19:23:05Z", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "367e41eedbae2fc410f64f20945ffbe54a33123a", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/367e41eedbae2fc410f64f20945ffbe54a33123a", "committedDate": "2020-06-15T20:44:15Z", "message": "address code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20bbd632ea069517952f076398662cfa91d2fe75", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/20bbd632ea069517952f076398662cfa91d2fe75", "committedDate": "2020-06-16T20:08:33Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f105f888bbbfe266514590a1234d28b1fda1b04", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3f105f888bbbfe266514590a1234d28b1fda1b04", "committedDate": "2020-06-16T21:10:29Z", "message": "Comment tweaks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6a93752704ac29f6cfd32883d3022463f1f5b44", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a6a93752704ac29f6cfd32883d3022463f1f5b44", "committedDate": "2020-06-16T21:24:04Z", "message": "Comment tweak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/c5e1c5f3b4c3712913efeb6c85647352a32d8c48", "committedDate": "2020-06-16T21:24:18Z", "message": "Add failing test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTA0NDA3", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-431904407", "createdAt": "2020-06-16T21:27:01Z", "commit": {"oid": "3f105f888bbbfe266514590a1234d28b1fda1b04"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMToyNzowMlrOGktylw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTozMjo1N1rOGkt89w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1MjE1MQ==", "bodyText": "The test case I had in mind contained a non-@This-returning method in the middle of a chain of @This-returning methods.  That is, there appear @This-returning methods both before and after it.  I added such a test case, and it fails.  It is poorly named m8 and you might want to rename it.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441152151", "createdAt": "2020-06-16T21:27:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue as long as\n+     * each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. Then all of the expressions {@code a.b().c()}, {@code a.b()}, and\n+     * {@code a} would have their estimates updated to include \"foo\". Note that due to what kind of\n+     * values can be held in the store, this information is lost outside the method chain. That is,\n+     * the returns-receiver propagated information is lost outside the expression in which the\n+     * returns-receiver method invocations are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNzE3NA=="}, "originalCommit": {"oid": "52abc210698334562fe89c1d6f1fba36b185935d"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1MzUyNg==", "bodyText": "Should the remainder of this loop be equivalent to a recursive call to accumulate, just more efficient?\nIf so, could you add a comment to that effect?  (Or maybe even make it a recursive call to accumulate, which will be shorter and simpler code, though a bit less efficient.  If you do that, you can remove the while loop.)", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441153526", "createdAt": "2020-06-16T21:30:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            while (methodInvocationNode != null) {\n+\n+                Node receiver = methodInvocationNode.getTarget().getReceiver();\n+\n+                if (receiver == null || !typeFactory.returnsThis((MethodInvocationTree) tree)) {\n+                    break;\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1NDgwNw==", "bodyText": "This use of newAnno looks wrong to me.  newAnno was computed earlier for a later method call, and if the recursion goes past a non-@This-returning call, then the value should be reset rather than carried across that call.  I added a failing test case, m8, that illustrates incorrect behavior.\nShould the recursion go through non-@This returning methods at all?\nIt is also a bit suspicious that no call of getUnionAnno occurs.  Could you write a comment saying why it is not needed, and it's OK to do complete replacement rather than GLB?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441154807", "createdAt": "2020-06-16T21:32:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getUnionAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            while (methodInvocationNode != null) {\n+\n+                Node receiver = methodInvocationNode.getTarget().getReceiver();\n+\n+                if (receiver == null || !typeFactory.returnsThis((MethodInvocationTree) tree)) {\n+                    break;\n+                }\n+\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though the code below can still continue to recurse.\n+                // (The code above tested that `tree` returns `this` but did not test `receiver`.)\n+                insertIntoStores(result, receiver, newAnno);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5e1c5f3b4c3712913efeb6c85647352a32d8c48"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b20b2a50022875e66a3e7d2ad1f96520d7d9683", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/1b20b2a50022875e66a3e7d2ad1f96520d7d9683", "committedDate": "2020-06-16T23:10:17Z", "message": "rewrite accumulate to be recursive, and to use dataflow facts directly rather than the ATF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4052ee7f9c681f342a41cfc4c64d56c254732d22", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/4052ee7f9c681f342a41cfc4c64d56c254732d22", "committedDate": "2020-06-16T23:49:34Z", "message": "Fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cac0323e0495a11957b6a7b441d8a9b37179f496", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cac0323e0495a11957b6a7b441d8a9b37179f496", "committedDate": "2020-06-17T00:05:09Z", "message": "Tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTczMzE2", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-431973316", "createdAt": "2020-06-17T00:10:35Z", "commit": {"oid": "cac0323e0495a11957b6a7b441d8a9b37179f496"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDoxMDozNVrOGkxREg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDoxMDozNVrOGkxREg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTEwNg==", "bodyText": "Is this for loop guaranteed to execute exactly 0 or 1 times?  Should it assert that about the size of flowAnnos?  I think that each one must be either the accumulator or bottom; is that correct?  Is that worth verifying?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r441209106", "createdAt": "2020-06-17T00:10:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to add a string to the estimate at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. In a chain of method calls, this process will continue backward as\n+     * long as each receiver is itself a receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose {@code node} is the expression {@code a.b().c()}, the new value\n+     * (added by the accumulation analysis because of the {@code .c()} call) is \"foo\", and b and c\n+     * return their receiver. This method will directly update the estimate of {@code a.b().c()} to\n+     * include \"foo\". In addition, the estimates for the expressions {@code a.b()} and {@code a}\n+     * would have their estimates updated to include \"foo\", because c and b (respectively) return\n+     * their receivers. Note that due to what kind of values can be held in the store, this\n+     * information is lost outside the method chain. That is, the returns-receiver propagated\n+     * information is lost outside the expression in which the returns-receiver method invocations\n+     * are nested.\n+     *\n+     * <p>As a concrete example, consider the Called Methods accumulation checker: if {@code build}\n+     * requires a, b, and c to be called, then {@code foo.a().b().c().build();} will typecheck (they\n+     * are in one fluent method chain), but {@code foo.a().b().c(); foo.build();} will not -- the\n+     * store does not keep the information that a, b, and c have been called outside the chain.\n+     * {@code foo}'s type will be {@code CalledMethods(\"a\")}, because only {@code a()} was called\n+     * directly on {@code foo}. For such code to typecheck, the Called Methods accumulation checker\n+     * uses an additional rule: the return type of a receiver-returning method {@code rr()} is\n+     * {@code CalledMethods(\"rr\")}. This rule is implemented directly in the {@link\n+     * org.checkerframework.framework.type.treeannotator.TreeAnnotator} subclass defined in the\n+     * Called Methods type factory.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        List<String> valuesAsList = Arrays.asList(values);\n+        // If dataflow has already recorded information about the target, fetch it and integrate\n+        // it into the list of values in the new annotation.\n+        CFValue flowValue = result.getResultValue();\n+        if (flowValue != null) {\n+            Set<AnnotationMirror> flowAnnos = flowValue.getAnnotations();\n+            for (AnnotationMirror anno : flowAnnos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cac0323e0495a11957b6a7b441d8a9b37179f496"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a3d5c6d9666fd089f3dc20e3548760ac100c71c", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/4a3d5c6d9666fd089f3dc20e3548760ac100c71c", "committedDate": "2020-06-17T17:56:54Z", "message": "try to make comment a bit more readable, and add an assertion about the size of the list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2be3ff9d8e36a87d9c42dad99379e16e5a44002c", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/2be3ff9d8e36a87d9c42dad99379e16e5a44002c", "committedDate": "2020-06-17T17:58:00Z", "message": "merge conflict with Mike's fix for the weird formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beffa549428ba139408bb29bcdb899941b33294b", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/beffa549428ba139408bb29bcdb899941b33294b", "committedDate": "2020-03-25T18:16:00Z", "message": "Initialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b63699b1dcb6aa74e0913a770a3b4012f774428", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/9b63699b1dcb6aa74e0913a770a3b4012f774428", "committedDate": "2020-03-26T19:35:59Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc4298b92e91330a1c62f162bb32956c2018c756", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/bc4298b92e91330a1c62f162bb32956c2018c756", "committedDate": "2020-03-26T19:41:34Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/a77dd34f6a7a54defb7a186be322f7d276ece232", "committedDate": "2020-03-26T20:01:21Z", "message": "resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71f08dc67b501f0072ec03a27fa3892c4801d3e1", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/71f08dc67b501f0072ec03a27fa3892c4801d3e1", "committedDate": "2020-03-27T17:17:25Z", "message": "test git"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9f9e3fd725fcca36f0a09656fcb771229d4200d", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/f9f9e3fd725fcca36f0a09656fcb771229d4200d", "committedDate": "2020-03-27T17:20:38Z", "message": "test git"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "committedDate": "2020-03-28T02:05:04Z", "message": "resolved issues and passed git pre-commit hooks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "committedDate": "2020-03-28T05:21:31Z", "message": "fixed issue with checkBasicStyle task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "committedDate": "2020-03-28T06:36:20Z", "message": "fixed all-test-jdk8 and all-test-jdk11 jobs in pipeline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "committedDate": "2020-03-28T06:50:42Z", "message": "git test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e005df3b5c841dbe272b502dc07bab3d2a41af98", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/e005df3b5c841dbe272b502dc07bab3d2a41af98", "committedDate": "2020-03-28T07:37:32Z", "message": "fixed checkInterning task"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7690604d845c8331ce3e03232f192a5525f601b6", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/7690604d845c8331ce3e03232f192a5525f601b6", "committedDate": "2020-03-28T08:27:05Z", "message": "misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "committedDate": "2020-03-28T08:39:37Z", "message": "misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27843ff602ba06a52db49498675e3be561fa1828", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/27843ff602ba06a52db49498675e3be561fa1828", "committedDate": "2020-03-28T19:08:15Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "committedDate": "2020-03-28T19:17:38Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "committedDate": "2020-03-28T21:33:17Z", "message": "returns receiver manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed02ca65fd427780a729589976818098433543f1", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/ed02ca65fd427780a729589976818098433543f1", "committedDate": "2020-03-28T21:34:03Z", "message": "trailing whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/9b5171fe0730113b1248680c19a97e5c3c75c953", "committedDate": "2020-03-29T00:28:07Z", "message": "Add final newline"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "committedDate": "2020-03-29T00:37:00Z", "message": "Capitalization fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4532df793fc199e7a440efa35c3051b0abc2e6b", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/f4532df793fc199e7a440efa35c3051b0abc2e6b", "committedDate": "2020-03-29T15:24:30Z", "message": "Improve naming.  Make switch statements report errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce4f098f11080d20257088603aae6c1b4a23bc51", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/ce4f098f11080d20257088603aae6c1b4a23bc51", "committedDate": "2020-03-29T15:41:40Z", "message": "Remove unnecessary text"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/eff17315021c4d2899189b30c6a25149548d5fe5", "committedDate": "2020-03-29T15:41:54Z", "message": "Improve naming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d13fe35aeee5b038c375da84e9377835b2dd5a84", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d13fe35aeee5b038c375da84e9377835b2dd5a84", "committedDate": "2020-03-30T16:24:48Z", "message": "Fixed contructor throw RuntimeException and javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "committedDate": "2020-03-30T19:33:55Z", "message": "fix misc-jdk8 and misc-jdk11"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85682f77cf4b561fb948799f672369f9238d2fd3", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/85682f77cf4b561fb948799f672369f9238d2fd3", "committedDate": "2020-04-01T17:28:07Z", "message": "working on manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f897ece84d1d0742df8a5d44218f975ff0a800c0", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/f897ece84d1d0742df8a5d44218f975ff0a800c0", "committedDate": "2020-04-01T17:38:52Z", "message": "pass on manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c326d568f2b94e6e3417c27fefac8ad955dab9b", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/2c326d568f2b94e6e3417c27fefac8ad955dab9b", "committedDate": "2020-04-01T17:41:45Z", "message": "changed framework support to enums"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "committedDate": "2020-04-01T17:42:00Z", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "748a84c18498ee263accd07d5107af4927db474d", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/748a84c18498ee263accd07d5107af4927db474d", "committedDate": "2020-04-01T17:50:09Z", "message": "remove paragraph on disabling framework support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "committedDate": "2020-04-01T21:10:47Z", "message": "Merge branch 'master' into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1c028fade3062f9cba9fbb3019984ca38b30171", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d1c028fade3062f9cba9fbb3019984ca38b30171", "committedDate": "2020-04-02T01:13:35Z", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "482809a6694b522ffd7c97ca7676a5db936c4866", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/482809a6694b522ffd7c97ca7676a5db936c4866", "committedDate": "2020-04-02T01:28:44Z", "message": "Rename MaybeThis to UnknownThis.\n\nThe name MaybeThis isn't bad, but the rest of the Checker Framework uses\nthe naming convention \"Unknown\" for the top type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc7a321c3c288e4e3a377edf683fe8f0559b6026", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cc7a321c3c288e4e3a377edf683fe8f0559b6026", "committedDate": "2020-04-02T01:51:44Z", "message": "Improve Javadoc: add explanations, examples, links"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf31b932ea22fb758a113f144732cb39bdab46fa", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/cf31b932ea22fb758a113f144732cb39bdab46fa", "committedDate": "2020-04-02T02:17:57Z", "message": "Edits to manual section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8e6b7290aad40d59affcf1e0e2113be79188368", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b8e6b7290aad40d59affcf1e0e2113be79188368", "committedDate": "2020-04-02T02:19:05Z", "message": "Mention terminology \"fluent API\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "941d35b64856461dca9c5ae04b253f3f9ec66b4e", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/941d35b64856461dca9c5ae04b253f3f9ec66b4e", "committedDate": "2020-04-02T03:56:38Z", "message": "Tweak message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/daafb8f1937dcf9ba1c78f58a69a675465cc62be", "committedDate": "2020-04-02T05:19:49Z", "message": "Edits from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "committedDate": "2020-04-02T19:28:31Z", "message": "Update changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "committedDate": "2020-04-03T07:28:13Z", "message": "removed frameworkSupport Interface and resolved comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acfb71a082e2aa5ed579bcad04447d36be7ef724", "author": {"user": {"login": "smillst", "name": "Suzanne Millstein"}}, "url": "https://github.com/typetools/checker-framework/commit/acfb71a082e2aa5ed579bcad04447d36be7ef724", "committedDate": "2020-04-05T18:20:05Z", "message": "Don't replace existing annotations."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "committedDate": "2020-04-06T02:20:13Z", "message": "fix misc_jdk8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b51b9199f33112538d3ecad583c7934248b13495", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/b51b9199f33112538d3ecad583c7934248b13495", "committedDate": "2020-04-06T23:24:54Z", "message": "removed FrameworkSupportUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "author": {"user": {"login": "nimakarimipour", "name": "Nima Karimipour"}}, "url": "https://github.com/typetools/checker-framework/commit/71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "committedDate": "2020-04-07T01:36:46Z", "message": "removed dependecies to AutoValue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "author": {"user": {"login": "msridhar", "name": "Manu Sridharan"}}, "url": "https://github.com/typetools/checker-framework/commit/606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "committedDate": "2020-04-07T03:46:33Z", "message": "clean up some logic in type factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d1edad52a2a714e186296fa82a25dac118d6cd1", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/1d1edad52a2a714e186296fa82a25dac118d6cd1", "committedDate": "2020-04-09T22:52:48Z", "message": "partial work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "231bf447bc4d9ffd81a0aef529e1c7b6d1888d13", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/231bf447bc4d9ffd81a0aef529e1c7b6d1888d13", "committedDate": "2020-05-01T00:15:06Z", "message": "use the merged version of the RR checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bc521df9a9666ecbc866d17b680910b282f41d3", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/6bc521df9a9666ecbc866d17b680910b282f41d3", "committedDate": "2020-05-01T00:50:50Z", "message": "basic testing infrastructure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "943996c9d0efb55aaeb35b1a86adb96b64ae1232", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/943996c9d0efb55aaeb35b1a86adb96b64ae1232", "committedDate": "2020-05-12T00:02:53Z", "message": "add another test case that checks that RR support works as intended"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0840bf3f8e7b1008f192a44050528534e2ba7579", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/0840bf3f8e7b1008f192a44050528534e2ba7579", "committedDate": "2020-05-12T20:41:34Z", "message": "add all remaining basic OCC tests that are relevant to a general accumulation analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946d6d6442adb8e41b4780fb399f69c181c21dde", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/946d6d6442adb8e41b4780fb399f69c181c21dde", "committedDate": "2020-05-12T21:33:10Z", "message": "add docs and remove debugging code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d03694e66f8863db5bd150ebfebd2436c8cb3db8", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/d03694e66f8863db5bd150ebfebd2436c8cb3db8", "committedDate": "2020-05-12T21:51:13Z", "message": "actually test the accumulate method, too, by making the test checker a very simple CM checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47920cd0e14c09689718a15200c218b570b41772", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/47920cd0e14c09689718a15200c218b570b41772", "committedDate": "2020-05-12T21:57:07Z", "message": "remove code that should have been deleted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca07011fcb0544d27a221921381fc9e870e8767f", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/ca07011fcb0544d27a221921381fc9e870e8767f", "committedDate": "2020-05-12T22:00:57Z", "message": "more docs, make Accumulation ATF constructor protected"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f723f6a609bf94a472189b3a9062c82686564f0", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/8f723f6a609bf94a472189b3a9062c82686564f0", "committedDate": "2020-05-12T22:02:20Z", "message": "add all-systems tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa7dc292d3d8f72e0158d3394d24f0467afd81e8", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/aa7dc292d3d8f72e0158d3394d24f0467afd81e8", "committedDate": "2020-05-12T22:59:12Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cabfb0dfd9d462bd9f13c00615e6bc9ab22e9e9a", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/cabfb0dfd9d462bd9f13c00615e6bc9ab22e9e9a", "committedDate": "2020-05-13T17:26:10Z", "message": "use Java 8 syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb4c0fbd7f797d4dcbca64f78c51f24e1495407d", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/eb4c0fbd7f797d4dcbca64f78c51f24e1495407d", "committedDate": "2020-05-13T17:26:36Z", "message": "Merge branch 'accumulation-analysis' of github.com:kelloggm/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da1ab9cbc6fb159908c68a87acfd79caa4ff3835", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/da1ab9cbc6fb159908c68a87acfd79caa4ff3835", "committedDate": "2020-05-13T18:17:05Z", "message": "add draft of manual section for building an accumulation checker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/16d5df6a2d08fb499909ea642a8c77d0f4ccf114", "committedDate": "2020-05-13T18:55:03Z", "message": "fix EP warning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjQzODA3", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-411243807", "createdAt": "2020-05-13T19:43:20Z", "commit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo0MzoyMFrOGVA4BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOTo1Mzo1M1rOGVBOMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NzYyMQ==", "bodyText": "with -> has", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424687621", "createdAt": "2020-05-13T19:43:20Z", "author": {"login": "msridhar"}, "path": "docs/manual/accumulation-checker.tex", "diffHunk": "@@ -0,0 +1,80 @@\n+\\htmlhr\n+\\chapterAndLabel{Building an accumulation checker}{accumulation-checker}\n+\n+%% This chapter should appear after the \"creating a checker\" chapter, or perhaps as part of it,\n+%% once accumulation support is complete.\n+\n+This chapter describes how to build a particular kind of checker---an accumulation\n+checker. If you want to \\emph{use} an existing checker, you do not need to read this chapter.\n+\n+An \\emph{accumulation analysis} is a program analysis where the\n+analysis abstraction is a monotonically increasing set, and some operation is legal\n+only when the set is large enough---that is, the estimate has accumulated\n+sufficiently many items.\n+Accumulation analysis is a special case of typestate analysis in which\n+(1) the order in which operations are performed does not affect what is subsequently legal,\n+and (2) the accumulation does not add restrictions; that is, as\n+more operations are performed, more operations become legal.\n+\n+Unlike a traditional typestate analysis, an accumulation analysis does\n+not require an alias analysis for soundness. It can therefore be implemented\n+as a flow-sensitive type system.\n+\n+The Checker Framework contains a generic accumulation analysis that can\n+be extended to implement any particular accumulation analysis. We refer to\n+such an extension as an \"accumulation checker\" in this chapter.\n+\n+Before reading the rest of this chapter, you should\n+read the section on creating a checker (Chapter~\\ref{creating-a-checker}).\n+The rest of this chapter assumes you have done so.\n+\n+\\paragraphAndLabel{Defining type qualifiers}{accumulation-qualifiers}\n+\n+The first step in building an accumulation checker is to decide what it is\n+your checker will accumulate, and how to represent it. The Checker Framework's\n+support for accumulation analysis requires you to accumulate a string representation\n+of whatever you are accumulating. For example, when accumulating which methods have\n+been called on an object, you might choose to accumulate method names.\n+\n+Define a type qualifier that with a single argument: a \\<String[]> named \\<value>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTIwMA==", "bodyText": "FWIW I can't really read this lattice.  Is this a standard notation?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424689200", "createdAt": "2020-05-13T19:46:24Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,280 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement their own version of the\n+ * constructor, which should take a {@link BaseTypeChecker} and pass constants for the annotation\n+ * classes required by the constructor defined in this class.\n+ *\n+ * <p>New subclasses must also call {@link #postInit()} in their constructors.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top and bottom annotations for this accumulation checker. */\n+    public final AnnotationMirror TOP, BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param t the top type in the hierarchy\n+     * @param bot the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> t,\n+            Class<? extends Annotation> bot) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, t);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bot);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with values's arguments,\n+     *     or top is {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Utility method that returns whether the return type of the given method invocation tree has\n+     * an @This annotation from the Returns Receiver Checker.\n+     *\n+     * @param tree the method invocation tree to check\n+     * @return whether the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return whether the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            // Check to see if the ReturnsReceiver Checker has a @This annotation\n+            // on the return type of the method.\n+            if (returnsThis(tree)) {\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <p>top / \\ acc(x) acc(y) ... \\ / acc(x,y) ... | bottom", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTkzOA==", "bodyText": "Is it possible someone might want to build an accumulation checker that does not require returns-receiver reasoning?  Or shall we just assume any accumulation checker is also dealing with fluent APIs?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424689938", "createdAt": "2020-05-13T19:47:47Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationChecker.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.checkerframework.common.accumulation;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+\n+/**\n+ * An accumulation checker is one that accumulates some property: method calls, keys into maps, etc.\n+ * All accumulation analyses share some common features: their type systems are similar in\n+ * structure, they need to reason about fluent APIs, and they need some way to easily add facts to\n+ * the accumulation they are tracking. This accumulation analysis represents all facts as Strings.\n+ *\n+ * <p>Accumulation checkers are particularly interesting because they can represent many\n+ * typestate-like properties, but do not require a precise alias analysis for soundness.\n+ *\n+ * <p>This class provides a basic accumulation checker that can be extended to implement a\n+ * particular accumulation type system. The primary extension point is the constructor of {@link\n+ * AccumulationAnnotatedTypeFactory}, which every subclass should override to provide custom\n+ * annotations.\n+ */\n+public abstract class AccumulationChecker extends BaseTypeChecker {\n+\n+    @Override\n+    protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n+        LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n+                super.getImmediateSubcheckerClasses();\n+        checkers.add(ReturnsReceiverChecker.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MDYzMA==", "bodyText": "This will only be true if methods b and c are deterministic.  If they are not, only the estimate of a will be updated, and the types of a.b() and a.b().c() are computed in the type factory.  We should update the documentation to be clearer about this", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424690630", "createdAt": "2020-05-13T19:49:05Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things node has accumulated to include all the values.\n+     *\n+     * @param node the node whose estimate should be adjusted\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MzI5Ng==", "bodyText": "As noted above, this call will do nothing when receiver is a method call that is not deterministic.  Not sure if we should change the implementation logic to reflect this more clearly.  Nothing incorrect happens now, but it may confuse future readers of the code", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424693296", "createdAt": "2020-05-13T19:53:53Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things node has accumulated to include all the values.\n+     *\n+     * @param node the node whose estimate should be adjusted\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver, all of the expressions {@code a}, {@code a.b()}, and\n+     * {@code a.b().c()} would have their estimates updated to include \"foo\".\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            insertIntoStores(result, receiver, newAnno);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16d5df6a2d08fb499909ea642a8c77d0f4ccf114"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "354ac0da65ffa956127454bd0e3308aee249838b", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/354ac0da65ffa956127454bd0e3308aee249838b", "committedDate": "2020-05-13T19:55:45Z", "message": "some javadoc that I missed before"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f81727d201bb9335f6992609dc89777f8c783c2", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/2f81727d201bb9335f6992609dc89777f8c783c2", "committedDate": "2020-05-13T20:54:00Z", "message": "address some code review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMjk5NTI0", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-411299524", "createdAt": "2020-05-13T21:06:30Z", "commit": {"oid": "2f81727d201bb9335f6992609dc89777f8c783c2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTowNjozMVrOGVDhtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTowNjozMVrOGVDhtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMTA2Mg==", "bodyText": "Can we add a bit more detail on what this tree annotator is actually doing?  Like the example we give in the transfer function documentation.  This can be in the class documentation or the docs of visitMethodInvocation().", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r424731062", "createdAt": "2020-05-13T21:06:31Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement their own version of the\n+ * constructor, which should take a {@link BaseTypeChecker} and pass constants for the annotation\n+ * classes required by the constructor defined in this class.\n+ *\n+ * <p>New subclasses must also call {@link #postInit()} in their constructors.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top and bottom annotations for this accumulation checker. */\n+    public final AnnotationMirror TOP, BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param t the top type in the hierarchy\n+     * @param bot the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> t,\n+            Class<? extends Annotation> bot) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, t);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bot);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with values's arguments,\n+     *     or top is {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Utility method that returns whether the return type of the given method invocation tree has\n+     * an @This annotation from the Returns Receiver Checker.\n+     *\n+     * @param tree the method invocation tree to check\n+     * @return whether the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return whether the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f81727d201bb9335f6992609dc89777f8c783c2"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02bba698cb153df0a4a4d47d30862e7445edad44", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/02bba698cb153df0a4a4d47d30862e7445edad44", "committedDate": "2020-05-14T16:19:44Z", "message": "improve docs on the tree annotator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTczMDc0", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-411973074", "createdAt": "2020-05-14T16:21:28Z", "commit": {"oid": "02bba698cb153df0a4a4d47d30862e7445edad44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjoyMToyOFrOGVkIvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjoyMToyOFrOGVkIvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NTM0MA==", "bodyText": "Wait, isn't the point that this annotator takes the receiver type and \"accumulates in\" the current method invocation?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r425265340", "createdAt": "2020-05-14T16:21:28Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -135,6 +135,14 @@ public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n             super(factory);\n         }\n \n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02bba698cb153df0a4a4d47d30862e7445edad44"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01cde05dbdf07f3202cb535b83de44e590435939", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/01cde05dbdf07f3202cb535b83de44e590435939", "committedDate": "2020-05-15T16:59:19Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48b0bc06b3447299ccf73bd01605d00b28807341", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/48b0bc06b3447299ccf73bd01605d00b28807341", "committedDate": "2020-05-15T17:36:12Z", "message": "Edits to manual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/1db3bcf35ce34724fbb2f868601ab10f198ead13", "committedDate": "2020-05-15T19:26:27Z", "message": "Changes from code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTE4NDQz", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-412918443", "createdAt": "2020-05-15T19:38:48Z", "commit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTozODo0OFrOGWRknw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMDowMzoyNlrOGWSPcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OQ==", "bodyText": "What are the requirements for top and bottom?\n\nMust they be instances of accumulator?  If top must be, I don't see the point of passing it explicitly.\nMust they be distinct from accumulator?\nMust they have a value field of String[] type?  The code seems to assume that top does, but I wonder if that assumption is warranted.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426009759", "createdAt": "2020-05-15T19:38:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDU1Nw==", "bodyText": "values is used/aliased without being copied.  That can be OK, but is worth documenting (or changing if it is not an intended part of the design).", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426010557", "createdAt": "2020-05-15T19:40:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY5NA==", "bodyText": "How about abstracting this into a field, to slightly improve efficiency?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426010694", "createdAt": "2020-05-15T19:40:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTAyOQ==", "bodyText": "How is this related to TOP and BOTTOM?  Is it definitely true of TOP, or only possibly true?  Is it definitely false of BOTTOM?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011029", "createdAt": "2020-05-15T19:41:40Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTE1OQ==", "bodyText": "Please use a more specific verb than \"handles\".", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011159", "createdAt": "2020-05-15T19:42:00Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTI1OQ==", "bodyText": "What does \"Mandatory\" mean here?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011259", "createdAt": "2020-05-15T19:42:12Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTYxMg==", "bodyText": "This comment may be true, but it doesn't say what the method does.  should it be \"... then give a method invocation the same type as the receiver\"?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011612", "createdAt": "2020-05-15T19:42:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMTk4NQ==", "bodyText": "\"i.e.\" implies they are the same.  They are .equals(), but not ==, I think:  the side effects won't affect the invoked method.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426011985", "createdAt": "2020-05-15T19:43:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMjI2Ng==", "bodyText": "The comment about the return type of the invorked method is not true for polymorphic methods.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426012266", "createdAt": "2020-05-15T19:44:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMjkzNA==", "bodyText": "I have a strong negative reaction to assignments within conditionals.\n\nThey are surprising and therefore liable to be overlooked or misinterpreted, especially given that \"=\" is a mathematical symbol for equality.\nThey are hard to reason about.\n\nPlease rewrite this code to avoid assignments within conditionals.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426012934", "createdAt": "2020-05-15T19:45:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMzUzNw==", "bodyText": "I am concerned about this call.  It is possible that receiverAnno is higher in the hierarchy than type, and so this would move the type up in the hierarchy (and override the method specification) rather than refining it.  Should this be GLB instead?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426013537", "createdAt": "2020-05-15T19:47:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMzg2Mw==", "bodyText": "top is either identical to, or equivalent in the type hierarchy to, acc().  So I would add \"= acc()\" here.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426013863", "createdAt": "2020-05-15T19:47:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNDk2Ng==", "bodyText": "This is assumes that TOP has no value field, or might have no value field.\nThat's rather subtle.  To make this (and other) code easier to read, please create a method isTop and use it.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426014966", "createdAt": "2020-05-15T19:50:14Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNjY5OQ==", "bodyText": "The use of LinkedHashSet seems pointless here, because a1Val will be in the wrong order afterward -- and anyway, createAccumulatorAnnotation always sorts its argument.\nHow about one of these?\n\nmake a1Val a TreeSet\nmake a1Val a LinkedList and instead of doing addAll, do a mergesort merge step?  That can be done efficiently in O(n) time.\n\nWith either of these approaches, you can have a private createAccumulatorAnnotationFromSorted routine that takes a sorted list and doesn't need to call sort.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426016699", "createdAt": "2020-05-15T19:54:00Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNzcyMw==", "bodyText": "This does not have to be a LinkedHashSet.  A HashSet will give the same results.  Though with a LinkedHashSet (or just a LinkedList for both variables is more efficient), you can do an O(n) instead of O(n log n) pass to remove duplicates, and then call a createAccumulatorAnnotationFromSorted routine to avoid subsequent calls to sort.\n(More generally, it seems the code is trying to retain order to reduce the need for sorting, but then it does not take advantage of that (except insofar as sort may run faster on a partially-sorted array).", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426017723", "createdAt": "2020-05-15T19:56:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODE4Mw==", "bodyText": "This uses a different test for top than !AnnotationUtils.hasElementValue(a1, \"value\") above.  Abstract it out into a method call, throughout.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018183", "createdAt": "2020-05-15T19:57:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return TOP;\n+            }\n+        }\n+\n+        /** isSubtype in this type system is subset. */\n+        @Override\n+        public boolean isSubtype(final AnnotationMirror subAnno, final AnnotationMirror superAnno) {\n+            if (AnnotationUtils.areSame(subAnno, BOTTOM)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(superAnno, BOTTOM)) {\n+                return false;\n+            }\n+\n+            if (AnnotationUtils.areSame(superAnno, TOP)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODUzOQ==", "bodyText": "Since both lists are sorted, this can use an O(n) algorithm rather than the O(n^2) algorithm in List.containsAll.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018539", "createdAt": "2020-05-15T19:58:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,296 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror TOP;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror BOTTOM;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> ACC;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy\n+     * @param bottom the bottom type in the hierarchy\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        TOP = AnnotationBuilder.fromClass(elements, top);\n+        BOTTOM = AnnotationBuilder.fromClass(elements, bottom);\n+        ACC = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values} in sorted order.\n+     *\n+     * @param values the arguments to the annotation\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(final String... values) {\n+        if (values.length == 0) {\n+            return TOP;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, ACC);\n+        Arrays.sort(values);\n+        builder.setValue(\"value\", values);\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, ACC);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /** Handles fluent APIs using the Returns Receiver Checker. */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Mandatory constructor.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * If a method returns its receiver, and the receiver has an accumulation type, then the\n+         * default type of its return value is the type of the receiver.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type of that tree (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                // Fetch the current type of the receiver, or top if none exists.\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType;\n+                AnnotationMirror receiverAnno;\n+\n+                if (receiverTree != null\n+                        && (receiverType = getAnnotatedType(receiverTree)) != null) {\n+                    receiverAnno = receiverType.getAnnotationInHierarchy(TOP);\n+                } else {\n+                    receiverAnno = TOP;\n+                }\n+\n+                type.replaceAnnotation(receiverAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *       top\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return TOP;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM) || AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return BOTTOM;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return BOTTOM;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, BOTTOM)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, BOTTOM)) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a1, \"value\")) {\n+                return a1;\n+            }\n+\n+            if (!AnnotationUtils.hasElementValue(a2, \"value\")) {\n+                return a2;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                Set<String> a1Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1));\n+                Set<String> a2Val =\n+                        new LinkedHashSet<>(\n+                                ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2));\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val.toArray(new String[0]));\n+            } else {\n+                return TOP;\n+            }\n+        }\n+\n+        /** isSubtype in this type system is subset. */\n+        @Override\n+        public boolean isSubtype(final AnnotationMirror subAnno, final AnnotationMirror superAnno) {\n+            if (AnnotationUtils.areSame(subAnno, BOTTOM)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(superAnno, BOTTOM)) {\n+                return false;\n+            }\n+\n+            if (AnnotationUtils.areSame(superAnno, TOP)) {\n+                return true;\n+            }\n+            if (AnnotationUtils.areSame(subAnno, TOP)) {\n+                return false;\n+            }\n+\n+            List<String> subVal = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(subAnno);\n+            List<String> superVal =\n+                    ValueCheckerUtils.getValueOfAnnotationWithStringArgument(superAnno);\n+            return subVal.containsAll(superVal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxODY5Mw==", "bodyText": "What does \"Required\" mean to convey here?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426018693", "createdAt": "2020-05-15T19:58:37Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTIzMw==", "bodyText": "The first sentence says this method is about receivers, but a.b().c() is not the receiver nor within the reciever.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019233", "createdAt": "2020-05-15T19:59:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTgwOQ==", "bodyText": "Does \"not affected\" mean they are not updated, or they are updated as if all the methods had been deterministic, or they are updated (not \"not updated\"), but maybe in a different way than if all the methods had been deterministic?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019809", "createdAt": "2020-05-15T20:01:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxOTg5Mg==", "bodyText": "Please be more specific.  Is this union?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426019892", "createdAt": "2020-05-15T20:01:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDI1NQ==", "bodyText": "getNewAnno is a vague name that I found confusing at call sites.  Please rename it.  Should \"New\" in the name be replaced by \"Glb\"?  (Or possibly by \"Union\"?)", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426020255", "createdAt": "2020-05-15T20:02:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getNewAnno(AnnotatedTypeMirror oldType, String[] newValues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAyMDcyMw==", "bodyText": "How can !typeFactory.isAccumulatorAnnotation(oldAnno) be true?  Is that an error?  Or is it a funny way to test for BOTTOM and (in some type systems) TOP?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426020723", "createdAt": "2020-05-15T20:03:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate} or\n+ * {@link #accumulate(MethodInvocationNode, TransferResult, String...)} methods to accumulate a\n+ * string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Required constructor.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(node.getTree());\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        insertIntoStores(result, node, newAnno);\n+    }\n+\n+    /**\n+     * Updates the estimate for the receiver and any other receiver-returning methods in a chain\n+     * with this MethodInvocationNode to include the new values.\n+     *\n+     * <p>For example, if the argument is the expression {@code a.b().c()}, the new value is \"foo\",\n+     * and b and c return their receiver (and are deterministic), all of the expressions {@code a},\n+     * {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include \"foo\". If\n+     * any method in the chain is non-deterministic, its estimate will not be updated (but the rest\n+     * of the chain is not affected).\n+     *\n+     * @param node a method invocation whose receiver is to be updated\n+     * @param result the result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(\n+            MethodInvocationNode node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Node receiver = node.getTarget().getReceiver();\n+        AnnotatedTypeMirror oldType = typeFactory.getReceiverType(node.getTree());\n+        // e.g. if the node being visited is static\n+        if (oldType == null) {\n+            return;\n+        }\n+        AnnotationMirror newAnno = getNewAnno(oldType, values);\n+        while (receiver != null) {\n+            // Note that this call doesn't do anything if receiver is a method call\n+            // that is not deterministic, though it can still continue to recurse.\n+            insertIntoStores(result, receiver, newAnno);\n+\n+            Tree receiverTree = receiver.getTree();\n+            // Possibly recurse: if the receiver is itself a method call,\n+            // then we need to also propagate this new information to its receiver\n+            // if the method being called has an @This return type.\n+            //\n+            // Note that we must check for null, because the tree could be\n+            // implicit (when calling an instance method on the class itself).\n+            // In that case, do not attempt to refine either - the receiver is\n+            // not a method invocation, anyway.\n+            if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                // Do not continue, because the receiver isn't a method invocation itself. The\n+                // end of the chain of calls has been reached.\n+                break;\n+            }\n+\n+            MethodInvocationTree receiverAsMethodInvocation =\n+                    (MethodInvocationTree) receiver.getTree();\n+\n+            if (typeFactory.returnsThis(receiverAsMethodInvocation)) {\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            } else {\n+                // Do not continue, because the method does not return @This.\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Combines the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getNewAnno(AnnotatedTypeMirror oldType, String[] newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {\n+            oldAnno = typeFactory.TOP;\n+        } else {\n+            oldAnno = oldType.getAnnotationInHierarchy(typeFactory.TOP);\n+            if (oldAnno == null || !typeFactory.isAccumulatorAnnotation(oldAnno)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db3bcf35ce34724fbb2f868601ab10f198ead13"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb5efe95df0d097be0721dc3b93c8aba41ca475e", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/bb5efe95df0d097be0721dc3b93c8aba41ca475e", "committedDate": "2020-05-15T21:31:49Z", "message": "correct capitalization of almost-constants :)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecaa1e0c5a7203ea779504339f7390d15d9524c7", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/ecaa1e0c5a7203ea779504339f7390d15d9524c7", "committedDate": "2020-05-15T21:50:41Z", "message": "make explicit the requirements on the top and bottom types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018bd1412720667387d8921a87a1b11b70bdd7a4", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/018bd1412720667387d8921a87a1b11b70bdd7a4", "committedDate": "2020-05-15T21:56:50Z", "message": "address todos in manual section"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99b0557eafb3bb6a2ef1b292cdb02cc08902323", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/e99b0557eafb3bb6a2ef1b292cdb02cc08902323", "committedDate": "2020-05-16T00:00:39Z", "message": "address remaining code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92430a9ef17881cea00737a17bed1c5db843c50a", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/92430a9ef17881cea00737a17bed1c5db843c50a", "committedDate": "2020-05-18T16:18:49Z", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac7e9dd3a9832dee698dd4daa8859bc848d98ad0", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/ac7e9dd3a9832dee698dd4daa8859bc848d98ad0", "committedDate": "2020-05-18T16:30:55Z", "message": "fix docS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a31f3904b80bd78307d891af77e700c42a45534", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/5a31f3904b80bd78307d891af77e700c42a45534", "committedDate": "2020-05-18T18:11:16Z", "message": "Add comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33f5bc1f6c43935251779356cf29c40ae141c170", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/33f5bc1f6c43935251779356cf29c40ae141c170", "committedDate": "2020-05-18T18:12:41Z", "message": "Split a paragraph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8401eb53c2eb37f39e5bd68b4b6ac9365f3113cd", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8401eb53c2eb37f39e5bd68b4b6ac9365f3113cd", "committedDate": "2020-05-18T19:49:55Z", "message": "Comment tweaks and a few logic simplifications"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/6047e3987fbc00fbbf23b6b115a40086d86eea57", "committedDate": "2020-05-18T19:50:15Z", "message": "Merge branch 'accumulation-analysis' of github.com:kelloggm/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzODk1MzUx", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-413895351", "createdAt": "2020-05-18T19:53:32Z", "commit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTo1MzozMlrOGXFbBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMDoyNjozOFrOGXLt_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTI2OQ==", "bodyText": "I don't see the need for a distinct top annotation.  I think that users can use @Accum() instead of @AccumTop.\n\nFewer annotations means less work for implementers and less for users to learn (less documentation to read).\n\"Top\" is type system jargon.  Let's avoid that were possible.\nIt's confusing to users to have two different ways to express the same concept: @Accum() and @AccumTop.  I am also concerned that error messages will refer to @AccumTop when the users wrote @Accum(), which may confuse them.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426859269", "createdAt": "2020-05-18T19:53:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1OTc1Mw==", "bodyText": "Facts like the existence of a single argument named \"value\" are testable in this method.  Users are likely to violate the requirements, unfortunately.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426859753", "createdAt": "2020-05-18T19:54:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDc4MA==", "bodyText": "What is the reason for permitting null as a value?  It is not used in the given code.  I think client code will be clearer if it uses Collections.emptyList(); it isn't obvious what null would be a special value for (a user might think it means bottom).  And, having two ways to accomplish the same goal can be confusing.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426860780", "createdAt": "2020-05-18T19:56:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MTE1Ng==", "bodyText": "It's usually clearer to name rules rather than number them.  That also insulates against renumbering or reordering.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426861156", "createdAt": "2020-05-18T19:57:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MjA2Ng==", "bodyText": "Minor: leastUpperBound uses else if rather than a second if.  We might as well make them consistent to avoid readers doing a double-take.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426862066", "createdAt": "2020-05-18T19:59:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MzA2NA==", "bodyText": "How can this happen?  (Maybe if there are other types than top, accumulator, and bottom?  But in that case clients should either use a different type hierarchy or should ensure that other types never flow to here.)\nI suggest making this throw an exception rather than silently returning bottom.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426863064", "createdAt": "2020-05-18T20:01:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return bottom;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MzI0MQ==", "bodyText": "Same question as above about whether this should be an error.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426863241", "createdAt": "2020-05-18T20:01:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The canonical top annotation for this accumulation checker. */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param top the top type in the hierarchy, which must be a supertype of {@code accumulator}.\n+     *     The top type should be an annotation with no arguments.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> top,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.top = AnnotationBuilder.fromClass(elements, top);\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.accumulator = accumulator;\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of the accumulator annotation that contains the elements of {@code\n+     * values}.\n+     *\n+     * @param values the arguments to the annotation. The values can contain duplicates and can be\n+     *     in any order.\n+     * @return an annotation mirror representing the accumulator annotation with {@code values}'s\n+     *     arguments, or top if {@code values} is null or empty\n+     */\n+    public AnnotationMirror createAccumulatorAnnotation(@Nullable List<String> values) {\n+        if (values == null || values.size() == 0) {\n+            return top;\n+        }\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, accumulator);\n+        builder.setValue(\"value\", ValueCheckerUtils.removeDuplicates(values));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Returns true if the return type of the given method invocation tree has an @This annotation\n+     * from the Returns Receiver Checker.\n+     *\n+     * @param tree a method invocation tree\n+     * @return true if the method being invoked returns its receiver\n+     */\n+    public boolean returnsThis(final MethodInvocationTree tree) {\n+        // Must call `getTypeFactoryOfSubchecker` each time, not store and reuse.\n+        ReturnsReceiverAnnotatedTypeFactory rrATF =\n+                getTypeFactoryOfSubchecker(ReturnsReceiverChecker.class);\n+        ExecutableElement methodEle = TreeUtils.elementFromUse(tree);\n+        AnnotatedTypeMirror methodAtm = rrATF.getAnnotatedType(methodEle);\n+        AnnotatedTypeMirror rrType =\n+                ((AnnotatedTypeMirror.AnnotatedExecutableType) methodAtm).getReturnType();\n+        return rrType != null && rrType.hasAnnotation(This.class);\n+    }\n+\n+    /**\n+     * Is the given annotation an accumulator annotation?\n+     *\n+     * @param anm an annotation mirror\n+     * @return true if the annotation mirror is an instance of this factory's accumulator annotation\n+     */\n+    public boolean isAccumulatorAnnotation(AnnotationMirror anm) {\n+        return AnnotationUtils.areSameByClass(anm, accumulator);\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new AccumulationTreeAnnotator(this));\n+    }\n+\n+    /**\n+     * This tree annotator implements the following rule(s): 1. If a method returns its receiver,\n+     * and the receiver has an accumulation type, then the default type of the method's return value\n+     * is the type of the receiver.\n+     */\n+    protected class AccumulationTreeAnnotator extends TreeAnnotator {\n+\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public AccumulationTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        /**\n+         * Implements rule 1.\n+         *\n+         * @param tree a method invocation tree\n+         * @param type the type {@code tree} (i.e. the return type of the invoked method). Is\n+         *     (possibly) side-effected by this method.\n+         * @return nothing, works by side-effect on {@code type}\n+         */\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            if (returnsThis(tree)) {\n+                // There is a @This annotation on the return type of the invoked method.\n+\n+                ExpressionTree receiverTree = TreeUtils.getReceiverTree(tree.getMethodSelect());\n+                AnnotatedTypeMirror receiverType =\n+                        receiverTree == null ? null : getAnnotatedType(receiverTree);\n+                // The current type of the receiver, or top if none exists.\n+                AnnotationMirror receiverAnno =\n+                        receiverType == null ? top : receiverType.getAnnotationInHierarchy(top);\n+\n+                AnnotationMirror returnAnno = type.getAnnotationInHierarchy(top);\n+                type.replaceAnnotation(qualHierarchy.greatestLowerBound(returnAnno, receiverAnno));\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+    }\n+\n+    @Override\n+    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n+        return new AccumulationQualifierHierarchy(factory);\n+    }\n+\n+    /**\n+     * All accumulation analyses share a similar type hierarchy. This hierarchy implements the\n+     * subtyping, LUB, and GLB for that hierarchy. The lattice looks like:\n+     *\n+     * <pre>\n+     *    top = acc()\n+     *      /   \\\n+     * acc(x)   acc(y) ...\n+     *      \\   /\n+     *     acc(x,y) ...\n+     *        |\n+     *      bottom\n+     * </pre>\n+     */\n+    protected class AccumulationQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+\n+        /**\n+         * Create the qualifier hierarchy\n+         *\n+         * @param factory the factory\n+         */\n+        public AccumulationQualifierHierarchy(MultiGraphFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public AnnotationMirror getTopAnnotation(final AnnotationMirror start) {\n+            return top;\n+        }\n+\n+        /**\n+         * GLB in this type system is set union of the arguments of the two annotations, unless one\n+         * of them is bottom, in which case the result is also bottom.\n+         */\n+        @Override\n+        public AnnotationMirror greatestLowerBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom) || AnnotationUtils.areSame(a2, bottom)) {\n+                return bottom;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top)) {\n+                return a2;\n+            }\n+\n+            if (AnnotationUtils.areSame(a2, top)) {\n+                return a1;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.addAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return bottom;\n+            }\n+        }\n+\n+        /**\n+         * LUB in this type system is set intersection of the arguments of the two annotations,\n+         * unless one of them is bottom, in which case the result is the other annotation.\n+         */\n+        @Override\n+        public AnnotationMirror leastUpperBound(\n+                final AnnotationMirror a1, final AnnotationMirror a2) {\n+            if (AnnotationUtils.areSame(a1, bottom)) {\n+                return a2;\n+            } else if (AnnotationUtils.areSame(a2, bottom)) {\n+                return a1;\n+            }\n+\n+            if (AnnotationUtils.areSame(a1, top) || AnnotationUtils.areSame(a2, top)) {\n+                return top;\n+            }\n+\n+            if (isAccumulatorAnnotation(a1) && isAccumulatorAnnotation(a2)) {\n+                List<String> a1Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a1);\n+                List<String> a2Val = ValueCheckerUtils.getValueOfAnnotationWithStringArgument(a2);\n+                a1Val.retainAll(a2Val);\n+                return createAccumulatorAnnotation(a1Val);\n+            } else {\n+                return top;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDMxMg==", "bodyText": "\"any deterministic methods\": they might follow it, as in a.b().nondet().c().d() where b, c, and d are deterministic.  Do the values go through nondet() and affect all of b(), c(), and d()?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960312", "createdAt": "2020-05-19T00:18:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDU2Mg==", "bodyText": "\"the ultimate receiver\": this isn't clear.  I think you mean a in your examples, but I'm not sure.  The receiver value is identical, so I'm not sure what this means.  It's only the expressions that differ.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960562", "createdAt": "2020-05-19T00:19:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MDg3OQ==", "bodyText": "Why is asList called?  The callee, getCombinedAnno, will make a copy anyway.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426960879", "createdAt": "2020-05-19T00:20:59Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTMwNw==", "bodyText": "The documentation is clear, but I still find \"getCombinedAnno\" unclear since it's not the annotations that are being combined (lubbed) but the values that are being combined (unioned).  I would change \"Combined\" in the method name to \"glb\" or \"union\" or \"accumulated\".", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961307", "createdAt": "2020-05-19T00:22:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTY0MQ==", "bodyText": "Why does this method treat null specially?  Are there places that null is more convenient to call?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961641", "createdAt": "2020-05-19T00:23:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MTk2NA==", "bodyText": "Is the logic in these lines similar to that in visitMethodInvocation?  If so, consider abstracting it out.\nOr, since getCombinedAnnotation is only called once, you could create a method getAnnotationMirror that calls getAnnotatedType and then calls this logic.  That seems like a logical place for it, and then this method could just take an AnnotationMirror as an argument.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426961964", "createdAt": "2020-05-19T00:24:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(\n+            @Nullable AnnotatedTypeMirror oldType, List<String> newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2MjQzMQ==", "bodyText": "I think this is a way of saying \"not top or bottom\".  It's surprising that combining any A with top has the same effect as combining A with bottom.  Is that intentional?  Should combining A with bottom lead to bottom?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r426962431", "createdAt": "2020-05-19T00:26:38Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the\n+     * types of any deterministic methods, and the ultimate receiver, will be updated).\n+     *\n+     * @param node the node whose estimate should be expanded\n+     * @param result the transfer result containing the store to be modified\n+     * @param values the new accumulation values\n+     */\n+    public void accumulate(Node node, TransferResult<CFValue, CFStore> result, String... values) {\n+        Tree tree = node.getTree();\n+        if (tree == null) {\n+            return;\n+        }\n+        AnnotatedTypeMirror oldType = typeFactory.getAnnotatedType(tree);\n+        AnnotationMirror newAnno = getCombinedAnno(oldType, Arrays.asList(values));\n+        insertIntoStores(result, node, newAnno);\n+\n+        if (tree.getKind() == Kind.METHOD_INVOCATION) {\n+            MethodInvocationNode methodInvocationNode = (MethodInvocationNode) node;\n+            Node receiver = methodInvocationNode.getTarget().getReceiver();\n+            MethodInvocationTree invokedMethod = (MethodInvocationTree) tree;\n+\n+            while (receiver != null && typeFactory.returnsThis(invokedMethod)) {\n+                // Note that this call doesn't do anything if receiver is a method call\n+                // that is not deterministic, though it can still continue to recurse.\n+                insertIntoStores(result, receiver, newAnno);\n+\n+                Tree receiverTree = receiver.getTree();\n+                // Possibly recurse: if the receiver is itself a method call,\n+                // then we need to also propagate this new information to its receiver\n+                // if the method being called has an @This return type.\n+                //\n+                // Note that we must check for null, because the tree could be\n+                // implicit (when calling an instance method on the class itself).\n+                // In that case, do not attempt to refine either - the receiver is\n+                // not a method invocation, anyway.\n+                if (receiverTree == null || receiverTree.getKind() != Tree.Kind.METHOD_INVOCATION) {\n+                    // Do not continue, because the receiver isn't a method invocation itself. The\n+                    // end of the chain of calls has been reached.\n+                    break;\n+                }\n+\n+                invokedMethod = (MethodInvocationTree) receiver.getTree();\n+                receiver = ((MethodInvocationNode) receiver).getTarget().getReceiver();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unions the values in oldType with the values in newValues to produce a single accumulator\n+     * type qualifier.\n+     *\n+     * @param oldType an annotated type mirror whose values should be included, or null which is\n+     *     treated as top\n+     * @param newValues new values to include\n+     * @return an annotation representing all the values\n+     */\n+    private AnnotationMirror getCombinedAnno(\n+            @Nullable AnnotatedTypeMirror oldType, List<String> newValues) {\n+        AnnotationMirror oldAnno;\n+        if (oldType == null) {\n+            oldAnno = typeFactory.top;\n+        } else {\n+            oldAnno = oldType.getAnnotationInHierarchy(typeFactory.top);\n+            if (oldAnno == null) {\n+                oldAnno = typeFactory.top;\n+            }\n+        }\n+        List<String> allValues = new ArrayList<>(newValues);\n+        if (typeFactory.isAccumulatorAnnotation(oldAnno)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6047e3987fbc00fbbf23b6b115a40086d86eea57"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01cbbe4d2783e65c2506d32b0cc2740a4eedcf00", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/01cbbe4d2783e65c2506d32b0cc2740a4eedcf00", "committedDate": "2020-05-28T16:00:07Z", "message": "Merge branch 'master' of github.com:typetools/checker-framework into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6550096079dd147767ab37d95025cbb5250f5a09", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/6550096079dd147767ab37d95025cbb5250f5a09", "committedDate": "2020-05-28T23:00:24Z", "message": "remove the need for a separate top type, and other miscellaneous improvements that go along with that"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6aa5275b5ef1f91dd8ba11bdcef87f0d5661500", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/b6aa5275b5ef1f91dd8ba11bdcef87f0d5661500", "committedDate": "2020-05-29T20:05:06Z", "message": "remove unnecessary null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5160f6978690c19dd51336995f76f7c1ba17ba34", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/5160f6978690c19dd51336995f76f7c1ba17ba34", "committedDate": "2020-05-29T20:32:44Z", "message": "add defensive logic to AccATF constructor to check that the accumulator annotation matches the requirements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba0c2ea62a7fcc2795b8825f65144839f8b1bd03", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/ba0c2ea62a7fcc2795b8825f65144839f8b1bd03", "committedDate": "2020-05-29T20:58:42Z", "message": "address remaining CR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a62ac9d69c8ba43aa8cea1ef1b530c1ececdc6ed", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/a62ac9d69c8ba43aa8cea1ef1b530c1ececdc6ed", "committedDate": "2020-05-29T23:09:08Z", "message": "thanks interning checkeR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/bd7e2283ffbdca30d18559ecb330c9428575ce8d", "committedDate": "2020-05-31T23:53:15Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f94fd08d98c987fe5929fe940f486fb5fd4e7ab", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/8f94fd08d98c987fe5929fe940f486fb5fd4e7ab", "committedDate": "2020-06-02T00:27:18Z", "message": "Documentation tweaks from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2652f871316a3dfc9f90b6bf77898942e2347a6", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/a2652f871316a3dfc9f90b6bf77898942e2347a6", "committedDate": "2020-06-02T04:23:11Z", "message": "Code review changes, mostly to documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c117619af274d50d2ec3681a5b2560d3a1faed3", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/0c117619af274d50d2ec3681a5b2560d3a1faed3", "committedDate": "2020-06-02T05:20:54Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0411993d94b694592dd4789b9a8bd7d1072de05", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/b0411993d94b694592dd4789b9a8bd7d1072de05", "committedDate": "2020-06-02T05:29:58Z", "message": "Tweak a test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzQzNDU1", "url": "https://github.com/typetools/checker-framework/pull/3306#pullrequestreview-422343455", "createdAt": "2020-06-02T05:02:13Z", "commit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNTowMjoxM1rOGdiIsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNToyOToxMFrOGdik8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTE2OQ==", "bodyText": "\"argument\" should be \"element\".\nThe test also fails if it has zero elements, so the message may be misleading.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621169", "createdAt": "2020-06-02T05:02:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTQzMw==", "bodyText": "This check, and the next one, are not about the annotation but about its value element, so the string created by rejectMalformedAccumulator is imprecise and possibly confusing.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621433", "createdAt": "2020-06-02T05:03:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");\n+        }\n+        Method value = accDeclaredMethods[0];\n+        if (value.getName() != \"value\") {\n+            rejectMalformedAccumulator(\"name its argument \\\"value\\\"\");\n+        }\n+        if (!value.getReturnType().isInstance(new String[0])) {\n+            rejectMalformedAccumulator(\"have an argument of type String[]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMTgyNA==", "bodyText": "A UserError is when a user passed wrong arguments to the Checker Framework.  It can be corrected by changing the run-time invocation.  A bug in the source code of a checker should be thrown as a BugInCF., even if that source code was written by someone other than the main Checker Framework developers.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433621824", "createdAt": "2020-06-02T05:04:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,311 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverAnnotatedTypeFactory;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * An annotated type factory for an accumulation checker.\n+ *\n+ * <p>New accumulation checkers should extend this class and implement a constructor, which should\n+ * take a {@link BaseTypeChecker} and call both the constructor defined in this class and {@link\n+ * #postInit()}.\n+ */\n+public abstract class AccumulationAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The canonical top annotation for this accumulation checker: an instance of the accumulator\n+     * annotation with no arguments.\n+     */\n+    public final AnnotationMirror top;\n+\n+    /** The canonical bottom annotation for this accumulation checker. */\n+    public final AnnotationMirror bottom;\n+\n+    /**\n+     * The annotation that accumulates things in this accumulation checker. Must be an annotation\n+     * with exactly one field named \"value\" whose type is a String array.\n+     */\n+    private final Class<? extends Annotation> accumulator;\n+\n+    /**\n+     * Create an annotated type factory for an accumulation checker.\n+     *\n+     * @param checker the checker\n+     * @param accumulator the accumulator type in the hierarchy. Must be an annotation with a single\n+     *     argument named \"value\" whose type is a String array.\n+     * @param bottom the bottom type in the hierarchy, which must be a subtype of {@code\n+     *     accumulator}. The bottom type should be an annotation with no arguments.\n+     */\n+    protected AccumulationAnnotatedTypeFactory(\n+            BaseTypeChecker checker,\n+            Class<? extends Annotation> accumulator,\n+            Class<? extends Annotation> bottom) {\n+        super(checker);\n+\n+        this.accumulator = accumulator;\n+\n+        // Check that the requirements of the accumulator are met.\n+        Method[] accDeclaredMethods = accumulator.getDeclaredMethods();\n+        if (accDeclaredMethods.length != 1) {\n+            rejectMalformedAccumulator(\"not have more than one argument\");\n+        }\n+        Method value = accDeclaredMethods[0];\n+        if (value.getName() != \"value\") {\n+            rejectMalformedAccumulator(\"name its argument \\\"value\\\"\");\n+        }\n+        if (!value.getReturnType().isInstance(new String[0])) {\n+            rejectMalformedAccumulator(\"have an argument of type String[]\");\n+        }\n+        if (((String[]) value.getDefaultValue()).length != 0) {\n+            rejectMalformedAccumulator(\"must have the empty string array {} as its default value\");\n+        }\n+\n+        this.bottom = AnnotationBuilder.fromClass(elements, bottom);\n+        this.top = createAccumulatorAnnotation(Collections.emptyList());\n+\n+        // Every subclass must call postInit!  This does not do so for subclasses.\n+        if (this.getClass() == AccumulationAnnotatedTypeFactory.class) {\n+            this.postInit();\n+        }\n+    }\n+\n+    /**\n+     * Common error message for malformed accumulator annotation.\n+     *\n+     * @param missing what is missing from the accumulator, suitable for use in this string to\n+     *     replace $MISSING$: \"The accumulator annotation Foo must $MISSING$.\"\n+     */\n+    private void rejectMalformedAccumulator(String missing) {\n+        throw new UserError(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTA5NA==", "bodyText": "\"the chain\" isn't really defined.  Can you define that term before you start discussing the behavior of the method?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433625094", "createdAt": "2020-06-02T05:17:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions\n+     * {@code a}, {@code a.b()}, and {@code a.b().c()} would have their estimates updated to include\n+     * \"foo\".\n+     *\n+     * <p>If any method in the chain is non-deterministic, its estimate will not be updated (but the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNTgzMg==", "bodyText": "Why is it important to mention that the method is deterministic?\nI think every method that returns its receiver is deterministic, so this would be a vacuous test and it's confusing why it is mentioned as an extra condition.", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433625832", "createdAt": "2020-06-02T05:20:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a\n+     * receiver-returning method invocation.\n+     *\n+     * <p>For example, suppose the argument is the expression {@code a.b().c()}, the new value is\n+     * \"foo\", and b and c return their receiver (and are deterministic). Then all of the expressions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNjY2OA==", "bodyText": "Please remove these comments, or indicate how they are actionable.  For example, is the programmer supposed to keep the two versions of the test in sync by making a duplicate pull request on the other repository?", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433626668", "createdAt": "2020-06-02T05:23:16Z", "author": {"login": "mernst"}, "path": "framework/tests/accumulation/Generics.java", "diffHunk": "@@ -0,0 +1,45 @@\n+// Copied from the Object Construction Checker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyODQwMg==", "bodyText": "Are there tests of this functionality?  Test SimpleFluent.java does not seem to test it.  I expect a test would look like\n  s.a().b().c();\n  s.build();", "url": "https://github.com/typetools/checker-framework/pull/3306#discussion_r433628402", "createdAt": "2020-06-02T05:29:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/accumulation/AccumulationTransfer.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package org.checkerframework.common.accumulation;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.Tree.Kind;\n+import java.util.Arrays;\n+import java.util.List;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.dataflow.analysis.FlowExpressions;\n+import org.checkerframework.dataflow.analysis.FlowExpressions.Receiver;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFTransfer;\n+import org.checkerframework.framework.flow.CFValue;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * The default transfer function for an accumulation checker.\n+ *\n+ * <p>Subclasses should call the {@link #accumulate(Node, TransferResult, String...)} accumulate}\n+ * method to accumulate a string at a particular program point.\n+ */\n+public class AccumulationTransfer extends CFTransfer {\n+\n+    /** The type factory. */\n+    protected final AccumulationAnnotatedTypeFactory typeFactory;\n+\n+    /**\n+     * Build a new AccumulationTransfer for the given analysis.\n+     *\n+     * @param analysis the analysis\n+     */\n+    public AccumulationTransfer(CFAnalysis analysis) {\n+        super(analysis);\n+        typeFactory = (AccumulationAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    /**\n+     * Updates the estimate of how many things {@code node} has accumulated.\n+     *\n+     * <p>If the node is an invocation of a method that returns its receiver, then its receiver's\n+     * type will also be updated. This chain will continue as long as each receiver is itself a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd7e2283ffbdca30d18559ecb330c9428575ce8d"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2abe73a6512ca901f516d94d08bbefcdd8fea55", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/d2abe73a6512ca901f516d94d08bbefcdd8fea55", "committedDate": "2020-06-03T16:54:23Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f71ee15c7552e35817990281d5943613989185f8", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/f71ee15c7552e35817990281d5943613989185f8", "committedDate": "2020-06-03T19:05:24Z", "message": "efficiency improvements Mike asked for, as best as I can tell"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20ef5525fcb14218821b3b6cc4ede71ee14bfaaa", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/20ef5525fcb14218821b3b6cc4ede71ee14bfaaa", "committedDate": "2020-06-03T19:21:28Z", "message": "address most code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6840005eb094e926f9cb69bde8304eafbdade16", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/d6840005eb094e926f9cb69bde8304eafbdade16", "committedDate": "2020-06-04T19:45:42Z", "message": "update some comments, add failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f2de7e8fd0bed28e9e8062ebccdb1dd782b5806", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/8f2de7e8fd0bed28e9e8062ebccdb1dd782b5806", "committedDate": "2020-06-05T18:41:00Z", "message": "handle failing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d13111da146e97cc91dd0bd290d00e1e2d36ef0c", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/d13111da146e97cc91dd0bd290d00e1e2d36ef0c", "committedDate": "2020-06-05T19:57:08Z", "message": "fix javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03e87ece7e1fa945da00cd94009e4fb6ef279ec6", "author": {"user": {"login": "kelloggm", "name": "Martin Kellogg"}}, "url": "https://github.com/typetools/checker-framework/commit/03e87ece7e1fa945da00cd94009e4fb6ef279ec6", "committedDate": "2020-06-05T21:00:20Z", "message": "don't include literal @"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3109b72ad30f592298391d7e39ad50913b3ec420", "author": {"user": {"login": "mernst", "name": "Michael Ernst"}}, "url": "https://github.com/typetools/checker-framework/commit/3109b72ad30f592298391d7e39ad50913b3ec420", "committedDate": "2020-06-08T20:39:17Z", "message": "Merge ../checker-framework-branch-master into accumulation-analysis"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2987, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}