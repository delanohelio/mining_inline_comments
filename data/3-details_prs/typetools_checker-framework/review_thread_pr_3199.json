{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0Mzk1MTE0", "number": 3199, "reviewThreads": {"totalCount": 96, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzozM1rODr4V0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1ODoyM1rOD3Zapw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzM4NDQ5OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzozM1rOF8fAOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzozM1rOF8fAOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2Njg0MA==", "bodyText": "Please remove any extraneous whitespace changes, like this one.  They make review more difficult.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398966840", "createdAt": "2020-03-27T00:17:33Z", "author": {"login": "msridhar"}, "path": "build.gradle", "diffHunk": "@@ -55,6 +55,7 @@ ext {\n     // This value is always overwritten, but Gradle needs the variable to be initialized.\n     localRepo = \".git\"\n }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzM4NDk4OnYy", "diffSide": "RIGHT", "path": "framework/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzo0NVrOF8fAdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoxNzo0NVrOF8fAdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2NjkwMw==", "bodyText": "Remove checkerFramework", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398966903", "createdAt": "2020-03-27T00:17:45Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -15,6 +15,14 @@ sourceSets {\n     }\n }\n \n+ext {\n+    versions = [\n+            checkerFramework: \"3.1.1\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzM5NjUzOnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/AutoValueTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMDoyMzozM1rOF8fG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMTowN1rOF84FXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg==", "bodyText": "@kelloggm do we want these tests and the test data in returnsrcvr sub-folders?  Or should we keep everything at the top level, in which case we should rename tests, e.g., to ReturnsRcvrAutoValueTest?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398968532", "createdAt": "2020-03-27T00:23:33Z", "author": {"login": "msridhar"}, "path": "framework/src/test/java/tests/AutoValueTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Nzc1Nw==", "bodyText": "I think keeping them at the top level is fine, but we should rename them as you suggested. The actual test data should definitely be in a returnsrcvr folder, though", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399377757", "createdAt": "2020-03-27T16:11:07Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/AutoValueTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg=="}, "originalCommit": {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODM2MDg3OnYy", "diffSide": "RIGHT", "path": "framework/build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQyMTo1MDoyMVrOF9MlsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjowMzo1OVrOGAb2Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMzcxMg==", "bodyText": "For reviewers: this means the Checker Framework will rely on the AutoValue annotations artifact.  This only contains AutoValue annotations, not any of the AutoValue annotation processors.  We could remove this dependence if desired, but it will require adding some reflection to the checker.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399713712", "createdAt": "2020-03-28T21:50:21Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +36,14 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in returns receiver checker\n+    implementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTA2Nw==", "bodyText": "I only see one import lombok and that appears in test code and that annotation is already here: https://github.com/typetools/checker-framework/blob/master/checker/src/testannotations/java/lombok/NonNull.java\nSo why do we need a lombok dependency?\nThe lombok annotations are already checked using just strings. Why can't the same be done for AutoValue.Builder in Framework? That is, check for the annotation using a string and add a testannotation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055067", "createdAt": "2020-04-03T14:42:13Z", "author": {"login": "wmdietl"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +36,14 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in returns receiver checker\n+    implementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMzcxMg=="}, "originalCommit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEwOTM5MA==", "bodyText": "We can probably get rid of the Lombok test dependency, sure.\nWe will get rid of the AutoValue annotations implementation as well.  There is a small safety loss, but I think it's worth it to avoid the dependency.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403109390", "createdAt": "2020-04-03T16:03:59Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +36,14 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in returns receiver checker\n+    implementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcxMzcxMg=="}, "originalCommit": {"oid": "ed02ca65fd427780a729589976818098433543f1"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODQ3MzcyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQwMDozOTo1OFrOF9Nbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNjo1NDozNlrOF9zJOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA==", "bodyText": "Each annotation's Javadoc should link to its manual chapter, to enable users to learn more.\nThe bottom type should additionally link to https://checkerframework.org/manual/#bottom-type.\nSee how other qualifiers do this, for example https://checkerframework.org/api/org/checkerframework/checker/nullness/qual/KeyForBottom.html .\nEven more importantly, say what the annotation means.  (The fact that it's the bottom type is relevant but isn't the most important information.)  For example, is null the only value of this type?\nThese comments apply to other annotations as well.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727494", "createdAt": "2020-03-29T00:39:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxNjI4OA==", "bodyText": "Hi @mernst, I see this documentation in the manual for other bottom types:\n\nThis is the bottom type for the XYZ type system. It should never need to be written by the programmer.\n\nIs that sufficient here?  I'm honestly not even sure what values (if any) take on the bottom type in the returns receiver type system.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400316288", "createdAt": "2020-03-30T16:11:53Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NTQwMA==", "bodyText": "Yes, that is often sufficient.  Usually the only value of the bottom type is null, but sometimes that is different.  Knowing what values helps readers to understand the type.  If you can't figure it out, you could leave that off.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400345400", "createdAt": "2020-03-30T16:54:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3ODQ3NTM4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQwMDo0MzoxN1rOF9NcUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQwMDo0MzoxN1rOF9NcUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzY5OA==", "bodyText": "The @This annotation does not represent a method.  Please rephrase.\nNit: please end sentences with punctuation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727698", "createdAt": "2020-03-29T00:43:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/** This represent methods that returns {@code this} */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE1ODgwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNToyODozM1rOF9Sp7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMToxMTozMFrOF-oZWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ==", "bodyText": "From this documentation, I cannot tell what a FrameworkSupport is.  Documentation for a type should indicate what it represents.  (And possibly should include other information such as how to use it.)\nFrom later reading, I'm not sure why this needs to be an interface with multiple implementations.\nWhy not just have a method in the Returns Receiver Checker that takes a framework as an argument, or takes a list of frameworks as an argument, and has a switch statement and inlines the definitions?  Or why not put the method in the Framework class?  Either of these designs seems simpler than the FrameworkSupport interface.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813101", "createdAt": "2020-03-29T15:28:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** To add support for frameworks that need to have {@code @This} in certain generated methods */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNzg4MA==", "bodyText": "Our plan here is to just put the method inside each enum element in the Framework class; thanks for pointing this out.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401217880", "createdAt": "2020-03-31T21:11:30Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** To add support for frameworks that need to have {@code @This} in certain generated methods */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ=="}, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE1OTc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNToyOToyMlrOF9SqaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNToyOToyMlrOF9SqaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzIyNA==", "bodyText": "Please indicate what the class does or is used for.  This comment doesn't tell the reader anything that the class name does not.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813224", "createdAt": "2020-03-29T15:29:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE2MDkyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMDoyNFrOF9Sq-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMDoyNFrOF9Sq-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzM3MA==", "bodyText": "If it is non-instantiable, the constructor must throw an error.  Making the constructor return normally lets errors creep in later.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813370", "createdAt": "2020-03-29T15:30:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE2MTM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMDo1N1rOF9SrPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMDo1N1rOF9SrPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQzOA==", "bodyText": "Please spell names correctly.  There should be no space in \"AutoValue\".", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813438", "createdAt": "2020-03-29T15:30:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE2MTQ2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMToxMVrOF9SrVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMToxMVrOF9SrVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQ2MQ==", "bodyText": "Please spell names correctly.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813461", "createdAt": "2020-03-29T15:31:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE2MzI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMzoxMFrOF9SsSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMzoxMFrOF9SsSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzcwNQ==", "bodyText": "It seems inside-out to make the framework class a nested class and the utilities be the top-level class.\nAlso, why is this an inner class rather than a static nested class?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813705", "createdAt": "2020-03-29T15:33:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE2NDAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMzo0MVrOF9Ssog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTozMzo0MVrOF9Ssog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzc5NA==", "bodyText": "Really, if it has an annotation of the given class.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813794", "createdAt": "2020-03-29T15:33:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Determine the framework supports that should be disabled according to the flag {@code\n+     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n+     *\n+     * @param option a comma-separated list of frameworks whose support should be disabled\n+     * @return an EnumSet of all framework supports in use\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFrameworkSupport.toUpperCase()) {\n+                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSet.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n+                        frameworkSet.remove(Framework.LOMBOK);\n+                        break;\n+                }\n+            }\n+        }\n+        return frameworkSet;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has the annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE3NjA2OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0NTo0MlrOF9Sy0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0NTo0MlrOF9Sy0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTM3OA==", "bodyText": "This is an odd topic sentence for the paragraph.  What is the paragraph about?  The topic sentence should convey that.  This information is relevant to the @This information and belongs there.\nDon't use jargon like \"polymorphic\" without explaining it.  Here you are just saying that it only has to be written on the return type, not on the receiver.  Do you even need to say that it doesn't need to be written on the receiver?  Just saying that it only needs to be written on the return type is problably enough.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815378", "createdAt": "2020-03-29T15:45:42Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE3NzI2OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0NzowM1rOF9Szdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0NzowM1rOF9Szdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTU0Mw==", "bodyText": "More generally, this whole section doesn't seem very useful to readers.  It describes warnings in vague terms without any examples.  If you are worried that the warnings are not clear to users, then improve the warning text.  I suggest removing this whole section except the parts that are documentation of the @This qualifier, which should be moved.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815543", "createdAt": "2020-03-29T15:47:03Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE3ODEyOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0Nzo1NVrOF9Sz5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0Nzo1NVrOF9Sz5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTY1NQ==", "bodyText": "Where it may be written is useful and essential documentation that belongs in the documentation of @This (probably both in the manual and in the Javadoc, since you don't know which one a reader will see), not in a \"warnings\" section.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815655", "createdAt": "2020-03-29T15:47:55Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE3OTI5OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0OTowMlrOF9S0eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo0OTowMlrOF9S0eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNTgwMQ==", "bodyText": "As explained at https://checkerframework.org/manual/#creating-documenting-a-checker, please list every annotation and draw a diagram.  Every annotation must be listed because users will search the manual for them.  The diagram is more effective at conveying the type hierarchy than text alone is.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399815801", "createdAt": "2020-03-29T15:49:02Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4MDgwOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1MDoyOFrOF9S1SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1MDoyOFrOF9S1SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjAwOA==", "bodyText": "\"Framework support\" is vague:  a reader can't tell from the section title what the section is about.  And it's confusing given that the Checker Framework is a framework.  Just be direct and say \"AutoValue and Lombok support\".", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816008", "createdAt": "2020-03-29T15:50:28Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4MTc3OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1MTozNlrOF9S1xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1MTozNlrOF9S1xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjEzMw==", "bodyText": "\"inject\" is jargon and implementation-specific.  Equally seriously, line 85 uses the word \"add\" for what is (I think) the same process.  Technical writing should always use the same word for the same concept.  Never use \"elegant variation\" as is recommended for novels.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816133", "createdAt": "2020-03-29T15:51:36Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4MzA3OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1Mjo0NFrOF9S2cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1Mjo0NFrOF9S2cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjMwNw==", "bodyText": "Start out by saying what these tools do:  they generate code.  That context is missing.\nThen, say that the generated code gets appropriate @This annotations.  (Users couldn't write that in any event.)\nI'm not sure you need to say much more than that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816307", "createdAt": "2020-03-29T15:52:44Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4NDE2OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1Mzo1MVrOF9S3DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1Mzo1MVrOF9S3DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjQ2MA==", "bodyText": "While writing this paragraph, you had code in mind.  But the reader doesn't know what it is, making the paragraph hard to follow.  Show the code, and show the annotations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816460", "createdAt": "2020-03-29T15:53:51Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4NjA0OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1NjowNVrOF9S4Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzo0OToyOVrOF_L4Ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjcxNQ==", "bodyText": "\"Disable ... support\" is vague and abstract.  Be specific:  to prevent inserting/injecting/adding (whatever term you use, though I would avoid \"inject\" since it suggests dependency injection) @This annotations in framework-generated code.\nAlso, state briefly why one would want to do that.  Otherwise the feature seems a bit mysterious to readers, and as a result they might not remember the feature nor use it properly.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816715", "createdAt": "2020-03-29T15:56:05Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class\n+\\<AutoValue\\_Animal.Builder> that extends \\<Animal.Builder> and implements its\n+abstract methods.  The Returns Receiver Checker automatically adds a\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation to the return type of\n+\\<Animal.Builder.setName> and \\<Animal.Builder.setNumberOfLegs>, and also to the\n+return types of those methods in the generated subclass.  The Returns Receiver\n+Checker still runs to ensure the implementation of the generated subclass is\n+consistent with the injected annotations.  Project Lombok Builders are supported\n+in a similar fashion.\n+\n+To disable the checker's built-in framework support, use the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5MjcwNA==", "bodyText": "To be honest, I don't recall why we added the ability to disable the framework support feature.  @kelloggm do you remember?  I seem to recall you thought it would be useful.  I could imagine disabling framework support might slightly speed up the checker, but this has never been measured.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401792704", "createdAt": "2020-04-01T17:38:29Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class\n+\\<AutoValue\\_Animal.Builder> that extends \\<Animal.Builder> and implements its\n+abstract methods.  The Returns Receiver Checker automatically adds a\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation to the return type of\n+\\<Animal.Builder.setName> and \\<Animal.Builder.setNumberOfLegs>, and also to the\n+return types of those methods in the generated subclass.  The Returns Receiver\n+Checker still runs to ensure the implementation of the generated subclass is\n+consistent with the injected annotations.  Project Lombok Builders are supported\n+in a similar fashion.\n+\n+To disable the checker's built-in framework support, use the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjcxNQ=="}, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NzE5Nw==", "bodyText": "It is necessary to run the machine image sniping check (and only that check) on projects that use AutoValue/Lombok. In those cases, we weren't interested in misuse of the frameworks, just in violations of the properties we'd encoded in our stub files.\nMore generally, it's useful because object construction via builders is a special-case of what the object construction checker's type system (called methods) is useful for.\nFor the RR checker, it's not clear to me why having the option is necessary, since it doesn't ever issue errors because of its framework support.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401797197", "createdAt": "2020-04-01T17:46:11Z", "author": {"login": "kelloggm"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class\n+\\<AutoValue\\_Animal.Builder> that extends \\<Animal.Builder> and implements its\n+abstract methods.  The Returns Receiver Checker automatically adds a\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation to the return type of\n+\\<Animal.Builder.setName> and \\<Animal.Builder.setNumberOfLegs>, and also to the\n+return types of those methods in the generated subclass.  The Returns Receiver\n+Checker still runs to ensure the implementation of the generated subclass is\n+consistent with the injected annotations.  Project Lombok Builders are supported\n+in a similar fashion.\n+\n+To disable the checker's built-in framework support, use the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjcxNQ=="}, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5OTI1MA==", "bodyText": "Good point.  I will go ahead and remove documentation of this option for the Returns Receiver Checker.  We can document it properly when we merge in the Object Construction Checker.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401799250", "createdAt": "2020-04-01T17:49:29Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}\n+    \\label{fig-autovalue-builder}\n+\\end{figure}\n+\n+For programs using builder generation support from\n+\\href{https://github.com/google/auto/tree/master/value}{AutoValue} or\n+\\href{https://projectlombok.org/}{Project Lombok}, the Returns Receiver Checker\n+will automatically inject \\refqualclass{common/returnsrcvr/qual}{This}\n+annotations on the return types of the fluent API methods of generated builders.\n+Consider the code using AutoValue in Figure~\\ref{fig-autovalue-builder}.  For\n+this code, AutoValue automatically generates a class\n+\\<AutoValue\\_Animal.Builder> that extends \\<Animal.Builder> and implements its\n+abstract methods.  The Returns Receiver Checker automatically adds a\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation to the return type of\n+\\<Animal.Builder.setName> and \\<Animal.Builder.setNumberOfLegs>, and also to the\n+return types of those methods in the generated subclass.  The Returns Receiver\n+Checker still runs to ensure the implementation of the generated subclass is\n+consistent with the injected annotations.  Project Lombok Builders are supported\n+in a similar fashion.\n+\n+To disable the checker's built-in framework support, use the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjcxNQ=="}, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4NzMyOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1NzoyOVrOF9S4uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1NzoyOVrOF9S4uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNjg5MQ==", "bodyText": "The fact that it is \"a code example\" is already obvious from the figure itself.  Try to avoid repeating the obvious.  (I had this same comment about some of your Javadoc.)  Use the caption to say what the point of the example is.  What does it demonstrate, or what does a reader learn from it?\nAlso, the caption should say what this code is.  Is it user-writtten code, automatically generated, or a combination?  Show the automatically-generated code separately, together with the automatically-added @This annotations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399816891", "createdAt": "2020-03-29T15:57:29Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The type annotation\n+\\refqualclass{common/returnsrcvr/qual}{This} on the return type of a method\n+indicates that the method returns its receiver.  The\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation should only be written\n+on the return type of a method, or (in rare cases) as part of a downcast.  When\n+using certain frameworks for the builder pattern,\n+\\refqualclass{common/returnsrcvr/qual}{This} annotations will be injected\n+automatically; see Section~\\ref{returns-receiver-checker-framework-support}.\n+\n+\n+\\sectionAndLabel{Warnings}{returns-receiver-checker-warnings}\n+\n+The \\refqualclass{common/returnsrcvr/qual}{This} annotation is a polymorphic\n+qualifier (see Section~\\ref{qualifier-polymorphism}).  When applied to a method\n+with an \\refqualclass{common/returnsrcvr/qual}{This} annotation on its return\n+type, the Returns Receiver Checker injects an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation on the method's receiver\n+parameter.  The presence of the polymorphic\n+\\refqualclass{common/returnsrcvr/qual}{This} qualifier on both the method's\n+return and receiver type force their types to be equal.  Hence, Checker\n+Framework's standard checking of type compatibility will discover cases where a\n+method is not properly returning its receiver.  When a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type returns some value\n+other than its receiver, the issue is reported as a\n+\\code{[return.type.incompatible]} warning.  Similarly, if a method with an\n+\\refqualclass{common/returnsrcvr/qual}{This} return type is overridden by a\n+method lacking \\refqualclass{common/returnsrcvr/qual}{This} on its return type,\n+the checker reports an \\code{[override.return.invalid]} warning.\n+\n+Additionally, an \\code{[invalid.this.location]} warning will be emitted if an\n+\\refqualclass{common/returnsrcvr/qual}{This} annotation is written in any\n+location other than on the return type of a method or in a downcast.\n+\n+\n+\\sectionAndLabel{Framework Support}{returns-receiver-checker-framework-support}\n+\n+\\begin{figure}\n+    \\begin{Verbatim}\n+    @AutoValue\n+    abstract class Animal {\n+        abstract String name();\n+        abstract int numberOfLegs();\n+        static Builder builder() {\n+            return new AutoValue_Animal.Builder();\n+        }\n+        @AutoValue.Builder\n+        abstract static class Builder {\n+            abstract Builder setName(String value);\n+            abstract Builder setNumberOfLegs(int value);\n+            abstract Animal build();\n+        }\n+    }\n+    \\end{Verbatim}\n+    \\caption{A code example using AutoValue's Builder support.}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTE4OTM3OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1OToxOVrOF9S5wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNTo1OToxOVrOF9S5wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxNzE1Mw==", "bodyText": "Neither the manual nor the Javadoc has an example of how to use the @This annotation.  Both should contain that.  Otherwise the documentation is abstract, hard to understand, and frustrating to users.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399817153", "createdAt": "2020-03-29T15:59:19Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,96 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDg5Nzg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNDo1NFrOF_pF2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMzo0Nzo0NFrOGBx3PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA==", "bodyText": "I find it surprising that this block is skipped for constructors, but the above block is not.  What is the reason for the discrepancy?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402277848", "createdAt": "2020-04-02T12:34:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxODcxNw==", "bodyText": "Restructured the logic so both blocks are skipped for constructors", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r404518717", "createdAt": "2020-04-07T03:47:44Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA=="}, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkwMDAyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNToyOVrOF_pHLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNToyOVrOF_pHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODE4OA==", "bodyText": "Make a field like THIS_ANNOTATION.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278188", "createdAt": "2020-04-02T12:35:29Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkwNDM2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNjo0MVrOF_pJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozNjo0MVrOF_pJ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODg3MQ==", "bodyText": "If you move the supported frameworks block first in the method, then you can delete these lines as they will be redundant.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278871", "createdAt": "2020-04-02T12:36:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {\n+                // check each supported framework\n+                for (FrameworkSupport frameworkSupport : frameworks) {\n+                    // see if the method in the framework should return this\n+                    if (frameworkSupport.returnsThis(t)) {\n+                        // add @This annotation\n+                        returnType.replaceAnnotation(THIS_ANNOTATION);\n+                        AnnotatedTypeMirror.AnnotatedDeclaredType receiverType =\n+                                t.getReceiverType();\n+                        receiverType.replaceAnnotation(THIS_ANNOTATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkxNDM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozOToxMlrOF_pP4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjozOToxMlrOF_pP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MDQxOQ==", "bodyText": "These comments are vacuous:  LOMBOK_SUPPORT is the string representation for LOMBOK_SUPPORT.\nUpon reading the code, I found out that these are the string representation of enum constants.\nIf so, they should be defined near the enum constants, not here in a different package.  Furthermore, there is no need for the enum constants.  It would be better to either iterate through the enum constants getting their toString representation.  (Or maybe create a method that takes a string and returns a matching enum constant.)\nBut, maybe these aren't needed at all if the Returns Receiver Checker doesn't need to support a --disableFrameworks command-line option.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402280419", "createdAt": "2020-04-02T12:39:12Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.source.SupportedOptions;\n+\n+/** Entry point for the Returns Receiver Checker. */\n+@SupportedOptions({ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT})\n+public class ReturnsReceiverChecker extends BaseTypeChecker {\n+    /** String representation for DISABLE_FRAMEWORK_SUPPORTS. */\n+    public static final String DISABLE_FRAMEWORK_SUPPORT = \"disableFrameworks\";\n+    /** String representation for LOMBOK_SUPPORT. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkxOTAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0MDozMlrOF_pSvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0MDozMlrOF_pSvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MTE0OA==", "bodyText": "This is a weird name.  What is a \"FrameworkSupport\"?  Each class should represent some clearly-defined concept.\nHere, I think that concept is a framework.  You could name this IFramework, but it would be better to structure the code not to need this class.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402281148", "createdAt": "2020-04-02T12:40:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * A framework supported by the Returns Receiver Checker. That is, some methods generated by the\n+ * framework return their receiver.\n+ */\n+public interface FrameworkSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkyNjAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0MjoyOFrOF_pXGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0MjoyOFrOF_pXGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MjI2Ng==", "bodyText": "How can the return type be null?\nI think it would be a bug in this method if inAnnotationValueBuilder is true but returnType is null.  In that case, I think it's better to throw an exception.  The same comment applies later in this file.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402282266", "createdAt": "2020-04-02T12:42:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework implements FrameworkSupport {\n+    /** AutoValue framework. */\n+    AUTO_VALUE {\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code\n+                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                // if enclosingType is an interface, the superclass has TypeKind NONE\n+                if (superclass.getKind() != TypeKind.NONE) {\n+                    // update enclosingElement to be for the superclass for this case\n+                    enclosingElement = TypesUtils.getTypeElement(superclass);\n+                    inAutoValueBuilder =\n+                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n+                }\n+            }\n+\n+            if (inAutoValueBuilder) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+                return returnType != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDkzNzYwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0NToyN1rOF_peQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0NToyN1rOF_peQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDA5OA==", "bodyText": "There is no documentation of this in the manual.  It should either be documented or removed.  I thought we agreed to remove it, so I'm not sure why it is still here in the code.\nIf it is retained, this logic belongs in the checker, not here in a separate package, because it is logically part of the checker.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284098", "createdAt": "2020-04-02T12:45:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDk0MDQzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0NjoyMFrOF_pgHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0NjoyMFrOF_pgHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDU3Mg==", "bodyText": "Eliminate these constant values and instead iterate through all frameworks, using their toString representation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284572", "createdAt": "2020-04-02T12:46:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDk0MjU0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0Njo1NVrOF_phcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjo0Njo1NVrOF_phcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDkxMg==", "bodyText": "What is the point of using an ArrayDeque, which is a more expensive data structure than an EnumSet?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284912", "createdAt": "2020-04-02T12:46:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTA0NDc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMzoxMjo1MFrOF_qhcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMzoxMjo1MFrOF_qhcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMTI5Nw==", "bodyText": "Can you use the containsSameByClass method from AnnotationUtils or from AnnotatedTypeFactory?\nSame question for the implementation below (AnnotatedTypeFactory has no containsSameByName, but we could add it if needed).", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402301297", "createdAt": "2020-04-02T13:12:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n+                        frameworkSupports.remove(Framework.LOMBOK);\n+                        break;\n+                    default:\n+                        throw new UserError(\n+                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n+                                        + disabledFrameworks);\n+                }\n+            }\n+        }\n+        return frameworkSupports;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has an annotation of that class.\n+     *\n+     * @param element the element that might have an annotation\n+     * @param annotClass the class of the annotation that might be present\n+     * @return true if the element has the annotation\n+     */\n+    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n+        return element.getAnnotationMirrors().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTg4MjQzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo0MjozOVrOGAYjHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo0MjozOVrOGAYjHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTM5MA==", "bodyText": "The fields in this class should have visibility modifiers.\nCan they be final?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055390", "createdAt": "2020-04-03T14:42:39Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.Framework;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTkyMzAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo1MjowNVrOGAY8eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozNzoyNFrOGKCrLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg==", "bodyText": "Note that this only validates explicit annotations in source code.\nYou could instead validate all methods/fields to ensure correct usage to also ensure stub files are correct.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403061882", "createdAt": "2020-04-03T14:52:05Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExODU4MQ==", "bodyText": "@wmdietl can we handle validation of stub files in a follow-up task?  I'm afraid we will end up going down a bit of a rabbit hole if we do that here (what about classes?  or generic type arguments?).  Or maybe I am misunderstanding and it's a simple change?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405118581", "createdAt": "2020-04-07T21:17:27Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTM0NQ==", "bodyText": "Sure. Maybe we don't have a nice way to validate executable types at the moment. So maybe file a follow-up issue.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455345", "createdAt": "2020-04-17T20:31:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4Mjc2Ng==", "bodyText": "Will file the follow-up after this lands", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413182766", "createdAt": "2020-04-22T17:37:24Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTk0MTE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo1NTo0NlrOGAZHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo1NTo0NlrOGAZHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NDY0NQ==", "bodyText": "Framework is a very vague name. Could you find a better name? SupportedReturnsReceiverSpecialCases is a bit long.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403064645", "createdAt": "2020-04-03T14:55:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTk1MzQ2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDo1ODozNlrOGAZPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjoxOToyNFrOGAclDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ==", "bodyText": "Is this class really worth it?\ngetSupportedFrameworks could be in Frameworks and the other two methods are very simple wrappers. (And I would like to remove the version that uses a Class, to not require a compile-time dependency on each framework.)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403066661", "createdAt": "2020-04-03T14:58:36Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyMTQyMQ==", "bodyText": "I agree this class is not worth it.  @wmdietl I think hasAnnotation and hasAnnotationByName belong in some other Checker Framework utility class, if they are not already there.  Do you have a suggestion on where they should go, or whether they should just be inlined?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403121421", "createdAt": "2020-04-03T16:19:24Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTk2MDU0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNTowMDowNlrOGAZThA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1NTo1OVrOGDjU2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA==", "bodyText": "Is there a reason to use the top type for null, Void, or lower bounds? It would be more standard to use the bottom type for these locations.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403067780", "createdAt": "2020-04-03T15:00:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzExNDE5NA==", "bodyText": "For null, we want to get an error for code like this (from a test):\n        @This B dontRetThis() {\n            // :: error: return.type.incompatible\n            return null;\n        }\nWithout using the top type for null we don't get an error.\nFor Void and lower bounds, I am less sure, but I'm pretty confident weird errors showed up in large benchmarks that motivated these additions.  I can try to track those down and add corresponding unit tests.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403114194", "createdAt": "2020-04-03T16:11:31Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTExNg==", "bodyText": "Looked into this.  Because we want to use the top type for null, we also need to use it for generic type lower bounds.  Otherwise, the GenericNull test case from the all-systems tests fails.  I could not find a case where using @UnknownThis for Void was required, so I removed that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405251116", "createdAt": "2020-04-08T04:27:42Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NzY5MA==", "bodyText": "Void can't be initialized, so its type probably doesn't matter.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406377690", "createdAt": "2020-04-09T17:55:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, "originalCommit": {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzI5ODMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyMzo0NlrOGC2__g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyMzo0NlrOGC2__g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTQ1NA==", "bodyText": "This code doesn't care about the existence of the FluentAPIGenerator class.  I would be inclined to create a method returnsThis and put the for loop within it.  Then the FluentAPIGenerator enum can be private, since it is only used by that method.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405651454", "createdAt": "2020-04-08T16:23:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                for (FluentAPIGenerator fluentAPIGenerator :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzMwMjM0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNDozNVrOGC3Cdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNDozNVrOGC3Cdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjA4Nw==", "bodyText": "It is inconsistent that this code uses getAnnotationByName but the below code uses containsSameByName.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405652087", "createdAt": "2020-04-08T16:24:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzMxMzM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNzowOFrOGC3JNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNzowOFrOGC3JNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzgxMg==", "bodyText": "Could you clarify this comment?  Is code generated if the superclass is an AutoValue builder, or if the superclass is not?  What is done with generated code:  ignore it, or be sure to process it too?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405653812", "createdAt": "2020-04-08T16:27:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(\n+                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n+                            != null;\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzMxNTg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNzo0NlrOGC3K1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoyNzo0NlrOGC3K1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NDIyOQ==", "bodyText": "Could you document this field?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405654229", "createdAt": "2020-04-08T16:27:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45df4580377cef06691e8476aa03042e5d6c208b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg1MjkxOnYy", "diffSide": "RIGHT", "path": "docs/manual/Makefile", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Mjo1M1rOGDi2_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjowMToxN1rOGDq7mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw==", "bodyText": "Why does this PR add purity-checker.tex here?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406370047", "createdAt": "2020-04-09T17:42:53Z", "author": {"login": "kelloggm"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0MTc0Mw==", "bodyText": "I re-ran latex-process-inputs -makefilelist manual.tex as suggested in the Makefile, and it added that line also", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406441743", "createdAt": "2020-04-09T19:55:05Z", "author": {"login": "msridhar"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0OTU0Ng==", "bodyText": "@mernst do you know why this might be happening? It seems wrong to me.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406449546", "createdAt": "2020-04-09T20:10:28Z", "author": {"login": "kelloggm"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1ODY5Nw==", "bodyText": "AFAIK there is no check on CI that the list in the Makefile is up to date.  Probably someone just forgot to add to the Makefile?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406458697", "createdAt": "2020-04-09T20:29:04Z", "author": {"login": "msridhar"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjI5Ng==", "bodyText": "The change is correct.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406502296", "createdAt": "2020-04-09T22:01:17Z", "author": {"login": "mernst"}, "path": "docs/manual/Makefile", "diffHunk": "@@ -23,8 +23,10 @@ signature-checker.tex \\\n guieffect-checker.tex \\\n units-checker.tex \\\n signedness-checker.tex \\\n-constant-value-checker.tex \\\n aliasing-checker.tex \\\n+purity-checker.tex \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MDA0Nw=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg2NDc4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0NTo1NFrOGDi98A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0NTo1NFrOGDi98A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTgyNA==", "bodyText": "nit: \"due to a side effect\"", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406371824", "createdAt": "2020-04-09T17:45:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg2ODg0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Njo1OVrOGDjAig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Njo1OVrOGDjAig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MjQ5MA==", "bodyText": "Nit: this code would be easier to read if you imported AnnotatedExecutableType directly rather than qualifying it everywhere it appears. Most of the other code in the CF uses that style.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406372490", "createdAt": "2020-04-09T17:46:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg3MTk4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Nzo1NFrOGDjCmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0Nzo1NFrOGDjCmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzAxOA==", "bodyText": "Why RuntimeException rather than BugInCF?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373018", "createdAt": "2020-04-09T17:47:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg3NzA3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0OToxMlrOGDjFqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0OToxMlrOGDjFqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzgwMg==", "bodyText": "same question about RuntimeException vs BugInCF", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373802", "createdAt": "2020-04-09T17:49:12Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg3OTY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0OTo1OVrOGDjHZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo0OTo1OVrOGDjHZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDI0NQ==", "bodyText": "Nit: t is the annotated type of the method signature, not the method itself (which would be an ExecutableElement, probably)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374245", "createdAt": "2020-04-09T17:49:59Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg4MTUzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1MDozMVrOGDjIjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1MDozMVrOGDjIjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDU0MQ==", "bodyText": "Same comment as above about t", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374541", "createdAt": "2020-04-09T17:50:31Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg4NTE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1MTozNVrOGDjK4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1MTozNVrOGDjK4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTEzOQ==", "bodyText": "It is better style to always use { and } to surround the body of an if, even if it is one statement, because the code might change later to include multiple statements.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406375139", "createdAt": "2020-04-09T17:51:35Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean checkForFluentAPIGenerators(\n+            AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTg5NjAwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1NDozOFrOGDjRww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozNzoxNVrOGHcV3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3Njg5OQ==", "bodyText": "Should this error state what the valid locations for @This annotations are?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406376899", "createdAt": "2020-04-09T17:54:38Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUwMjA3OQ==", "bodyText": "I don't think that extra verbosity is needed.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406502079", "createdAt": "2020-04-09T22:00:44Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3Njg5OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NzU2NA==", "bodyText": "Oh, I would find invalid location for @This annotation, only usable on method returns and receivers more helpful.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410457564", "createdAt": "2020-04-17T20:37:15Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3Njg5OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTkwMzgwOnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1Njo1NFrOGDjWvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1Njo1NFrOGDjWvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODE3Mg==", "bodyText": "Please add a Javadoc comment for this test", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378172", "createdAt": "2020-04-09T17:56:54Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTkwNTk4OnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1NzoyOVrOGDjYPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1Nzo1MVrOGDjZFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ==", "bodyText": "This comment is no longer accurate. It can be shortened to just \"tests the returns receiver checker's lombok integration\" or similar", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378559", "createdAt": "2020-04-09T17:57:29Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODc3NA==", "bodyText": "It probably ought to also mention that the test files have been delomobok'd", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378774", "createdAt": "2020-04-09T17:57:51Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTkwOTgyOnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/ReturnsReceiverTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1ODozNVrOGDjapQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1ODozNVrOGDjapQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTE3Mw==", "bodyText": "We probably don't need this comment here anymore. If nothing else, please change the link so that it's no longer a URL, since these are now in the same repo.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379173", "createdAt": "2020-04-09T17:58:35Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/returnsreceiver} folder. To add a new test\n+ * case, create a Java file in that directory. The file contains \"// ::\" comments to indicate\n+ * expected errors and warnings; see\n+ * https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTkxMzE1OnYy", "diffSide": "RIGHT", "path": "framework/build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzo1OToyM1rOGDjcqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjo1MTozMlrOGEHuRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTY4OQ==", "bodyText": "The tests don't actually run lombok - the code is already delombok'd.\nWe should probably add a script that does, in fact, run delombok on the original source files before running the RR tests.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379689", "createdAt": "2020-04-09T17:59:23Z", "author": {"login": "kelloggm"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +34,13 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk2ODM4Ng==", "bodyText": "Overall this is in good shape. I had a few minor comments throughout.\nMy big concern is the testing for lombok. Right now, the code being checked in has already been delombok'd, but lombok is listed as a dependency in the build file. We should either:\n\nkeep the delombok'd test code, and remove lombok from the build file, or\ncreate/find the pre-lombok source files that correspond to the delombok'd tests here, and then write a script that delomboks them and make that script a prerequisite for running these tests\n\nI prefer option 2, because it will catch any breaking changes in new lombok versions. I'm willing to help to do this. Option 1 is easier, and removes a dependency, but it won't alert us if a new lombok version breaks RR support.\n\nRegarding option 1, if we remove the Lombok from build file, we will face the error \"lombok package is missing\" since we are using the annotations in the tests. Would you please help me how can I remove it without facing this error, or do you prefer to keep it in the build file as it is. @kelloggm", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406968386", "createdAt": "2020-04-10T22:27:22Z", "author": {"login": "nimakarimipour"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +34,13 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTY4OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDQ2Mg==", "bodyText": "That's a good point that I had missed - Lombok does not distribute separate annotation and processor jars, like AutoValue. So if we keep things as-is, you're right that we'd need to keep the dependency. A note about why it's needed even though the annotation processor isn't being run would be helpful.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406970462", "createdAt": "2020-04-10T22:35:56Z", "author": {"login": "kelloggm"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +34,13 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTY4OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NDAyMQ==", "bodyText": "Thank you for your help @kelloggm", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406974021", "createdAt": "2020-04-10T22:51:32Z", "author": {"login": "nimakarimipour"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +34,13 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTY4OQ=="}, "originalCommit": {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk0NTM0OnYy", "diffSide": "RIGHT", "path": "framework/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMjozN1rOGFjUPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozMjozN1rOGFjUPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NDY4NQ==", "bodyText": "@nimakarimipour can we add a comment here indicating why this canBeResolved flag is needed?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408474685", "createdAt": "2020-04-14T22:32:37Z", "author": {"login": "msridhar"}, "path": "framework/build.gradle", "diffHunk": "@@ -29,6 +35,19 @@ dependencies {\n     testImplementation group: 'junit', name: 'junit', version: '4.13'\n     testImplementation project(':framework-test')\n     testImplementation sourceSets.testannotations.output\n+\n+    // AutoValue support in Returns Receiver Checker\n+    testImplementation \"com.google.auto.value:auto-value-annotations:${versions.autoValue}\"\n+    testImplementation \"com.google.auto.value:auto-value:${versions.autoValue}\"\n+\n+    // Lombok support in Returns Receiver Checker\n+    testImplementation \"org.projectlombok:lombok:${versions.lombok}\"\n+}\n+\n+configurations{\n+    testImplementation{\n+        canBeResolved = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk5NjExOnYy", "diffSide": "RIGHT", "path": "framework/tests/returnsreceiverlombok/lombok.config", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NDozNVrOGFjzKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NzoyMlrOGFj3Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjYwMg==", "bodyText": "@kelloggm it seems that if Lombok is run without this option, the Returns Receiver Checker does not add annotations properly, since it looks for @lombok.Generated annotations.  I'm guessing the same is true for Object Construction Checker.  Does this sound right?  If so, we should document it somewhere.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408482602", "createdAt": "2020-04-14T22:54:35Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/lombok.config", "diffHunk": "@@ -0,0 +1 @@\n+lombok.addLombokGeneratedAnnotation = true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU5MQ==", "bodyText": "That's correct. I suspect the OCC's documentation doesn't mention it because it requires users to use the Gradle plugin, which does this automatically.\nI'll still make a PR against the OCC to add a note about it.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408483591", "createdAt": "2020-04-14T22:57:22Z", "author": {"login": "kelloggm"}, "path": "framework/tests/returnsreceiverlombok/lombok.config", "diffHunk": "@@ -0,0 +1 @@\n+lombok.addLombokGeneratedAnnotation = true", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjYwMg=="}, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE3ODUwOnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMToxM1rOGFleTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMToxM1rOGFleTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDAyOQ==", "bodyText": "not -> note\nAlso, I think this comment needs to be updated given the new strategy for delombok'ing the tests.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510029", "createdAt": "2020-04-15T00:21:13Z", "author": {"login": "kelloggm"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, please not that the test files have been", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE4Mzk4OnYy", "diffSide": "RIGHT", "path": "framework/tests/returnsreceiverlombok/BuilderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMzo1MVrOGFlheA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMzo1MVrOGFlheA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDg0MA==", "bodyText": "These two builders are not \"good\" - they're both incorrect. That comment looks like a holdover from the Object Construction Checker, and should be removed.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510840", "createdAt": "2020-04-15T00:23:51Z", "author": {"login": "kelloggm"}, "path": "framework/tests/returnsreceiverlombok/BuilderTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderTest {\n+    @Getter @Setter private Integer x;\n+    @Getter @Setter @NonNull private Integer y;\n+    @Getter @Setter @NonNull private Integer z;\n+\n+    public static void test_simplePattern() {\n+        BuilderTest.builder().x(0).y(0).build(); // good builder\n+        BuilderTest.builder().y(0).build(); // good builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE5MTg5OnYy", "diffSide": "RIGHT", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyNzo1NFrOGFlmNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMjoyMDozNVrOGGNo6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA==", "bodyText": "@kelloggm this subclass has the wrapper methods that ensure that @This annotations are getting inserted correctly for Lombok.  I think this should be sufficient for testing, but let us know if you think they belong elsewhere or need better documentation", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408512054", "createdAt": "2020-04-15T00:27:54Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExMDA2MA==", "bodyText": "These are great. My comment wasn't clear, but I was referring to framework/tests/returnsreceiverlombok/BuilderTest.java, which doesn't test anything other than that the RR checker issues no error on that file. It should check that the setters have @This annotations, too.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409110060", "createdAt": "2020-04-15T20:20:57Z", "author": {"login": "kelloggm"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2NzU3NA==", "bodyText": "Now added", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409167574", "createdAt": "2020-04-15T22:19:13Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODEwNQ==", "bodyText": "BTW, these extra tests are how we discovered the need for the extra flag for Lombok.  So they are definitely useful \ud83d\udc4d", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409168105", "createdAt": "2020-04-15T22:20:35Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, "originalCommit": {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI4MDkxOnYy", "diffSide": "RIGHT", "path": "changelog.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTozOTo1OVrOGHaytw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTozOTo1OVrOGHaytw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjE4Mw==", "bodyText": "I like the first sentence from the manual section better than this summary. How about using that here?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410432183", "createdAt": "2020-04-17T19:39:59Z", "author": {"login": "wmdietl"}, "path": "changelog.txt", "diffHunk": "@@ -1,3 +1,8 @@\n+Version 3.3.1, May 1, 2020\n+\n+The Returns Receiver Checker verifies whether a method returns its", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODI4Nzk3OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Mjo0M1rOGHa3Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzo0NDo1MFrOGNBNZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw==", "bodyText": "Shouldn't it be legal to explicitly write it on the receiver type?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410433367", "createdAt": "2020-04-17T19:42:43Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzY2Ng==", "bodyText": "Should this mention that the return type has to be exactly the type of the enclosing method? (Or is there a different rule?)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410433666", "createdAt": "2020-04-17T19:43:23Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2OTA3MQ==", "bodyText": "Regarding your first comment:\nI see no harm to writing it explicitly on the receiver type.  I also see no benefit.\nSome advantages of the current choice:\n\nIt is marginally less verbose.\nPermitting only one syntax will avoid confusion from readers seeing different variants.\n\nRegarding your second comment:  good point, @msridhar should address that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411669071", "createdAt": "2020-04-20T20:27:07Z", "author": {"login": "mernst"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3NDE2OQ==", "bodyText": "Should this mention that the return type has to be exactly the type of the enclosing method? (Or is there a different rule?)\n\nI'm not sure I understand.  Did you mean enclosing class?  If so, that is not true; the return type, e.g., can be a superclass.  This is what occurs in the generated sub-class for an AutoValue Builder (see the fig-autovalue-builder-generated below).  If you meant something else, please let me know.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411674169", "createdAt": "2020-04-20T20:35:48Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzYwNA==", "bodyText": "Ah, yes, the enclosing class or superclasses makes sense. Does @This Object always make sense? Whatever the rules are, it would be nice to document them.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411717604", "createdAt": "2020-04-20T21:53:10Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MDI5NQ==", "bodyText": "I think @This Object makes perfect sense, though I don't immediately have a concrete use case.  Are you sure it would be useful to document these constraints on the return type?  They are directly implied by the fact that the checker ensures the method returns this.  I am trying to write a sentence or two on it but it does not seem useful.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412340295", "createdAt": "2020-04-21T17:14:20Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDUwOQ==", "bodyText": "This was the first I read about this type system, so I was wondering when I can use it.\nI find descriptions of the rules useful in documentation.\nIf you prefer being vague, that's fine with me.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413404509", "createdAt": "2020-04-22T23:37:33Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDQ4NQ==", "bodyText": "Shouldn't it be legal to explicitly write it on the receiver type?\n\nIt is now legal to write on the receiver type.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416304485", "createdAt": "2020-04-28T03:44:50Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMzM2Nw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODMwMjcwOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Nzo1MlrOGHbAxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Nzo1MlrOGHbAxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTc4MQ==", "bodyText": "Pragrammers -> Programmers", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410435781", "createdAt": "2020-04-17T19:47:52Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODMwNTgzOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0ODo1N1rOGHbCxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0ODo1N1rOGHbCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjI5Mg==", "bodyText": "Why are you telling me about them, then? I find this introduction a bit off-putting. Maybe phrase this more inviting?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410436292", "createdAt": "2020-04-17T19:48:57Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODMwOTMxOnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo1MDoxMlrOGHbFJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo1MDoxMlrOGHbFJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjkwMA==", "bodyText": "The polymorphic qualifier for a hierarchy is a subtype of top for that hierarchy. Top is top...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410436900", "createdAt": "2020-04-17T19:50:12Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODMyNzk5OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo1Njo0OVrOGHbRIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo1Njo0OVrOGHbRIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzOTk3MA==", "bodyText": "annoattion -> annotation", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410439970", "createdAt": "2020-04-17T19:56:49Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annoattion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODMzODg0OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowMDo0OVrOGHbYFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowMDo0OVrOGHbYFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MTc0OA==", "bodyText": "This talks about a default that you implemented, it doesn't explain the type hierarchy.\nA polymorphic annotation gets resolved to one of the other qualifiers in the hierarchy. The only other qualifiers are UnknownThis and BottomThis... which one is the default otherwise? You simply reply on the fact that within a method you don't know what a polymorphic qualifier is resolved to and is the only thing that is assignable to a poly return. You don't care at all about polymorphism at the invocation site.\nSo poly resolution and the hierarchy could be described a bit nicer here...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410441748", "createdAt": "2020-04-17T20:00:49Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,118 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Pragrammers rarely need to write these annotations.\n+\n+Here are some implementation details that most users will not care about.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is \\emph{not} a subtype of \\refqualclass{common/returnsreceiver/qual}{UnknownThis},\n+but instead is a polymorphic qualifier.  When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annoattion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM1Mjc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNjowNlrOGHbhAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1MToxN1rOGHcs6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw==", "bodyText": "Documentation of the public purpose of this class would still be useful... is this meant as an opaque token?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444033", "createdAt": "2020-04-17T20:06:06Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5Mg==", "bodyText": "The point of the class seems to be method checkForFluentAPIGenerators. So I would have liked to see a documentation of that, not the implementation detail about the enum.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448092", "createdAt": "2020-04-17T20:15:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODk4Nw==", "bodyText": "(I'm also not sure whether I would repeat the class name in the method name... instead of FluentAPIGenerator.checkForFluentAPIGenerators isn't FluentAPIGenerator.check simpler and as clear?)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448987", "createdAt": "2020-04-17T20:17:22Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MzQ2Ng==", "bodyText": "You could also move the method to the beginning of the class...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410463466", "createdAt": "2020-04-17T20:51:17Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM1NTc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNzoyNFrOGHbjHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNzoyNFrOGHbjHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDU3Mg==", "bodyText": "Should the needed instead be needs?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444572", "createdAt": "2020-04-17T20:07:24Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM2MjE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowOTozM1rOGHbm2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowOTozM1rOGHbm2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NTUzMQ==", "bodyText": "Should enclosingType be enclosingElement or something else?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410445531", "createdAt": "2020-04-17T20:09:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM4NTM2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxODowMFrOGHb1YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxODowMFrOGHb1YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTI0OQ==", "bodyText": "This is the only public method for this class and should be documented.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449249", "createdAt": "2020-04-17T20:18:00Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the annotated type of the method signature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM4NzE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxODozMFrOGHb2Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1Mjo1MlrOGHcvPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ==", "bodyText": "Why does this need to be package private? Could it be protected or even private?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449511", "createdAt": "2020-04-17T20:18:30Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDA2Mg==", "bodyText": "I see one usage outside this package, which could just use areSameByClass...\nat least add a comment why you used package private.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410464062", "createdAt": "2020-04-17T20:52:52Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM5NDY1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyMDo1M1rOGHb69Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyMDo1M1rOGHb69Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDY3Nw==", "bodyText": "Why not simply return if it's a constructor? That makes the intent even clearer and reduces the indentation for the rest of the method.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410450677", "createdAt": "2020-04-17T20:20:53Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQwMjg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyMzo0NlrOGHcAFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyMzo0NlrOGHcAFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MTk5MA==", "bodyText": "Why do you need this special logic?\nCouldn't you simply add @DefaultFor({TypeUseLocation.RECEIVER}) to the declaration of @This?\nAll receivers are @This. The only extra logic you need is to automatically make the fluent API return types @This.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410451990", "createdAt": "2020-04-17T20:23:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQxMjEwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyNjo1OFrOGHcFsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyNjo1OFrOGHcFsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQyNw==", "bodyText": "There is a single use of this method.\nWouldn't it be much simpler to simply write if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) { return; } above? (Addressing my earlier comment about returning early.)", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410453427", "createdAt": "2020-04-17T20:26:58Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation\n+                // to the receiver type.\n+                AnnotationMirror retAnnotation =\n+                        returnType.getAnnotationInHierarchy(THIS_ANNOTATION);\n+                if (retAnnotation != null\n+                        && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                    AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                    if (!receiverType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        receiverType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+            }\n+            return super.visitExecutable(t, p);\n+        }\n+    }\n+\n+    /**\n+     * @return {@code true} if the param {@code t} is a {@code Constructor}\n+     * @param t a {@link AnnotatedTypeMirror}\n+     */\n+    private boolean isConstructor(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQyNTk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozMjozMVrOGHcOuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzozODoxNlrOGKQOfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ==", "bodyText": "I find !isReturn && !isCastAnnot easier to look at visually and easier to understand... but you might prefer this way.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455739", "createdAt": "2020-04-17T20:32:31Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2OTQ1Ng==", "bodyText": "I personally like it this way \ud83d\ude42 I think we will leave it", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412369456", "createdAt": "2020-04-21T17:54:43Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDc5OQ==", "bodyText": "Sure, no objection.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413404799", "createdAt": "2020-04-22T23:38:16Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQzNDg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozNjoyOFrOGHcUsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozNjoyOFrOGHcUsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NzI2NA==", "bodyText": "You could either use the existing type.invalid annotation or follow that naming type.invalid.this.location.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410457264", "createdAt": "2020-04-17T20:36:28Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/messages.properties", "diffHunk": "@@ -0,0 +1 @@\n+invalid.this.location=invalid location for @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ0ODk4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MjoxOFrOGHceJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MjoxOFrOGHceJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTY4Nw==", "bodyText": "value -> type", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410459687", "createdAt": "2020-04-17T20:42:18Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ1MjEwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0MzoyOVrOGHcgHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNTowMDozNVrOGLb4Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ==", "bodyText": "Instead of putting it so operationally, why not make this simply a default for all receivers.\nIs there any harm if they are always @This?\nIs there any harm in allowing programmers to explicitly mark receivers @This?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410460189", "createdAt": "2020-04-17T20:43:29Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MDgxNg==", "bodyText": "In terms of explicitly marking receivers @This, I think that just adds confusion with not much gain (probably most programmers don't even know you can annotate the receiver).  But let's see, maybe we'll be able to make it default if we can work out the implementation issues.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413180816", "createdAt": "2020-04-22T17:34:38Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzA4Mg==", "bodyText": "I would see it the other way around: why forbid something that other type systems allow? Conceptually, you want that both the receiver and return type are annotated @This. So if somebody wants to make that explicit, what's the harm? Most users won't care about this, I agree, but it would make the type system follow the common style of the framework.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407082", "createdAt": "2020-04-22T23:44:13Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzAyNg==", "bodyText": "@wmdietl what if a programmer writes @This on the receiver but not the return value?  Should we add code to insert @This on the return value in that case?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413997026", "createdAt": "2020-04-23T17:43:36Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMzAzMw==", "bodyText": "I would add @This on the return value exactly when it is currently, regardless of whether @This is explicitly or implicitly written on the receiver.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414033033", "createdAt": "2020-04-23T18:37:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NDMxMQ==", "bodyText": "In my mind, the receiver parameter is always @This. The return type is only @This if it is a special method that actually returns the receiver.\nSo no, I don't think there should be logic that adds @This to the return type if the receiver has it.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414644311", "createdAt": "2020-04-24T15:00:35Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, "originalCommit": {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ2MjU3OnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0NzoyN1rOGHcm2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo0NzoyN1rOGHcm2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MTkxMw==", "bodyText": "You should start javadoc sentences with an upper case letter and end it with a ..", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410461913", "createdAt": "2020-04-17T20:47:27Z", "author": {"login": "wmdietl"}, "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, the test files in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ac96286a2c944ce7b0929bba4dc487e69521bd9"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg0MjYyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozODozM1rOGIoyXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMjowODo1M1rOGM_Xtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ==", "bodyText": "#3199 (comment)\nDid you try using @DefaultFor({TypeUseLocation.RECEIVER}) on the declaration of @This?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411710045", "createdAt": "2020-04-20T21:38:33Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTIzOA==", "bodyText": "I tried adding this to the declaration of @This, but below tests fails for this change:\n\nreturnsreceiver\nall-systems/java8/memberref\nall-systems/java8/lambda\nall-systems/java8inference\n\nIs there anything else I should do to make this change or we should keep it as it is ?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412435238", "createdAt": "2020-04-21T19:33:29Z", "author": {"login": "nimakarimipour"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3OTA0Ng==", "bodyText": "It seems the primary issue here is with method references.  Here is one false-positive report we get:\ntests/all-systems/java8/memberref/MemberReferences.java:119: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n        Consumer<Number> f1 = bound::func1;\n                              ^\n  Method\n    @UnknownThis BoundWithArg<@UnknownThis Number>\n  is not a valid method reference for\n    void func1(@This BoundWithArg<@UnknownThis Number> this, @UnknownThis Number p0) in BoundWithArg\n  found   : @UnknownThis BoundWithArg<@UnknownThis Number>\n  required: @This BoundWithArg<@UnknownThis Number>\n\n@wmdietl I'm not sure why this is an error; seems like an interaction between polymorphic annotations and generics?  Maybe it's a Checker Framework bug?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413179046", "createdAt": "2020-04-22T17:31:59Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMzQ3Ng==", "bodyText": "It looks like you don't have a lot of lambda/method reference tests and running on all-systems with the change revealed that...\nThe following test without generics gives a similar error (incorrectly I named it Lambda, but then I used a method reference... I'm sure you can write something similar that actually uses a lambda):\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass Lambda {\n\n    @This Lambda set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n}\ngives:\nLambda.java:13: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n    Setter co = this::set;\n                ^\n  Method\n    @UnknownThis Lambda\n  is not a valid method reference for\n    @This Lambda set(@This Lambda this, @UnknownThis Object p0) in Lambda\n  found   : @UnknownThis Lambda\n  required: @This Lambda\n1 error\n\nThis is with tip of this branch, so independent of the proposed change.\nShould that be an error? What is the allowed interaction between @This and lamdas/method references?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413403476", "createdAt": "2020-04-22T23:35:03Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzI5NQ==", "bodyText": "Good catch!  I am not sure what is going on here.  Our checker should be adding @This on the receiver of set().  @wmdietl do you happen to know why this error message says @UnknownThis Lambda as opposed to @This Lambda?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407295", "createdAt": "2020-04-22T23:44:48Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDE4OA==", "bodyText": "No, I don't. Maybe there is a problem with how polymorphic annotations are resolved on receivers?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413410188", "createdAt": "2020-04-22T23:52:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMjU4NQ==", "bodyText": "The error message seems odd, as it says Method @UnknownThis Lambda, which is just a declared type, not a method type.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413412585", "createdAt": "2020-04-22T23:58:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NzkwMw==", "bodyText": "I think the error message is just phrased poorly.  What seems to be going on is that there is a subtype check that fails because @UnknownThis Lambda is not a subtype of @This Lambda.  I've added this example as a test case now but renamed it to MethodRef.\nI am not too sure about how to fix this one, and whether it's a bug in our checker or not.  @smillst any chance you could take a look?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413497903", "createdAt": "2020-04-23T04:21:59Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MDAxMw==", "bodyText": "Thinking more, this example is actually quite subtle, and I'm now not sure if there should be a type error or not.  Consider this extended version of the example:\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass MethodRef {\n\n    @This MethodRef set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n\n    public static void main(String[] args) {\n        MethodRef m = new MethodRef();\n        // this assertion fails!\n        assert m.co.consume(new Object()) == m.co : \"not returning receiver\";\n    }\n}\nI read the @This annotation on the Setter.consume() return type as indicating that any implementation of Setter.consume() should return its receiver.  But if we allow the above code to type check, that property does not hold (since this::set will return the value of this bound by the method reference, not the receiver passed into the call to consume()).\nSo maybe there should be an error in this case (perhaps with a better message)?  @wmdietl @kelloggm @mernst thoughts?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415370013", "createdAt": "2020-04-26T18:25:14Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzNzk3MA==", "bodyText": "The Checker Framework does not handle polymorphic qualifiers receivers on the functional methods to member references are assigned.  For example, the receiver of Setter#consume has a polymorphic annotation on its receiver so, Setter co = this::set; causes a weird error.  There should be some sort of error, but methodref.receiver.bound.invalid seems to be the wrong one.\nWe have one open issue on the #2931.  I've added an example to that issue using the Tainting Checker that shows this problem.\nI would just work around this problem in this checker, which I think that's why you wrote the defaulting in place to begin with.  So, maybe just add a comment pointing to #2931?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415437970", "createdAt": "2020-04-27T00:26:07Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0NzUzNg==", "bodyText": "Thanks a lot, @smillst!  It seems like we will run into this issue whether @This is the default for receivers or not.  So I think ideally we should follow @wmdietl's suggestion to use @DefaultFor({TypeUseLocation.RECEIVER}) (which will save us a bit of code).  But then, some of the all-systems tests will fail.  Is there a way to suppress some warnings but still use the all-systems tests?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415447536", "createdAt": "2020-04-27T01:10:39Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwMzg0Ng==", "bodyText": "You can add\n@SuppressWarnings(\"returnsreceiver: methodref.receiver.bound.invalid\") // See Issue #2931\n\nto any all-systems tests that need it.  In general, it is acceptable to suppress a type system specific warning in the all-system test so long as an explanation is given.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416103846", "createdAt": "2020-04-27T19:53:15Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI3NDM1OA==", "bodyText": "Unfortunately, it seems that currently, we get too many false positives with method references if we use @DefaultFor({TypeUseLocation.RECEIVER}) on @This.  E.g., with receiver defaulting, we get an error in this variant:\nclass MethodRef {\n    void doNothing() {}\n\n    interface Fun {\n        void run();\n    }\n\n    Fun f = this::doNothing;\n}\nI think any method reference that binds the receiver will yield an error with the returns receiver checker if receivers are defaulted to @This.  I think this is an unacceptable level of false positives, so for now we will not do the defaulting but will leave a comment as to why we don't do it.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416274358", "createdAt": "2020-04-28T02:08:53Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, "originalCommit": {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTMwNzY0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjozNzo0N1rOGLrjSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNjoxNzo1NVrOGNcLPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ==", "bodyText": "You could meta-annotate all your qualifiers as org.checkerframework.framework.qual.TargetLocations for RETURN and RECEIVER. The annotation isn't enforced yet, but it might already be good documentation.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414901065", "createdAt": "2020-04-24T22:37:47Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNTA0Mg==", "bodyText": "It is also allowed in a downcast.  Would that be prohibited if we add the @TargetLocations meta-annotation?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416305042", "createdAt": "2020-04-28T03:46:29Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}, "originalCommit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NjMwMQ==", "bodyText": "I went ahead and added the @TargetLocations annotation, under the assumption that a qualifier is always allowed to appear in a downcast", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416746301", "createdAt": "2020-04-28T16:17:55Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}, "originalCommit": {"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk2NTM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyMjozMFrOGM4RDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyMjozMFrOGM4RDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1Nzk2Ng==", "bodyText": "Please delete this code rather than commenting it out", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416157966", "createdAt": "2020-04-27T21:22:30Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            //            // If return type is annotated with @This, add @This annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk3Mjk0OnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/java8/lambda/Issue450.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNDoxMlrOGM4VTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNDoxMlrOGM4VTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTA1Mg==", "bodyText": "What is the error in this file?  I don't see any method references", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159052", "createdAt": "2020-04-27T21:24:12Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/lambda/Issue450.java", "diffHunk": "@@ -1,3 +1,4 @@\n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\") // See Issue #2931", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk3NDcxOnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/java8/memberref/MemberReferences.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNDozOFrOGM4WTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNDozOFrOGM4WTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTMwOA==", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159308", "createdAt": "2020-04-27T21:24:38Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/memberref/MemberReferences.java", "diffHunk": "@@ -112,6 +112,7 @@ void context(Bound bound) {\n     }\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk3OTI5OnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/java8/memberref/Receivers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNTo1MlrOGM4ZBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNTo1MlrOGM4ZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDAwNA==", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160004", "createdAt": "2020-04-27T21:25:52Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8/memberref/Receivers.java", "diffHunk": "@@ -11,6 +11,7 @@\n     R supply();\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk4MjE3OnYy", "diffSide": "RIGHT", "path": "framework/tests/all-systems/java8inference/Issue1715.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNjoyMlrOGM4aeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyNjoyMlrOGM4aeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDM3Ng==", "bodyText": "Please include // See Issue #2931 at the end of the line.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160376", "createdAt": "2020-04-27T21:26:22Z", "author": {"login": "msridhar"}, "path": "framework/tests/all-systems/java8inference/Issue1715.java", "diffHunk": "@@ -1,6 +1,7 @@\n import java.util.List;\n import java.util.function.Function;\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODk5MDQ4OnYy", "diffSide": "RIGHT", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyODoyNFrOGM4fJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMToyODoyNFrOGM4fJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTU3NQ==", "bodyText": "This is not a valid error.  We should either use @SuppressWarnings or add a comment indicating this is not a valid error, pointing to #2931", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416161575", "createdAt": "2020-04-27T21:28:24Z", "author": {"login": "msridhar"}, "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,31 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        // :: error: (methodref.receiver.bound.invalid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDEwNTg3OnYy", "diffSide": "RIGHT", "path": "docs/manual/contributors.tex", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0NDoxN1rOGNoKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzowMTo0OFrOGNqHRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjYyMw==", "bodyText": "Is that a different person from Nima Karimipour above?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416942623", "createdAt": "2020-04-28T21:44:17Z", "author": {"login": "wmdietl"}, "path": "docs/manual/contributors.tex", "diffHunk": "@@ -97,4 +98,5 @@\n Vlastimil Dort,\n Weitian Xing,\n Werner Dietl,\n-Zhiping Cai.\n+Zhiping Cai,\n+nimakarimipour.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MjkyNw==", "bodyText": "Fixed, good catch!", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416972927", "createdAt": "2020-04-28T22:57:04Z", "author": {"login": "msridhar"}, "path": "docs/manual/contributors.tex", "diffHunk": "@@ -97,4 +98,5 @@\n Vlastimil Dort,\n Weitian Xing,\n Werner Dietl,\n-Zhiping Cai.\n+Zhiping Cai,\n+nimakarimipour.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjYyMw=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDY2MA==", "bodyText": "This needed to be fixed in the plume-scripts repository, or the problem will recur.  I have fixed it.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416974660", "createdAt": "2020-04-28T23:01:48Z", "author": {"login": "mernst"}, "path": "docs/manual/contributors.tex", "diffHunk": "@@ -97,4 +98,5 @@\n Vlastimil Dort,\n Weitian Xing,\n Werner Dietl,\n-Zhiping Cai.\n+Zhiping Cai,\n+nimakarimipour.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjYyMw=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDExNjg1OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0ODowNlrOGNoRFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0ODowNlrOGNoRFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NDQwNg==", "bodyText": "You could adapt this description to make it clear that the receiver is always @This. Or leave this sentence out completely.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416944406", "createdAt": "2020-04-28T21:48:06Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.\n+When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDExOTQ4OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0ODo1OVrOGNoSrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo0ODo1OVrOGNoSrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NDgxMg==", "bodyText": "You could add a reference to the section on polymorphic qualifiers.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416944812", "createdAt": "2020-04-28T21:48:59Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDEyNDE3OnYy", "diffSide": "RIGHT", "path": "docs/manual/returns-receiver-checker.tex", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MDo0MVrOGNoViw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMjo1Mjo0MFrOGNp6NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NTU0Nw==", "bodyText": "Do you also want to add a sentence about the method caller perspective? The polymorphic annotation gets resolved to UnknownThis and the type on the caller's side doesn't really matter. But maybe that's too much detail.\nIt's just a very different way how this is using the polymorphic qualifier, so it might confuse people that understand that.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416945547", "createdAt": "2020-04-28T21:50:41Z", "author": {"login": "wmdietl"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.\n+When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annotation\n+\\refqualclass{common/returnsreceiver/qual}{This} on both the method's return and\n+receiver type forces their type qualifiers to be \\emph{equal}.  Hence, the\n+method will only pass the type checker if it returns its receiver argument,\n+achieving the desired checking.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTMxNg==", "bodyText": "Yes, I think this would be too much detail.  Hopefully what is written is enough for the user.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416971316", "createdAt": "2020-04-28T22:52:40Z", "author": {"login": "msridhar"}, "path": "docs/manual/returns-receiver-checker.tex", "diffHunk": "@@ -0,0 +1,120 @@\n+\\htmlhr\n+\\chapterAndLabel{Returns Receiver Checker}{returns-receiver-checker}\n+\n+The Returns Receiver Checker enables documenting and checking that a method\n+returns its receiver (i.e., the \\<this> parameter).\n+\n+There are two ways to run the Returns Receiver Checker.\n+\\begin{itemize}\n+\\item\n+Typically, it is automatically run by another checker.\n+\\item\n+Alternately, you can run just the Returns Receiver Checker, by\n+supplying the following command-line options to javac:\n+\\code{-processor org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker}\n+\\end{itemize}\n+\n+\n+\\sectionAndLabel{Annotations}{returns-receiver-checker-annotations}\n+\n+The qualifier \\refqualclass{common/returnsreceiver/qual}{This} on the return\n+type of a method indicates that the method returns its receiver.  Methods\n+that return their receiver are common in so-called ``fluent'' APIs.  Here\n+is an example:\n+\n+\\begin{Verbatim}\n+class MyBuilder {\n+  @This MyBuilder setName(String name) {\n+    this.name = name;\n+    return this;\n+  }\n+}\n+\\end{Verbatim}\n+\n+An \\refqualclass{common/returnsreceiver/qual}{This} annotation can only be\n+written on the return type of a method or in a downcast.\n+\n+As is standard, the Returns Receiver Checker has a top qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{UnknownThis}, and a bottom qualifier,\n+\\refqualclass{common/returnsreceiver/qual}{BottomThis}.\n+Programmers rarely need to write these annotations.\n+\n+Here are additional details.\n+\\refqualclass{common/returnsreceiver/qual}{This}\n+is a polymorphic qualifier rather than a regular type qualifier.\n+When the Returns Receiver Checker observes an\n+\\refqualclass{common/returnsreceiver/qual}{This} annotation on a method return type,\n+it adds \\refqualclass{common/returnsreceiver/qual}{This} to\n+the method's receiver type. The presence of the polymorphic annotation\n+\\refqualclass{common/returnsreceiver/qual}{This} on both the method's return and\n+receiver type forces their type qualifiers to be \\emph{equal}.  Hence, the\n+method will only pass the type checker if it returns its receiver argument,\n+achieving the desired checking.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NTU0Nw=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDEyODQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MjoxM1rOGNoYIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MjoxM1rOGNoYIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjIxMA==", "bodyText": "Use {@code @This} or a link?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946210", "createdAt": "2020-04-28T21:52:13Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDEzMTIzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MzoxNVrOGNoZ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1MzoxNVrOGNoZ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY2NA==", "bodyText": "I'm not sure that's the best description of the method you could come up with...", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946664", "createdAt": "2020-04-28T21:53:15Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NDE0Njk1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1ODoyM1rOGNojZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMzoyNDo1NlrOGNqoKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA==", "bodyText": "Maybe add the note about the automatic defaulting here also. Maybe file a follow-up issue to keep track of method reference handling and the false positives.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416949094", "createdAt": "2020-04-28T21:58:23Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzEyMQ==", "bodyText": "Do we need an issue separate from #2931?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416973121", "createdAt": "2020-04-28T22:57:39Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTg4MQ==", "bodyText": "Now that there is a reference to that issue, this is fine.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416979881", "createdAt": "2020-04-28T23:16:13Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MDQ5NQ==", "bodyText": "Oh, there is none here. Can you add one, to make it easier to find all places that should be touched once #2931 is fixed?", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416980495", "createdAt": "2020-04-28T23:17:50Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTI4OA==", "bodyText": "It's there:  https://github.com/typetools/checker-framework/pull/3199/files#diff-4fedb1e93f819c78e6268bc5f23478b1R82-R83  The GitHub UI is confusing with outdated views", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416981288", "createdAt": "2020-04-28T23:20:06Z", "author": {"login": "msridhar"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MzA4MQ==", "bodyText": "Oh, I specifically tried to look on a reload and didn't see it... thanks, so that's good then.", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416983081", "createdAt": "2020-04-28T23:24:56Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, "originalCommit": {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1772, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}