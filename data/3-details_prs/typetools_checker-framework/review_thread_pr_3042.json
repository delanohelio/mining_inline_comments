{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMDc2MDk1", "number": 3042, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzozMzo0OVrODXS7Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzozNDoyNlrODXS7aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzUzODc5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzozMzo0OVrOFcilFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzozMzo0OVrOFcilFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MDk5Ng==", "bodyText": "A comment about the first case would be good in the documentation below.", "url": "https://github.com/typetools/checker-framework/pull/3042#discussion_r365470996", "createdAt": "2020-01-10T23:33:49Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "diffHunk": "@@ -135,7 +136,12 @@ public DefaultTypeArgumentInference(AnnotatedTypeFactory typeFactory) {\n \n         final Set<TypeVariable> targets = TypeArgInferenceUtil.methodTypeToTargets(methodType);\n \n-        if (assignedTo == null && TreeUtils.getAssignmentContext(pathToExpression) != null) {\n+        if ((pathToExpression.getParentPath() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e04e59c212794d8e03bdd77177181ce71f315bd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzUzOTYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQyMzozNDoyN1rOFcilig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMjoyMDozMVrOFcj1dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTExNA==", "bodyText": "I'm wondering whether using TreeUtils.enclosingMethodOrLambda and then checking for LAMBDA_EXPRESSION would be a bit shorter.", "url": "https://github.com/typetools/checker-framework/pull/3042#discussion_r365471114", "createdAt": "2020-01-10T23:34:27Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "diffHunk": "@@ -135,7 +136,12 @@ public DefaultTypeArgumentInference(AnnotatedTypeFactory typeFactory) {\n \n         final Set<TypeVariable> targets = TypeArgInferenceUtil.methodTypeToTargets(methodType);\n \n-        if (assignedTo == null && TreeUtils.getAssignmentContext(pathToExpression) != null) {\n+        if ((pathToExpression.getParentPath() != null\n+                        && pathToExpression.getParentPath().getLeaf() != null\n+                        && pathToExpression.getParentPath().getLeaf().getKind()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e04e59c212794d8e03bdd77177181ce71f315bd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MzUyMQ==", "bodyText": "The type arguments cannot be inferred if the immediate parent is lambda expression.  TreeUtils.enclosingMethodOrLambda might return a lambda expression that is the parent's parent, so it doesn't work.", "url": "https://github.com/typetools/checker-framework/pull/3042#discussion_r365473521", "createdAt": "2020-01-10T23:47:05Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "diffHunk": "@@ -135,7 +136,12 @@ public DefaultTypeArgumentInference(AnnotatedTypeFactory typeFactory) {\n \n         final Set<TypeVariable> targets = TypeArgInferenceUtil.methodTypeToTargets(methodType);\n \n-        if (assignedTo == null && TreeUtils.getAssignmentContext(pathToExpression) != null) {\n+        if ((pathToExpression.getParentPath() != null\n+                        && pathToExpression.getParentPath().getLeaf() != null\n+                        && pathToExpression.getParentPath().getLeaf().getKind()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTExNA=="}, "originalCommit": {"oid": "7e04e59c212794d8e03bdd77177181ce71f315bd"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ5MTU3Mw==", "bodyText": "Couldn't the method invocation be parenthesized?\nCouldn't one write mapper = dsData1 -> ((ImmutableMap.of(...)))? Not the nicest style, but would be a bit odd not to handle.", "url": "https://github.com/typetools/checker-framework/pull/3042#discussion_r365491573", "createdAt": "2020-01-11T02:20:31Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/typeinference/DefaultTypeArgumentInference.java", "diffHunk": "@@ -135,7 +136,12 @@ public DefaultTypeArgumentInference(AnnotatedTypeFactory typeFactory) {\n \n         final Set<TypeVariable> targets = TypeArgInferenceUtil.methodTypeToTargets(methodType);\n \n-        if (assignedTo == null && TreeUtils.getAssignmentContext(pathToExpression) != null) {\n+        if ((pathToExpression.getParentPath() != null\n+                        && pathToExpression.getParentPath().getLeaf() != null\n+                        && pathToExpression.getParentPath().getLeaf().getKind()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTExNA=="}, "originalCommit": {"oid": "7e04e59c212794d8e03bdd77177181ce71f315bd"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1838, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}